(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
        i(r);
    new MutationObserver(r=>{
        for (const s of r)
            if (s.type === "childList")
                for (const o of s.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && i(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(r) {
        const s = {};
        return r.integrity && (s.integrity = r.integrity),
        r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
        r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin",
        s
    }
    function i(r) {
        if (r.ep)
            return;
        r.ep = !0;
        const s = t(r);
        fetch(r.href, s)
    }
}
)();
window.NodeList && !NodeList.prototype.forEach && (NodeList.prototype.forEach = function(n, e) {
    e = e || window;
    for (var t = 0; t < this.length; t++)
        n.call(e, this[t], t, this)
}
);
window.history.scrollRestoration && (window.history.scrollRestoration = "manual");
const hF = n=>{
    const e = new Set;
    do
        for (const t of Reflect.ownKeys(n))
            e.add([n, t]);
    while ((n = Reflect.getPrototypeOf(n)) && n !== Object.prototype);
    return e
}
;
function Il(n, {include: e, exclude: t}={}) {
    const i = r=>{
        const s = o=>typeof o == "string" ? r === o : o.test(r);
        return e ? e.some(s) : t ? !t.some(s) : !0
    }
    ;
    for (const [r,s] of hF(n.constructor.prototype)) {
        if (s === "constructor" || !i(s))
            continue;
        const o = Reflect.getOwnPropertyDescriptor(r, s);
        o && typeof o.value == "function" && (n[s] = n[s].bind(n))
    }
    return n
}
var lr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Uo(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}
function Fo(n) {
    if (n.__esModule)
        return n;
    var e = n.default;
    if (typeof e == "function") {
        var t = function i() {
            return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        t.prototype = e.prototype
    } else
        t = {};
    return Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    Object.keys(n).forEach(function(i) {
        var r = Object.getOwnPropertyDescriptor(n, i);
        Object.defineProperty(t, i, r.get ? r : {
            enumerable: !0,
            get: function() {
                return n[i]
            }
        })
    }),
    t
}
var FS = !1, sl, A_, M_, Xd, qd, fT, jd, T_, C_, R_, hT, P_, L_, dT, pT;
function yr() {
    if (!FS) {
        FS = !0;
        var n = navigator.userAgent
          , e = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(n)
          , t = /(Mac OS X)|(Windows)|(Linux)/.exec(n);
        if (P_ = /\b(iPhone|iP[ao]d)/.exec(n),
        L_ = /\b(iP[ao]d)/.exec(n),
        R_ = /Android/i.exec(n),
        dT = /FBAN\/\w+;/i.exec(n),
        pT = /Mobile/i.exec(n),
        hT = !!/Win64/.exec(n),
        e) {
            sl = e[1] ? parseFloat(e[1]) : e[5] ? parseFloat(e[5]) : NaN,
            sl && document && document.documentMode && (sl = document.documentMode);
            var i = /(?:Trident\/(\d+.\d+))/.exec(n);
            fT = i ? parseFloat(i[1]) + 4 : sl,
            A_ = e[2] ? parseFloat(e[2]) : NaN,
            M_ = e[3] ? parseFloat(e[3]) : NaN,
            Xd = e[4] ? parseFloat(e[4]) : NaN,
            Xd ? (e = /(?:Chrome\/(\d+\.\d+))/.exec(n),
            qd = e && e[1] ? parseFloat(e[1]) : NaN) : qd = NaN
        } else
            sl = A_ = M_ = qd = Xd = NaN;
        if (t) {
            if (t[1]) {
                var r = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(n);
                jd = r ? parseFloat(r[1].replace("_", ".")) : !0
            } else
                jd = !1;
            T_ = !!t[2],
            C_ = !!t[3]
        } else
            jd = T_ = C_ = !1
    }
}
var D_ = {
    ie: function() {
        return yr() || sl
    },
    ieCompatibilityMode: function() {
        return yr() || fT > sl
    },
    ie64: function() {
        return D_.ie() && hT
    },
    firefox: function() {
        return yr() || A_
    },
    opera: function() {
        return yr() || M_
    },
    webkit: function() {
        return yr() || Xd
    },
    safari: function() {
        return D_.webkit()
    },
    chrome: function() {
        return yr() || qd
    },
    windows: function() {
        return yr() || T_
    },
    osx: function() {
        return yr() || jd
    },
    linux: function() {
        return yr() || C_
    },
    iphone: function() {
        return yr() || P_
    },
    mobile: function() {
        return yr() || P_ || L_ || R_ || pT
    },
    nativeApp: function() {
        return yr() || dT
    },
    android: function() {
        return yr() || R_
    },
    ipad: function() {
        return yr() || L_
    }
}, dF = D_, Qh = !!(typeof window < "u" && window.document && window.document.createElement), pF = {
    canUseDOM: Qh,
    canUseWorkers: typeof Worker < "u",
    canUseEventListeners: Qh && !!(window.addEventListener || window.attachEvent),
    canUseViewport: Qh && !!window.screen,
    isInWorker: !Qh
}, mF = pF, mT = mF, gT;
mT.canUseDOM && (gT = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function gF(n, e) {
    if (!mT.canUseDOM || e && !("addEventListener"in document))
        return !1;
    var t = "on" + n
      , i = t in document;
    if (!i) {
        var r = document.createElement("div");
        r.setAttribute(t, "return;"),
        i = typeof r[t] == "function"
    }
    return !i && gT && n === "wheel" && (i = document.implementation.hasFeature("Events.wheel", "3.0")),
    i
}
var _F = gF
  , vF = dF
  , yF = _F
  , BS = 10
  , kS = 40
  , zS = 800;
function _T(n) {
    var e = 0
      , t = 0
      , i = 0
      , r = 0;
    return "detail"in n && (t = n.detail),
    "wheelDelta"in n && (t = -n.wheelDelta / 120),
    "wheelDeltaY"in n && (t = -n.wheelDeltaY / 120),
    "wheelDeltaX"in n && (e = -n.wheelDeltaX / 120),
    "axis"in n && n.axis === n.HORIZONTAL_AXIS && (e = t,
    t = 0),
    i = e * BS,
    r = t * BS,
    "deltaY"in n && (r = n.deltaY),
    "deltaX"in n && (i = n.deltaX),
    (i || r) && n.deltaMode && (n.deltaMode == 1 ? (i *= kS,
    r *= kS) : (i *= zS,
    r *= zS)),
    i && !e && (e = i < 1 ? -1 : 1),
    r && !t && (t = r < 1 ? -1 : 1),
    {
        spinX: e,
        spinY: t,
        pixelX: i,
        pixelY: r
    }
}
_T.getEventType = function() {
    return vF.firefox() ? "DOMMouseScroll" : yF("wheel") ? "wheel" : "mousewheel"
}
;
var xF = _T
  , bF = xF;
const SF = Uo(bF);
function Eo(n) {
    if (n === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return n
}
function vT(n, e) {
    n.prototype = Object.create(e.prototype),
    n.prototype.constructor = n,
    n.__proto__ = e
}
/*!
 * GSAP 3.12.3
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Kr = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
        lineHeight: ""
    }
}, Hc = {
    duration: .5,
    overwrite: !1,
    delay: 0
}, ay, $i, Vn, _s = 1e8, Sn = 1 / _s, I_ = Math.PI * 2, wF = I_ / 4, EF = 0, yT = Math.sqrt, AF = Math.cos, MF = Math.sin, wi = function(e) {
    return typeof e == "string"
}, Wn = function(e) {
    return typeof e == "function"
}, Io = function(e) {
    return typeof e == "number"
}, ly = function(e) {
    return typeof e > "u"
}, io = function(e) {
    return typeof e == "object"
}, Tr = function(e) {
    return e !== !1
}, cy = function() {
    return typeof window < "u"
}, ed = function(e) {
    return Wn(e) || wi(e)
}, xT = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {}
, Xi = Array.isArray, O_ = /(?:-?\.?\d|\.)+/gi, bT = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Ac = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Lg = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, ST = /[+-]=-?[.\d]+/, wT = /[^,'"\[\]\s]+/gi, TF = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, Fn, fs, N_, uy, Jr = {}, dp = {}, ET, AT = function(e) {
    return (dp = Ml(e, Jr)) && Dr
}, fy = function(e, t) {
    return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
}, Df = function(e, t) {
    return !t && console.warn(e)
}, MT = function(e, t) {
    return e && (Jr[e] = t) && dp && (dp[e] = t) || Jr
}, If = function() {
    return 0
}, CF = {
    suppressEvents: !0,
    isStart: !0,
    kill: !1
}, Yd = {
    suppressEvents: !0,
    kill: !1
}, RF = {
    suppressEvents: !0
}, hy = {}, ga = [], U_ = {}, TT, $r = {}, Dg = {}, HS = 30, Kd = [], dy = "", py = function(e) {
    var t = e[0], i, r;
    if (io(t) || Wn(t) || (e = [e]),
    !(i = (t._gsap || {}).harness)) {
        for (r = Kd.length; r-- && !Kd[r].targetTest(t); )
            ;
        i = Kd[r]
    }
    for (r = e.length; r--; )
        e[r] && (e[r]._gsap || (e[r]._gsap = new ZT(e[r],i))) || e.splice(r, 1);
    return e
}, pl = function(e) {
    return e._gsap || py(vs(e))[0]._gsap
}, CT = function(e, t, i) {
    return (i = e[t]) && Wn(i) ? e[t]() : ly(i) && e.getAttribute && e.getAttribute(t) || i
}, Cr = function(e, t) {
    return (e = e.split(",")).forEach(t) || e
}, jn = function(e) {
    return Math.round(e * 1e5) / 1e5 || 0
}, xi = function(e) {
    return Math.round(e * 1e7) / 1e7 || 0
}, Pc = function(e, t) {
    var i = t.charAt(0)
      , r = parseFloat(t.substr(2));
    return e = parseFloat(e),
    i === "+" ? e + r : i === "-" ? e - r : i === "*" ? e * r : e / r
}, PF = function(e, t) {
    for (var i = t.length, r = 0; e.indexOf(t[r]) < 0 && ++r < i; )
        ;
    return r < i
}, pp = function() {
    var e = ga.length, t = ga.slice(0), i, r;
    for (U_ = {},
    ga.length = 0,
    i = 0; i < e; i++)
        r = t[i],
        r && r._lazy && (r.render(r._lazy[0], r._lazy[1], !0)._lazy = 0)
}, RT = function(e, t, i, r) {
    ga.length && !$i && pp(),
    e.render(t, i, r || $i && t < 0 && (e._initted || e._startAt)),
    ga.length && !$i && pp()
}, PT = function(e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(wT).length < 2 ? t : wi(e) ? e.trim() : e
}, LT = function(e) {
    return e
}, xs = function(e, t) {
    for (var i in t)
        i in e || (e[i] = t[i]);
    return e
}, LF = function(e) {
    return function(t, i) {
        for (var r in i)
            r in t || r === "duration" && e || r === "ease" || (t[r] = i[r])
    }
}, Ml = function(e, t) {
    for (var i in t)
        e[i] = t[i];
    return e
}, GS = function n(e, t) {
    for (var i in t)
        i !== "__proto__" && i !== "constructor" && i !== "prototype" && (e[i] = io(t[i]) ? n(e[i] || (e[i] = {}), t[i]) : t[i]);
    return e
}, mp = function(e, t) {
    var i = {}, r;
    for (r in e)
        r in t || (i[r] = e[r]);
    return i
}, mf = function(e) {
    var t = e.parent || Fn
      , i = e.keyframes ? LF(Xi(e.keyframes)) : xs;
    if (Tr(e.inherit))
        for (; t; )
            i(e, t.vars.defaults),
            t = t.parent || t._dp;
    return e
}, DF = function(e, t) {
    for (var i = e.length, r = i === t.length; r && i-- && e[i] === t[i]; )
        ;
    return i < 0
}, DT = function(e, t, i, r, s) {
    i === void 0 && (i = "_first"),
    r === void 0 && (r = "_last");
    var o = e[r], a;
    if (s)
        for (a = t[s]; o && o[s] > a; )
            o = o._prev;
    return o ? (t._next = o._next,
    o._next = t) : (t._next = e[i],
    e[i] = t),
    t._next ? t._next._prev = t : e[r] = t,
    t._prev = o,
    t.parent = t._dp = e,
    t
}, $p = function(e, t, i, r) {
    i === void 0 && (i = "_first"),
    r === void 0 && (r = "_last");
    var s = t._prev
      , o = t._next;
    s ? s._next = o : e[i] === t && (e[i] = o),
    o ? o._prev = s : e[r] === t && (e[r] = s),
    t._next = t._prev = t.parent = null
}, wa = function(e, t) {
    e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e),
    e._act = 0
}, ml = function(e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
        for (var i = e; i; )
            i._dirty = 1,
            i = i.parent;
    return e
}, IF = function(e) {
    for (var t = e.parent; t && t.parent; )
        t._dirty = 1,
        t.totalDuration(),
        t = t.parent;
    return e
}, F_ = function(e, t, i, r) {
    return e._startAt && ($i ? e._startAt.revert(Yd) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, r))
}, OF = function n(e) {
    return !e || e._ts && n(e.parent)
}, VS = function(e) {
    return e._repeat ? Gc(e._tTime, e = e.duration() + e._rDelay) * e : 0
}, Gc = function(e, t) {
    var i = Math.floor(e /= t);
    return e && i === e ? i - 1 : i
}, gp = function(e, t) {
    return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
}, Xp = function(e) {
    return e._end = xi(e._start + (e._tDur / Math.abs(e._ts || e._rts || Sn) || 0))
}, qp = function(e, t) {
    var i = e._dp;
    return i && i.smoothChildTiming && e._ts && (e._start = xi(i._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)),
    Xp(e),
    i._dirty || ml(i, e)),
    e
}, IT = function(e, t) {
    var i;
    if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (i = gp(e.rawTime(), t),
    (!t._dur || th(0, t.totalDuration(), i) - t._tTime > Sn) && t.render(i, !0)),
    ml(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
        if (e._dur < e.duration())
            for (i = e; i._dp; )
                i.rawTime() >= 0 && i.totalTime(i._tTime),
                i = i._dp;
        e._zTime = -Sn
    }
}, Ys = function(e, t, i, r) {
    return t.parent && wa(t),
    t._start = xi((Io(i) ? i : i || e !== Fn ? us(e, i, t) : e._time) + t._delay),
    t._end = xi(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)),
    DT(e, t, "_first", "_last", e._sort ? "_start" : 0),
    B_(t) || (e._recent = t),
    r || IT(e, t),
    e._ts < 0 && qp(e, e._tTime),
    e
}, OT = function(e, t) {
    return (Jr.ScrollTrigger || fy("scrollTrigger", t)) && Jr.ScrollTrigger.create(t, e)
}, NT = function(e, t, i, r, s) {
    if (gy(e, t, s),
    !e._initted)
        return 1;
    if (!i && e._pt && !$i && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && TT !== Xr.frame)
        return ga.push(e),
        e._lazy = [s, r],
        1
}, NF = function n(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n(t))
}, B_ = function(e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart"
}, UF = function(e, t, i, r) {
    var s = e.ratio, o = t < 0 || !t && (!e._start && NF(e) && !(!e._initted && B_(e)) || (e._ts < 0 || e._dp._ts < 0) && !B_(e)) ? 0 : 1, a = e._rDelay, c = 0, u, h, m;
    if (a && e._repeat && (c = th(0, e._tDur, t),
    h = Gc(c, a),
    e._yoyo && h & 1 && (o = 1 - o),
    h !== Gc(e._tTime, a) && (s = 1 - o,
    e.vars.repeatRefresh && e._initted && e.invalidate())),
    o !== s || $i || r || e._zTime === Sn || !t && e._zTime) {
        if (!e._initted && NT(e, t, r, i, c))
            return;
        for (m = e._zTime,
        e._zTime = t || (i ? Sn : 0),
        i || (i = t && !m),
        e.ratio = o,
        e._from && (o = 1 - o),
        e._time = 0,
        e._tTime = c,
        u = e._pt; u; )
            u.r(o, u.d),
            u = u._next;
        t < 0 && F_(e, t, i, !0),
        e._onUpdate && !i && Yr(e, "onUpdate"),
        c && e._repeat && !i && e.parent && Yr(e, "onRepeat"),
        (t >= e._tDur || t < 0) && e.ratio === o && (o && wa(e, 1),
        !i && !$i && (Yr(e, o ? "onComplete" : "onReverseComplete", !0),
        e._prom && e._prom()))
    } else
        e._zTime || (e._zTime = t)
}, FF = function(e, t, i) {
    var r;
    if (i > t)
        for (r = e._first; r && r._start <= i; ) {
            if (r.data === "isPause" && r._start > t)
                return r;
            r = r._next
        }
    else
        for (r = e._last; r && r._start >= i; ) {
            if (r.data === "isPause" && r._start < t)
                return r;
            r = r._prev
        }
}, Vc = function(e, t, i, r) {
    var s = e._repeat
      , o = xi(t) || 0
      , a = e._tTime / e._tDur;
    return a && !r && (e._time *= o / e._dur),
    e._dur = o,
    e._tDur = s ? s < 0 ? 1e10 : xi(o * (s + 1) + e._rDelay * s) : o,
    a > 0 && !r && qp(e, e._tTime = e._tDur * a),
    e.parent && Xp(e),
    i || ml(e.parent, e),
    e
}, WS = function(e) {
    return e instanceof cr ? ml(e) : Vc(e, e._dur)
}, BF = {
    _start: 0,
    endTime: If,
    totalDuration: If
}, us = function n(e, t, i) {
    var r = e.labels, s = e._recent || BF, o = e.duration() >= _s ? s.endTime(!1) : e._dur, a, c, u;
    return wi(t) && (isNaN(t) || t in r) ? (c = t.charAt(0),
    u = t.substr(-1) === "%",
    a = t.indexOf("="),
    c === "<" || c === ">" ? (a >= 0 && (t = t.replace(/=/, "")),
    (c === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (u ? (a < 0 ? s : i).totalDuration() / 100 : 1)) : a < 0 ? (t in r || (r[t] = o),
    r[t]) : (c = parseFloat(t.charAt(a - 1) + t.substr(a + 1)),
    u && i && (c = c / 100 * (Xi(i) ? i[0] : i).totalDuration()),
    a > 1 ? n(e, t.substr(0, a - 1), i) + c : o + c)) : t == null ? o : +t
}, gf = function(e, t, i) {
    var r = Io(t[1]), s = (r ? 2 : 1) + (e < 2 ? 0 : 1), o = t[s], a, c;
    if (r && (o.duration = t[1]),
    o.parent = i,
    e) {
        for (a = o,
        c = i; c && !("immediateRender"in a); )
            a = c.vars.defaults || {},
            c = Tr(c.vars.inherit) && c.parent;
        o.immediateRender = Tr(a.immediateRender),
        e < 2 ? o.runBackwards = 1 : o.startAt = t[s - 1]
    }
    return new ni(t[0],o,t[s + 1])
}, Pa = function(e, t) {
    return e || e === 0 ? t(e) : t
}, th = function(e, t, i) {
    return i < e ? e : i > t ? t : i
}, Vi = function(e, t) {
    return !wi(e) || !(t = TF.exec(e)) ? "" : t[1]
}, kF = function(e, t, i) {
    return Pa(i, function(r) {
        return th(e, t, r)
    })
}, k_ = [].slice, UT = function(e, t) {
    return e && io(e) && "length"in e && (!t && !e.length || e.length - 1 in e && io(e[0])) && !e.nodeType && e !== fs
}, zF = function(e, t, i) {
    return i === void 0 && (i = []),
    e.forEach(function(r) {
        var s;
        return wi(r) && !t || UT(r, 1) ? (s = i).push.apply(s, vs(r)) : i.push(r)
    }) || i
}, vs = function(e, t, i) {
    return Vn && !t && Vn.selector ? Vn.selector(e) : wi(e) && !i && (N_ || !Wc()) ? k_.call((t || uy).querySelectorAll(e), 0) : Xi(e) ? zF(e, i) : UT(e) ? k_.call(e, 0) : e ? [e] : []
}, z_ = function(e) {
    return e = vs(e)[0] || Df("Invalid scope") || {},
    function(t) {
        var i = e.current || e.nativeElement || e;
        return vs(t, i.querySelectorAll ? i : i === e ? Df("Invalid scope") || uy.createElement("div") : e)
    }
}, FT = function(e) {
    return e.sort(function() {
        return .5 - Math.random()
    })
}, BT = function(e) {
    if (Wn(e))
        return e;
    var t = io(e) ? e : {
        each: e
    }
      , i = gl(t.ease)
      , r = t.from || 0
      , s = parseFloat(t.base) || 0
      , o = {}
      , a = r > 0 && r < 1
      , c = isNaN(r) || a
      , u = t.axis
      , h = r
      , m = r;
    return wi(r) ? h = m = {
        center: .5,
        edges: .5,
        end: 1
    }[r] || 0 : !a && c && (h = r[0],
    m = r[1]),
    function(d, f, _) {
        var g = (_ || t).length, v = o[g], y, w, S, E, b, T, C, P, A;
        if (!v) {
            if (A = t.grid === "auto" ? 0 : (t.grid || [1, _s])[1],
            !A) {
                for (C = -_s; C < (C = _[A++].getBoundingClientRect().left) && A < g; )
                    ;
                A < g && A--
            }
            for (v = o[g] = [],
            y = c ? Math.min(A, g) * h - .5 : r % A,
            w = A === _s ? 0 : c ? g * m / A - .5 : r / A | 0,
            C = 0,
            P = _s,
            T = 0; T < g; T++)
                S = T % A - y,
                E = w - (T / A | 0),
                v[T] = b = u ? Math.abs(u === "y" ? E : S) : yT(S * S + E * E),
                b > C && (C = b),
                b < P && (P = b);
            r === "random" && FT(v),
            v.max = C - P,
            v.min = P,
            v.v = g = (parseFloat(t.amount) || parseFloat(t.each) * (A > g ? g - 1 : u ? u === "y" ? g / A : A : Math.max(A, g / A)) || 0) * (r === "edges" ? -1 : 1),
            v.b = g < 0 ? s - g : s,
            v.u = Vi(t.amount || t.each) || 0,
            i = i && g < 0 ? jT(i) : i
        }
        return g = (v[d] - v.min) / v.max || 0,
        xi(v.b + (i ? i(g) : g) * v.v) + v.u
    }
}, H_ = function(e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function(i) {
        var r = xi(Math.round(parseFloat(i) / e) * e * t);
        return (r - r % 1) / t + (Io(i) ? 0 : Vi(i))
    }
}, kT = function(e, t) {
    var i = Xi(e), r, s;
    return !i && io(e) && (r = i = e.radius || _s,
    e.values ? (e = vs(e.values),
    (s = !Io(e[0])) && (r *= r)) : e = H_(e.increment)),
    Pa(t, i ? Wn(e) ? function(o) {
        return s = e(o),
        Math.abs(s - o) <= r ? s : o
    }
    : function(o) {
        for (var a = parseFloat(s ? o.x : o), c = parseFloat(s ? o.y : 0), u = _s, h = 0, m = e.length, d, f; m--; )
            s ? (d = e[m].x - a,
            f = e[m].y - c,
            d = d * d + f * f) : d = Math.abs(e[m] - a),
            d < u && (u = d,
            h = m);
        return h = !r || u <= r ? e[h] : o,
        s || h === o || Io(o) ? h : h + Vi(o)
    }
    : H_(e))
}, zT = function(e, t, i, r) {
    return Pa(Xi(e) ? !t : i === !0 ? !!(i = 0) : !r, function() {
        return Xi(e) ? e[~~(Math.random() * e.length)] : (i = i || 1e-5) && (r = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((e - i / 2 + Math.random() * (t - e + i * .99)) / i) * i * r) / r
    })
}, HF = function() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
    return function(r) {
        return t.reduce(function(s, o) {
            return o(s)
        }, r)
    }
}, GF = function(e, t) {
    return function(i) {
        return e(parseFloat(i)) + (t || Vi(i))
    }
}, VF = function(e, t, i) {
    return GT(e, t, 0, 1, i)
}, HT = function(e, t, i) {
    return Pa(i, function(r) {
        return e[~~t(r)]
    })
}, WF = function n(e, t, i) {
    var r = t - e;
    return Xi(e) ? HT(e, n(0, e.length), t) : Pa(i, function(s) {
        return (r + (s - e) % r) % r + e
    })
}, $F = function n(e, t, i) {
    var r = t - e
      , s = r * 2;
    return Xi(e) ? HT(e, n(0, e.length - 1), t) : Pa(i, function(o) {
        return o = (s + (o - e) % s) % s || 0,
        e + (o > r ? s - o : o)
    })
}, Of = function(e) {
    for (var t = 0, i = "", r, s, o, a; ~(r = e.indexOf("random(", t)); )
        o = e.indexOf(")", r),
        a = e.charAt(r + 7) === "[",
        s = e.substr(r + 7, o - r - 7).match(a ? wT : O_),
        i += e.substr(t, r - t) + zT(a ? s : +s[0], a ? 0 : +s[1], +s[2] || 1e-5),
        t = o + 1;
    return i + e.substr(t, e.length - t)
}, GT = function(e, t, i, r, s) {
    var o = t - e
      , a = r - i;
    return Pa(s, function(c) {
        return i + ((c - e) / o * a || 0)
    })
}, XF = function n(e, t, i, r) {
    var s = isNaN(e + t) ? 0 : function(f) {
        return (1 - f) * e + f * t
    }
    ;
    if (!s) {
        var o = wi(e), a = {}, c, u, h, m, d;
        if (i === !0 && (r = 1) && (i = null),
        o)
            e = {
                p: e
            },
            t = {
                p: t
            };
        else if (Xi(e) && !Xi(t)) {
            for (h = [],
            m = e.length,
            d = m - 2,
            u = 1; u < m; u++)
                h.push(n(e[u - 1], e[u]));
            m--,
            s = function(_) {
                _ *= m;
                var g = Math.min(d, ~~_);
                return h[g](_ - g)
            }
            ,
            i = t
        } else
            r || (e = Ml(Xi(e) ? [] : {}, e));
        if (!h) {
            for (c in t)
                my.call(a, e, c, "get", t[c]);
            s = function(_) {
                return yy(_, a) || (o ? e.p : e)
            }
        }
    }
    return Pa(i, s)
}, $S = function(e, t, i) {
    var r = e.labels, s = _s, o, a, c;
    for (o in r)
        a = r[o] - t,
        a < 0 == !!i && a && s > (a = Math.abs(a)) && (c = o,
        s = a);
    return c
}, Yr = function(e, t, i) {
    var r = e.vars, s = r[t], o = Vn, a = e._ctx, c, u, h;
    if (s)
        return c = r[t + "Params"],
        u = r.callbackScope || e,
        i && ga.length && pp(),
        a && (Vn = a),
        h = c ? s.apply(u, c) : s.call(u),
        Vn = o,
        h
}, lf = function(e) {
    return wa(e),
    e.scrollTrigger && e.scrollTrigger.kill(!!$i),
    e.progress() < 1 && Yr(e, "onInterrupt"),
    e
}, Mc, VT = [], WT = function(e) {
    if (cy() && e) {
        e = !e.name && e.default || e;
        var t = e.name
          , i = Wn(e)
          , r = t && !i && e.init ? function() {
            this._props = []
        }
        : e
          , s = {
            init: If,
            render: yy,
            add: my,
            kill: lB,
            modifier: aB,
            rawVars: 0
        }
          , o = {
            targetTest: 0,
            get: 0,
            getSetter: vy,
            aliases: {},
            register: 0
        };
        if (Wc(),
        e !== r) {
            if ($r[t])
                return;
            xs(r, xs(mp(e, s), o)),
            Ml(r.prototype, Ml(s, mp(e, o))),
            $r[r.prop = t] = r,
            e.targetTest && (Kd.push(r),
            hy[t] = 1),
            t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
        }
        MT(t, r),
        e.register && e.register(Dr, r, Rr)
    } else
        e && VT.push(e)
}, bn = 255, cf = {
    aqua: [0, bn, bn],
    lime: [0, bn, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, bn],
    navy: [0, 0, 128],
    white: [bn, bn, bn],
    olive: [128, 128, 0],
    yellow: [bn, bn, 0],
    orange: [bn, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [bn, 0, 0],
    pink: [bn, 192, 203],
    cyan: [0, bn, bn],
    transparent: [bn, bn, bn, 0]
}, Ig = function(e, t, i) {
    return e += e < 0 ? 1 : e > 1 ? -1 : 0,
    (e * 6 < 1 ? t + (i - t) * e * 6 : e < .5 ? i : e * 3 < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) * bn + .5 | 0
}, $T = function(e, t, i) {
    var r = e ? Io(e) ? [e >> 16, e >> 8 & bn, e & bn] : 0 : cf.black, s, o, a, c, u, h, m, d, f, _;
    if (!r) {
        if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)),
        cf[e])
            r = cf[e];
        else if (e.charAt(0) === "#") {
            if (e.length < 6 && (s = e.charAt(1),
            o = e.charAt(2),
            a = e.charAt(3),
            e = "#" + s + s + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")),
            e.length === 9)
                return r = parseInt(e.substr(1, 6), 16),
                [r >> 16, r >> 8 & bn, r & bn, parseInt(e.substr(7), 16) / 255];
            e = parseInt(e.substr(1), 16),
            r = [e >> 16, e >> 8 & bn, e & bn]
        } else if (e.substr(0, 3) === "hsl") {
            if (r = _ = e.match(O_),
            !t)
                c = +r[0] % 360 / 360,
                u = +r[1] / 100,
                h = +r[2] / 100,
                o = h <= .5 ? h * (u + 1) : h + u - h * u,
                s = h * 2 - o,
                r.length > 3 && (r[3] *= 1),
                r[0] = Ig(c + 1 / 3, s, o),
                r[1] = Ig(c, s, o),
                r[2] = Ig(c - 1 / 3, s, o);
            else if (~e.indexOf("="))
                return r = e.match(bT),
                i && r.length < 4 && (r[3] = 1),
                r
        } else
            r = e.match(O_) || cf.transparent;
        r = r.map(Number)
    }
    return t && !_ && (s = r[0] / bn,
    o = r[1] / bn,
    a = r[2] / bn,
    m = Math.max(s, o, a),
    d = Math.min(s, o, a),
    h = (m + d) / 2,
    m === d ? c = u = 0 : (f = m - d,
    u = h > .5 ? f / (2 - m - d) : f / (m + d),
    c = m === s ? (o - a) / f + (o < a ? 6 : 0) : m === o ? (a - s) / f + 2 : (s - o) / f + 4,
    c *= 60),
    r[0] = ~~(c + .5),
    r[1] = ~~(u * 100 + .5),
    r[2] = ~~(h * 100 + .5)),
    i && r.length < 4 && (r[3] = 1),
    r
}, XT = function(e) {
    var t = []
      , i = []
      , r = -1;
    return e.split(_a).forEach(function(s) {
        var o = s.match(Ac) || [];
        t.push.apply(t, o),
        i.push(r += o.length + 1)
    }),
    t.c = i,
    t
}, XS = function(e, t, i) {
    var r = "", s = (e + r).match(_a), o = t ? "hsla(" : "rgba(", a = 0, c, u, h, m;
    if (!s)
        return e;
    if (s = s.map(function(d) {
        return (d = $T(d, t, 1)) && o + (t ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) + ")"
    }),
    i && (h = XT(e),
    c = i.c,
    c.join(r) !== h.c.join(r)))
        for (u = e.replace(_a, "1").split(Ac),
        m = u.length - 1; a < m; a++)
            r += u[a] + (~c.indexOf(a) ? s.shift() || o + "0,0,0,0)" : (h.length ? h : s.length ? s : i).shift());
    if (!u)
        for (u = e.split(_a),
        m = u.length - 1; a < m; a++)
            r += u[a] + s[a];
    return r + u[m]
}, _a = function() {
    var n = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
    for (e in cf)
        n += "|" + e + "\\b";
    return new RegExp(n + ")","gi")
}(), qF = /hsl[a]?\(/, qT = function(e) {
    var t = e.join(" "), i;
    if (_a.lastIndex = 0,
    _a.test(t))
        return i = qF.test(t),
        e[1] = XS(e[1], i),
        e[0] = XS(e[0], i, XT(e[1])),
        !0
}, Nf, Xr = function() {
    var n = Date.now, e = 500, t = 33, i = n(), r = i, s = 1e3 / 240, o = s, a = [], c, u, h, m, d, f, _ = function g(v) {
        var y = n() - r, w = v === !0, S, E, b, T;
        if (y > e && (i += y - t),
        r += y,
        b = r - i,
        S = b - o,
        (S > 0 || w) && (T = ++m.frame,
        d = b - m.time * 1e3,
        m.time = b = b / 1e3,
        o += S + (S >= s ? 4 : s - S),
        E = 1),
        w || (c = u(g)),
        E)
            for (f = 0; f < a.length; f++)
                a[f](b, d, T, v)
    };
    return m = {
        time: 0,
        frame: 0,
        tick: function() {
            _(!0)
        },
        deltaRatio: function(v) {
            return d / (1e3 / (v || 60))
        },
        wake: function() {
            ET && (!N_ && cy() && (fs = N_ = window,
            uy = fs.document || {},
            Jr.gsap = Dr,
            (fs.gsapVersions || (fs.gsapVersions = [])).push(Dr.version),
            AT(dp || fs.GreenSockGlobals || !fs.gsap && fs || {}),
            h = fs.requestAnimationFrame,
            VT.forEach(WT)),
            c && m.sleep(),
            u = h || function(v) {
                return setTimeout(v, o - m.time * 1e3 + 1 | 0)
            }
            ,
            Nf = 1,
            _(2))
        },
        sleep: function() {
            (h ? fs.cancelAnimationFrame : clearTimeout)(c),
            Nf = 0,
            u = If
        },
        lagSmoothing: function(v, y) {
            e = v || 1 / 0,
            t = Math.min(y || 33, e)
        },
        fps: function(v) {
            s = 1e3 / (v || 240),
            o = m.time * 1e3 + s
        },
        add: function(v, y, w) {
            var S = y ? function(E, b, T, C) {
                v(E, b, T, C),
                m.remove(S)
            }
            : v;
            return m.remove(v),
            a[w ? "unshift" : "push"](S),
            Wc(),
            S
        },
        remove: function(v, y) {
            ~(y = a.indexOf(v)) && a.splice(y, 1) && f >= y && f--
        },
        _listeners: a
    },
    m
}(), Wc = function() {
    return !Nf && Xr.wake()
}, sn = {}, jF = /^[\d.\-M][\d.\-,\s]/, YF = /["']/g, KF = function(e) {
    for (var t = {}, i = e.substr(1, e.length - 3).split(":"), r = i[0], s = 1, o = i.length, a, c, u; s < o; s++)
        c = i[s],
        a = s !== o - 1 ? c.lastIndexOf(",") : c.length,
        u = c.substr(0, a),
        t[r] = isNaN(u) ? u.replace(YF, "").trim() : +u,
        r = c.substr(a + 1).trim();
    return t
}, ZF = function(e) {
    var t = e.indexOf("(") + 1
      , i = e.indexOf(")")
      , r = e.indexOf("(", t);
    return e.substring(t, ~r && r < i ? e.indexOf(")", i + 1) : i)
}, JF = function(e) {
    var t = (e + "").split("(")
      , i = sn[t[0]];
    return i && t.length > 1 && i.config ? i.config.apply(null, ~e.indexOf("{") ? [KF(t[1])] : ZF(e).split(",").map(PT)) : sn._CE && jF.test(e) ? sn._CE("", e) : i
}, jT = function(e) {
    return function(t) {
        return 1 - e(1 - t)
    }
}, YT = function n(e, t) {
    for (var i = e._first, r; i; )
        i instanceof cr ? n(i, t) : i.vars.yoyoEase && (!i._yoyo || !i._repeat) && i._yoyo !== t && (i.timeline ? n(i.timeline, t) : (r = i._ease,
        i._ease = i._yEase,
        i._yEase = r,
        i._yoyo = t)),
        i = i._next
}, gl = function(e, t) {
    return e && (Wn(e) ? e : sn[e] || JF(e)) || t
}, Ol = function(e, t, i, r) {
    i === void 0 && (i = function(c) {
        return 1 - t(1 - c)
    }
    ),
    r === void 0 && (r = function(c) {
        return c < .5 ? t(c * 2) / 2 : 1 - t((1 - c) * 2) / 2
    }
    );
    var s = {
        easeIn: t,
        easeOut: i,
        easeInOut: r
    }, o;
    return Cr(e, function(a) {
        sn[a] = Jr[a] = s,
        sn[o = a.toLowerCase()] = i;
        for (var c in s)
            sn[o + (c === "easeIn" ? ".in" : c === "easeOut" ? ".out" : ".inOut")] = sn[a + "." + c] = s[c]
    }),
    s
}, KT = function(e) {
    return function(t) {
        return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2
    }
}, Og = function n(e, t, i) {
    var r = t >= 1 ? t : 1
      , s = (i || (e ? .3 : .45)) / (t < 1 ? t : 1)
      , o = s / I_ * (Math.asin(1 / r) || 0)
      , a = function(h) {
        return h === 1 ? 1 : r * Math.pow(2, -10 * h) * MF((h - o) * s) + 1
    }
      , c = e === "out" ? a : e === "in" ? function(u) {
        return 1 - a(1 - u)
    }
    : KT(a);
    return s = I_ / s,
    c.config = function(u, h) {
        return n(e, u, h)
    }
    ,
    c
}, Ng = function n(e, t) {
    t === void 0 && (t = 1.70158);
    var i = function(o) {
        return o ? --o * o * ((t + 1) * o + t) + 1 : 0
    }
      , r = e === "out" ? i : e === "in" ? function(s) {
        return 1 - i(1 - s)
    }
    : KT(i);
    return r.config = function(s) {
        return n(e, s)
    }
    ,
    r
};
Cr("Linear,Quad,Cubic,Quart,Quint,Strong", function(n, e) {
    var t = e < 5 ? e + 1 : e;
    Ol(n + ",Power" + (t - 1), e ? function(i) {
        return Math.pow(i, t)
    }
    : function(i) {
        return i
    }
    , function(i) {
        return 1 - Math.pow(1 - i, t)
    }, function(i) {
        return i < .5 ? Math.pow(i * 2, t) / 2 : 1 - Math.pow((1 - i) * 2, t) / 2
    })
});
sn.Linear.easeNone = sn.none = sn.Linear.easeIn;
Ol("Elastic", Og("in"), Og("out"), Og());
(function(n, e) {
    var t = 1 / e
      , i = 2 * t
      , r = 2.5 * t
      , s = function(a) {
        return a < t ? n * a * a : a < i ? n * Math.pow(a - 1.5 / e, 2) + .75 : a < r ? n * (a -= 2.25 / e) * a + .9375 : n * Math.pow(a - 2.625 / e, 2) + .984375
    };
    Ol("Bounce", function(o) {
        return 1 - s(1 - o)
    }, s)
}
)(7.5625, 2.75);
Ol("Expo", function(n) {
    return n ? Math.pow(2, 10 * (n - 1)) : 0
});
Ol("Circ", function(n) {
    return -(yT(1 - n * n) - 1)
});
Ol("Sine", function(n) {
    return n === 1 ? 1 : -AF(n * wF) + 1
});
Ol("Back", Ng("in"), Ng("out"), Ng());
sn.SteppedEase = sn.steps = Jr.SteppedEase = {
    config: function(e, t) {
        e === void 0 && (e = 1);
        var i = 1 / e
          , r = e + (t ? 0 : 1)
          , s = t ? 1 : 0
          , o = 1 - Sn;
        return function(a) {
            return ((r * th(0, o, a) | 0) + s) * i
        }
    }
};
Hc.ease = sn["quad.out"];
Cr("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(n) {
    return dy += n + "," + n + "Params,"
});
var ZT = function(e, t) {
    this.id = EF++,
    e._gsap = this,
    this.target = e,
    this.harness = t,
    this.get = t ? t.get : CT,
    this.set = t ? t.getSetter : vy
}
  , Uf = function() {
    function n(t) {
        this.vars = t,
        this._delay = +t.delay || 0,
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0,
        this._yoyo = !!t.yoyo || !!t.yoyoEase),
        this._ts = 1,
        Vc(this, +t.duration, 1, 1),
        this.data = t.data,
        Vn && (this._ctx = Vn,
        Vn.data.push(this)),
        Nf || Xr.wake()
    }
    var e = n.prototype;
    return e.delay = function(i) {
        return i || i === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + i - this._delay),
        this._delay = i,
        this) : this._delay
    }
    ,
    e.duration = function(i) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i) : this.totalDuration() && this._dur
    }
    ,
    e.totalDuration = function(i) {
        return arguments.length ? (this._dirty = 0,
        Vc(this, this._repeat < 0 ? i : (i - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
    }
    ,
    e.totalTime = function(i, r) {
        if (Wc(),
        !arguments.length)
            return this._tTime;
        var s = this._dp;
        if (s && s.smoothChildTiming && this._ts) {
            for (qp(this, i),
            !s._dp || s.parent || IT(s, this); s && s.parent; )
                s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, !0),
                s = s.parent;
            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && i < this._tDur || this._ts < 0 && i > 0 || !this._tDur && !i) && Ys(this._dp, this, this._start - this._delay)
        }
        return (this._tTime !== i || !this._dur && !r || this._initted && Math.abs(this._zTime) === Sn || !i && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = i),
        RT(this, i, r)),
        this
    }
    ,
    e.time = function(i, r) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), i + VS(this)) % (this._dur + this._rDelay) || (i ? this._dur : 0), r) : this._time
    }
    ,
    e.totalProgress = function(i, r) {
        return arguments.length ? this.totalTime(this.totalDuration() * i, r) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
    }
    ,
    e.progress = function(i, r) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) + VS(this), r) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
    }
    ,
    e.iteration = function(i, r) {
        var s = this.duration() + this._rDelay;
        return arguments.length ? this.totalTime(this._time + (i - 1) * s, r) : this._repeat ? Gc(this._tTime, s) + 1 : 1
    }
    ,
    e.timeScale = function(i, r) {
        if (!arguments.length)
            return this._rts === -Sn ? 0 : this._rts;
        if (this._rts === i)
            return this;
        var s = this.parent && this._ts ? gp(this.parent._time, this) : this._tTime;
        return this._rts = +i || 0,
        this._ts = this._ps || i === -Sn ? 0 : this._rts,
        this.totalTime(th(-Math.abs(this._delay), this._tDur, s), r !== !1),
        Xp(this),
        IF(this)
    }
    ,
    e.paused = function(i) {
        return arguments.length ? (this._ps !== i && (this._ps = i,
        i ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
        this._ts = this._act = 0) : (Wc(),
        this._ts = this._rts,
        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Sn && (this._tTime -= Sn)))),
        this) : this._ps
    }
    ,
    e.startTime = function(i) {
        if (arguments.length) {
            this._start = i;
            var r = this.parent || this._dp;
            return r && (r._sort || !this.parent) && Ys(r, this, i - this._delay),
            this
        }
        return this._start
    }
    ,
    e.endTime = function(i) {
        return this._start + (Tr(i) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
    }
    ,
    e.rawTime = function(i) {
        var r = this.parent || this._dp;
        return r ? i && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? gp(r.rawTime(i), this) : this._tTime : this._tTime
    }
    ,
    e.revert = function(i) {
        i === void 0 && (i = RF);
        var r = $i;
        return $i = i,
        (this._initted || this._startAt) && (this.timeline && this.timeline.revert(i),
        this.totalTime(-.01, i.suppressEvents)),
        this.data !== "nested" && i.kill !== !1 && this.kill(),
        $i = r,
        this
    }
    ,
    e.globalTime = function(i) {
        for (var r = this, s = arguments.length ? i : r.rawTime(); r; )
            s = r._start + s / (Math.abs(r._ts) || 1),
            r = r._dp;
        return !this.parent && this._sat ? this._sat.globalTime(i) : s
    }
    ,
    e.repeat = function(i) {
        return arguments.length ? (this._repeat = i === 1 / 0 ? -2 : i,
        WS(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
    }
    ,
    e.repeatDelay = function(i) {
        if (arguments.length) {
            var r = this._time;
            return this._rDelay = i,
            WS(this),
            r ? this.time(r) : this
        }
        return this._rDelay
    }
    ,
    e.yoyo = function(i) {
        return arguments.length ? (this._yoyo = i,
        this) : this._yoyo
    }
    ,
    e.seek = function(i, r) {
        return this.totalTime(us(this, i), Tr(r))
    }
    ,
    e.restart = function(i, r) {
        return this.play().totalTime(i ? -this._delay : 0, Tr(r))
    }
    ,
    e.play = function(i, r) {
        return i != null && this.seek(i, r),
        this.reversed(!1).paused(!1)
    }
    ,
    e.reverse = function(i, r) {
        return i != null && this.seek(i || this.totalDuration(), r),
        this.reversed(!0).paused(!1)
    }
    ,
    e.pause = function(i, r) {
        return i != null && this.seek(i, r),
        this.paused(!0)
    }
    ,
    e.resume = function() {
        return this.paused(!1)
    }
    ,
    e.reversed = function(i) {
        return arguments.length ? (!!i !== this.reversed() && this.timeScale(-this._rts || (i ? -Sn : 0)),
        this) : this._rts < 0
    }
    ,
    e.invalidate = function() {
        return this._initted = this._act = 0,
        this._zTime = -Sn,
        this
    }
    ,
    e.isActive = function() {
        var i = this.parent || this._dp, r = this._start, s;
        return !!(!i || this._ts && this._initted && i.isActive() && (s = i.rawTime(!0)) >= r && s < this.endTime(!0) - Sn)
    }
    ,
    e.eventCallback = function(i, r, s) {
        var o = this.vars;
        return arguments.length > 1 ? (r ? (o[i] = r,
        s && (o[i + "Params"] = s),
        i === "onUpdate" && (this._onUpdate = r)) : delete o[i],
        this) : o[i]
    }
    ,
    e.then = function(i) {
        var r = this;
        return new Promise(function(s) {
            var o = Wn(i) ? i : LT
              , a = function() {
                var u = r.then;
                r.then = null,
                Wn(o) && (o = o(r)) && (o.then || o === r) && (r.then = u),
                s(o),
                r.then = u
            };
            r._initted && r.totalProgress() === 1 && r._ts >= 0 || !r._tTime && r._ts < 0 ? a() : r._prom = a
        }
        )
    }
    ,
    e.kill = function() {
        lf(this)
    }
    ,
    n
}();
xs(Uf.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -Sn,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var cr = function(n) {
    vT(e, n);
    function e(i, r) {
        var s;
        return i === void 0 && (i = {}),
        s = n.call(this, i) || this,
        s.labels = {},
        s.smoothChildTiming = !!i.smoothChildTiming,
        s.autoRemoveChildren = !!i.autoRemoveChildren,
        s._sort = Tr(i.sortChildren),
        Fn && Ys(i.parent || Fn, Eo(s), r),
        i.reversed && s.reverse(),
        i.paused && s.paused(!0),
        i.scrollTrigger && OT(Eo(s), i.scrollTrigger),
        s
    }
    var t = e.prototype;
    return t.to = function(r, s, o) {
        return gf(0, arguments, this),
        this
    }
    ,
    t.from = function(r, s, o) {
        return gf(1, arguments, this),
        this
    }
    ,
    t.fromTo = function(r, s, o, a) {
        return gf(2, arguments, this),
        this
    }
    ,
    t.set = function(r, s, o) {
        return s.duration = 0,
        s.parent = this,
        mf(s).repeatDelay || (s.repeat = 0),
        s.immediateRender = !!s.immediateRender,
        new ni(r,s,us(this, o),1),
        this
    }
    ,
    t.call = function(r, s, o) {
        return Ys(this, ni.delayedCall(0, r, s), o)
    }
    ,
    t.staggerTo = function(r, s, o, a, c, u, h) {
        return o.duration = s,
        o.stagger = o.stagger || a,
        o.onComplete = u,
        o.onCompleteParams = h,
        o.parent = this,
        new ni(r,o,us(this, c)),
        this
    }
    ,
    t.staggerFrom = function(r, s, o, a, c, u, h) {
        return o.runBackwards = 1,
        mf(o).immediateRender = Tr(o.immediateRender),
        this.staggerTo(r, s, o, a, c, u, h)
    }
    ,
    t.staggerFromTo = function(r, s, o, a, c, u, h, m) {
        return a.startAt = o,
        mf(a).immediateRender = Tr(a.immediateRender),
        this.staggerTo(r, s, a, c, u, h, m)
    }
    ,
    t.render = function(r, s, o) {
        var a = this._time, c = this._dirty ? this.totalDuration() : this._tDur, u = this._dur, h = r <= 0 ? 0 : xi(r), m = this._zTime < 0 != r < 0 && (this._initted || !u), d, f, _, g, v, y, w, S, E, b, T, C;
        if (this !== Fn && h > c && r >= 0 && (h = c),
        h !== this._tTime || o || m) {
            if (a !== this._time && u && (h += this._time - a,
            r += this._time - a),
            d = h,
            E = this._start,
            S = this._ts,
            y = !S,
            m && (u || (a = this._zTime),
            (r || !s) && (this._zTime = r)),
            this._repeat) {
                if (T = this._yoyo,
                v = u + this._rDelay,
                this._repeat < -1 && r < 0)
                    return this.totalTime(v * 100 + r, s, o);
                if (d = xi(h % v),
                h === c ? (g = this._repeat,
                d = u) : (g = ~~(h / v),
                g && g === h / v && (d = u,
                g--),
                d > u && (d = u)),
                b = Gc(this._tTime, v),
                !a && this._tTime && b !== g && this._tTime - b * v - this._dur <= 0 && (b = g),
                T && g & 1 && (d = u - d,
                C = 1),
                g !== b && !this._lock) {
                    var P = T && b & 1
                      , A = P === (T && g & 1);
                    if (g < b && (P = !P),
                    a = P ? 0 : h % u ? u : h,
                    this._lock = 1,
                    this.render(a || (C ? 0 : xi(g * v)), s, !u)._lock = 0,
                    this._tTime = h,
                    !s && this.parent && Yr(this, "onRepeat"),
                    this.vars.repeatRefresh && !C && (this.invalidate()._lock = 1),
                    a && a !== this._time || y !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                        return this;
                    if (u = this._dur,
                    c = this._tDur,
                    A && (this._lock = 2,
                    a = P ? u : -1e-4,
                    this.render(a, !0),
                    this.vars.repeatRefresh && !C && this.invalidate()),
                    this._lock = 0,
                    !this._ts && !y)
                        return this;
                    YT(this, C)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (w = FF(this, xi(a), xi(d)),
            w && (h -= d - (d = w._start))),
            this._tTime = h,
            this._time = d,
            this._act = !S,
            this._initted || (this._onUpdate = this.vars.onUpdate,
            this._initted = 1,
            this._zTime = r,
            a = 0),
            !a && d && !s && !g && (Yr(this, "onStart"),
            this._tTime !== h))
                return this;
            if (d >= a && r >= 0)
                for (f = this._first; f; ) {
                    if (_ = f._next,
                    (f._act || d >= f._start) && f._ts && w !== f) {
                        if (f.parent !== this)
                            return this.render(r, s, o);
                        if (f.render(f._ts > 0 ? (d - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (d - f._start) * f._ts, s, o),
                        d !== this._time || !this._ts && !y) {
                            w = 0,
                            _ && (h += this._zTime = -Sn);
                            break
                        }
                    }
                    f = _
                }
            else {
                f = this._last;
                for (var R = r < 0 ? r : d; f; ) {
                    if (_ = f._prev,
                    (f._act || R <= f._end) && f._ts && w !== f) {
                        if (f.parent !== this)
                            return this.render(r, s, o);
                        if (f.render(f._ts > 0 ? (R - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (R - f._start) * f._ts, s, o || $i && (f._initted || f._startAt)),
                        d !== this._time || !this._ts && !y) {
                            w = 0,
                            _ && (h += this._zTime = R ? -Sn : Sn);
                            break
                        }
                    }
                    f = _
                }
            }
            if (w && !s && (this.pause(),
            w.render(d >= a ? 0 : -Sn)._zTime = d >= a ? 1 : -1,
            this._ts))
                return this._start = E,
                Xp(this),
                this.render(r, s, o);
            this._onUpdate && !s && Yr(this, "onUpdate", !0),
            (h === c && this._tTime >= this.totalDuration() || !h && a) && (E === this._start || Math.abs(S) !== Math.abs(this._ts)) && (this._lock || ((r || !u) && (h === c && this._ts > 0 || !h && this._ts < 0) && wa(this, 1),
            !s && !(r < 0 && !a) && (h || a || !c) && (Yr(this, h === c && r >= 0 ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(h < c && this.timeScale() > 0) && this._prom())))
        }
        return this
    }
    ,
    t.add = function(r, s) {
        var o = this;
        if (Io(s) || (s = us(this, s, r)),
        !(r instanceof Uf)) {
            if (Xi(r))
                return r.forEach(function(a) {
                    return o.add(a, s)
                }),
                this;
            if (wi(r))
                return this.addLabel(r, s);
            if (Wn(r))
                r = ni.delayedCall(0, r);
            else
                return this
        }
        return this !== r ? Ys(this, r, s) : this
    }
    ,
    t.getChildren = function(r, s, o, a) {
        r === void 0 && (r = !0),
        s === void 0 && (s = !0),
        o === void 0 && (o = !0),
        a === void 0 && (a = -_s);
        for (var c = [], u = this._first; u; )
            u._start >= a && (u instanceof ni ? s && c.push(u) : (o && c.push(u),
            r && c.push.apply(c, u.getChildren(!0, s, o)))),
            u = u._next;
        return c
    }
    ,
    t.getById = function(r) {
        for (var s = this.getChildren(1, 1, 1), o = s.length; o--; )
            if (s[o].vars.id === r)
                return s[o]
    }
    ,
    t.remove = function(r) {
        return wi(r) ? this.removeLabel(r) : Wn(r) ? this.killTweensOf(r) : ($p(this, r),
        r === this._recent && (this._recent = this._last),
        ml(this))
    }
    ,
    t.totalTime = function(r, s) {
        return arguments.length ? (this._forcing = 1,
        !this._dp && this._ts && (this._start = xi(Xr.time - (this._ts > 0 ? r / this._ts : (this.totalDuration() - r) / -this._ts))),
        n.prototype.totalTime.call(this, r, s),
        this._forcing = 0,
        this) : this._tTime
    }
    ,
    t.addLabel = function(r, s) {
        return this.labels[r] = us(this, s),
        this
    }
    ,
    t.removeLabel = function(r) {
        return delete this.labels[r],
        this
    }
    ,
    t.addPause = function(r, s, o) {
        var a = ni.delayedCall(0, s || If, o);
        return a.data = "isPause",
        this._hasPause = 1,
        Ys(this, a, us(this, r))
    }
    ,
    t.removePause = function(r) {
        var s = this._first;
        for (r = us(this, r); s; )
            s._start === r && s.data === "isPause" && wa(s),
            s = s._next
    }
    ,
    t.killTweensOf = function(r, s, o) {
        for (var a = this.getTweensOf(r, o), c = a.length; c--; )
            la !== a[c] && a[c].kill(r, s);
        return this
    }
    ,
    t.getTweensOf = function(r, s) {
        for (var o = [], a = vs(r), c = this._first, u = Io(s), h; c; )
            c instanceof ni ? PF(c._targets, a) && (u ? (!la || c._initted && c._ts) && c.globalTime(0) <= s && c.globalTime(c.totalDuration()) > s : !s || c.isActive()) && o.push(c) : (h = c.getTweensOf(a, s)).length && o.push.apply(o, h),
            c = c._next;
        return o
    }
    ,
    t.tweenTo = function(r, s) {
        s = s || {};
        var o = this, a = us(o, r), c = s, u = c.startAt, h = c.onStart, m = c.onStartParams, d = c.immediateRender, f, _ = ni.to(o, xs({
            ease: s.ease || "none",
            lazy: !1,
            immediateRender: !1,
            time: a,
            overwrite: "auto",
            duration: s.duration || Math.abs((a - (u && "time"in u ? u.time : o._time)) / o.timeScale()) || Sn,
            onStart: function() {
                if (o.pause(),
                !f) {
                    var v = s.duration || Math.abs((a - (u && "time"in u ? u.time : o._time)) / o.timeScale());
                    _._dur !== v && Vc(_, v, 0, 1).render(_._time, !0, !0),
                    f = 1
                }
                h && h.apply(_, m || [])
            }
        }, s));
        return d ? _.render(0) : _
    }
    ,
    t.tweenFromTo = function(r, s, o) {
        return this.tweenTo(s, xs({
            startAt: {
                time: us(this, r)
            }
        }, o))
    }
    ,
    t.recent = function() {
        return this._recent
    }
    ,
    t.nextLabel = function(r) {
        return r === void 0 && (r = this._time),
        $S(this, us(this, r))
    }
    ,
    t.previousLabel = function(r) {
        return r === void 0 && (r = this._time),
        $S(this, us(this, r), 1)
    }
    ,
    t.currentLabel = function(r) {
        return arguments.length ? this.seek(r, !0) : this.previousLabel(this._time + Sn)
    }
    ,
    t.shiftChildren = function(r, s, o) {
        o === void 0 && (o = 0);
        for (var a = this._first, c = this.labels, u; a; )
            a._start >= o && (a._start += r,
            a._end += r),
            a = a._next;
        if (s)
            for (u in c)
                c[u] >= o && (c[u] += r);
        return ml(this)
    }
    ,
    t.invalidate = function(r) {
        var s = this._first;
        for (this._lock = 0; s; )
            s.invalidate(r),
            s = s._next;
        return n.prototype.invalidate.call(this, r)
    }
    ,
    t.clear = function(r) {
        r === void 0 && (r = !0);
        for (var s = this._first, o; s; )
            o = s._next,
            this.remove(s),
            s = o;
        return this._dp && (this._time = this._tTime = this._pTime = 0),
        r && (this.labels = {}),
        ml(this)
    }
    ,
    t.totalDuration = function(r) {
        var s = 0, o = this, a = o._last, c = _s, u, h, m;
        if (arguments.length)
            return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -r : r));
        if (o._dirty) {
            for (m = o.parent; a; )
                u = a._prev,
                a._dirty && a.totalDuration(),
                h = a._start,
                h > c && o._sort && a._ts && !o._lock ? (o._lock = 1,
                Ys(o, a, h - a._delay, 1)._lock = 0) : c = h,
                h < 0 && a._ts && (s -= h,
                (!m && !o._dp || m && m.smoothChildTiming) && (o._start += h / o._ts,
                o._time -= h,
                o._tTime -= h),
                o.shiftChildren(-h, !1, -1 / 0),
                c = 0),
                a._end > s && a._ts && (s = a._end),
                a = u;
            Vc(o, o === Fn && o._time > s ? o._time : s, 1, 1),
            o._dirty = 0
        }
        return o._tDur
    }
    ,
    e.updateRoot = function(r) {
        if (Fn._ts && (RT(Fn, gp(r, Fn)),
        TT = Xr.frame),
        Xr.frame >= HS) {
            HS += Kr.autoSleep || 120;
            var s = Fn._first;
            if ((!s || !s._ts) && Kr.autoSleep && Xr._listeners.length < 2) {
                for (; s && !s._ts; )
                    s = s._next;
                s || Xr.sleep()
            }
        }
    }
    ,
    e
}(Uf);
xs(cr.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var QF = function(e, t, i, r, s, o, a) {
    var c = new Rr(this._pt,e,t,0,1,iC,null,s), u = 0, h = 0, m, d, f, _, g, v, y, w;
    for (c.b = i,
    c.e = r,
    i += "",
    r += "",
    (y = ~r.indexOf("random(")) && (r = Of(r)),
    o && (w = [i, r],
    o(w, e, t),
    i = w[0],
    r = w[1]),
    d = i.match(Lg) || []; m = Lg.exec(r); )
        _ = m[0],
        g = r.substring(u, m.index),
        f ? f = (f + 1) % 5 : g.substr(-5) === "rgba(" && (f = 1),
        _ !== d[h++] && (v = parseFloat(d[h - 1]) || 0,
        c._pt = {
            _next: c._pt,
            p: g || h === 1 ? g : ",",
            s: v,
            c: _.charAt(1) === "=" ? Pc(v, _) - v : parseFloat(_) - v,
            m: f && f < 4 ? Math.round : 0
        },
        u = Lg.lastIndex);
    return c.c = u < r.length ? r.substring(u, r.length) : "",
    c.fp = a,
    (ST.test(r) || y) && (c.e = 0),
    this._pt = c,
    c
}, my = function(e, t, i, r, s, o, a, c, u, h) {
    Wn(r) && (r = r(s || 0, e, o));
    var m = e[t], d = i !== "get" ? i : Wn(m) ? u ? e[t.indexOf("set") || !Wn(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](u) : e[t]() : m, f = Wn(m) ? u ? rB : tC : _y, _;
    if (wi(r) && (~r.indexOf("random(") && (r = Of(r)),
    r.charAt(1) === "=" && (_ = Pc(d, r) + (Vi(d) || 0),
    (_ || _ === 0) && (r = _))),
    !h || d !== r || G_)
        return !isNaN(d * r) && r !== "" ? (_ = new Rr(this._pt,e,t,+d || 0,r - (d || 0),typeof m == "boolean" ? oB : nC,0,f),
        u && (_.fp = u),
        a && _.modifier(a, this, e),
        this._pt = _) : (!m && !(t in e) && fy(t, r),
        QF.call(this, e, t, d, r, f, c || Kr.stringFilter, u))
}, eB = function(e, t, i, r, s) {
    if (Wn(e) && (e = _f(e, s, t, i, r)),
    !io(e) || e.style && e.nodeType || Xi(e) || xT(e))
        return wi(e) ? _f(e, s, t, i, r) : e;
    var o = {}, a;
    for (a in e)
        o[a] = _f(e[a], s, t, i, r);
    return o
}, JT = function(e, t, i, r, s, o) {
    var a, c, u, h;
    if ($r[e] && (a = new $r[e]).init(s, a.rawVars ? t[e] : eB(t[e], r, s, o, i), i, r, o) !== !1 && (i._pt = c = new Rr(i._pt,s,e,0,1,a.render,a,0,a.priority),
    i !== Mc))
        for (u = i._ptLookup[i._targets.indexOf(s)],
        h = a._props.length; h--; )
            u[a._props[h]] = c;
    return a
}, la, G_, gy = function n(e, t, i) {
    var r = e.vars, s = r.ease, o = r.startAt, a = r.immediateRender, c = r.lazy, u = r.onUpdate, h = r.runBackwards, m = r.yoyoEase, d = r.keyframes, f = r.autoRevert, _ = e._dur, g = e._startAt, v = e._targets, y = e.parent, w = y && y.data === "nested" ? y.vars.targets : v, S = e._overwrite === "auto" && !ay, E = e.timeline, b, T, C, P, A, R, I, D, H, B, G, X, V;
    if (E && (!d || !s) && (s = "none"),
    e._ease = gl(s, Hc.ease),
    e._yEase = m ? jT(gl(m === !0 ? s : m, Hc.ease)) : 0,
    m && e._yoyo && !e._repeat && (m = e._yEase,
    e._yEase = e._ease,
    e._ease = m),
    e._from = !E && !!r.runBackwards,
    !E || d && !r.stagger) {
        if (D = v[0] ? pl(v[0]).harness : 0,
        X = D && r[D.prop],
        b = mp(r, hy),
        g && (g._zTime < 0 && g.progress(1),
        t < 0 && h && a && !f ? g.render(-1, !0) : g.revert(h && _ ? Yd : CF),
        g._lazy = 0),
        o) {
            if (wa(e._startAt = ni.set(v, xs({
                data: "isStart",
                overwrite: !1,
                parent: y,
                immediateRender: !0,
                lazy: !g && Tr(c),
                startAt: null,
                delay: 0,
                onUpdate: u && function() {
                    return Yr(e, "onUpdate")
                }
                ,
                stagger: 0
            }, o))),
            e._startAt._dp = 0,
            e._startAt._sat = e,
            t < 0 && ($i || !a && !f) && e._startAt.revert(Yd),
            a && _ && t <= 0 && i <= 0) {
                t && (e._zTime = t);
                return
            }
        } else if (h && _ && !g) {
            if (t && (a = !1),
            C = xs({
                overwrite: !1,
                data: "isFromStart",
                lazy: a && !g && Tr(c),
                immediateRender: a,
                stagger: 0,
                parent: y
            }, b),
            X && (C[D.prop] = X),
            wa(e._startAt = ni.set(v, C)),
            e._startAt._dp = 0,
            e._startAt._sat = e,
            t < 0 && ($i ? e._startAt.revert(Yd) : e._startAt.render(-1, !0)),
            e._zTime = t,
            !a)
                n(e._startAt, Sn, Sn);
            else if (!t)
                return
        }
        for (e._pt = e._ptCache = 0,
        c = _ && Tr(c) || c && !_,
        T = 0; T < v.length; T++) {
            if (A = v[T],
            I = A._gsap || py(v)[T]._gsap,
            e._ptLookup[T] = B = {},
            U_[I.id] && ga.length && pp(),
            G = w === v ? T : w.indexOf(A),
            D && (H = new D).init(A, X || b, e, G, w) !== !1 && (e._pt = P = new Rr(e._pt,A,H.name,0,1,H.render,H,0,H.priority),
            H._props.forEach(function(ee) {
                B[ee] = P
            }),
            H.priority && (R = 1)),
            !D || X)
                for (C in b)
                    $r[C] && (H = JT(C, b, e, G, A, w)) ? H.priority && (R = 1) : B[C] = P = my.call(e, A, C, "get", b[C], G, w, 0, r.stringFilter);
            e._op && e._op[T] && e.kill(A, e._op[T]),
            S && e._pt && (la = e,
            Fn.killTweensOf(A, B, e.globalTime(t)),
            V = !e.parent,
            la = 0),
            e._pt && c && (U_[I.id] = 1)
        }
        R && rC(e),
        e._onInit && e._onInit(e)
    }
    e._onUpdate = u,
    e._initted = (!e._op || e._pt) && !V,
    d && t <= 0 && E.render(_s, !0, !0)
}, tB = function(e, t, i, r, s, o, a, c) {
    var u = (e._pt && e._ptCache || (e._ptCache = {}))[t], h, m, d, f;
    if (!u)
        for (u = e._ptCache[t] = [],
        d = e._ptLookup,
        f = e._targets.length; f--; ) {
            if (h = d[f][t],
            h && h.d && h.d._pt)
                for (h = h.d._pt; h && h.p !== t && h.fp !== t; )
                    h = h._next;
            if (!h)
                return G_ = 1,
                e.vars[t] = "+=0",
                gy(e, a),
                G_ = 0,
                c ? Df(t + " not eligible for reset") : 1;
            u.push(h)
        }
    for (f = u.length; f--; )
        m = u[f],
        h = m._pt || m,
        h.s = (r || r === 0) && !s ? r : h.s + (r || 0) + o * h.c,
        h.c = i - h.s,
        m.e && (m.e = jn(i) + Vi(m.e)),
        m.b && (m.b = h.s + Vi(m.b))
}, nB = function(e, t) {
    var i = e[0] ? pl(e[0]).harness : 0, r = i && i.aliases, s, o, a, c;
    if (!r)
        return t;
    s = Ml({}, t);
    for (o in r)
        if (o in s)
            for (c = r[o].split(","),
            a = c.length; a--; )
                s[c[a]] = s[o];
    return s
}, iB = function(e, t, i, r) {
    var s = t.ease || r || "power1.inOut", o, a;
    if (Xi(t))
        a = i[e] || (i[e] = []),
        t.forEach(function(c, u) {
            return a.push({
                t: u / (t.length - 1) * 100,
                v: c,
                e: s
            })
        });
    else
        for (o in t)
            a = i[o] || (i[o] = []),
            o === "ease" || a.push({
                t: parseFloat(e),
                v: t[o],
                e: s
            })
}, _f = function(e, t, i, r, s) {
    return Wn(e) ? e.call(t, i, r, s) : wi(e) && ~e.indexOf("random(") ? Of(e) : e
}, QT = dy + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", eC = {};
Cr(QT + ",id,stagger,delay,duration,paused,scrollTrigger", function(n) {
    return eC[n] = 1
});
var ni = function(n) {
    vT(e, n);
    function e(i, r, s, o) {
        var a;
        typeof r == "number" && (s.duration = r,
        r = s,
        s = null),
        a = n.call(this, o ? r : mf(r)) || this;
        var c = a.vars, u = c.duration, h = c.delay, m = c.immediateRender, d = c.stagger, f = c.overwrite, _ = c.keyframes, g = c.defaults, v = c.scrollTrigger, y = c.yoyoEase, w = r.parent || Fn, S = (Xi(i) || xT(i) ? Io(i[0]) : "length"in r) ? [i] : vs(i), E, b, T, C, P, A, R, I;
        if (a._targets = S.length ? py(S) : Df("GSAP target " + i + " not found. https://gsap.com", !Kr.nullTargetWarn) || [],
        a._ptLookup = [],
        a._overwrite = f,
        _ || d || ed(u) || ed(h)) {
            if (r = a.vars,
            E = a.timeline = new cr({
                data: "nested",
                defaults: g || {},
                targets: w && w.data === "nested" ? w.vars.targets : S
            }),
            E.kill(),
            E.parent = E._dp = Eo(a),
            E._start = 0,
            d || ed(u) || ed(h)) {
                if (C = S.length,
                R = d && BT(d),
                io(d))
                    for (P in d)
                        ~QT.indexOf(P) && (I || (I = {}),
                        I[P] = d[P]);
                for (b = 0; b < C; b++)
                    T = mp(r, eC),
                    T.stagger = 0,
                    y && (T.yoyoEase = y),
                    I && Ml(T, I),
                    A = S[b],
                    T.duration = +_f(u, Eo(a), b, A, S),
                    T.delay = (+_f(h, Eo(a), b, A, S) || 0) - a._delay,
                    !d && C === 1 && T.delay && (a._delay = h = T.delay,
                    a._start += h,
                    T.delay = 0),
                    E.to(A, T, R ? R(b, A, S) : 0),
                    E._ease = sn.none;
                E.duration() ? u = h = 0 : a.timeline = 0
            } else if (_) {
                mf(xs(E.vars.defaults, {
                    ease: "none"
                })),
                E._ease = gl(_.ease || r.ease || "none");
                var D = 0, H, B, G;
                if (Xi(_))
                    _.forEach(function(X) {
                        return E.to(S, X, ">")
                    }),
                    E.duration();
                else {
                    T = {};
                    for (P in _)
                        P === "ease" || P === "easeEach" || iB(P, _[P], T, _.easeEach);
                    for (P in T)
                        for (H = T[P].sort(function(X, V) {
                            return X.t - V.t
                        }),
                        D = 0,
                        b = 0; b < H.length; b++)
                            B = H[b],
                            G = {
                                ease: B.e,
                                duration: (B.t - (b ? H[b - 1].t : 0)) / 100 * u
                            },
                            G[P] = B.v,
                            E.to(S, G, D),
                            D += G.duration;
                    E.duration() < u && E.to({}, {
                        duration: u - E.duration()
                    })
                }
            }
            u || a.duration(u = E.duration())
        } else
            a.timeline = 0;
        return f === !0 && !ay && (la = Eo(a),
        Fn.killTweensOf(S),
        la = 0),
        Ys(w, Eo(a), s),
        r.reversed && a.reverse(),
        r.paused && a.paused(!0),
        (m || !u && !_ && a._start === xi(w._time) && Tr(m) && OF(Eo(a)) && w.data !== "nested") && (a._tTime = -Sn,
        a.render(Math.max(0, -h) || 0)),
        v && OT(Eo(a), v),
        a
    }
    var t = e.prototype;
    return t.render = function(r, s, o) {
        var a = this._time, c = this._tDur, u = this._dur, h = r < 0, m = r > c - Sn && !h ? c : r < Sn ? 0 : r, d, f, _, g, v, y, w, S, E;
        if (!u)
            UF(this, r, s, o);
        else if (m !== this._tTime || !r || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== h) {
            if (d = m,
            S = this.timeline,
            this._repeat) {
                if (g = u + this._rDelay,
                this._repeat < -1 && h)
                    return this.totalTime(g * 100 + r, s, o);
                if (d = xi(m % g),
                m === c ? (_ = this._repeat,
                d = u) : (_ = ~~(m / g),
                _ && _ === xi(m / g) && (d = u,
                _--),
                d > u && (d = u)),
                y = this._yoyo && _ & 1,
                y && (E = this._yEase,
                d = u - d),
                v = Gc(this._tTime, g),
                d === a && !o && this._initted && _ === v)
                    return this._tTime = m,
                    this;
                _ !== v && (S && this._yEase && YT(S, y),
                this.vars.repeatRefresh && !y && !this._lock && this._time !== u && this._initted && (this._lock = o = 1,
                this.render(xi(g * _), !0).invalidate()._lock = 0))
            }
            if (!this._initted) {
                if (NT(this, h ? r : d, o, s, m))
                    return this._tTime = 0,
                    this;
                if (a !== this._time && !(o && this.vars.repeatRefresh && _ !== v))
                    return this;
                if (u !== this._dur)
                    return this.render(r, s, o)
            }
            if (this._tTime = m,
            this._time = d,
            !this._act && this._ts && (this._act = 1,
            this._lazy = 0),
            this.ratio = w = (E || this._ease)(d / u),
            this._from && (this.ratio = w = 1 - w),
            d && !a && !s && !_ && (Yr(this, "onStart"),
            this._tTime !== m))
                return this;
            for (f = this._pt; f; )
                f.r(w, f.d),
                f = f._next;
            S && S.render(r < 0 ? r : !d && y ? -Sn : S._dur * S._ease(d / this._dur), s, o) || this._startAt && (this._zTime = r),
            this._onUpdate && !s && (h && F_(this, r, s, o),
            Yr(this, "onUpdate")),
            this._repeat && _ !== v && this.vars.onRepeat && !s && this.parent && Yr(this, "onRepeat"),
            (m === this._tDur || !m) && this._tTime === m && (h && !this._onUpdate && F_(this, r, !0, !0),
            (r || !u) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && wa(this, 1),
            !s && !(h && !a) && (m || a || y) && (Yr(this, m === c ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(m < c && this.timeScale() > 0) && this._prom()))
        }
        return this
    }
    ,
    t.targets = function() {
        return this._targets
    }
    ,
    t.invalidate = function(r) {
        return (!r || !this.vars.runBackwards) && (this._startAt = 0),
        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
        this._ptLookup = [],
        this.timeline && this.timeline.invalidate(r),
        n.prototype.invalidate.call(this, r)
    }
    ,
    t.resetTo = function(r, s, o, a, c) {
        Nf || Xr.wake(),
        this._ts || this.play();
        var u = Math.min(this._dur, (this._dp._time - this._start) * this._ts), h;
        return this._initted || gy(this, u),
        h = this._ease(u / this._dur),
        tB(this, r, s, o, a, h, u, c) ? this.resetTo(r, s, o, a, 1) : (qp(this, 0),
        this.parent || DT(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
        this.render(0))
    }
    ,
    t.kill = function(r, s) {
        if (s === void 0 && (s = "all"),
        !r && (!s || s === "all"))
            return this._lazy = this._pt = 0,
            this.parent ? lf(this) : this;
        if (this.timeline) {
            var o = this.timeline.totalDuration();
            return this.timeline.killTweensOf(r, s, la && la.vars.overwrite !== !0)._first || lf(this),
            this.parent && o !== this.timeline.totalDuration() && Vc(this, this._dur * this.timeline._tDur / o, 0, 1),
            this
        }
        var a = this._targets, c = r ? vs(r) : a, u = this._ptLookup, h = this._pt, m, d, f, _, g, v, y;
        if ((!s || s === "all") && DF(a, c))
            return s === "all" && (this._pt = 0),
            lf(this);
        for (m = this._op = this._op || [],
        s !== "all" && (wi(s) && (g = {},
        Cr(s, function(w) {
            return g[w] = 1
        }),
        s = g),
        s = nB(a, s)),
        y = a.length; y--; )
            if (~c.indexOf(a[y])) {
                d = u[y],
                s === "all" ? (m[y] = s,
                _ = d,
                f = {}) : (f = m[y] = m[y] || {},
                _ = s);
                for (g in _)
                    v = d && d[g],
                    v && ((!("kill"in v.d) || v.d.kill(g) === !0) && $p(this, v, "_pt"),
                    delete d[g]),
                    f !== "all" && (f[g] = 1)
            }
        return this._initted && !this._pt && h && lf(this),
        this
    }
    ,
    e.to = function(r, s) {
        return new e(r,s,arguments[2])
    }
    ,
    e.from = function(r, s) {
        return gf(1, arguments)
    }
    ,
    e.delayedCall = function(r, s, o, a) {
        return new e(s,0,{
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: r,
            onComplete: s,
            onReverseComplete: s,
            onCompleteParams: o,
            onReverseCompleteParams: o,
            callbackScope: a
        })
    }
    ,
    e.fromTo = function(r, s, o) {
        return gf(2, arguments)
    }
    ,
    e.set = function(r, s) {
        return s.duration = 0,
        s.repeatDelay || (s.repeat = 0),
        new e(r,s)
    }
    ,
    e.killTweensOf = function(r, s, o) {
        return Fn.killTweensOf(r, s, o)
    }
    ,
    e
}(Uf);
xs(ni.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
});
Cr("staggerTo,staggerFrom,staggerFromTo", function(n) {
    ni[n] = function() {
        var e = new cr
          , t = k_.call(arguments, 0);
        return t.splice(n === "staggerFromTo" ? 5 : 4, 0, 0),
        e[n].apply(e, t)
    }
});
var _y = function(e, t, i) {
    return e[t] = i
}
  , tC = function(e, t, i) {
    return e[t](i)
}
  , rB = function(e, t, i, r) {
    return e[t](r.fp, i)
}
  , sB = function(e, t, i) {
    return e.setAttribute(t, i)
}
  , vy = function(e, t) {
    return Wn(e[t]) ? tC : ly(e[t]) && e.setAttribute ? sB : _y
}
  , nC = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t)
}
  , oB = function(e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t)
}
  , iC = function(e, t) {
    var i = t._pt
      , r = "";
    if (!e && t.b)
        r = t.b;
    else if (e === 1 && t.e)
        r = t.e;
    else {
        for (; i; )
            r = i.p + (i.m ? i.m(i.s + i.c * e) : Math.round((i.s + i.c * e) * 1e4) / 1e4) + r,
            i = i._next;
        r += t.c
    }
    t.set(t.t, t.p, r, t)
}
  , yy = function(e, t) {
    for (var i = t._pt; i; )
        i.r(e, i.d),
        i = i._next
}
  , aB = function(e, t, i, r) {
    for (var s = this._pt, o; s; )
        o = s._next,
        s.p === r && s.modifier(e, t, i),
        s = o
}
  , lB = function(e) {
    for (var t = this._pt, i, r; t; )
        r = t._next,
        t.p === e && !t.op || t.op === e ? $p(this, t, "_pt") : t.dep || (i = 1),
        t = r;
    return !i
}
  , cB = function(e, t, i, r) {
    r.mSet(e, t, r.m.call(r.tween, i, r.mt), r)
}
  , rC = function(e) {
    for (var t = e._pt, i, r, s, o; t; ) {
        for (i = t._next,
        r = s; r && r.pr > t.pr; )
            r = r._next;
        (t._prev = r ? r._prev : o) ? t._prev._next = t : s = t,
        (t._next = r) ? r._prev = t : o = t,
        t = i
    }
    e._pt = s
}
  , Rr = function() {
    function n(t, i, r, s, o, a, c, u, h) {
        this.t = i,
        this.s = s,
        this.c = o,
        this.p = r,
        this.r = a || nC,
        this.d = c || this,
        this.set = u || _y,
        this.pr = h || 0,
        this._next = t,
        t && (t._prev = this)
    }
    var e = n.prototype;
    return e.modifier = function(i, r, s) {
        this.mSet = this.mSet || this.set,
        this.set = cB,
        this.m = i,
        this.mt = s,
        this.tween = r
    }
    ,
    n
}();
Cr(dy + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(n) {
    return hy[n] = 1
});
Jr.TweenMax = Jr.TweenLite = ni;
Jr.TimelineLite = Jr.TimelineMax = cr;
Fn = new cr({
    sortChildren: !1,
    defaults: Hc,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
});
Kr.stringFilter = qT;
var _l = []
  , Zd = {}
  , uB = []
  , qS = 0
  , fB = 0
  , Ug = function(e) {
    return (Zd[e] || uB).map(function(t) {
        return t()
    })
}
  , V_ = function() {
    var e = Date.now()
      , t = [];
    e - qS > 2 && (Ug("matchMediaInit"),
    _l.forEach(function(i) {
        var r = i.queries, s = i.conditions, o, a, c, u;
        for (a in r)
            o = fs.matchMedia(r[a]).matches,
            o && (c = 1),
            o !== s[a] && (s[a] = o,
            u = 1);
        u && (i.revert(),
        c && t.push(i))
    }),
    Ug("matchMediaRevert"),
    t.forEach(function(i) {
        return i.onMatch(i, function(r) {
            return i.add(null, r)
        })
    }),
    qS = e,
    Ug("matchMedia"))
}
  , sC = function() {
    function n(t, i) {
        this.selector = i && z_(i),
        this.data = [],
        this._r = [],
        this.isReverted = !1,
        this.id = fB++,
        t && this.add(t)
    }
    var e = n.prototype;
    return e.add = function(i, r, s) {
        Wn(i) && (s = r,
        r = i,
        i = Wn);
        var o = this
          , a = function() {
            var u = Vn, h = o.selector, m;
            return u && u !== o && u.data.push(o),
            s && (o.selector = z_(s)),
            Vn = o,
            m = r.apply(o, arguments),
            Wn(m) && o._r.push(m),
            Vn = u,
            o.selector = h,
            o.isReverted = !1,
            m
        };
        return o.last = a,
        i === Wn ? a(o, function(c) {
            return o.add(null, c)
        }) : i ? o[i] = a : a
    }
    ,
    e.ignore = function(i) {
        var r = Vn;
        Vn = null,
        i(this),
        Vn = r
    }
    ,
    e.getTweens = function() {
        var i = [];
        return this.data.forEach(function(r) {
            return r instanceof n ? i.push.apply(i, r.getTweens()) : r instanceof ni && !(r.parent && r.parent.data === "nested") && i.push(r)
        }),
        i
    }
    ,
    e.clear = function() {
        this._r.length = this.data.length = 0
    }
    ,
    e.kill = function(i, r) {
        var s = this;
        if (i ? function() {
            for (var a = s.getTweens(), c = s.data.length, u; c--; )
                u = s.data[c],
                u.data === "isFlip" && (u.revert(),
                u.getChildren(!0, !0, !1).forEach(function(h) {
                    return a.splice(a.indexOf(h), 1)
                }));
            for (a.map(function(h) {
                return {
                    g: h._dur || h._delay || h._sat && !h._sat.vars.immediateRender ? h.globalTime(0) : -1 / 0,
                    t: h
                }
            }).sort(function(h, m) {
                return m.g - h.g || -1 / 0
            }).forEach(function(h) {
                return h.t.revert(i)
            }),
            c = s.data.length; c--; )
                u = s.data[c],
                u instanceof cr ? u.data !== "nested" && (u.scrollTrigger && u.scrollTrigger.revert(),
                u.kill()) : !(u instanceof ni) && u.revert && u.revert(i);
            s._r.forEach(function(h) {
                return h(i, s)
            }),
            s.isReverted = !0
        }() : this.data.forEach(function(a) {
            return a.kill && a.kill()
        }),
        this.clear(),
        r)
            for (var o = _l.length; o--; )
                _l[o].id === this.id && _l.splice(o, 1)
    }
    ,
    e.revert = function(i) {
        this.kill(i || {})
    }
    ,
    n
}()
  , hB = function() {
    function n(t) {
        this.contexts = [],
        this.scope = t
    }
    var e = n.prototype;
    return e.add = function(i, r, s) {
        io(i) || (i = {
            matches: i
        });
        var o = new sC(0,s || this.scope), a = o.conditions = {}, c, u, h;
        Vn && !o.selector && (o.selector = Vn.selector),
        this.contexts.push(o),
        r = o.add("onMatch", r),
        o.queries = i;
        for (u in i)
            u === "all" ? h = 1 : (c = fs.matchMedia(i[u]),
            c && (_l.indexOf(o) < 0 && _l.push(o),
            (a[u] = c.matches) && (h = 1),
            c.addListener ? c.addListener(V_) : c.addEventListener("change", V_)));
        return h && r(o, function(m) {
            return o.add(null, m)
        }),
        this
    }
    ,
    e.revert = function(i) {
        this.kill(i || {})
    }
    ,
    e.kill = function(i) {
        this.contexts.forEach(function(r) {
            return r.kill(i, !0)
        })
    }
    ,
    n
}()
  , _p = {
    registerPlugin: function() {
        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
            t[i] = arguments[i];
        t.forEach(function(r) {
            return WT(r)
        })
    },
    timeline: function(e) {
        return new cr(e)
    },
    getTweensOf: function(e, t) {
        return Fn.getTweensOf(e, t)
    },
    getProperty: function(e, t, i, r) {
        wi(e) && (e = vs(e)[0]);
        var s = pl(e || {}).get
          , o = i ? LT : PT;
        return i === "native" && (i = ""),
        e && (t ? o(($r[t] && $r[t].get || s)(e, t, i, r)) : function(a, c, u) {
            return o(($r[a] && $r[a].get || s)(e, a, c, u))
        }
        )
    },
    quickSetter: function(e, t, i) {
        if (e = vs(e),
        e.length > 1) {
            var r = e.map(function(h) {
                return Dr.quickSetter(h, t, i)
            })
              , s = r.length;
            return function(h) {
                for (var m = s; m--; )
                    r[m](h)
            }
        }
        e = e[0] || {};
        var o = $r[t]
          , a = pl(e)
          , c = a.harness && (a.harness.aliases || {})[t] || t
          , u = o ? function(h) {
            var m = new o;
            Mc._pt = 0,
            m.init(e, i ? h + i : h, Mc, 0, [e]),
            m.render(1, m),
            Mc._pt && yy(1, Mc)
        }
        : a.set(e, c);
        return o ? u : function(h) {
            return u(e, c, i ? h + i : h, a, 1)
        }
    },
    quickTo: function(e, t, i) {
        var r, s = Dr.to(e, Ml((r = {},
        r[t] = "+=0.1",
        r.paused = !0,
        r), i || {})), o = function(c, u, h) {
            return s.resetTo(t, c, u, h)
        };
        return o.tween = s,
        o
    },
    isTweening: function(e) {
        return Fn.getTweensOf(e, !0).length > 0
    },
    defaults: function(e) {
        return e && e.ease && (e.ease = gl(e.ease, Hc.ease)),
        GS(Hc, e || {})
    },
    config: function(e) {
        return GS(Kr, e || {})
    },
    registerEffect: function(e) {
        var t = e.name
          , i = e.effect
          , r = e.plugins
          , s = e.defaults
          , o = e.extendTimeline;
        (r || "").split(",").forEach(function(a) {
            return a && !$r[a] && !Jr[a] && Df(t + " effect requires " + a + " plugin.")
        }),
        Dg[t] = function(a, c, u) {
            return i(vs(a), xs(c || {}, s), u)
        }
        ,
        o && (cr.prototype[t] = function(a, c, u) {
            return this.add(Dg[t](a, io(c) ? c : (u = c) && {}, this), u)
        }
        )
    },
    registerEase: function(e, t) {
        sn[e] = gl(t)
    },
    parseEase: function(e, t) {
        return arguments.length ? gl(e, t) : sn
    },
    getById: function(e) {
        return Fn.getById(e)
    },
    exportRoot: function(e, t) {
        e === void 0 && (e = {});
        var i = new cr(e), r, s;
        for (i.smoothChildTiming = Tr(e.smoothChildTiming),
        Fn.remove(i),
        i._dp = 0,
        i._time = i._tTime = Fn._time,
        r = Fn._first; r; )
            s = r._next,
            (t || !(!r._dur && r instanceof ni && r.vars.onComplete === r._targets[0])) && Ys(i, r, r._start - r._delay),
            r = s;
        return Ys(Fn, i, 0),
        i
    },
    context: function(e, t) {
        return e ? new sC(e,t) : Vn
    },
    matchMedia: function(e) {
        return new hB(e)
    },
    matchMediaRefresh: function() {
        return _l.forEach(function(e) {
            var t = e.conditions, i, r;
            for (r in t)
                t[r] && (t[r] = !1,
                i = 1);
            i && e.revert()
        }) || V_()
    },
    addEventListener: function(e, t) {
        var i = Zd[e] || (Zd[e] = []);
        ~i.indexOf(t) || i.push(t)
    },
    removeEventListener: function(e, t) {
        var i = Zd[e]
          , r = i && i.indexOf(t);
        r >= 0 && i.splice(r, 1)
    },
    utils: {
        wrap: WF,
        wrapYoyo: $F,
        distribute: BT,
        random: zT,
        snap: kT,
        normalize: VF,
        getUnit: Vi,
        clamp: kF,
        splitColor: $T,
        toArray: vs,
        selector: z_,
        mapRange: GT,
        pipe: HF,
        unitize: GF,
        interpolate: XF,
        shuffle: FT
    },
    install: AT,
    effects: Dg,
    ticker: Xr,
    updateRoot: cr.updateRoot,
    plugins: $r,
    globalTimeline: Fn,
    core: {
        PropTween: Rr,
        globals: MT,
        Tween: ni,
        Timeline: cr,
        Animation: Uf,
        getCache: pl,
        _removeLinkedListItem: $p,
        reverting: function() {
            return $i
        },
        context: function(e) {
            return e && Vn && (Vn.data.push(e),
            e._ctx = Vn),
            Vn
        },
        suppressOverwrites: function(e) {
            return ay = e
        }
    }
};
Cr("to,from,fromTo,delayedCall,set,killTweensOf", function(n) {
    return _p[n] = ni[n]
});
Xr.add(cr.updateRoot);
Mc = _p.to({}, {
    duration: 0
});
var dB = function(e, t) {
    for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t; )
        i = i._next;
    return i
}
  , pB = function(e, t) {
    var i = e._targets, r, s, o;
    for (r in t)
        for (s = i.length; s--; )
            o = e._ptLookup[s][r],
            o && (o = o.d) && (o._pt && (o = dB(o, r)),
            o && o.modifier && o.modifier(t[r], e, i[s], r))
}
  , Fg = function(e, t) {
    return {
        name: e,
        rawVars: 1,
        init: function(r, s, o) {
            o._onInit = function(a) {
                var c, u;
                if (wi(s) && (c = {},
                Cr(s, function(h) {
                    return c[h] = 1
                }),
                s = c),
                t) {
                    c = {};
                    for (u in s)
                        c[u] = t(s[u]);
                    s = c
                }
                pB(a, s)
            }
        }
    }
}
  , Dr = _p.registerPlugin({
    name: "attr",
    init: function(e, t, i, r, s) {
        var o, a, c;
        this.tween = i;
        for (o in t)
            c = e.getAttribute(o) || "",
            a = this.add(e, "setAttribute", (c || 0) + "", t[o], r, s, 0, 0, o),
            a.op = o,
            a.b = c,
            this._props.push(o)
    },
    render: function(e, t) {
        for (var i = t._pt; i; )
            $i ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d),
            i = i._next
    }
}, {
    name: "endArray",
    init: function(e, t) {
        for (var i = t.length; i--; )
            this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1)
    }
}, Fg("roundProps", H_), Fg("modifiers"), Fg("snap", kT)) || _p;
ni.version = cr.version = Dr.version = "3.12.3";
ET = 1;
cy() && Wc();
sn.Power0;
sn.Power1;
sn.Power2;
sn.Power3;
sn.Power4;
sn.Linear;
sn.Quad;
sn.Cubic;
sn.Quart;
sn.Quint;
sn.Strong;
sn.Elastic;
sn.Back;
sn.SteppedEase;
sn.Bounce;
sn.Sine;
sn.Expo;
sn.Circ;
/*!
 * CSSPlugin 3.12.3
 * https://gsap.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var jS, ca, Lc, xy, ll, YS, by, mB = function() {
    return typeof window < "u"
}, Oo = {}, Ja = 180 / Math.PI, Dc = Math.PI / 180, tc = Math.atan2, KS = 1e8, Sy = /([A-Z])/g, gB = /(left|right|width|margin|padding|x)/i, _B = /[\s,\(]\S/, Ks = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
}, W_ = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
}, vB = function(e, t) {
    return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
}, yB = function(e, t) {
    return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
}, xB = function(e, t) {
    var i = t.s + t.c * e;
    t.set(t.t, t.p, ~~(i + (i < 0 ? -.5 : .5)) + t.u, t)
}, oC = function(e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t)
}, aC = function(e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t)
}, bB = function(e, t, i) {
    return e.style[t] = i
}, SB = function(e, t, i) {
    return e.style.setProperty(t, i)
}, wB = function(e, t, i) {
    return e._gsap[t] = i
}, EB = function(e, t, i) {
    return e._gsap.scaleX = e._gsap.scaleY = i
}, AB = function(e, t, i, r, s) {
    var o = e._gsap;
    o.scaleX = o.scaleY = i,
    o.renderTransform(s, o)
}, MB = function(e, t, i, r, s) {
    var o = e._gsap;
    o[t] = i,
    o.renderTransform(s, o)
}, kn = "transform", Pr = kn + "Origin", TB = function n(e, t) {
    var i = this
      , r = this.target
      , s = r.style
      , o = r._gsap;
    if (e in Oo && s) {
        if (this.tfm = this.tfm || {},
        e !== "transform")
            e = Ks[e] || e,
            ~e.indexOf(",") ? e.split(",").forEach(function(a) {
                return i.tfm[a] = Mo(r, a)
            }) : this.tfm[e] = o.x ? o[e] : Mo(r, e),
            e === Pr && (this.tfm.zOrigin = o.zOrigin);
        else
            return Ks.transform.split(",").forEach(function(a) {
                return n.call(i, a, t)
            });
        if (this.props.indexOf(kn) >= 0)
            return;
        o.svg && (this.svgo = r.getAttribute("data-svg-origin"),
        this.props.push(Pr, t, "")),
        e = kn
    }
    (s || t) && this.props.push(e, t, s[e])
}, lC = function(e) {
    e.translate && (e.removeProperty("translate"),
    e.removeProperty("scale"),
    e.removeProperty("rotate"))
}, CB = function() {
    var e = this.props, t = this.target, i = t.style, r = t._gsap, s, o;
    for (s = 0; s < e.length; s += 3)
        e[s + 1] ? t[e[s]] = e[s + 2] : e[s + 2] ? i[e[s]] = e[s + 2] : i.removeProperty(e[s].substr(0, 2) === "--" ? e[s] : e[s].replace(Sy, "-$1").toLowerCase());
    if (this.tfm) {
        for (o in this.tfm)
            r[o] = this.tfm[o];
        r.svg && (r.renderTransform(),
        t.setAttribute("data-svg-origin", this.svgo || "")),
        s = by(),
        (!s || !s.isStart) && !i[kn] && (lC(i),
        r.zOrigin && i[Pr] && (i[Pr] += " " + r.zOrigin + "px",
        r.zOrigin = 0,
        r.renderTransform()),
        r.uncache = 1)
    }
}, cC = function(e, t) {
    var i = {
        target: e,
        props: [],
        revert: CB,
        save: TB
    };
    return e._gsap || Dr.core.getCache(e),
    t && t.split(",").forEach(function(r) {
        return i.save(r)
    }),
    i
}, uC, $_ = function(e, t) {
    var i = ca.createElementNS ? ca.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : ca.createElement(e);
    return i && i.style ? i : ca.createElement(e)
}, Qs = function n(e, t, i) {
    var r = getComputedStyle(e);
    return r[t] || r.getPropertyValue(t.replace(Sy, "-$1").toLowerCase()) || r.getPropertyValue(t) || !i && n(e, $c(t) || t, 1) || ""
}, ZS = "O,Moz,ms,Ms,Webkit".split(","), $c = function(e, t, i) {
    var r = t || ll
      , s = r.style
      , o = 5;
    if (e in s && !i)
        return e;
    for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(ZS[o] + e in s); )
        ;
    return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? ZS[o] : "") + e
}, X_ = function() {
    mB() && window.document && (jS = window,
    ca = jS.document,
    Lc = ca.documentElement,
    ll = $_("div") || {
        style: {}
    },
    $_("div"),
    kn = $c(kn),
    Pr = kn + "Origin",
    ll.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
    uC = !!$c("perspective"),
    by = Dr.core.reverting,
    xy = 1)
}, Bg = function n(e) {
    var t = $_("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = this.parentNode, r = this.nextSibling, s = this.style.cssText, o;
    if (Lc.appendChild(t),
    t.appendChild(this),
    this.style.display = "block",
    e)
        try {
            o = this.getBBox(),
            this._gsapBBox = this.getBBox,
            this.getBBox = n
        } catch {}
    else
        this._gsapBBox && (o = this._gsapBBox());
    return i && (r ? i.insertBefore(this, r) : i.appendChild(this)),
    Lc.removeChild(t),
    this.style.cssText = s,
    o
}, JS = function(e, t) {
    for (var i = t.length; i--; )
        if (e.hasAttribute(t[i]))
            return e.getAttribute(t[i])
}, fC = function(e) {
    var t;
    try {
        t = e.getBBox()
    } catch {
        t = Bg.call(e, !0)
    }
    return t && (t.width || t.height) || e.getBBox === Bg || (t = Bg.call(e, !0)),
    t && !t.width && !t.x && !t.y ? {
        x: +JS(e, ["x", "cx", "x1"]) || 0,
        y: +JS(e, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
    } : t
}, hC = function(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && fC(e))
}, Tl = function(e, t) {
    if (t) {
        var i = e.style, r;
        t in Oo && t !== Pr && (t = kn),
        i.removeProperty ? (r = t.substr(0, 2),
        (r === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t),
        i.removeProperty(r === "--" ? t : t.replace(Sy, "-$1").toLowerCase())) : i.removeAttribute(t)
    }
}, ua = function(e, t, i, r, s, o) {
    var a = new Rr(e._pt,t,i,0,1,o ? aC : oC);
    return e._pt = a,
    a.b = r,
    a.e = s,
    e._props.push(i),
    a
}, QS = {
    deg: 1,
    rad: 1,
    turn: 1
}, RB = {
    grid: 1,
    flex: 1
}, Ea = function n(e, t, i, r) {
    var s = parseFloat(i) || 0, o = (i + "").trim().substr((s + "").length) || "px", a = ll.style, c = gB.test(t), u = e.tagName.toLowerCase() === "svg", h = (u ? "client" : "offset") + (c ? "Width" : "Height"), m = 100, d = r === "px", f = r === "%", _, g, v, y;
    if (r === o || !s || QS[r] || QS[o])
        return s;
    if (o !== "px" && !d && (s = n(e, t, i, "px")),
    y = e.getCTM && hC(e),
    (f || o === "%") && (Oo[t] || ~t.indexOf("adius")))
        return _ = y ? e.getBBox()[c ? "width" : "height"] : e[h],
        jn(f ? s / _ * m : s / 100 * _);
    if (a[c ? "width" : "height"] = m + (d ? o : r),
    g = ~t.indexOf("adius") || r === "em" && e.appendChild && !u ? e : e.parentNode,
    y && (g = (e.ownerSVGElement || {}).parentNode),
    (!g || g === ca || !g.appendChild) && (g = ca.body),
    v = g._gsap,
    v && f && v.width && c && v.time === Xr.time && !v.uncache)
        return jn(s / v.width * m);
    if (f && (t === "height" || t === "width")) {
        var w = e.style[t];
        e.style[t] = m + r,
        _ = e[h],
        w ? e.style[t] = w : Tl(e, t)
    } else
        (f || o === "%") && !RB[Qs(g, "display")] && (a.position = Qs(e, "position")),
        g === e && (a.position = "static"),
        g.appendChild(ll),
        _ = ll[h],
        g.removeChild(ll),
        a.position = "absolute";
    return c && f && (v = pl(g),
    v.time = Xr.time,
    v.width = g[h]),
    jn(d ? _ * s / m : _ && s ? m / _ * s : 0)
}, Mo = function(e, t, i, r) {
    var s;
    return xy || X_(),
    t in Ks && t !== "transform" && (t = Ks[t],
    ~t.indexOf(",") && (t = t.split(",")[0])),
    Oo[t] && t !== "transform" ? (s = Bf(e, r),
    s = t !== "transformOrigin" ? s[t] : s.svg ? s.origin : yp(Qs(e, Pr)) + " " + s.zOrigin + "px") : (s = e.style[t],
    (!s || s === "auto" || r || ~(s + "").indexOf("calc(")) && (s = vp[t] && vp[t](e, t, i) || Qs(e, t) || CT(e, t) || (t === "opacity" ? 1 : 0))),
    i && !~(s + "").trim().indexOf(" ") ? Ea(e, t, s, i) + i : s
}, PB = function(e, t, i, r) {
    if (!i || i === "none") {
        var s = $c(t, e, 1)
          , o = s && Qs(e, s, 1);
        o && o !== i ? (t = s,
        i = o) : t === "borderColor" && (i = Qs(e, "borderTopColor"))
    }
    var a = new Rr(this._pt,e.style,t,0,1,iC), c = 0, u = 0, h, m, d, f, _, g, v, y, w, S, E, b;
    if (a.b = i,
    a.e = r,
    i += "",
    r += "",
    r === "auto" && (g = e.style[t],
    e.style[t] = r,
    r = Qs(e, t) || r,
    g ? e.style[t] = g : Tl(e, t)),
    h = [i, r],
    qT(h),
    i = h[0],
    r = h[1],
    d = i.match(Ac) || [],
    b = r.match(Ac) || [],
    b.length) {
        for (; m = Ac.exec(r); )
            v = m[0],
            w = r.substring(c, m.index),
            _ ? _ = (_ + 1) % 5 : (w.substr(-5) === "rgba(" || w.substr(-5) === "hsla(") && (_ = 1),
            v !== (g = d[u++] || "") && (f = parseFloat(g) || 0,
            E = g.substr((f + "").length),
            v.charAt(1) === "=" && (v = Pc(f, v) + E),
            y = parseFloat(v),
            S = v.substr((y + "").length),
            c = Ac.lastIndex - S.length,
            S || (S = S || Kr.units[t] || E,
            c === r.length && (r += S,
            a.e += S)),
            E !== S && (f = Ea(e, t, g, S) || 0),
            a._pt = {
                _next: a._pt,
                p: w || u === 1 ? w : ",",
                s: f,
                c: y - f,
                m: _ && _ < 4 || t === "zIndex" ? Math.round : 0
            });
        a.c = c < r.length ? r.substring(c, r.length) : ""
    } else
        a.r = t === "display" && r === "none" ? aC : oC;
    return ST.test(r) && (a.e = 0),
    this._pt = a,
    a
}, ew = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
}, LB = function(e) {
    var t = e.split(" ")
      , i = t[0]
      , r = t[1] || "50%";
    return (i === "top" || i === "bottom" || r === "left" || r === "right") && (e = i,
    i = r,
    r = e),
    t[0] = ew[i] || i,
    t[1] = ew[r] || r,
    t.join(" ")
}, DB = function(e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
        var i = t.t, r = i.style, s = t.u, o = i._gsap, a, c, u;
        if (s === "all" || s === !0)
            r.cssText = "",
            c = 1;
        else
            for (s = s.split(","),
            u = s.length; --u > -1; )
                a = s[u],
                Oo[a] && (c = 1,
                a = a === "transformOrigin" ? Pr : kn),
                Tl(i, a);
        c && (Tl(i, kn),
        o && (o.svg && i.removeAttribute("transform"),
        Bf(i, 1),
        o.uncache = 1,
        lC(r)))
    }
}, vp = {
    clearProps: function(e, t, i, r, s) {
        if (s.data !== "isFromStart") {
            var o = e._pt = new Rr(e._pt,t,i,0,0,DB);
            return o.u = r,
            o.pr = -10,
            o.tween = s,
            e._props.push(i),
            1
        }
    }
}, Ff = [1, 0, 0, 1, 0, 0], dC = {}, pC = function(e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
}, tw = function(e) {
    var t = Qs(e, kn);
    return pC(t) ? Ff : t.substr(7).match(bT).map(jn)
}, wy = function(e, t) {
    var i = e._gsap || pl(e), r = e.style, s = tw(e), o, a, c, u;
    return i.svg && e.getAttribute("transform") ? (c = e.transform.baseVal.consolidate().matrix,
    s = [c.a, c.b, c.c, c.d, c.e, c.f],
    s.join(",") === "1,0,0,1,0,0" ? Ff : s) : (s === Ff && !e.offsetParent && e !== Lc && !i.svg && (c = r.display,
    r.display = "block",
    o = e.parentNode,
    (!o || !e.offsetParent) && (u = 1,
    a = e.nextElementSibling,
    Lc.appendChild(e)),
    s = tw(e),
    c ? r.display = c : Tl(e, "display"),
    u && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : Lc.removeChild(e))),
    t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s)
}, q_ = function(e, t, i, r, s, o) {
    var a = e._gsap, c = s || wy(e, !0), u = a.xOrigin || 0, h = a.yOrigin || 0, m = a.xOffset || 0, d = a.yOffset || 0, f = c[0], _ = c[1], g = c[2], v = c[3], y = c[4], w = c[5], S = t.split(" "), E = parseFloat(S[0]) || 0, b = parseFloat(S[1]) || 0, T, C, P, A;
    i ? c !== Ff && (C = f * v - _ * g) && (P = E * (v / C) + b * (-g / C) + (g * w - v * y) / C,
    A = E * (-_ / C) + b * (f / C) - (f * w - _ * y) / C,
    E = P,
    b = A) : (T = fC(e),
    E = T.x + (~S[0].indexOf("%") ? E / 100 * T.width : E),
    b = T.y + (~(S[1] || S[0]).indexOf("%") ? b / 100 * T.height : b),
    !("xOrigin"in a) && (E || b) && (E -= T.x,
    b -= T.y)),
    r || r !== !1 && a.smooth ? (y = E - u,
    w = b - h,
    a.xOffset = m + (y * f + w * g) - y,
    a.yOffset = d + (y * _ + w * v) - w) : a.xOffset = a.yOffset = 0,
    a.xOrigin = E,
    a.yOrigin = b,
    a.smooth = !!r,
    a.origin = t,
    a.originIsAbsolute = !!i,
    e.style[Pr] = "0px 0px",
    o && (ua(o, a, "xOrigin", u, E),
    ua(o, a, "yOrigin", h, b),
    ua(o, a, "xOffset", m, a.xOffset),
    ua(o, a, "yOffset", d, a.yOffset)),
    e.setAttribute("data-svg-origin", E + " " + b)
}, Bf = function(e, t) {
    var i = e._gsap || new ZT(e);
    if ("x"in i && !t && !i.uncache)
        return i;
    var r = e.style, s = i.scaleX < 0, o = "px", a = "deg", c = getComputedStyle(e), u = Qs(e, Pr) || "0", h, m, d, f, _, g, v, y, w, S, E, b, T, C, P, A, R, I, D, H, B, G, X, V, ee, re, k, oe, ae, ne, fe, xe;
    return h = m = d = g = v = y = w = S = E = 0,
    f = _ = 1,
    i.svg = !!(e.getCTM && hC(e)),
    c.translate && ((c.translate !== "none" || c.scale !== "none" || c.rotate !== "none") && (r[kn] = (c.translate !== "none" ? "translate3d(" + (c.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (c.rotate !== "none" ? "rotate(" + c.rotate + ") " : "") + (c.scale !== "none" ? "scale(" + c.scale.split(" ").join(",") + ") " : "") + (c[kn] !== "none" ? c[kn] : "")),
    r.scale = r.rotate = r.translate = "none"),
    C = wy(e, i.svg),
    i.svg && (i.uncache ? (ee = e.getBBox(),
    u = i.xOrigin - ee.x + "px " + (i.yOrigin - ee.y) + "px",
    V = "") : V = !t && e.getAttribute("data-svg-origin"),
    q_(e, V || u, !!V || i.originIsAbsolute, i.smooth !== !1, C)),
    b = i.xOrigin || 0,
    T = i.yOrigin || 0,
    C !== Ff && (I = C[0],
    D = C[1],
    H = C[2],
    B = C[3],
    h = G = C[4],
    m = X = C[5],
    C.length === 6 ? (f = Math.sqrt(I * I + D * D),
    _ = Math.sqrt(B * B + H * H),
    g = I || D ? tc(D, I) * Ja : 0,
    w = H || B ? tc(H, B) * Ja + g : 0,
    w && (_ *= Math.abs(Math.cos(w * Dc))),
    i.svg && (h -= b - (b * I + T * H),
    m -= T - (b * D + T * B))) : (xe = C[6],
    ne = C[7],
    k = C[8],
    oe = C[9],
    ae = C[10],
    fe = C[11],
    h = C[12],
    m = C[13],
    d = C[14],
    P = tc(xe, ae),
    v = P * Ja,
    P && (A = Math.cos(-P),
    R = Math.sin(-P),
    V = G * A + k * R,
    ee = X * A + oe * R,
    re = xe * A + ae * R,
    k = G * -R + k * A,
    oe = X * -R + oe * A,
    ae = xe * -R + ae * A,
    fe = ne * -R + fe * A,
    G = V,
    X = ee,
    xe = re),
    P = tc(-H, ae),
    y = P * Ja,
    P && (A = Math.cos(-P),
    R = Math.sin(-P),
    V = I * A - k * R,
    ee = D * A - oe * R,
    re = H * A - ae * R,
    fe = B * R + fe * A,
    I = V,
    D = ee,
    H = re),
    P = tc(D, I),
    g = P * Ja,
    P && (A = Math.cos(P),
    R = Math.sin(P),
    V = I * A + D * R,
    ee = G * A + X * R,
    D = D * A - I * R,
    X = X * A - G * R,
    I = V,
    G = ee),
    v && Math.abs(v) + Math.abs(g) > 359.9 && (v = g = 0,
    y = 180 - y),
    f = jn(Math.sqrt(I * I + D * D + H * H)),
    _ = jn(Math.sqrt(X * X + xe * xe)),
    P = tc(G, X),
    w = Math.abs(P) > 2e-4 ? P * Ja : 0,
    E = fe ? 1 / (fe < 0 ? -fe : fe) : 0),
    i.svg && (V = e.getAttribute("transform"),
    i.forceCSS = e.setAttribute("transform", "") || !pC(Qs(e, kn)),
    V && e.setAttribute("transform", V))),
    Math.abs(w) > 90 && Math.abs(w) < 270 && (s ? (f *= -1,
    w += g <= 0 ? 180 : -180,
    g += g <= 0 ? 180 : -180) : (_ *= -1,
    w += w <= 0 ? 180 : -180)),
    t = t || i.uncache,
    i.x = h - ((i.xPercent = h && (!t && i.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-h) ? -50 : 0))) ? e.offsetWidth * i.xPercent / 100 : 0) + o,
    i.y = m - ((i.yPercent = m && (!t && i.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-m) ? -50 : 0))) ? e.offsetHeight * i.yPercent / 100 : 0) + o,
    i.z = d + o,
    i.scaleX = jn(f),
    i.scaleY = jn(_),
    i.rotation = jn(g) + a,
    i.rotationX = jn(v) + a,
    i.rotationY = jn(y) + a,
    i.skewX = w + a,
    i.skewY = S + a,
    i.transformPerspective = E + o,
    (i.zOrigin = parseFloat(u.split(" ")[2]) || !t && i.zOrigin || 0) && (r[Pr] = yp(u)),
    i.svg || (i.xOffset = i.yOffset = 0),
    i.force3D = Kr.force3D,
    i.renderTransform = i.svg ? OB : uC ? mC : IB,
    i.uncache = 0,
    i
}, yp = function(e) {
    return (e = e.split(" "))[0] + " " + e[1]
}, kg = function(e, t, i) {
    var r = Vi(t);
    return jn(parseFloat(t) + parseFloat(Ea(e, "x", i + "px", r))) + r
}, IB = function(e, t) {
    t.z = "0px",
    t.rotationY = t.rotationX = "0deg",
    t.force3D = 0,
    mC(e, t)
}, Wa = "0deg", Cu = "0px", $a = ") ", mC = function(e, t) {
    var i = t || this
      , r = i.xPercent
      , s = i.yPercent
      , o = i.x
      , a = i.y
      , c = i.z
      , u = i.rotation
      , h = i.rotationY
      , m = i.rotationX
      , d = i.skewX
      , f = i.skewY
      , _ = i.scaleX
      , g = i.scaleY
      , v = i.transformPerspective
      , y = i.force3D
      , w = i.target
      , S = i.zOrigin
      , E = ""
      , b = y === "auto" && e && e !== 1 || y === !0;
    if (S && (m !== Wa || h !== Wa)) {
        var T = parseFloat(h) * Dc, C = Math.sin(T), P = Math.cos(T), A;
        T = parseFloat(m) * Dc,
        A = Math.cos(T),
        o = kg(w, o, C * A * -S),
        a = kg(w, a, -Math.sin(T) * -S),
        c = kg(w, c, P * A * -S + S)
    }
    v !== Cu && (E += "perspective(" + v + $a),
    (r || s) && (E += "translate(" + r + "%, " + s + "%) "),
    (b || o !== Cu || a !== Cu || c !== Cu) && (E += c !== Cu || b ? "translate3d(" + o + ", " + a + ", " + c + ") " : "translate(" + o + ", " + a + $a),
    u !== Wa && (E += "rotate(" + u + $a),
    h !== Wa && (E += "rotateY(" + h + $a),
    m !== Wa && (E += "rotateX(" + m + $a),
    (d !== Wa || f !== Wa) && (E += "skew(" + d + ", " + f + $a),
    (_ !== 1 || g !== 1) && (E += "scale(" + _ + ", " + g + $a),
    w.style[kn] = E || "translate(0, 0)"
}, OB = function(e, t) {
    var i = t || this, r = i.xPercent, s = i.yPercent, o = i.x, a = i.y, c = i.rotation, u = i.skewX, h = i.skewY, m = i.scaleX, d = i.scaleY, f = i.target, _ = i.xOrigin, g = i.yOrigin, v = i.xOffset, y = i.yOffset, w = i.forceCSS, S = parseFloat(o), E = parseFloat(a), b, T, C, P, A;
    c = parseFloat(c),
    u = parseFloat(u),
    h = parseFloat(h),
    h && (h = parseFloat(h),
    u += h,
    c += h),
    c || u ? (c *= Dc,
    u *= Dc,
    b = Math.cos(c) * m,
    T = Math.sin(c) * m,
    C = Math.sin(c - u) * -d,
    P = Math.cos(c - u) * d,
    u && (h *= Dc,
    A = Math.tan(u - h),
    A = Math.sqrt(1 + A * A),
    C *= A,
    P *= A,
    h && (A = Math.tan(h),
    A = Math.sqrt(1 + A * A),
    b *= A,
    T *= A)),
    b = jn(b),
    T = jn(T),
    C = jn(C),
    P = jn(P)) : (b = m,
    P = d,
    T = C = 0),
    (S && !~(o + "").indexOf("px") || E && !~(a + "").indexOf("px")) && (S = Ea(f, "x", o, "px"),
    E = Ea(f, "y", a, "px")),
    (_ || g || v || y) && (S = jn(S + _ - (_ * b + g * C) + v),
    E = jn(E + g - (_ * T + g * P) + y)),
    (r || s) && (A = f.getBBox(),
    S = jn(S + r / 100 * A.width),
    E = jn(E + s / 100 * A.height)),
    A = "matrix(" + b + "," + T + "," + C + "," + P + "," + S + "," + E + ")",
    f.setAttribute("transform", A),
    w && (f.style[kn] = A)
}, NB = function(e, t, i, r, s) {
    var o = 360, a = wi(s), c = parseFloat(s) * (a && ~s.indexOf("rad") ? Ja : 1), u = c - r, h = r + u + "deg", m, d;
    return a && (m = s.split("_")[1],
    m === "short" && (u %= o,
    u !== u % (o / 2) && (u += u < 0 ? o : -o)),
    m === "cw" && u < 0 ? u = (u + o * KS) % o - ~~(u / o) * o : m === "ccw" && u > 0 && (u = (u - o * KS) % o - ~~(u / o) * o)),
    e._pt = d = new Rr(e._pt,t,i,r,u,vB),
    d.e = h,
    d.u = "deg",
    e._props.push(i),
    d
}, nw = function(e, t) {
    for (var i in t)
        e[i] = t[i];
    return e
}, UB = function(e, t, i) {
    var r = nw({}, i._gsap), s = "perspective,force3D,transformOrigin,svgOrigin", o = i.style, a, c, u, h, m, d, f, _;
    r.svg ? (u = i.getAttribute("transform"),
    i.setAttribute("transform", ""),
    o[kn] = t,
    a = Bf(i, 1),
    Tl(i, kn),
    i.setAttribute("transform", u)) : (u = getComputedStyle(i)[kn],
    o[kn] = t,
    a = Bf(i, 1),
    o[kn] = u);
    for (c in Oo)
        u = r[c],
        h = a[c],
        u !== h && s.indexOf(c) < 0 && (f = Vi(u),
        _ = Vi(h),
        m = f !== _ ? Ea(i, c, u, _) : parseFloat(u),
        d = parseFloat(h),
        e._pt = new Rr(e._pt,a,c,m,d - m,W_),
        e._pt.u = _ || 0,
        e._props.push(c));
    nw(a, r)
};
Cr("padding,margin,Width,Radius", function(n, e) {
    var t = "Top"
      , i = "Right"
      , r = "Bottom"
      , s = "Left"
      , o = (e < 3 ? [t, i, r, s] : [t + s, t + i, r + i, r + s]).map(function(a) {
        return e < 2 ? n + a : "border" + a + n
    });
    vp[e > 1 ? "border" + n : n] = function(a, c, u, h, m) {
        var d, f;
        if (arguments.length < 4)
            return d = o.map(function(_) {
                return Mo(a, _, u)
            }),
            f = d.join(" "),
            f.split(d[0]).length === 5 ? d[0] : f;
        d = (h + "").split(" "),
        f = {},
        o.forEach(function(_, g) {
            return f[_] = d[g] = d[g] || d[(g - 1) / 2 | 0]
        }),
        a.init(c, f, m)
    }
});
var gC = {
    name: "css",
    register: X_,
    targetTest: function(e) {
        return e.style && e.nodeType
    },
    init: function(e, t, i, r, s) {
        var o = this._props, a = e.style, c = i.vars.startAt, u, h, m, d, f, _, g, v, y, w, S, E, b, T, C, P;
        xy || X_(),
        this.styles = this.styles || cC(e),
        P = this.styles.props,
        this.tween = i;
        for (g in t)
            if (g !== "autoRound" && (h = t[g],
            !($r[g] && JT(g, t, i, r, e, s)))) {
                if (f = typeof h,
                _ = vp[g],
                f === "function" && (h = h.call(i, r, e, s),
                f = typeof h),
                f === "string" && ~h.indexOf("random(") && (h = Of(h)),
                _)
                    _(this, e, g, h, i) && (C = 1);
                else if (g.substr(0, 2) === "--")
                    u = (getComputedStyle(e).getPropertyValue(g) + "").trim(),
                    h += "",
                    _a.lastIndex = 0,
                    _a.test(u) || (v = Vi(u),
                    y = Vi(h)),
                    y ? v !== y && (u = Ea(e, g, u, y) + y) : v && (h += v),
                    this.add(a, "setProperty", u, h, r, s, 0, 0, g),
                    o.push(g),
                    P.push(g, 0, a[g]);
                else if (f !== "undefined") {
                    if (c && g in c ? (u = typeof c[g] == "function" ? c[g].call(i, r, e, s) : c[g],
                    wi(u) && ~u.indexOf("random(") && (u = Of(u)),
                    Vi(u + "") || u === "auto" || (u += Kr.units[g] || Vi(Mo(e, g)) || ""),
                    (u + "").charAt(1) === "=" && (u = Mo(e, g))) : u = Mo(e, g),
                    d = parseFloat(u),
                    w = f === "string" && h.charAt(1) === "=" && h.substr(0, 2),
                    w && (h = h.substr(2)),
                    m = parseFloat(h),
                    g in Ks && (g === "autoAlpha" && (d === 1 && Mo(e, "visibility") === "hidden" && m && (d = 0),
                    P.push("visibility", 0, a.visibility),
                    ua(this, a, "visibility", d ? "inherit" : "hidden", m ? "inherit" : "hidden", !m)),
                    g !== "scale" && g !== "transform" && (g = Ks[g],
                    ~g.indexOf(",") && (g = g.split(",")[0]))),
                    S = g in Oo,
                    S) {
                        if (this.styles.save(g),
                        E || (b = e._gsap,
                        b.renderTransform && !t.parseTransform || Bf(e, t.parseTransform),
                        T = t.smoothOrigin !== !1 && b.smooth,
                        E = this._pt = new Rr(this._pt,a,kn,0,1,b.renderTransform,b,0,-1),
                        E.dep = 1),
                        g === "scale")
                            this._pt = new Rr(this._pt,b,"scaleY",b.scaleY,(w ? Pc(b.scaleY, w + m) : m) - b.scaleY || 0,W_),
                            this._pt.u = 0,
                            o.push("scaleY", g),
                            g += "X";
                        else if (g === "transformOrigin") {
                            P.push(Pr, 0, a[Pr]),
                            h = LB(h),
                            b.svg ? q_(e, h, 0, T, 0, this) : (y = parseFloat(h.split(" ")[2]) || 0,
                            y !== b.zOrigin && ua(this, b, "zOrigin", b.zOrigin, y),
                            ua(this, a, g, yp(u), yp(h)));
                            continue
                        } else if (g === "svgOrigin") {
                            q_(e, h, 1, T, 0, this);
                            continue
                        } else if (g in dC) {
                            NB(this, b, g, d, w ? Pc(d, w + h) : h);
                            continue
                        } else if (g === "smoothOrigin") {
                            ua(this, b, "smooth", b.smooth, h);
                            continue
                        } else if (g === "force3D") {
                            b[g] = h;
                            continue
                        } else if (g === "transform") {
                            UB(this, h, e);
                            continue
                        }
                    } else
                        g in a || (g = $c(g) || g);
                    if (S || (m || m === 0) && (d || d === 0) && !_B.test(h) && g in a)
                        v = (u + "").substr((d + "").length),
                        m || (m = 0),
                        y = Vi(h) || (g in Kr.units ? Kr.units[g] : v),
                        v !== y && (d = Ea(e, g, u, y)),
                        this._pt = new Rr(this._pt,S ? b : a,g,d,(w ? Pc(d, w + m) : m) - d,!S && (y === "px" || g === "zIndex") && t.autoRound !== !1 ? xB : W_),
                        this._pt.u = y || 0,
                        v !== y && y !== "%" && (this._pt.b = u,
                        this._pt.r = yB);
                    else if (g in a)
                        PB.call(this, e, g, u, w ? w + h : h);
                    else if (g in e)
                        this.add(e, g, u || e[g], w ? w + h : h, r, s);
                    else if (g !== "parseTransform") {
                        fy(g, h);
                        continue
                    }
                    S || (g in a ? P.push(g, 0, a[g]) : P.push(g, 1, u || e[g])),
                    o.push(g)
                }
            }
        C && rC(this)
    },
    render: function(e, t) {
        if (t.tween._time || !by())
            for (var i = t._pt; i; )
                i.r(e, i.d),
                i = i._next;
        else
            t.styles.revert()
    },
    get: Mo,
    aliases: Ks,
    getSetter: function(e, t, i) {
        var r = Ks[t];
        return r && r.indexOf(",") < 0 && (t = r),
        t in Oo && t !== Pr && (e._gsap.x || Mo(e, "x")) ? i && YS === i ? t === "scale" ? EB : wB : (YS = i || {}) && (t === "scale" ? AB : MB) : e.style && !ly(e.style[t]) ? bB : ~t.indexOf("-") ? SB : vy(e, t)
    },
    core: {
        _removeProperty: Tl,
        _getMatrix: wy
    }
};
Dr.utils.checkPrefix = $c;
Dr.core.getStyleSaver = cC;
(function(n, e, t, i) {
    var r = Cr(n + "," + e + "," + t, function(s) {
        Oo[s] = 1
    });
    Cr(e, function(s) {
        Kr.units[s] = "deg",
        dC[s] = 1
    }),
    Ks[r[13]] = n + "," + e,
    Cr(i, function(s) {
        var o = s.split(":");
        Ks[o[1]] = r[o[0]]
    })
}
)("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
Cr("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(n) {
    Kr.units[n] = "px"
});
Dr.registerPlugin(gC);
var ve = Dr.registerPlugin(gC) || Dr;
ve.core.Tween;
/*!
 * paths 3.12.3
 * https://gsap.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var FB = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig
  , BB = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig
  , kB = Math.PI / 180
  , td = Math.sin
  , nd = Math.cos
  , vf = Math.abs
  , Ru = Math.sqrt
  , zB = function(e) {
    return typeof e == "number"
}
  , iw = 1e5
  , Yo = function(e) {
    return Math.round(e * iw) / iw || 0
};
function HB(n, e, t, i, r, s, o) {
    for (var a = n.length, c, u, h, m, d; --a > -1; )
        for (c = n[a],
        u = c.length,
        h = 0; h < u; h += 2)
            m = c[h],
            d = c[h + 1],
            c[h] = m * e + d * i + s,
            c[h + 1] = m * t + d * r + o;
    return n._dirty = 1,
    n
}
function GB(n, e, t, i, r, s, o, a, c) {
    if (!(n === a && e === c)) {
        t = vf(t),
        i = vf(i);
        var u = r % 360 * kB
          , h = nd(u)
          , m = td(u)
          , d = Math.PI
          , f = d * 2
          , _ = (n - a) / 2
          , g = (e - c) / 2
          , v = h * _ + m * g
          , y = -m * _ + h * g
          , w = v * v
          , S = y * y
          , E = w / (t * t) + S / (i * i);
        E > 1 && (t = Ru(E) * t,
        i = Ru(E) * i);
        var b = t * t
          , T = i * i
          , C = (b * T - b * S - T * w) / (b * S + T * w);
        C < 0 && (C = 0);
        var P = (s === o ? -1 : 1) * Ru(C)
          , A = P * (t * y / i)
          , R = P * -(i * v / t)
          , I = (n + a) / 2
          , D = (e + c) / 2
          , H = I + (h * A - m * R)
          , B = D + (m * A + h * R)
          , G = (v - A) / t
          , X = (y - R) / i
          , V = (-v - A) / t
          , ee = (-y - R) / i
          , re = G * G + X * X
          , k = (X < 0 ? -1 : 1) * Math.acos(G / Ru(re))
          , oe = (G * ee - X * V < 0 ? -1 : 1) * Math.acos((G * V + X * ee) / Ru(re * (V * V + ee * ee)));
        isNaN(oe) && (oe = d),
        !o && oe > 0 ? oe -= f : o && oe < 0 && (oe += f),
        k %= f,
        oe %= f;
        var ae = Math.ceil(vf(oe) / (f / 4)), ne = [], fe = oe / ae, xe = 4 / 3 * td(fe / 2) / (1 + nd(fe / 2)), Re = h * t, Ue = m * t, He = m * -i, qe = h * i, Xe;
        for (Xe = 0; Xe < ae; Xe++)
            r = k + Xe * fe,
            v = nd(r),
            y = td(r),
            G = nd(r += fe),
            X = td(r),
            ne.push(v - xe * y, y + xe * v, G + xe * X, X - xe * G, G, X);
        for (Xe = 0; Xe < ne.length; Xe += 2)
            v = ne[Xe],
            y = ne[Xe + 1],
            ne[Xe] = v * Re + y * He + H,
            ne[Xe + 1] = v * Ue + y * qe + B;
        return ne[Xe - 2] = a,
        ne[Xe - 1] = c,
        ne
    }
}
function VB(n) {
    var e = (n + "").replace(BB, function(A) {
        var R = +A;
        return R < 1e-4 && R > -1e-4 ? 0 : R
    }).match(FB) || [], t = [], i = 0, r = 0, s = 2 / 3, o = e.length, a = 0, c = "ERROR: malformed path: " + n, u, h, m, d, f, _, g, v, y, w, S, E, b, T, C, P = function(R, I, D, H) {
        w = (D - R) / 3,
        S = (H - I) / 3,
        g.push(R + w, I + S, D - w, H - S, D, H)
    };
    if (!n || !isNaN(e[0]) || isNaN(e[1]))
        return console.log(c),
        t;
    for (u = 0; u < o; u++)
        if (b = f,
        isNaN(e[u]) ? (f = e[u].toUpperCase(),
        _ = f !== e[u]) : u--,
        m = +e[u + 1],
        d = +e[u + 2],
        _ && (m += i,
        d += r),
        u || (v = m,
        y = d),
        f === "M")
            g && (g.length < 8 ? t.length -= 1 : a += g.length),
            i = v = m,
            r = y = d,
            g = [m, d],
            t.push(g),
            u += 2,
            f = "L";
        else if (f === "C")
            g || (g = [0, 0]),
            _ || (i = r = 0),
            g.push(m, d, i + e[u + 3] * 1, r + e[u + 4] * 1, i += e[u + 5] * 1, r += e[u + 6] * 1),
            u += 6;
        else if (f === "S")
            w = i,
            S = r,
            (b === "C" || b === "S") && (w += i - g[g.length - 4],
            S += r - g[g.length - 3]),
            _ || (i = r = 0),
            g.push(w, S, m, d, i += e[u + 3] * 1, r += e[u + 4] * 1),
            u += 4;
        else if (f === "Q")
            w = i + (m - i) * s,
            S = r + (d - r) * s,
            _ || (i = r = 0),
            i += e[u + 3] * 1,
            r += e[u + 4] * 1,
            g.push(w, S, i + (m - i) * s, r + (d - r) * s, i, r),
            u += 4;
        else if (f === "T")
            w = i - g[g.length - 4],
            S = r - g[g.length - 3],
            g.push(i + w, r + S, m + (i + w * 1.5 - m) * s, d + (r + S * 1.5 - d) * s, i = m, r = d),
            u += 2;
        else if (f === "H")
            P(i, r, i = m, r),
            u += 1;
        else if (f === "V")
            P(i, r, i, r = m + (_ ? r - i : 0)),
            u += 1;
        else if (f === "L" || f === "Z")
            f === "Z" && (m = v,
            d = y,
            g.closed = !0),
            (f === "L" || vf(i - m) > .5 || vf(r - d) > .5) && (P(i, r, m, d),
            f === "L" && (u += 2)),
            i = m,
            r = d;
        else if (f === "A") {
            if (T = e[u + 4],
            C = e[u + 5],
            w = e[u + 6],
            S = e[u + 7],
            h = 7,
            T.length > 1 && (T.length < 3 ? (S = w,
            w = C,
            h--) : (S = C,
            w = T.substr(2),
            h -= 2),
            C = T.charAt(1),
            T = T.charAt(0)),
            E = GB(i, r, +e[u + 1], +e[u + 2], +e[u + 3], +T, +C, (_ ? i : 0) + w * 1, (_ ? r : 0) + S * 1),
            u += h,
            E)
                for (h = 0; h < E.length; h++)
                    g.push(E[h]);
            i = g[g.length - 2],
            r = g[g.length - 1]
        } else
            console.log(c);
    return u = g.length,
    u < 6 ? (t.pop(),
    u = 0) : g[0] === g[u - 2] && g[1] === g[u - 1] && (g.closed = !0),
    t.totalPoints = a + u,
    t
}
function WB(n) {
    zB(n[0]) && (n = [n]);
    var e = "", t = n.length, i, r, s, o;
    for (r = 0; r < t; r++) {
        for (o = n[r],
        e += "M" + Yo(o[0]) + "," + Yo(o[1]) + " C",
        i = o.length,
        s = 2; s < i; s++)
            e += Yo(o[s++]) + "," + Yo(o[s++]) + " " + Yo(o[s++]) + "," + Yo(o[s++]) + " " + Yo(o[s++]) + "," + Yo(o[s]) + " ";
        o.closed && (e += "z")
    }
    return e
}
/*!
 * CustomEase 3.12.3
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var wr, _C, vC = function() {
    return wr || typeof window < "u" && (wr = window.gsap) && wr.registerPlugin && wr
}, rw = function() {
    wr = vC(),
    wr ? (wr.registerEase("_CE", Bo.create),
    _C = 1) : console.warn("Please gsap.registerPlugin(CustomEase)")
}, $B = 1e20, id = function(e) {
    return ~~(e * 1e3 + (e < 0 ? -.5 : .5)) / 1e3
}, XB = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/gi, qB = /[cLlsSaAhHvVtTqQ]/g, jB = function(e) {
    var t = e.length, i = $B, r;
    for (r = 1; r < t; r += 6)
        +e[r] < i && (i = +e[r]);
    return i
}, YB = function(e, t, i) {
    !i && i !== 0 && (i = Math.max(+e[e.length - 1], +e[1]));
    var r = +e[0] * -1, s = -i, o = e.length, a = 1 / (+e[o - 2] + r), c = -t || (Math.abs(+e[o - 1] - +e[1]) < .01 * (+e[o - 2] - +e[0]) ? jB(e) + s : +e[o - 1] + s), u;
    for (c ? c = 1 / c : c = -a,
    u = 0; u < o; u += 2)
        e[u] = (+e[u] + r) * a,
        e[u + 1] = (+e[u + 1] + s) * c
}, KB = function n(e, t, i, r, s, o, a, c, u, h, m) {
    var d = (e + i) / 2, f = (t + r) / 2, _ = (i + s) / 2, g = (r + o) / 2, v = (s + a) / 2, y = (o + c) / 2, w = (d + _) / 2, S = (f + g) / 2, E = (_ + v) / 2, b = (g + y) / 2, T = (w + E) / 2, C = (S + b) / 2, P = a - e, A = c - t, R = Math.abs((i - a) * A - (r - c) * P), I = Math.abs((s - a) * A - (o - c) * P), D;
    return h || (h = [{
        x: e,
        y: t
    }, {
        x: a,
        y: c
    }],
    m = 1),
    h.splice(m || h.length - 1, 0, {
        x: T,
        y: C
    }),
    (R + I) * (R + I) > u * (P * P + A * A) && (D = h.length,
    n(e, t, d, f, w, S, T, C, u, h, m),
    n(T, C, E, b, v, y, a, c, u, h, m + 1 + (h.length - D))),
    h
}, Bo = function() {
    function n(t, i, r) {
        _C || rw(),
        this.id = t,
        this.setData(i, r)
    }
    var e = n.prototype;
    return e.setData = function(i, r) {
        r = r || {},
        i = i || "0,0,1,1";
        var s = i.match(XB), o = 1, a = [], c = [], u = r.precision || 1, h = u <= 1, m, d, f, _, g, v, y, w, S;
        if (this.data = i,
        (qB.test(i) || ~i.indexOf("M") && i.indexOf("C") < 0) && (s = VB(i)[0]),
        m = s.length,
        m === 4)
            s.unshift(0, 0),
            s.push(1, 1),
            m = 8;
        else if ((m - 2) % 6)
            throw "Invalid CustomEase";
        for ((+s[0] != 0 || +s[m - 2] != 1) && YB(s, r.height, r.originY),
        this.segment = s,
        _ = 2; _ < m; _ += 6)
            d = {
                x: +s[_ - 2],
                y: +s[_ - 1]
            },
            f = {
                x: +s[_ + 4],
                y: +s[_ + 5]
            },
            a.push(d, f),
            KB(d.x, d.y, +s[_], +s[_ + 1], +s[_ + 2], +s[_ + 3], f.x, f.y, 1 / (u * 2e5), a, a.length - 1);
        for (m = a.length,
        _ = 0; _ < m; _++)
            y = a[_],
            w = a[_ - 1] || y,
            (y.x > w.x || w.y !== y.y && w.x === y.x || y === w) && y.x <= 1 ? (w.cx = y.x - w.x,
            w.cy = y.y - w.y,
            w.n = y,
            w.nx = y.x,
            h && _ > 1 && Math.abs(w.cy / w.cx - a[_ - 2].cy / a[_ - 2].cx) > 2 && (h = 0),
            w.cx < o && (w.cx ? o = w.cx : (w.cx = .001,
            _ === m - 1 && (w.x -= .001,
            o = Math.min(o, .001),
            h = 0)))) : (a.splice(_--, 1),
            m--);
        if (m = 1 / o + 1 | 0,
        g = 1 / m,
        v = 0,
        y = a[0],
        h) {
            for (_ = 0; _ < m; _++)
                S = _ * g,
                y.nx < S && (y = a[++v]),
                d = y.y + (S - y.x) / y.cx * y.cy,
                c[_] = {
                    x: S,
                    cx: g,
                    y: d,
                    cy: 0,
                    nx: 9
                },
                _ && (c[_ - 1].cy = d - c[_ - 1].y);
            c[m - 1].cy = a[a.length - 1].y - d
        } else {
            for (_ = 0; _ < m; _++)
                y.nx < _ * g && (y = a[++v]),
                c[_] = y;
            v < a.length - 1 && (c[_ - 1] = a[a.length - 2])
        }
        return this.ease = function(E) {
            var b = c[E * m | 0] || c[m - 1];
            return b.nx < E && (b = b.n),
            b.y + (E - b.x) / b.cx * b.cy
        }
        ,
        this.ease.custom = this,
        this.id && wr && wr.registerEase(this.id, this.ease),
        this
    }
    ,
    e.getSVGData = function(i) {
        return n.getSVGData(this, i)
    }
    ,
    n.create = function(i, r, s) {
        return new n(i,r,s).ease
    }
    ,
    n.register = function(i) {
        wr = i,
        rw()
    }
    ,
    n.get = function(i) {
        return wr.parseEase(i)
    }
    ,
    n.getSVGData = function(i, r) {
        r = r || {};
        var s = r.width || 100, o = r.height || 100, a = r.x || 0, c = (r.y || 0) + o, u = wr.utils.toArray(r.path)[0], h, m, d, f, _, g, v, y, w, S;
        if (r.invert && (o = -o,
        c = 0),
        typeof i == "string" && (i = wr.parseEase(i)),
        i.custom && (i = i.custom),
        i instanceof n)
            h = WB(HB([i.segment], s, 0, 0, -o, a, c));
        else {
            for (h = [a, c],
            v = Math.max(5, (r.precision || 1) * 200),
            f = 1 / v,
            v += 2,
            y = 5 / v,
            w = id(a + f * s),
            S = id(c + i(f) * -o),
            m = (S - c) / (w - a),
            d = 2; d < v; d++)
                _ = id(a + d * f * s),
                g = id(c + i(d * f) * -o),
                (Math.abs((g - S) / (_ - w) - m) > y || d === v - 1) && (h.push(w, S),
                m = (g - S) / (_ - w)),
                w = _,
                S = g;
            h = "M" + h.join(",")
        }
        return u && u.setAttribute("d", h),
        h
    }
    ,
    n
}();
vC() && wr.registerPlugin(Bo);
Bo.version = "3.12.3";
function sw(n, e) {
    for (var t = 0; t < e.length; t++) {
        var i = e[t];
        i.enumerable = i.enumerable || !1,
        i.configurable = !0,
        "value"in i && (i.writable = !0),
        Object.defineProperty(n, i.key, i)
    }
}
function ZB(n, e, t) {
    return e && sw(n.prototype, e),
    t && sw(n, t),
    n
}
/*!
 * Observer 3.12.3
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Ri, Jd, qr, fa, ha, Ic, yC, Qa, yf, xC, Ro, Ps, bC, SC = function() {
    return Ri || typeof window < "u" && (Ri = window.gsap) && Ri.registerPlugin && Ri
}, wC = 1, Tc = [], Zt = [], eo = [], xf = Date.now, j_ = function(e, t) {
    return t
}, JB = function() {
    var e = yf.core
      , t = e.bridge || {}
      , i = e._scrollers
      , r = e._proxies;
    i.push.apply(i, Zt),
    r.push.apply(r, eo),
    Zt = i,
    eo = r,
    j_ = function(o, a) {
        return t[o](a)
    }
}, va = function(e, t) {
    return ~eo.indexOf(e) && eo[eo.indexOf(e) + 1][t]
}, bf = function(e) {
    return !!~xC.indexOf(e)
}, Zi = function(e, t, i, r, s) {
    return e.addEventListener(t, i, {
        passive: !r,
        capture: !!s
    })
}, Ki = function(e, t, i, r) {
    return e.removeEventListener(t, i, !!r)
}, rd = "scrollLeft", sd = "scrollTop", Y_ = function() {
    return Ro && Ro.isPressed || Zt.cache++
}, xp = function(e, t) {
    var i = function r(s) {
        if (s || s === 0) {
            wC && (qr.history.scrollRestoration = "manual");
            var o = Ro && Ro.isPressed;
            s = r.v = Math.round(s) || (Ro && Ro.iOS ? 1 : 0),
            e(s),
            r.cacheID = Zt.cache,
            o && j_("ss", s)
        } else
            (t || Zt.cache !== r.cacheID || j_("ref")) && (r.cacheID = Zt.cache,
            r.v = e());
        return r.v + r.offset
    };
    return i.offset = 0,
    e && i
}, ur = {
    s: rd,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: xp(function(n) {
        return arguments.length ? qr.scrollTo(n, ci.sc()) : qr.pageXOffset || fa[rd] || ha[rd] || Ic[rd] || 0
    })
}, ci = {
    s: sd,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: ur,
    sc: xp(function(n) {
        return arguments.length ? qr.scrollTo(ur.sc(), n) : qr.pageYOffset || fa[sd] || ha[sd] || Ic[sd] || 0
    })
}, Sr = function(e, t) {
    return (t && t._ctx && t._ctx.selector || Ri.utils.toArray)(e)[0] || (typeof e == "string" && Ri.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null)
}, Aa = function(e, t) {
    var i = t.s
      , r = t.sc;
    bf(e) && (e = fa.scrollingElement || ha);
    var s = Zt.indexOf(e)
      , o = r === ci.sc ? 1 : 2;
    !~s && (s = Zt.push(e) - 1),
    Zt[s + o] || Zi(e, "scroll", Y_);
    var a = Zt[s + o]
      , c = a || (Zt[s + o] = xp(va(e, i), !0) || (bf(e) ? r : xp(function(u) {
        return arguments.length ? e[i] = u : e[i]
    })));
    return c.target = e,
    a || (c.smooth = Ri.getProperty(e, "scrollBehavior") === "smooth"),
    c
}, K_ = function(e, t, i) {
    var r = e
      , s = e
      , o = xf()
      , a = o
      , c = t || 50
      , u = Math.max(500, c * 3)
      , h = function(_, g) {
        var v = xf();
        g || v - o > c ? (s = r,
        r = _,
        a = o,
        o = v) : i ? r += _ : r = s + (_ - s) / (v - a) * (o - a)
    }
      , m = function() {
        s = r = i ? 0 : r,
        a = o = 0
    }
      , d = function(_) {
        var g = a
          , v = s
          , y = xf();
        return (_ || _ === 0) && _ !== r && h(_),
        o === a || y - a > u ? 0 : (r + (i ? v : -v)) / ((i ? y : o) - g) * 1e3
    };
    return {
        update: h,
        reset: m,
        getVelocity: d
    }
}, Pu = function(e, t) {
    return t && !e._gsapAllow && e.preventDefault(),
    e.changedTouches ? e.changedTouches[0] : e
}, ow = function(e) {
    var t = Math.max.apply(Math, e)
      , i = Math.min.apply(Math, e);
    return Math.abs(t) >= Math.abs(i) ? t : i
}, EC = function() {
    yf = Ri.core.globals().ScrollTrigger,
    yf && yf.core && JB()
}, AC = function(e) {
    return Ri = e || SC(),
    !Jd && Ri && typeof document < "u" && document.body && (qr = window,
    fa = document,
    ha = fa.documentElement,
    Ic = fa.body,
    xC = [qr, fa, ha, Ic],
    Ri.utils.clamp,
    bC = Ri.core.context || function() {}
    ,
    Qa = "onpointerenter"in Ic ? "pointer" : "mouse",
    yC = ii.isTouch = qr.matchMedia && qr.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart"in qr || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0,
    Ps = ii.eventTypes = ("ontouchstart"in ha ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown"in ha ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","),
    setTimeout(function() {
        return wC = 0
    }, 500),
    EC(),
    Jd = 1),
    Jd
};
ur.op = ci;
Zt.cache = 0;
var ii = function() {
    function n(t) {
        this.init(t)
    }
    var e = n.prototype;
    return e.init = function(i) {
        Jd || AC(Ri) || console.warn("Please gsap.registerPlugin(Observer)"),
        yf || EC();
        var r = i.tolerance
          , s = i.dragMinimum
          , o = i.type
          , a = i.target
          , c = i.lineHeight
          , u = i.debounce
          , h = i.preventDefault
          , m = i.onStop
          , d = i.onStopDelay
          , f = i.ignore
          , _ = i.wheelSpeed
          , g = i.event
          , v = i.onDragStart
          , y = i.onDragEnd
          , w = i.onDrag
          , S = i.onPress
          , E = i.onRelease
          , b = i.onRight
          , T = i.onLeft
          , C = i.onUp
          , P = i.onDown
          , A = i.onChangeX
          , R = i.onChangeY
          , I = i.onChange
          , D = i.onToggleX
          , H = i.onToggleY
          , B = i.onHover
          , G = i.onHoverEnd
          , X = i.onMove
          , V = i.ignoreCheck
          , ee = i.isNormalizer
          , re = i.onGestureStart
          , k = i.onGestureEnd
          , oe = i.onWheel
          , ae = i.onEnable
          , ne = i.onDisable
          , fe = i.onClick
          , xe = i.scrollSpeed
          , Re = i.capture
          , Ue = i.allowClicks
          , He = i.lockAxis
          , qe = i.onLockAxis;
        this.target = a = Sr(a) || ha,
        this.vars = i,
        f && (f = Ri.utils.toArray(f)),
        r = r || 1e-9,
        s = s || 0,
        _ = _ || 1,
        xe = xe || 1,
        o = o || "wheel,touch,pointer",
        u = u !== !1,
        c || (c = parseFloat(qr.getComputedStyle(Ic).lineHeight) || 22);
        var Xe, st, ie, dt, Ne, Ye, Qe, te = this, ot = 0, ft = 0, Tt = Aa(a, ur), pt = Aa(a, ci), Ct = Tt(), z = pt(), N = ~o.indexOf("touch") && !~o.indexOf("pointer") && Ps[0] === "pointerdown", j = bf(a), he = a.ownerDocument || fa, le = [0, 0, 0], me = [0, 0, 0], We = 0, Te = function() {
            return We = xf()
        }, Ee = function(je, Et) {
            return (te.event = je) && f && ~f.indexOf(je.target) || Et && N && je.pointerType !== "touch" || V && V(je, Et)
        }, Ae = function() {
            te._vx.reset(),
            te._vy.reset(),
            st.pause(),
            m && m(te)
        }, _t = function() {
            var je = te.deltaX = ow(le)
              , Et = te.deltaY = ow(me)
              , At = Math.abs(je) >= r
              , Be = Math.abs(Et) >= r;
            I && (At || Be) && I(te, je, Et, le, me),
            At && (b && te.deltaX > 0 && b(te),
            T && te.deltaX < 0 && T(te),
            A && A(te),
            D && te.deltaX < 0 != ot < 0 && D(te),
            ot = te.deltaX,
            le[0] = le[1] = le[2] = 0),
            Be && (P && te.deltaY > 0 && P(te),
            C && te.deltaY < 0 && C(te),
            R && R(te),
            H && te.deltaY < 0 != ft < 0 && H(te),
            ft = te.deltaY,
            me[0] = me[1] = me[2] = 0),
            (dt || ie) && (X && X(te),
            ie && (w(te),
            ie = !1),
            dt = !1),
            Ye && !(Ye = !1) && qe && qe(te),
            Ne && (oe(te),
            Ne = !1),
            Xe = 0
        }, Pe = function(je, Et, At) {
            le[At] += je,
            me[At] += Et,
            te._vx.update(je),
            te._vy.update(Et),
            u ? Xe || (Xe = requestAnimationFrame(_t)) : _t()
        }, Bt = function(je, Et) {
            He && !Qe && (te.axis = Qe = Math.abs(je) > Math.abs(Et) ? "x" : "y",
            Ye = !0),
            Qe !== "y" && (le[2] += je,
            te._vx.update(je, !0)),
            Qe !== "x" && (me[2] += Et,
            te._vy.update(Et, !0)),
            u ? Xe || (Xe = requestAnimationFrame(_t)) : _t()
        }, vt = function(je) {
            if (!Ee(je, 1)) {
                je = Pu(je, h);
                var Et = je.clientX
                  , At = je.clientY
                  , Be = Et - te.x
                  , bt = At - te.y
                  , yt = te.isDragging;
                te.x = Et,
                te.y = At,
                (yt || Math.abs(te.startX - Et) >= s || Math.abs(te.startY - At) >= s) && (w && (ie = !0),
                yt || (te.isDragging = !0),
                Bt(Be, bt),
                yt || v && v(te))
            }
        }, ht = te.onPress = function(Ge) {
            Ee(Ge, 1) || Ge && Ge.button || (te.axis = Qe = null,
            st.pause(),
            te.isPressed = !0,
            Ge = Pu(Ge),
            ot = ft = 0,
            te.startX = te.x = Ge.clientX,
            te.startY = te.y = Ge.clientY,
            te._vx.reset(),
            te._vy.reset(),
            Zi(ee ? a : he, Ps[1], vt, h, !0),
            te.deltaX = te.deltaY = 0,
            S && S(te))
        }
        , at = te.onRelease = function(Ge) {
            if (!Ee(Ge, 1)) {
                Ki(ee ? a : he, Ps[1], vt, !0);
                var je = !isNaN(te.y - te.startY)
                  , Et = te.isDragging
                  , At = Et && (Math.abs(te.x - te.startX) > 3 || Math.abs(te.y - te.startY) > 3)
                  , Be = Pu(Ge);
                !At && je && (te._vx.reset(),
                te._vy.reset(),
                h && Ue && Ri.delayedCall(.08, function() {
                    if (xf() - We > 300 && !Ge.defaultPrevented) {
                        if (Ge.target.click)
                            Ge.target.click();
                        else if (he.createEvent) {
                            var bt = he.createEvent("MouseEvents");
                            bt.initMouseEvent("click", !0, !0, qr, 1, Be.screenX, Be.screenY, Be.clientX, Be.clientY, !1, !1, !1, !1, 0, null),
                            Ge.target.dispatchEvent(bt)
                        }
                    }
                })),
                te.isDragging = te.isGesturing = te.isPressed = !1,
                m && Et && !ee && st.restart(!0),
                y && Et && y(te),
                E && E(te, At)
            }
        }
        , Le = function(je) {
            return je.touches && je.touches.length > 1 && (te.isGesturing = !0) && re(je, te.isDragging)
        }, Lt = function() {
            return (te.isGesturing = !1) || k(te)
        }, Y = function(je) {
            if (!Ee(je)) {
                var Et = Tt()
                  , At = pt();
                Pe((Et - Ct) * xe, (At - z) * xe, 1),
                Ct = Et,
                z = At,
                m && st.restart(!0)
            }
        }, ze = function(je) {
            if (!Ee(je)) {
                je = Pu(je, h),
                oe && (Ne = !0);
                var Et = (je.deltaMode === 1 ? c : je.deltaMode === 2 ? qr.innerHeight : 1) * _;
                Pe(je.deltaX * Et, je.deltaY * Et, 0),
                m && !ee && st.restart(!0)
            }
        }, De = function(je) {
            if (!Ee(je)) {
                var Et = je.clientX
                  , At = je.clientY
                  , Be = Et - te.x
                  , bt = At - te.y;
                te.x = Et,
                te.y = At,
                dt = !0,
                m && st.restart(!0),
                (Be || bt) && Bt(Be, bt)
            }
        }, ge = function(je) {
            te.event = je,
            B(te)
        }, Fe = function(je) {
            te.event = je,
            G(te)
        }, ut = function(je) {
            return Ee(je) || Pu(je, h) && fe(te)
        };
        st = te._dc = Ri.delayedCall(d || .25, Ae).pause(),
        te.deltaX = te.deltaY = 0,
        te._vx = K_(0, 50, !0),
        te._vy = K_(0, 50, !0),
        te.scrollX = Tt,
        te.scrollY = pt,
        te.isDragging = te.isGesturing = te.isPressed = !1,
        bC(this),
        te.enable = function(Ge) {
            return te.isEnabled || (Zi(j ? he : a, "scroll", Y_),
            o.indexOf("scroll") >= 0 && Zi(j ? he : a, "scroll", Y, h, Re),
            o.indexOf("wheel") >= 0 && Zi(a, "wheel", ze, h, Re),
            (o.indexOf("touch") >= 0 && yC || o.indexOf("pointer") >= 0) && (Zi(a, Ps[0], ht, h, Re),
            Zi(he, Ps[2], at),
            Zi(he, Ps[3], at),
            Ue && Zi(a, "click", Te, !1, !0),
            fe && Zi(a, "click", ut),
            re && Zi(he, "gesturestart", Le),
            k && Zi(he, "gestureend", Lt),
            B && Zi(a, Qa + "enter", ge),
            G && Zi(a, Qa + "leave", Fe),
            X && Zi(a, Qa + "move", De)),
            te.isEnabled = !0,
            Ge && Ge.type && ht(Ge),
            ae && ae(te)),
            te
        }
        ,
        te.disable = function() {
            te.isEnabled && (Tc.filter(function(Ge) {
                return Ge !== te && bf(Ge.target)
            }).length || Ki(j ? he : a, "scroll", Y_),
            te.isPressed && (te._vx.reset(),
            te._vy.reset(),
            Ki(ee ? a : he, Ps[1], vt, !0)),
            Ki(j ? he : a, "scroll", Y, Re),
            Ki(a, "wheel", ze, Re),
            Ki(a, Ps[0], ht, Re),
            Ki(he, Ps[2], at),
            Ki(he, Ps[3], at),
            Ki(a, "click", Te, !0),
            Ki(a, "click", ut),
            Ki(he, "gesturestart", Le),
            Ki(he, "gestureend", Lt),
            Ki(a, Qa + "enter", ge),
            Ki(a, Qa + "leave", Fe),
            Ki(a, Qa + "move", De),
            te.isEnabled = te.isPressed = te.isDragging = !1,
            ne && ne(te))
        }
        ,
        te.kill = te.revert = function() {
            te.disable();
            var Ge = Tc.indexOf(te);
            Ge >= 0 && Tc.splice(Ge, 1),
            Ro === te && (Ro = 0)
        }
        ,
        Tc.push(te),
        ee && bf(a) && (Ro = te),
        te.enable(g)
    }
    ,
    ZB(n, [{
        key: "velocityX",
        get: function() {
            return this._vx.getVelocity()
        }
    }, {
        key: "velocityY",
        get: function() {
            return this._vy.getVelocity()
        }
    }]),
    n
}();
ii.version = "3.12.3";
ii.create = function(n) {
    return new ii(n)
}
;
ii.register = AC;
ii.getAll = function() {
    return Tc.slice()
}
;
ii.getById = function(n) {
    return Tc.filter(function(e) {
        return e.vars.id === n
    })[0]
}
;
SC() && Ri.registerPlugin(ii);
/*!
 * ScrollTrigger 3.12.3
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var it, wc, rn, Un, Ds, Ln, MC, bp, kf, Cc, Qd, od, Hi, jp, Z_, nr, aw, lw, Ec, TC, zg, CC, tr, RC, PC, LC, sa, J_, Ey, Oc, Ay, My, Q_, Hg, ad = 1, rr = Date.now, Gg = rr(), ys = 0, uf = 0, cw = function(e, t, i) {
    var r = Wr(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
    return i["_" + t + "Clamp"] = r,
    r ? e.substr(6, e.length - 7) : e
}, uw = function(e, t) {
    return t && (!Wr(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e
}, QB = function n() {
    return uf && requestAnimationFrame(n)
}, fw = function() {
    return jp = 1
}, hw = function() {
    return jp = 0
}, Xs = function(e) {
    return e
}, ff = function(e) {
    return Math.round(e * 1e5) / 1e5 || 0
}, DC = function() {
    return typeof window < "u"
}, IC = function() {
    return it || DC() && (it = window.gsap) && it.registerPlugin && it
}, Cl = function(e) {
    return !!~MC.indexOf(e)
}, OC = function(e) {
    return (e === "Height" ? Ay : rn["inner" + e]) || Ds["client" + e] || Ln["client" + e]
}, NC = function(e) {
    return va(e, "getBoundingClientRect") || (Cl(e) ? function() {
        return sp.width = rn.innerWidth,
        sp.height = Ay,
        sp
    }
    : function() {
        return To(e)
    }
    )
}, ek = function(e, t, i) {
    var r = i.d
      , s = i.d2
      , o = i.a;
    return (o = va(e, "getBoundingClientRect")) ? function() {
        return o()[r]
    }
    : function() {
        return (t ? OC(s) : e["client" + s]) || 0
    }
}, tk = function(e, t) {
    return !t || ~eo.indexOf(e) ? NC(e) : function() {
        return sp
    }
}, Zs = function(e, t) {
    var i = t.s
      , r = t.d2
      , s = t.d
      , o = t.a;
    return Math.max(0, (i = "scroll" + r) && (o = va(e, i)) ? o() - NC(e)()[s] : Cl(e) ? (Ds[i] || Ln[i]) - OC(r) : e[i] - e["offset" + r])
}, ld = function(e, t) {
    for (var i = 0; i < Ec.length; i += 3)
        (!t || ~t.indexOf(Ec[i + 1])) && e(Ec[i], Ec[i + 1], Ec[i + 2])
}, Wr = function(e) {
    return typeof e == "string"
}, fr = function(e) {
    return typeof e == "function"
}, ep = function(e) {
    return typeof e == "number"
}, el = function(e) {
    return typeof e == "object"
}, Lu = function(e, t, i) {
    return e && e.progress(t ? 0 : 1) && i && e.pause()
}, Vg = function(e, t) {
    if (e.enabled) {
        var i = e._ctx ? e._ctx.add(function() {
            return t(e)
        }) : t(e);
        i && i.totalTime && (e.callbackAnimation = i)
    }
}, nc = Math.abs, UC = "left", FC = "top", Ty = "right", Cy = "bottom", vl = "width", yl = "height", Sf = "Right", wf = "Left", Ef = "Top", Af = "Bottom", ti = "padding", hs = "margin", Xc = "Width", Ry = "Height", _i = "px", ds = function(e) {
    return rn.getComputedStyle(e)
}, nk = function(e) {
    var t = ds(e).position;
    e.style.position = t === "absolute" || t === "fixed" ? t : "relative"
}, dw = function(e, t) {
    for (var i in t)
        i in e || (e[i] = t[i]);
    return e
}, To = function(e, t) {
    var i = t && ds(e)[Z_] !== "matrix(1, 0, 0, 1, 0, 0)" && it.to(e, {
        x: 0,
        y: 0,
        xPercent: 0,
        yPercent: 0,
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        scale: 1,
        skewX: 0,
        skewY: 0
    }).progress(1)
      , r = e.getBoundingClientRect();
    return i && i.progress(0).kill(),
    r
}, ev = function(e, t) {
    var i = t.d2;
    return e["offset" + i] || e["client" + i] || 0
}, BC = function(e) {
    var t = [], i = e.labels, r = e.duration(), s;
    for (s in i)
        t.push(i[s] / r);
    return t
}, ik = function(e) {
    return function(t) {
        return it.utils.snap(BC(e), t)
    }
}, Py = function(e) {
    var t = it.utils.snap(e)
      , i = Array.isArray(e) && e.slice(0).sort(function(r, s) {
        return r - s
    });
    return i ? function(r, s, o) {
        o === void 0 && (o = .001);
        var a;
        if (!s)
            return t(r);
        if (s > 0) {
            for (r -= o,
            a = 0; a < i.length; a++)
                if (i[a] >= r)
                    return i[a];
            return i[a - 1]
        } else
            for (a = i.length,
            r += o; a--; )
                if (i[a] <= r)
                    return i[a];
        return i[0]
    }
    : function(r, s, o) {
        o === void 0 && (o = .001);
        var a = t(r);
        return !s || Math.abs(a - r) < o || a - r < 0 == s < 0 ? a : t(s < 0 ? r - e : r + e)
    }
}, rk = function(e) {
    return function(t, i) {
        return Py(BC(e))(t, i.direction)
    }
}, cd = function(e, t, i, r) {
    return i.split(",").forEach(function(s) {
        return e(t, s, r)
    })
}, yi = function(e, t, i, r, s) {
    return e.addEventListener(t, i, {
        passive: !r,
        capture: !!s
    })
}, vi = function(e, t, i, r) {
    return e.removeEventListener(t, i, !!r)
}, ud = function(e, t, i) {
    i = i && i.wheelHandler,
    i && (e(t, "wheel", i),
    e(t, "touchmove", i))
}, pw = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal"
}, fd = {
    toggleActions: "play",
    anticipatePin: 0
}, Sp = {
    top: 0,
    left: 0,
    center: .5,
    bottom: 1,
    right: 1
}, tp = function(e, t) {
    if (Wr(e)) {
        var i = e.indexOf("=")
          , r = ~i ? +(e.charAt(i - 1) + 1) * parseFloat(e.substr(i + 1)) : 0;
        ~i && (e.indexOf("%") > i && (r *= t / 100),
        e = e.substr(0, i - 1)),
        e = r + (e in Sp ? Sp[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
    }
    return e
}, hd = function(e, t, i, r, s, o, a, c) {
    var u = s.startColor
      , h = s.endColor
      , m = s.fontSize
      , d = s.indent
      , f = s.fontWeight
      , _ = Un.createElement("div")
      , g = Cl(i) || va(i, "pinType") === "fixed"
      , v = e.indexOf("scroller") !== -1
      , y = g ? Ln : i
      , w = e.indexOf("start") !== -1
      , S = w ? u : h
      , E = "border-color:" + S + ";font-size:" + m + ";color:" + S + ";font-weight:" + f + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    return E += "position:" + ((v || c) && g ? "fixed;" : "absolute;"),
    (v || c || !g) && (E += (r === ci ? Ty : Cy) + ":" + (o + parseFloat(d)) + "px;"),
    a && (E += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"),
    _._isStart = w,
    _.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")),
    _.style.cssText = E,
    _.innerText = t || t === 0 ? e + "-" + t : e,
    y.children[0] ? y.insertBefore(_, y.children[0]) : y.appendChild(_),
    _._offset = _["offset" + r.op.d2],
    np(_, 0, r, w),
    _
}, np = function(e, t, i, r) {
    var s = {
        display: "block"
    }
      , o = i[r ? "os2" : "p2"]
      , a = i[r ? "p2" : "os2"];
    e._isFlipped = r,
    s[i.a + "Percent"] = r ? -100 : 0,
    s[i.a] = r ? "1px" : 0,
    s["border" + o + Xc] = 1,
    s["border" + a + Xc] = 0,
    s[i.p] = t + "px",
    it.set(e, s)
}, Xt = [], tv = {}, zf, mw = function() {
    return rr() - ys > 34 && (zf || (zf = requestAnimationFrame(Do)))
}, ic = function() {
    (!tr || !tr.isPressed || tr.startX > Ln.clientWidth) && (Zt.cache++,
    tr ? zf || (zf = requestAnimationFrame(Do)) : Do(),
    ys || Pl("scrollStart"),
    ys = rr())
}, Wg = function() {
    LC = rn.innerWidth,
    PC = rn.innerHeight
}, hf = function() {
    Zt.cache++,
    !Hi && !CC && !Un.fullscreenElement && !Un.webkitFullscreenElement && (!RC || LC !== rn.innerWidth || Math.abs(rn.innerHeight - PC) > rn.innerHeight * .25) && bp.restart(!0)
}, Rl = {}, sk = [], kC = function n() {
    return vi(Ot, "scrollEnd", n) || cl(!0)
}, Pl = function(e) {
    return Rl[e] && Rl[e].map(function(t) {
        return t()
    }) || sk
}, Vr = [], zC = function(e) {
    for (var t = 0; t < Vr.length; t += 5)
        (!e || Vr[t + 4] && Vr[t + 4].query === e) && (Vr[t].style.cssText = Vr[t + 1],
        Vr[t].getBBox && Vr[t].setAttribute("transform", Vr[t + 2] || ""),
        Vr[t + 3].uncache = 1)
}, Ly = function(e, t) {
    var i;
    for (nr = 0; nr < Xt.length; nr++)
        i = Xt[nr],
        i && (!t || i._ctx === t) && (e ? i.kill(1) : i.revert(!0, !0));
    My = !0,
    t && zC(t),
    t || Pl("revert")
}, HC = function(e, t) {
    Zt.cache++,
    (t || !ir) && Zt.forEach(function(i) {
        return fr(i) && i.cacheID++ && (i.rec = 0)
    }),
    Wr(e) && (rn.history.scrollRestoration = Ey = e)
}, ir, xl = 0, gw, ok = function() {
    if (gw !== xl) {
        var e = gw = xl;
        requestAnimationFrame(function() {
            return e === xl && cl(!0)
        })
    }
}, GC = function() {
    Ln.appendChild(Oc),
    Ay = !tr && Oc.offsetHeight || rn.innerHeight,
    Ln.removeChild(Oc)
}, _w = function(e) {
    return kf(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(t) {
        return t.style.display = e ? "none" : "block"
    })
}, cl = function(e, t) {
    if (ys && !e) {
        yi(Ot, "scrollEnd", kC);
        return
    }
    GC(),
    ir = Ot.isRefreshing = !0,
    Zt.forEach(function(r) {
        return fr(r) && ++r.cacheID && (r.rec = r())
    });
    var i = Pl("refreshInit");
    TC && Ot.sort(),
    t || Ly(),
    Zt.forEach(function(r) {
        fr(r) && (r.smooth && (r.target.style.scrollBehavior = "auto"),
        r(0))
    }),
    Xt.slice(0).forEach(function(r) {
        return r.refresh()
    }),
    My = !1,
    Xt.forEach(function(r) {
        if (r._subPinOffset && r.pin) {
            var s = r.vars.horizontal ? "offsetWidth" : "offsetHeight"
              , o = r.pin[s];
            r.revert(!0, 1),
            r.adjustPinSpacing(r.pin[s] - o),
            r.refresh()
        }
    }),
    Q_ = 1,
    _w(!0),
    Xt.forEach(function(r) {
        var s = Zs(r.scroller, r._dir)
          , o = r.vars.end === "max" || r._endClamp && r.end > s
          , a = r._startClamp && r.start >= s;
        (o || a) && r.setPositions(a ? s - 1 : r.start, o ? Math.max(a ? s : r.start + 1, s) : r.end, !0)
    }),
    _w(!1),
    Q_ = 0,
    i.forEach(function(r) {
        return r && r.render && r.render(-1)
    }),
    Zt.forEach(function(r) {
        fr(r) && (r.smooth && requestAnimationFrame(function() {
            return r.target.style.scrollBehavior = "smooth"
        }),
        r.rec && r(r.rec))
    }),
    HC(Ey, 1),
    bp.pause(),
    xl++,
    ir = 2,
    Do(2),
    Xt.forEach(function(r) {
        return fr(r.vars.onRefresh) && r.vars.onRefresh(r)
    }),
    ir = Ot.isRefreshing = !1,
    Pl("refresh")
}, nv = 0, ip = 1, Mf, Do = function(e) {
    if (e === 2 || !ir && !My) {
        Ot.isUpdating = !0,
        Mf && Mf.update(0);
        var t = Xt.length
          , i = rr()
          , r = i - Gg >= 50
          , s = t && Xt[0].scroll();
        if (ip = nv > s ? -1 : 1,
        ir || (nv = s),
        r && (ys && !jp && i - ys > 200 && (ys = 0,
        Pl("scrollEnd")),
        Qd = Gg,
        Gg = i),
        ip < 0) {
            for (nr = t; nr-- > 0; )
                Xt[nr] && Xt[nr].update(0, r);
            ip = 1
        } else
            for (nr = 0; nr < t; nr++)
                Xt[nr] && Xt[nr].update(0, r);
        Ot.isUpdating = !1
    }
    zf = 0
}, iv = [UC, FC, Cy, Ty, hs + Af, hs + Sf, hs + Ef, hs + wf, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], rp = iv.concat([vl, yl, "boxSizing", "max" + Xc, "max" + Ry, "position", hs, ti, ti + Ef, ti + Sf, ti + Af, ti + wf]), ak = function(e, t, i) {
    Nc(i);
    var r = e._gsap;
    if (r.spacerIsNative)
        Nc(r.spacerState);
    else if (e._gsap.swappedIn) {
        var s = t.parentNode;
        s && (s.insertBefore(e, t),
        s.removeChild(t))
    }
    e._gsap.swappedIn = !1
}, $g = function(e, t, i, r) {
    if (!e._gsap.swappedIn) {
        for (var s = iv.length, o = t.style, a = e.style, c; s--; )
            c = iv[s],
            o[c] = i[c];
        o.position = i.position === "absolute" ? "absolute" : "relative",
        i.display === "inline" && (o.display = "inline-block"),
        a[Cy] = a[Ty] = "auto",
        o.flexBasis = i.flexBasis || "auto",
        o.overflow = "visible",
        o.boxSizing = "border-box",
        o[vl] = ev(e, ur) + _i,
        o[yl] = ev(e, ci) + _i,
        o[ti] = a[hs] = a[FC] = a[UC] = "0",
        Nc(r),
        a[vl] = a["max" + Xc] = i[vl],
        a[yl] = a["max" + Ry] = i[yl],
        a[ti] = i[ti],
        e.parentNode !== t && (e.parentNode.insertBefore(t, e),
        t.appendChild(e)),
        e._gsap.swappedIn = !0
    }
}, lk = /([A-Z])/g, Nc = function(e) {
    if (e) {
        var t = e.t.style, i = e.length, r = 0, s, o;
        for ((e.t._gsap || it.core.getCache(e.t)).uncache = 1; r < i; r += 2)
            o = e[r + 1],
            s = e[r],
            o ? t[s] = o : t[s] && t.removeProperty(s.replace(lk, "-$1").toLowerCase())
    }
}, dd = function(e) {
    for (var t = rp.length, i = e.style, r = [], s = 0; s < t; s++)
        r.push(rp[s], i[rp[s]]);
    return r.t = e,
    r
}, ck = function(e, t, i) {
    for (var r = [], s = e.length, o = i ? 8 : 0, a; o < s; o += 2)
        a = e[o],
        r.push(a, a in t ? t[a] : e[o + 1]);
    return r.t = e.t,
    r
}, sp = {
    left: 0,
    top: 0
}, vw = function(e, t, i, r, s, o, a, c, u, h, m, d, f, _) {
    fr(e) && (e = e(c)),
    Wr(e) && e.substr(0, 3) === "max" && (e = d + (e.charAt(4) === "=" ? tp("0" + e.substr(3), i) : 0));
    var g = f ? f.time() : 0, v, y, w;
    if (f && f.seek(0),
    isNaN(e) || (e = +e),
    ep(e))
        f && (e = it.utils.mapRange(f.scrollTrigger.start, f.scrollTrigger.end, 0, d, e)),
        a && np(a, i, r, !0);
    else {
        fr(t) && (t = t(c));
        var S = (e || "0").split(" "), E, b, T, C;
        w = Sr(t, c) || Ln,
        E = To(w) || {},
        (!E || !E.left && !E.top) && ds(w).display === "none" && (C = w.style.display,
        w.style.display = "block",
        E = To(w),
        C ? w.style.display = C : w.style.removeProperty("display")),
        b = tp(S[0], E[r.d]),
        T = tp(S[1] || "0", i),
        e = E[r.p] - u[r.p] - h + b + s - T,
        a && np(a, T, r, i - T < 20 || a._isStart && T > 20),
        i -= i - T
    }
    if (_ && (c[_] = e || -.001,
    e < 0 && (e = 0)),
    o) {
        var P = e + i
          , A = o._isStart;
        v = "scroll" + r.d2,
        np(o, P, r, A && P > 20 || !A && (m ? Math.max(Ln[v], Ds[v]) : o.parentNode[v]) <= P + 1),
        m && (u = To(a),
        m && (o.style[r.op.p] = u[r.op.p] - r.op.m - o._offset + _i))
    }
    return f && w && (v = To(w),
    f.seek(d),
    y = To(w),
    f._caScrollDist = v[r.p] - y[r.p],
    e = e / f._caScrollDist * d),
    f && f.seek(g),
    f ? e : Math.round(e)
}, uk = /(webkit|moz|length|cssText|inset)/i, yw = function(e, t, i, r) {
    if (e.parentNode !== t) {
        var s = e.style, o, a;
        if (t === Ln) {
            e._stOrig = s.cssText,
            a = ds(e);
            for (o in a)
                !+o && !uk.test(o) && a[o] && typeof s[o] == "string" && o !== "0" && (s[o] = a[o]);
            s.top = i,
            s.left = r
        } else
            s.cssText = e._stOrig;
        it.core.getCache(e).uncache = 1,
        t.appendChild(e)
    }
}, VC = function(e, t, i) {
    var r = t
      , s = r;
    return function(o) {
        var a = Math.round(e());
        return a !== r && a !== s && Math.abs(a - r) > 3 && Math.abs(a - s) > 3 && (o = a,
        i && i()),
        s = r,
        r = o,
        o
    }
}, pd = function(e, t, i) {
    var r = {};
    r[t.p] = "+=" + i,
    it.set(e, r)
}, xw = function(e, t) {
    var i = Aa(e, t)
      , r = "_scroll" + t.p2
      , s = function o(a, c, u, h, m) {
        var d = o.tween
          , f = c.onComplete
          , _ = {};
        u = u || i();
        var g = VC(i, u, function() {
            d.kill(),
            o.tween = 0
        });
        return m = h && m || 0,
        h = h || a - u,
        d && d.kill(),
        c[r] = a,
        c.modifiers = _,
        _[r] = function() {
            return g(u + h * d.ratio + m * d.ratio * d.ratio)
        }
        ,
        c.onUpdate = function() {
            Zt.cache++,
            o.tween && Do()
        }
        ,
        c.onComplete = function() {
            o.tween = 0,
            f && f.call(d)
        }
        ,
        d = o.tween = it.to(e, c),
        d
    };
    return e[r] = i,
    i.wheelHandler = function() {
        return s.tween && s.tween.kill() && (s.tween = 0)
    }
    ,
    yi(e, "wheel", i.wheelHandler),
    Ot.isTouch && yi(e, "touchmove", i.wheelHandler),
    s
}, Ot = function() {
    function n(t, i) {
        wc || n.register(it) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
        J_(this),
        this.init(t, i)
    }
    var e = n.prototype;
    return e.init = function(i, r) {
        if (this.progress = this.start = 0,
        this.vars && this.kill(!0, !0),
        !uf) {
            this.update = this.refresh = this.kill = Xs;
            return
        }
        i = dw(Wr(i) || ep(i) || i.nodeType ? {
            trigger: i
        } : i, fd);
        var s = i, o = s.onUpdate, a = s.toggleClass, c = s.id, u = s.onToggle, h = s.onRefresh, m = s.scrub, d = s.trigger, f = s.pin, _ = s.pinSpacing, g = s.invalidateOnRefresh, v = s.anticipatePin, y = s.onScrubComplete, w = s.onSnapComplete, S = s.once, E = s.snap, b = s.pinReparent, T = s.pinSpacer, C = s.containerAnimation, P = s.fastScrollEnd, A = s.preventOverlaps, R = i.horizontal || i.containerAnimation && i.horizontal !== !1 ? ur : ci, I = !m && m !== 0, D = Sr(i.scroller || rn), H = it.core.getCache(D), B = Cl(D), G = ("pinType"in i ? i.pinType : va(D, "pinType") || B && "fixed") === "fixed", X = [i.onEnter, i.onLeave, i.onEnterBack, i.onLeaveBack], V = I && i.toggleActions.split(" "), ee = "markers"in i ? i.markers : fd.markers, re = B ? 0 : parseFloat(ds(D)["border" + R.p2 + Xc]) || 0, k = this, oe = i.onRefreshInit && function() {
            return i.onRefreshInit(k)
        }
        , ae = ek(D, B, R), ne = tk(D, B), fe = 0, xe = 0, Re = 0, Ue = Aa(D, R), He, qe, Xe, st, ie, dt, Ne, Ye, Qe, te, ot, ft, Tt, pt, Ct, z, N, j, he, le, me, We, Te, Ee, Ae, _t, Pe, Bt, vt, ht, at, Le, Lt, Y, ze, De, ge, Fe, ut;
        if (k._startClamp = k._endClamp = !1,
        k._dir = R,
        v *= 45,
        k.scroller = D,
        k.scroll = C ? C.time.bind(C) : Ue,
        st = Ue(),
        k.vars = i,
        r = r || i.animation,
        "refreshPriority"in i && (TC = 1,
        i.refreshPriority === -9999 && (Mf = k)),
        H.tweenScroll = H.tweenScroll || {
            top: xw(D, ci),
            left: xw(D, ur)
        },
        k.tweenTo = He = H.tweenScroll[R.p],
        k.scrubDuration = function(Be) {
            Lt = ep(Be) && Be,
            Lt ? Le ? Le.duration(Be) : Le = it.to(r, {
                ease: "expo",
                totalProgress: "+=0",
                duration: Lt,
                paused: !0,
                onComplete: function() {
                    return y && y(k)
                }
            }) : (Le && Le.progress(1).kill(),
            Le = 0)
        }
        ,
        r && (r.vars.lazy = !1,
        r._initted && !k.isReverted || r.vars.immediateRender !== !1 && i.immediateRender !== !1 && r.duration() && r.render(0, !0, !0),
        k.animation = r.pause(),
        r.scrollTrigger = k,
        k.scrubDuration(m),
        ht = 0,
        c || (c = r.vars.id)),
        E && ((!el(E) || E.push) && (E = {
            snapTo: E
        }),
        "scrollBehavior"in Ln.style && it.set(B ? [Ln, Ds] : D, {
            scrollBehavior: "auto"
        }),
        Zt.forEach(function(Be) {
            return fr(Be) && Be.target === (B ? Un.scrollingElement || Ds : D) && (Be.smooth = !1)
        }),
        Xe = fr(E.snapTo) ? E.snapTo : E.snapTo === "labels" ? ik(r) : E.snapTo === "labelsDirectional" ? rk(r) : E.directional !== !1 ? function(Be, bt) {
            return Py(E.snapTo)(Be, rr() - xe < 500 ? 0 : bt.direction)
        }
        : it.utils.snap(E.snapTo),
        Y = E.duration || {
            min: .1,
            max: 2
        },
        Y = el(Y) ? Cc(Y.min, Y.max) : Cc(Y, Y),
        ze = it.delayedCall(E.delay || Lt / 2 || .1, function() {
            var Be = Ue()
              , bt = rr() - xe < 500
              , yt = He.tween;
            if ((bt || Math.abs(k.getVelocity()) < 10) && !yt && !jp && fe !== Be) {
                var kt = (Be - dt) / pt
                  , Mn = r && !I ? r.totalProgress() : kt
                  , $t = bt ? 0 : (Mn - at) / (rr() - Qd) * 1e3 || 0
                  , dn = it.utils.clamp(-kt, 1 - kt, nc($t / 2) * $t / .185)
                  , Kn = kt + (E.inertia === !1 ? 0 : dn)
                  , On = Cc(0, 1, Xe(Kn, k))
                  , _n = Math.round(dt + On * pt)
                  , ln = E
                  , Di = ln.onStart
                  , F = ln.onInterrupt
                  , J = ln.onComplete;
                if (Be <= Ne && Be >= dt && _n !== Be) {
                    if (yt && !yt._initted && yt.data <= nc(_n - Be))
                        return;
                    E.inertia === !1 && (dn = On - kt),
                    He(_n, {
                        duration: Y(nc(Math.max(nc(Kn - Mn), nc(On - Mn)) * .185 / $t / .05 || 0)),
                        ease: E.ease || "power3",
                        data: nc(_n - Be),
                        onInterrupt: function() {
                            return ze.restart(!0) && F && F(k)
                        },
                        onComplete: function() {
                            k.update(),
                            fe = Ue(),
                            Le && r && r.progress(On),
                            ht = at = r && !I ? r.totalProgress() : k.progress,
                            w && w(k),
                            J && J(k)
                        }
                    }, Be, dn * pt, _n - Be - dn * pt),
                    Di && Di(k, He.tween)
                }
            } else
                k.isActive && fe !== Be && ze.restart(!0)
        }).pause()),
        c && (tv[c] = k),
        d = k.trigger = Sr(d || f !== !0 && f),
        ut = d && d._gsap && d._gsap.stRevert,
        ut && (ut = ut(k)),
        f = f === !0 ? d : Sr(f),
        Wr(a) && (a = {
            targets: d,
            className: a
        }),
        f && (_ === !1 || _ === hs || (_ = !_ && f.parentNode && f.parentNode.style && ds(f.parentNode).display === "flex" ? !1 : ti),
        k.pin = f,
        qe = it.core.getCache(f),
        qe.spacer ? Ct = qe.pinState : (T && (T = Sr(T),
        T && !T.nodeType && (T = T.current || T.nativeElement),
        qe.spacerIsNative = !!T,
        T && (qe.spacerState = dd(T))),
        qe.spacer = j = T || Un.createElement("div"),
        j.classList.add("pin-spacer"),
        c && j.classList.add("pin-spacer-" + c),
        qe.pinState = Ct = dd(f)),
        i.force3D !== !1 && it.set(f, {
            force3D: !0
        }),
        k.spacer = j = qe.spacer,
        vt = ds(f),
        Ee = vt[_ + R.os2],
        le = it.getProperty(f),
        me = it.quickSetter(f, R.a, _i),
        $g(f, j, vt),
        N = dd(f)),
        ee) {
            ft = el(ee) ? dw(ee, pw) : pw,
            te = hd("scroller-start", c, D, R, ft, 0),
            ot = hd("scroller-end", c, D, R, ft, 0, te),
            he = te["offset" + R.op.d2];
            var Ge = Sr(va(D, "content") || D);
            Ye = this.markerStart = hd("start", c, Ge, R, ft, he, 0, C),
            Qe = this.markerEnd = hd("end", c, Ge, R, ft, he, 0, C),
            C && (Fe = it.quickSetter([Ye, Qe], R.a, _i)),
            !G && !(eo.length && va(D, "fixedMarkers") === !0) && (nk(B ? Ln : D),
            it.set([te, ot], {
                force3D: !0
            }),
            _t = it.quickSetter(te, R.a, _i),
            Bt = it.quickSetter(ot, R.a, _i))
        }
        if (C) {
            var je = C.vars.onUpdate
              , Et = C.vars.onUpdateParams;
            C.eventCallback("onUpdate", function() {
                k.update(0, 0, 1),
                je && je.apply(C, Et || [])
            })
        }
        if (k.previous = function() {
            return Xt[Xt.indexOf(k) - 1]
        }
        ,
        k.next = function() {
            return Xt[Xt.indexOf(k) + 1]
        }
        ,
        k.revert = function(Be, bt) {
            if (!bt)
                return k.kill(!0);
            var yt = Be !== !1 || !k.enabled
              , kt = Hi;
            yt !== k.isReverted && (yt && (De = Math.max(Ue(), k.scroll.rec || 0),
            Re = k.progress,
            ge = r && r.progress()),
            Ye && [Ye, Qe, te, ot].forEach(function(Mn) {
                return Mn.style.display = yt ? "none" : "block"
            }),
            yt && (Hi = k,
            k.update(yt)),
            f && (!b || !k.isActive) && (yt ? ak(f, j, Ct) : $g(f, j, ds(f), Ae)),
            yt || k.update(yt),
            Hi = kt,
            k.isReverted = yt)
        }
        ,
        k.refresh = function(Be, bt, yt, kt) {
            if (!((Hi || !k.enabled) && !bt)) {
                if (f && Be && ys) {
                    yi(n, "scrollEnd", kC);
                    return
                }
                !ir && oe && oe(k),
                Hi = k,
                He.tween && !yt && (He.tween.kill(),
                He.tween = 0),
                Le && Le.pause(),
                g && r && r.revert({
                    kill: !1
                }).invalidate(),
                k.isReverted || k.revert(!0, !0),
                k._subPinOffset = !1;
                var Mn = ae(), $t = ne(), dn = C ? C.duration() : Zs(D, R), Kn = pt <= .01, On = 0, _n = kt || 0, ln = el(yt) ? yt.end : i.end, Di = i.endTrigger || d, F = el(yt) ? yt.start : i.start || (i.start === 0 || !d ? 0 : f ? "0 0" : "0 100%"), J = k.pinnedContainer = i.pinnedContainer && Sr(i.pinnedContainer, k), ce = d && Math.max(0, Xt.indexOf(k)) || 0, ue = ce, se, ke, et, mt, tt, lt, gt, Pt, vn, zn, an, Ei, un;
                for (ee && el(yt) && (Ei = it.getProperty(te, R.p),
                un = it.getProperty(ot, R.p)); ue--; )
                    lt = Xt[ue],
                    lt.end || lt.refresh(0, 1) || (Hi = k),
                    gt = lt.pin,
                    gt && (gt === d || gt === f || gt === J) && !lt.isReverted && (zn || (zn = []),
                    zn.unshift(lt),
                    lt.revert(!0, !0)),
                    lt !== Xt[ue] && (ce--,
                    ue--);
                for (fr(F) && (F = F(k)),
                F = cw(F, "start", k),
                dt = vw(F, d, Mn, R, Ue(), Ye, te, k, $t, re, G, dn, C, k._startClamp && "_startClamp") || (f ? -.001 : 0),
                fr(ln) && (ln = ln(k)),
                Wr(ln) && !ln.indexOf("+=") && (~ln.indexOf(" ") ? ln = (Wr(F) ? F.split(" ")[0] : "") + ln : (On = tp(ln.substr(2), Mn),
                ln = Wr(F) ? F : (C ? it.utils.mapRange(0, C.duration(), C.scrollTrigger.start, C.scrollTrigger.end, dt) : dt) + On,
                Di = d)),
                ln = cw(ln, "end", k),
                Ne = Math.max(dt, vw(ln || (Di ? "100% 0" : dn), Di, Mn, R, Ue() + On, Qe, ot, k, $t, re, G, dn, C, k._endClamp && "_endClamp")) || -.001,
                On = 0,
                ue = ce; ue--; )
                    lt = Xt[ue],
                    gt = lt.pin,
                    gt && lt.start - lt._pinPush <= dt && !C && lt.end > 0 && (se = lt.end - (k._startClamp ? Math.max(0, lt.start) : lt.start),
                    (gt === d && lt.start - lt._pinPush < dt || gt === J) && isNaN(F) && (On += se * (1 - lt.progress)),
                    gt === f && (_n += se));
                if (dt += On,
                Ne += On,
                k._startClamp && (k._startClamp += On),
                k._endClamp && !ir && (k._endClamp = Ne || -.001,
                Ne = Math.min(Ne, Zs(D, R))),
                pt = Ne - dt || (dt -= .01) && .001,
                Kn && (Re = it.utils.clamp(0, 1, it.utils.normalize(dt, Ne, De))),
                k._pinPush = _n,
                Ye && On && (se = {},
                se[R.a] = "+=" + On,
                J && (se[R.p] = "-=" + Ue()),
                it.set([Ye, Qe], se)),
                f && !(Q_ && k.end >= Zs(D, R)))
                    se = ds(f),
                    mt = R === ci,
                    et = Ue(),
                    We = parseFloat(le(R.a)) + _n,
                    !dn && Ne > 1 && (an = (B ? Un.scrollingElement || Ds : D).style,
                    an = {
                        style: an,
                        value: an["overflow" + R.a.toUpperCase()]
                    },
                    B && ds(Ln)["overflow" + R.a.toUpperCase()] !== "scroll" && (an.style["overflow" + R.a.toUpperCase()] = "scroll")),
                    $g(f, j, se),
                    N = dd(f),
                    ke = To(f, !0),
                    Pt = G && Aa(D, mt ? ur : ci)(),
                    _ && (Ae = [_ + R.os2, pt + _n + _i],
                    Ae.t = j,
                    ue = _ === ti ? ev(f, R) + pt + _n : 0,
                    ue && (Ae.push(R.d, ue + _i),
                    j.style.flexBasis !== "auto" && (j.style.flexBasis = ue + _i)),
                    Nc(Ae),
                    J && Xt.forEach(function(Dt) {
                        Dt.pin === J && Dt.vars.pinSpacing !== !1 && (Dt._subPinOffset = !0)
                    }),
                    G && Ue(De)),
                    G && (tt = {
                        top: ke.top + (mt ? et - dt : Pt) + _i,
                        left: ke.left + (mt ? Pt : et - dt) + _i,
                        boxSizing: "border-box",
                        position: "fixed"
                    },
                    tt[vl] = tt["max" + Xc] = Math.ceil(ke.width) + _i,
                    tt[yl] = tt["max" + Ry] = Math.ceil(ke.height) + _i,
                    tt[hs] = tt[hs + Ef] = tt[hs + Sf] = tt[hs + Af] = tt[hs + wf] = "0",
                    tt[ti] = se[ti],
                    tt[ti + Ef] = se[ti + Ef],
                    tt[ti + Sf] = se[ti + Sf],
                    tt[ti + Af] = se[ti + Af],
                    tt[ti + wf] = se[ti + wf],
                    z = ck(Ct, tt, b),
                    ir && Ue(0)),
                    r ? (vn = r._initted,
                    zg(1),
                    r.render(r.duration(), !0, !0),
                    Te = le(R.a) - We + pt + _n,
                    Pe = Math.abs(pt - Te) > 1,
                    G && Pe && z.splice(z.length - 2, 2),
                    r.render(0, !0, !0),
                    vn || r.invalidate(!0),
                    r.parent || r.totalTime(r.totalTime()),
                    zg(0)) : Te = pt,
                    an && (an.value ? an.style["overflow" + R.a.toUpperCase()] = an.value : an.style.removeProperty("overflow-" + R.a));
                else if (d && Ue() && !C)
                    for (ke = d.parentNode; ke && ke !== Ln; )
                        ke._pinOffset && (dt -= ke._pinOffset,
                        Ne -= ke._pinOffset),
                        ke = ke.parentNode;
                zn && zn.forEach(function(Dt) {
                    return Dt.revert(!1, !0)
                }),
                k.start = dt,
                k.end = Ne,
                st = ie = ir ? De : Ue(),
                !C && !ir && (st < De && Ue(De),
                k.scroll.rec = 0),
                k.revert(!1, !0),
                xe = rr(),
                ze && (fe = -1,
                ze.restart(!0)),
                Hi = 0,
                r && I && (r._initted || ge) && r.progress() !== ge && r.progress(ge || 0, !0).render(r.time(), !0, !0),
                (Kn || Re !== k.progress || C) && (r && !I && r.totalProgress(C && dt < -.001 && !Re ? it.utils.normalize(dt, Ne, 0) : Re, !0),
                k.progress = Kn || (st - dt) / pt === Re ? 0 : Re),
                f && _ && (j._pinOffset = Math.round(k.progress * Te)),
                Le && Le.invalidate(),
                isNaN(Ei) || (Ei -= it.getProperty(te, R.p),
                un -= it.getProperty(ot, R.p),
                pd(te, R, Ei),
                pd(Ye, R, Ei - (kt || 0)),
                pd(ot, R, un),
                pd(Qe, R, un - (kt || 0))),
                Kn && !ir && k.update(),
                h && !ir && !Tt && (Tt = !0,
                h(k),
                Tt = !1)
            }
        }
        ,
        k.getVelocity = function() {
            return (Ue() - ie) / (rr() - Qd) * 1e3 || 0
        }
        ,
        k.endAnimation = function() {
            Lu(k.callbackAnimation),
            r && (Le ? Le.progress(1) : r.paused() ? I || Lu(r, k.direction < 0, 1) : Lu(r, r.reversed()))
        }
        ,
        k.labelToScroll = function(Be) {
            return r && r.labels && (dt || k.refresh() || dt) + r.labels[Be] / r.duration() * pt || 0
        }
        ,
        k.getTrailing = function(Be) {
            var bt = Xt.indexOf(k)
              , yt = k.direction > 0 ? Xt.slice(0, bt).reverse() : Xt.slice(bt + 1);
            return (Wr(Be) ? yt.filter(function(kt) {
                return kt.vars.preventOverlaps === Be
            }) : yt).filter(function(kt) {
                return k.direction > 0 ? kt.end <= dt : kt.start >= Ne
            })
        }
        ,
        k.update = function(Be, bt, yt) {
            if (!(C && !yt && !Be)) {
                var kt = ir === !0 ? De : k.scroll(), Mn = Be ? 0 : (kt - dt) / pt, $t = Mn < 0 ? 0 : Mn > 1 ? 1 : Mn || 0, dn = k.progress, Kn, On, _n, ln, Di, F, J, ce;
                if (bt && (ie = st,
                st = C ? Ue() : kt,
                E && (at = ht,
                ht = r && !I ? r.totalProgress() : $t)),
                v && !$t && f && !Hi && !ad && ys && dt < kt + (kt - ie) / (rr() - Qd) * v && ($t = 1e-4),
                $t !== dn && k.enabled) {
                    if (Kn = k.isActive = !!$t && $t < 1,
                    On = !!dn && dn < 1,
                    F = Kn !== On,
                    Di = F || !!$t != !!dn,
                    k.direction = $t > dn ? 1 : -1,
                    k.progress = $t,
                    Di && !Hi && (_n = $t && !dn ? 0 : $t === 1 ? 1 : dn === 1 ? 2 : 3,
                    I && (ln = !F && V[_n + 1] !== "none" && V[_n + 1] || V[_n],
                    ce = r && (ln === "complete" || ln === "reset" || ln in r))),
                    A && (F || ce) && (ce || m || !r) && (fr(A) ? A(k) : k.getTrailing(A).forEach(function(et) {
                        return et.endAnimation()
                    })),
                    I || (Le && !Hi && !ad ? (Le._dp._time - Le._start !== Le._time && Le.render(Le._dp._time - Le._start),
                    Le.resetTo ? Le.resetTo("totalProgress", $t, r._tTime / r._tDur) : (Le.vars.totalProgress = $t,
                    Le.invalidate().restart())) : r && r.totalProgress($t, !!(Hi && (xe || Be)))),
                    f) {
                        if (Be && _ && (j.style[_ + R.os2] = Ee),
                        !G)
                            me(ff(We + Te * $t));
                        else if (Di) {
                            if (J = !Be && $t > dn && Ne + 1 > kt && kt + 1 >= Zs(D, R),
                            b)
                                if (!Be && (Kn || J)) {
                                    var ue = To(f, !0)
                                      , se = kt - dt;
                                    yw(f, Ln, ue.top + (R === ci ? se : 0) + _i, ue.left + (R === ci ? 0 : se) + _i)
                                } else
                                    yw(f, j);
                            Nc(Kn || J ? z : N),
                            Pe && $t < 1 && Kn || me(We + ($t === 1 && !J ? Te : 0))
                        }
                    }
                    E && !He.tween && !Hi && !ad && ze.restart(!0),
                    a && (F || S && $t && ($t < 1 || !Hg)) && kf(a.targets).forEach(function(et) {
                        return et.classList[Kn || S ? "add" : "remove"](a.className)
                    }),
                    o && !I && !Be && o(k),
                    Di && !Hi ? (I && (ce && (ln === "complete" ? r.pause().totalProgress(1) : ln === "reset" ? r.restart(!0).pause() : ln === "restart" ? r.restart(!0) : r[ln]()),
                    o && o(k)),
                    (F || !Hg) && (u && F && Vg(k, u),
                    X[_n] && Vg(k, X[_n]),
                    S && ($t === 1 ? k.kill(!1, 1) : X[_n] = 0),
                    F || (_n = $t === 1 ? 1 : 3,
                    X[_n] && Vg(k, X[_n]))),
                    P && !Kn && Math.abs(k.getVelocity()) > (ep(P) ? P : 2500) && (Lu(k.callbackAnimation),
                    Le ? Le.progress(1) : Lu(r, ln === "reverse" ? 1 : !$t, 1))) : I && o && !Hi && o(k)
                }
                if (Bt) {
                    var ke = C ? kt / C.duration() * (C._caScrollDist || 0) : kt;
                    _t(ke + (te._isFlipped ? 1 : 0)),
                    Bt(ke)
                }
                Fe && Fe(-kt / C.duration() * (C._caScrollDist || 0))
            }
        }
        ,
        k.enable = function(Be, bt) {
            k.enabled || (k.enabled = !0,
            yi(D, "resize", hf),
            B || yi(D, "scroll", ic),
            oe && yi(n, "refreshInit", oe),
            Be !== !1 && (k.progress = Re = 0,
            st = ie = fe = Ue()),
            bt !== !1 && k.refresh())
        }
        ,
        k.getTween = function(Be) {
            return Be && He ? He.tween : Le
        }
        ,
        k.setPositions = function(Be, bt, yt, kt) {
            if (C) {
                var Mn = C.scrollTrigger
                  , $t = C.duration()
                  , dn = Mn.end - Mn.start;
                Be = Mn.start + dn * Be / $t,
                bt = Mn.start + dn * bt / $t
            }
            k.refresh(!1, !1, {
                start: uw(Be, yt && !!k._startClamp),
                end: uw(bt, yt && !!k._endClamp)
            }, kt),
            k.update()
        }
        ,
        k.adjustPinSpacing = function(Be) {
            if (Ae && Be) {
                var bt = Ae.indexOf(R.d) + 1;
                Ae[bt] = parseFloat(Ae[bt]) + Be + _i,
                Ae[1] = parseFloat(Ae[1]) + Be + _i,
                Nc(Ae)
            }
        }
        ,
        k.disable = function(Be, bt) {
            if (k.enabled && (Be !== !1 && k.revert(!0, !0),
            k.enabled = k.isActive = !1,
            bt || Le && Le.pause(),
            De = 0,
            qe && (qe.uncache = 1),
            oe && vi(n, "refreshInit", oe),
            ze && (ze.pause(),
            He.tween && He.tween.kill() && (He.tween = 0)),
            !B)) {
                for (var yt = Xt.length; yt--; )
                    if (Xt[yt].scroller === D && Xt[yt] !== k)
                        return;
                vi(D, "resize", hf),
                B || vi(D, "scroll", ic)
            }
        }
        ,
        k.kill = function(Be, bt) {
            k.disable(Be, bt),
            Le && !bt && Le.kill(),
            c && delete tv[c];
            var yt = Xt.indexOf(k);
            yt >= 0 && Xt.splice(yt, 1),
            yt === nr && ip > 0 && nr--,
            yt = 0,
            Xt.forEach(function(kt) {
                return kt.scroller === k.scroller && (yt = 1)
            }),
            yt || ir || (k.scroll.rec = 0),
            r && (r.scrollTrigger = null,
            Be && r.revert({
                kill: !1
            }),
            bt || r.kill()),
            Ye && [Ye, Qe, te, ot].forEach(function(kt) {
                return kt.parentNode && kt.parentNode.removeChild(kt)
            }),
            Mf === k && (Mf = 0),
            f && (qe && (qe.uncache = 1),
            yt = 0,
            Xt.forEach(function(kt) {
                return kt.pin === f && yt++
            }),
            yt || (qe.spacer = 0)),
            i.onKill && i.onKill(k)
        }
        ,
        Xt.push(k),
        k.enable(!1, !1),
        ut && ut(k),
        r && r.add && !pt) {
            var At = k.update;
            k.update = function() {
                k.update = At,
                dt || Ne || k.refresh()
            }
            ,
            it.delayedCall(.01, k.update),
            pt = .01,
            dt = Ne = 0
        } else
            k.refresh();
        f && ok()
    }
    ,
    n.register = function(i) {
        return wc || (it = i || IC(),
        DC() && window.document && n.enable(),
        wc = uf),
        wc
    }
    ,
    n.defaults = function(i) {
        if (i)
            for (var r in i)
                fd[r] = i[r];
        return fd
    }
    ,
    n.disable = function(i, r) {
        uf = 0,
        Xt.forEach(function(o) {
            return o[r ? "kill" : "disable"](i)
        }),
        vi(rn, "wheel", ic),
        vi(Un, "scroll", ic),
        clearInterval(od),
        vi(Un, "touchcancel", Xs),
        vi(Ln, "touchstart", Xs),
        cd(vi, Un, "pointerdown,touchstart,mousedown", fw),
        cd(vi, Un, "pointerup,touchend,mouseup", hw),
        bp.kill(),
        ld(vi);
        for (var s = 0; s < Zt.length; s += 3)
            ud(vi, Zt[s], Zt[s + 1]),
            ud(vi, Zt[s], Zt[s + 2])
    }
    ,
    n.enable = function() {
        if (rn = window,
        Un = document,
        Ds = Un.documentElement,
        Ln = Un.body,
        it && (kf = it.utils.toArray,
        Cc = it.utils.clamp,
        J_ = it.core.context || Xs,
        zg = it.core.suppressOverwrites || Xs,
        Ey = rn.history.scrollRestoration || "auto",
        nv = rn.pageYOffset,
        it.core.globals("ScrollTrigger", n),
        Ln)) {
            uf = 1,
            Oc = document.createElement("div"),
            Oc.style.height = "100vh",
            Oc.style.position = "absolute",
            GC(),
            QB(),
            ii.register(it),
            n.isTouch = ii.isTouch,
            sa = ii.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
            yi(rn, "wheel", ic),
            MC = [rn, Un, Ds, Ln],
            it.matchMedia ? (n.matchMedia = function(c) {
                var u = it.matchMedia(), h;
                for (h in c)
                    u.add(h, c[h]);
                return u
            }
            ,
            it.addEventListener("matchMediaInit", function() {
                return Ly()
            }),
            it.addEventListener("matchMediaRevert", function() {
                return zC()
            }),
            it.addEventListener("matchMedia", function() {
                cl(0, 1),
                Pl("matchMedia")
            }),
            it.matchMedia("(orientation: portrait)", function() {
                return Wg(),
                Wg
            })) : console.warn("Requires GSAP 3.11.0 or later"),
            Wg(),
            yi(Un, "scroll", ic);
            var i = Ln.style, r = i.borderTopStyle, s = it.core.Animation.prototype, o, a;
            for (s.revert || Object.defineProperty(s, "revert", {
                value: function() {
                    return this.time(-.01, !0)
                }
            }),
            i.borderTopStyle = "solid",
            o = To(Ln),
            ci.m = Math.round(o.top + ci.sc()) || 0,
            ur.m = Math.round(o.left + ur.sc()) || 0,
            r ? i.borderTopStyle = r : i.removeProperty("border-top-style"),
            od = setInterval(mw, 250),
            it.delayedCall(.5, function() {
                return ad = 0
            }),
            yi(Un, "touchcancel", Xs),
            yi(Ln, "touchstart", Xs),
            cd(yi, Un, "pointerdown,touchstart,mousedown", fw),
            cd(yi, Un, "pointerup,touchend,mouseup", hw),
            Z_ = it.utils.checkPrefix("transform"),
            rp.push(Z_),
            wc = rr(),
            bp = it.delayedCall(.2, cl).pause(),
            Ec = [Un, "visibilitychange", function() {
                var c = rn.innerWidth
                  , u = rn.innerHeight;
                Un.hidden ? (aw = c,
                lw = u) : (aw !== c || lw !== u) && hf()
            }
            , Un, "DOMContentLoaded", cl, rn, "load", cl, rn, "resize", hf],
            ld(yi),
            Xt.forEach(function(c) {
                return c.enable(0, 1)
            }),
            a = 0; a < Zt.length; a += 3)
                ud(vi, Zt[a], Zt[a + 1]),
                ud(vi, Zt[a], Zt[a + 2])
        }
    }
    ,
    n.config = function(i) {
        "limitCallbacks"in i && (Hg = !!i.limitCallbacks);
        var r = i.syncInterval;
        r && clearInterval(od) || (od = r) && setInterval(mw, r),
        "ignoreMobileResize"in i && (RC = n.isTouch === 1 && i.ignoreMobileResize),
        "autoRefreshEvents"in i && (ld(vi) || ld(yi, i.autoRefreshEvents || "none"),
        CC = (i.autoRefreshEvents + "").indexOf("resize") === -1)
    }
    ,
    n.scrollerProxy = function(i, r) {
        var s = Sr(i)
          , o = Zt.indexOf(s)
          , a = Cl(s);
        ~o && Zt.splice(o, a ? 6 : 2),
        r && (a ? eo.unshift(rn, r, Ln, r, Ds, r) : eo.unshift(s, r))
    }
    ,
    n.clearMatchMedia = function(i) {
        Xt.forEach(function(r) {
            return r._ctx && r._ctx.query === i && r._ctx.kill(!0, !0)
        })
    }
    ,
    n.isInViewport = function(i, r, s) {
        var o = (Wr(i) ? Sr(i) : i).getBoundingClientRect()
          , a = o[s ? vl : yl] * r || 0;
        return s ? o.right - a > 0 && o.left + a < rn.innerWidth : o.bottom - a > 0 && o.top + a < rn.innerHeight
    }
    ,
    n.positionInViewport = function(i, r, s) {
        Wr(i) && (i = Sr(i));
        var o = i.getBoundingClientRect()
          , a = o[s ? vl : yl]
          , c = r == null ? a / 2 : r in Sp ? Sp[r] * a : ~r.indexOf("%") ? parseFloat(r) * a / 100 : parseFloat(r) || 0;
        return s ? (o.left + c) / rn.innerWidth : (o.top + c) / rn.innerHeight
    }
    ,
    n.killAll = function(i) {
        if (Xt.slice(0).forEach(function(s) {
            return s.vars.id !== "ScrollSmoother" && s.kill()
        }),
        i !== !0) {
            var r = Rl.killAll || [];
            Rl = {},
            r.forEach(function(s) {
                return s()
            })
        }
    }
    ,
    n
}();
Ot.version = "3.12.3";
Ot.saveStyles = function(n) {
    return n ? kf(n).forEach(function(e) {
        if (e && e.style) {
            var t = Vr.indexOf(e);
            t >= 0 && Vr.splice(t, 5),
            Vr.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), it.core.getCache(e), J_())
        }
    }) : Vr
}
;
Ot.revert = function(n, e) {
    return Ly(!n, e)
}
;
Ot.create = function(n, e) {
    return new Ot(n,e)
}
;
Ot.refresh = function(n) {
    return n ? hf() : (wc || Ot.register()) && cl(!0)
}
;
Ot.update = function(n) {
    return ++Zt.cache && Do(n === !0 ? 2 : 0)
}
;
Ot.clearScrollMemory = HC;
Ot.maxScroll = function(n, e) {
    return Zs(n, e ? ur : ci)
}
;
Ot.getScrollFunc = function(n, e) {
    return Aa(Sr(n), e ? ur : ci)
}
;
Ot.getById = function(n) {
    return tv[n]
}
;
Ot.getAll = function() {
    return Xt.filter(function(n) {
        return n.vars.id !== "ScrollSmoother"
    })
}
;
Ot.isScrolling = function() {
    return !!ys
}
;
Ot.snapDirectional = Py;
Ot.addEventListener = function(n, e) {
    var t = Rl[n] || (Rl[n] = []);
    ~t.indexOf(e) || t.push(e)
}
;
Ot.removeEventListener = function(n, e) {
    var t = Rl[n]
      , i = t && t.indexOf(e);
    i >= 0 && t.splice(i, 1)
}
;
Ot.batch = function(n, e) {
    var t = [], i = {}, r = e.interval || .016, s = e.batchMax || 1e9, o = function(u, h) {
        var m = []
          , d = []
          , f = it.delayedCall(r, function() {
            h(m, d),
            m = [],
            d = []
        }).pause();
        return function(_) {
            m.length || f.restart(!0),
            m.push(_.trigger),
            d.push(_),
            s <= m.length && f.progress(1)
        }
    }, a;
    for (a in e)
        i[a] = a.substr(0, 2) === "on" && fr(e[a]) && a !== "onRefreshInit" ? o(a, e[a]) : e[a];
    return fr(s) && (s = s(),
    yi(Ot, "refresh", function() {
        return s = e.batchMax()
    })),
    kf(n).forEach(function(c) {
        var u = {};
        for (a in i)
            u[a] = i[a];
        u.trigger = c,
        t.push(Ot.create(u))
    }),
    t
}
;
var bw = function(e, t, i, r) {
    return t > r ? e(r) : t < 0 && e(0),
    i > r ? (r - t) / (i - t) : i < 0 ? t / (t - i) : 1
}, Xg = function n(e, t) {
    t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (ii.isTouch ? " pinch-zoom" : "") : "none",
    e === Ds && n(Ln, t)
}, md = {
    auto: 1,
    scroll: 1
}, fk = function(e) {
    var t = e.event, i = e.target, r = e.axis, s = (t.changedTouches ? t.changedTouches[0] : t).target, o = s._gsap || it.core.getCache(s), a = rr(), c;
    if (!o._isScrollT || a - o._isScrollT > 2e3) {
        for (; s && s !== Ln && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !(md[(c = ds(s)).overflowY] || md[c.overflowX])); )
            s = s.parentNode;
        o._isScroll = s && s !== i && !Cl(s) && (md[(c = ds(s)).overflowY] || md[c.overflowX]),
        o._isScrollT = a
    }
    (o._isScroll || r === "x") && (t.stopPropagation(),
    t._gsapAllow = !0)
}, WC = function(e, t, i, r) {
    return ii.create({
        target: e,
        capture: !0,
        debounce: !1,
        lockAxis: !0,
        type: t,
        onWheel: r = r && fk,
        onPress: r,
        onDrag: r,
        onScroll: r,
        onEnable: function() {
            return i && yi(Un, ii.eventTypes[0], ww, !1, !0)
        },
        onDisable: function() {
            return vi(Un, ii.eventTypes[0], ww, !0)
        }
    })
}, hk = /(input|label|select|textarea)/i, Sw, ww = function(e) {
    var t = hk.test(e.target.tagName);
    (t || Sw) && (e._gsapAllow = !0,
    Sw = t)
}, dk = function(e) {
    el(e) || (e = {}),
    e.preventDefault = e.isNormalizer = e.allowClicks = !0,
    e.type || (e.type = "wheel,touch"),
    e.debounce = !!e.debounce,
    e.id = e.id || "normalizer";
    var t = e, i = t.normalizeScrollX, r = t.momentum, s = t.allowNestedScroll, o = t.onRelease, a, c, u = Sr(e.target) || Ds, h = it.core.globals().ScrollSmoother, m = h && h.get(), d = sa && (e.content && Sr(e.content) || m && e.content !== !1 && !m.smooth() && m.content()), f = Aa(u, ci), _ = Aa(u, ur), g = 1, v = (ii.isTouch && rn.visualViewport ? rn.visualViewport.scale * rn.visualViewport.width : rn.outerWidth) / rn.innerWidth, y = 0, w = fr(r) ? function() {
        return r(a)
    }
    : function() {
        return r || 2.8
    }
    , S, E, b = WC(u, e.type, !0, s), T = function() {
        return E = !1
    }, C = Xs, P = Xs, A = function() {
        c = Zs(u, ci),
        P = Cc(sa ? 1 : 0, c),
        i && (C = Cc(0, Zs(u, ur))),
        S = xl
    }, R = function() {
        d._gsap.y = ff(parseFloat(d._gsap.y) + f.offset) + "px",
        d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(d._gsap.y) + ", 0, 1)",
        f.offset = f.cacheID = 0
    }, I = function() {
        if (E) {
            requestAnimationFrame(T);
            var ee = ff(a.deltaY / 2)
              , re = P(f.v - ee);
            if (d && re !== f.v + f.offset) {
                f.offset = re - f.v;
                var k = ff((parseFloat(d && d._gsap.y) || 0) - f.offset);
                d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + k + ", 0, 1)",
                d._gsap.y = k + "px",
                f.cacheID = Zt.cache,
                Do()
            }
            return !0
        }
        f.offset && R(),
        E = !0
    }, D, H, B, G, X = function() {
        A(),
        D.isActive() && D.vars.scrollY > c && (f() > c ? D.progress(1) && f(c) : D.resetTo("scrollY", c))
    };
    return d && it.set(d, {
        y: "+=0"
    }),
    e.ignoreCheck = function(V) {
        return sa && V.type === "touchmove" && I() || g > 1.05 && V.type !== "touchstart" || a.isGesturing || V.touches && V.touches.length > 1
    }
    ,
    e.onPress = function() {
        E = !1;
        var V = g;
        g = ff((rn.visualViewport && rn.visualViewport.scale || 1) / v),
        D.pause(),
        V !== g && Xg(u, g > 1.01 ? !0 : i ? !1 : "x"),
        H = _(),
        B = f(),
        A(),
        S = xl
    }
    ,
    e.onRelease = e.onGestureStart = function(V, ee) {
        if (f.offset && R(),
        !ee)
            G.restart(!0);
        else {
            Zt.cache++;
            var re = w(), k, oe;
            i && (k = _(),
            oe = k + re * .05 * -V.velocityX / .227,
            re *= bw(_, k, oe, Zs(u, ur)),
            D.vars.scrollX = C(oe)),
            k = f(),
            oe = k + re * .05 * -V.velocityY / .227,
            re *= bw(f, k, oe, Zs(u, ci)),
            D.vars.scrollY = P(oe),
            D.invalidate().duration(re).play(.01),
            (sa && D.vars.scrollY >= c || k >= c - 1) && it.to({}, {
                onUpdate: X,
                duration: re
            })
        }
        o && o(V)
    }
    ,
    e.onWheel = function() {
        D._ts && D.pause(),
        rr() - y > 1e3 && (S = 0,
        y = rr())
    }
    ,
    e.onChange = function(V, ee, re, k, oe) {
        if (xl !== S && A(),
        ee && i && _(C(k[2] === ee ? H + (V.startX - V.x) : _() + ee - k[1])),
        re) {
            f.offset && R();
            var ae = oe[2] === re
              , ne = ae ? B + V.startY - V.y : f() + re - oe[1]
              , fe = P(ne);
            ae && ne !== fe && (B += fe - ne),
            f(fe)
        }
        (re || ee) && Do()
    }
    ,
    e.onEnable = function() {
        Xg(u, i ? !1 : "x"),
        Ot.addEventListener("refresh", X),
        yi(rn, "resize", X),
        f.smooth && (f.target.style.scrollBehavior = "auto",
        f.smooth = _.smooth = !1),
        b.enable()
    }
    ,
    e.onDisable = function() {
        Xg(u, !0),
        vi(rn, "resize", X),
        Ot.removeEventListener("refresh", X),
        b.kill()
    }
    ,
    e.lockAxis = e.lockAxis !== !1,
    a = new ii(e),
    a.iOS = sa,
    sa && !f() && f(1),
    sa && it.ticker.add(Xs),
    G = a._dc,
    D = it.to(a, {
        ease: "power4",
        paused: !0,
        scrollX: i ? "+=0.1" : "+=0",
        scrollY: "+=0.1",
        modifiers: {
            scrollY: VC(f, f(), function() {
                return D.pause()
            })
        },
        onUpdate: Do,
        onComplete: G.vars.onComplete
    }),
    a
};
Ot.sort = function(n) {
    return Xt.sort(n || function(e, t) {
        return (e.vars.refreshPriority || 0) * -1e6 + e.start - (t.start + (t.vars.refreshPriority || 0) * -1e6)
    }
    )
}
;
Ot.observe = function(n) {
    return new ii(n)
}
;
Ot.normalizeScroll = function(n) {
    if (typeof n > "u")
        return tr;
    if (n === !0 && tr)
        return tr.enable();
    if (n === !1) {
        tr && tr.kill(),
        tr = n;
        return
    }
    var e = n instanceof ii ? n : dk(n);
    return tr && tr.target === e.target && tr.kill(),
    Cl(e.target) && (tr = e),
    e
}
;
Ot.core = {
    _getVelocityProp: K_,
    _inputObserver: WC,
    _scrollers: Zt,
    _proxies: eo,
    bridge: {
        ss: function() {
            ys || Pl("scrollStart"),
            ys = rr()
        },
        ref: function() {
            return Hi
        }
    }
};
IC() && it.registerPlugin(Ot);
var wp = {
    exports: {}
};
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
wp.exports;
(function(n, e) {
    (function() {
        var t, i = "4.17.21", r = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", o = "Expected a function", a = "Invalid `variable` option passed into `_.template`", c = "__lodash_hash_undefined__", u = 500, h = "__lodash_placeholder__", m = 1, d = 2, f = 4, _ = 1, g = 2, v = 1, y = 2, w = 4, S = 8, E = 16, b = 32, T = 64, C = 128, P = 256, A = 512, R = 30, I = "...", D = 800, H = 16, B = 1, G = 2, X = 3, V = 1 / 0, ee = 9007199254740991, re = 17976931348623157e292, k = 0 / 0, oe = 4294967295, ae = oe - 1, ne = oe >>> 1, fe = [["ary", C], ["bind", v], ["bindKey", y], ["curry", S], ["curryRight", E], ["flip", A], ["partial", b], ["partialRight", T], ["rearg", P]], xe = "[object Arguments]", Re = "[object Array]", Ue = "[object AsyncFunction]", He = "[object Boolean]", qe = "[object Date]", Xe = "[object DOMException]", st = "[object Error]", ie = "[object Function]", dt = "[object GeneratorFunction]", Ne = "[object Map]", Ye = "[object Number]", Qe = "[object Null]", te = "[object Object]", ot = "[object Promise]", ft = "[object Proxy]", Tt = "[object RegExp]", pt = "[object Set]", Ct = "[object String]", z = "[object Symbol]", N = "[object Undefined]", j = "[object WeakMap]", he = "[object WeakSet]", le = "[object ArrayBuffer]", me = "[object DataView]", We = "[object Float32Array]", Te = "[object Float64Array]", Ee = "[object Int8Array]", Ae = "[object Int16Array]", _t = "[object Int32Array]", Pe = "[object Uint8Array]", Bt = "[object Uint8ClampedArray]", vt = "[object Uint16Array]", ht = "[object Uint32Array]", at = /\b__p \+= '';/g, Le = /\b(__p \+=) '' \+/g, Lt = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Y = /&(?:amp|lt|gt|quot|#39);/g, ze = /[&<>"']/g, De = RegExp(Y.source), ge = RegExp(ze.source), Fe = /<%-([\s\S]+?)%>/g, ut = /<%([\s\S]+?)%>/g, Ge = /<%=([\s\S]+?)%>/g, je = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Et = /^\w*$/, At = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Be = /[\\^$.*+?()[\]{}|]/g, bt = RegExp(Be.source), yt = /^\s+/, kt = /\s/, Mn = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, $t = /\{\n\/\* \[wrapped with (.+)\] \*/, dn = /,? & /, Kn = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, On = /[()=,{}\[\]\/\s]/, _n = /\\(\\)?/g, ln = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Di = /\w*$/, F = /^[-+]0x[0-9a-f]+$/i, J = /^0b[01]+$/i, ce = /^\[object .+?Constructor\]$/, ue = /^0o[0-7]+$/i, se = /^(?:0|[1-9]\d*)$/, ke = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, et = /($^)/, mt = /['\n\r\u2028\u2029\\]/g, tt = "\\ud800-\\udfff", lt = "\\u0300-\\u036f", gt = "\\ufe20-\\ufe2f", Pt = "\\u20d0-\\u20ff", vn = lt + gt + Pt, zn = "\\u2700-\\u27bf", an = "a-z\\xdf-\\xf6\\xf8-\\xff", Ei = "\\xac\\xb1\\xd7\\xf7", un = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Dt = "\\u2000-\\u206f", uu = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Tn = "A-Z\\xc0-\\xd6\\xd8-\\xde", Hs = "\\ufe0e\\ufe0f", fu = Ei + un + Dt + uu, ao = "[']", hu = "[" + tt + "]", si = "[" + fu + "]", es = "[" + vn + "]", Bl = "\\d+", pr = "[" + zn + "]", kl = "[" + an + "]", dh = "[^" + tt + fu + Bl + zn + an + Tn + "]", zl = "\\ud83c[\\udffb-\\udfff]", pL = "(?:" + es + "|" + zl + ")", Sx = "[^" + tt + "]", wm = "(?:\\ud83c[\\udde6-\\uddff]){2}", Em = "[\\ud800-\\udbff][\\udc00-\\udfff]", Hl = "[" + Tn + "]", wx = "\\u200d", Ex = "(?:" + kl + "|" + dh + ")", mL = "(?:" + Hl + "|" + dh + ")", Ax = "(?:" + ao + "(?:d|ll|m|re|s|t|ve))?", Mx = "(?:" + ao + "(?:D|LL|M|RE|S|T|VE))?", Tx = pL + "?", Cx = "[" + Hs + "]?", gL = "(?:" + wx + "(?:" + [Sx, wm, Em].join("|") + ")" + Cx + Tx + ")*", _L = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", vL = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Rx = Cx + Tx + gL, yL = "(?:" + [pr, wm, Em].join("|") + ")" + Rx, xL = "(?:" + [Sx + es + "?", es, wm, Em, hu].join("|") + ")", bL = RegExp(ao, "g"), SL = RegExp(es, "g"), Am = RegExp(zl + "(?=" + zl + ")|" + xL + Rx, "g"), wL = RegExp([Hl + "?" + kl + "+" + Ax + "(?=" + [si, Hl, "$"].join("|") + ")", mL + "+" + Mx + "(?=" + [si, Hl + Ex, "$"].join("|") + ")", Hl + "?" + Ex + "+" + Ax, Hl + "+" + Mx, vL, _L, Bl, yL].join("|"), "g"), EL = RegExp("[" + wx + tt + vn + Hs + "]"), AL = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, ML = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], TL = -1, Cn = {};
        Cn[We] = Cn[Te] = Cn[Ee] = Cn[Ae] = Cn[_t] = Cn[Pe] = Cn[Bt] = Cn[vt] = Cn[ht] = !0,
        Cn[xe] = Cn[Re] = Cn[le] = Cn[He] = Cn[me] = Cn[qe] = Cn[st] = Cn[ie] = Cn[Ne] = Cn[Ye] = Cn[te] = Cn[Tt] = Cn[pt] = Cn[Ct] = Cn[j] = !1;
        var wn = {};
        wn[xe] = wn[Re] = wn[le] = wn[me] = wn[He] = wn[qe] = wn[We] = wn[Te] = wn[Ee] = wn[Ae] = wn[_t] = wn[Ne] = wn[Ye] = wn[te] = wn[Tt] = wn[pt] = wn[Ct] = wn[z] = wn[Pe] = wn[Bt] = wn[vt] = wn[ht] = !0,
        wn[st] = wn[ie] = wn[j] = !1;
        var CL = {
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "C",
            : "c",
            : "D",
            : "d",
            : "E",
            : "E",
            : "E",
            : "E",
            : "e",
            : "e",
            : "e",
            : "e",
            : "I",
            : "I",
            : "I",
            : "I",
            : "i",
            : "i",
            : "i",
            : "i",
            : "N",
            : "n",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "U",
            : "U",
            : "U",
            : "U",
            : "u",
            : "u",
            : "u",
            : "u",
            : "Y",
            : "y",
            : "y",
            : "Ae",
            : "ae",
            : "Th",
            : "th",
            : "ss",
            : "A",
            : "A",
            : "A",
            : "a",
            : "a",
            : "a",
            : "C",
            : "C",
            : "C",
            : "C",
            : "c",
            : "c",
            : "c",
            : "c",
            : "D",
            : "D",
            : "d",
            : "d",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "G",
            : "G",
            : "G",
            : "G",
            : "g",
            : "g",
            : "g",
            : "g",
            : "H",
            : "H",
            : "h",
            : "h",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "J",
            : "j",
            : "K",
            : "k",
            : "k",
            : "L",
            : "L",
            : "L",
            : "L",
            : "L",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "N",
            : "N",
            : "N",
            : "N",
            : "n",
            : "n",
            : "n",
            : "n",
            : "O",
            : "O",
            : "O",
            : "o",
            : "o",
            : "o",
            : "R",
            : "R",
            : "R",
            : "r",
            : "r",
            : "r",
            : "S",
            : "S",
            : "S",
            : "S",
            : "s",
            : "s",
            : "s",
            : "s",
            : "T",
            : "T",
            : "T",
            : "t",
            : "t",
            : "t",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "W",
            : "w",
            : "Y",
            : "y",
            : "Y",
            : "Z",
            : "Z",
            : "Z",
            : "z",
            : "z",
            : "z",
            : "IJ",
            : "ij",
            : "Oe",
            : "oe",
            : "'n",
            : "s"
        }
          , RL = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        }
          , PL = {
            "&amp;": "&",
            "&lt;": "<",
            "&gt;": ">",
            "&quot;": '"',
            "&#39;": "'"
        }
          , LL = {
            "\\": "\\",
            "'": "'",
            "\n": "n",
            "\r": "r",
            "\u2028": "u2028",
            "\u2029": "u2029"
        }
          , DL = parseFloat
          , IL = parseInt
          , Px = typeof lr == "object" && lr && lr.Object === Object && lr
          , OL = typeof self == "object" && self && self.Object === Object && self
          , Ai = Px || OL || Function("return this")()
          , Mm = e && !e.nodeType && e
          , Na = Mm && !0 && n && !n.nodeType && n
          , Lx = Na && Na.exports === Mm
          , Tm = Lx && Px.process
          , ts = function() {
            try {
                var Z = Na && Na.require && Na.require("util").types;
                return Z || Tm && Tm.binding && Tm.binding("util")
            } catch {}
        }()
          , Dx = ts && ts.isArrayBuffer
          , Ix = ts && ts.isDate
          , Ox = ts && ts.isMap
          , Nx = ts && ts.isRegExp
          , Ux = ts && ts.isSet
          , Fx = ts && ts.isTypedArray;
        function Or(Z, _e, de) {
            switch (de.length) {
            case 0:
                return Z.call(_e);
            case 1:
                return Z.call(_e, de[0]);
            case 2:
                return Z.call(_e, de[0], de[1]);
            case 3:
                return Z.call(_e, de[0], de[1], de[2])
            }
            return Z.apply(_e, de)
        }
        function NL(Z, _e, de, nt) {
            for (var Nt = -1, cn = Z == null ? 0 : Z.length; ++Nt < cn; ) {
                var oi = Z[Nt];
                _e(nt, oi, de(oi), Z)
            }
            return nt
        }
        function ns(Z, _e) {
            for (var de = -1, nt = Z == null ? 0 : Z.length; ++de < nt && _e(Z[de], de, Z) !== !1; )
                ;
            return Z
        }
        function UL(Z, _e) {
            for (var de = Z == null ? 0 : Z.length; de-- && _e(Z[de], de, Z) !== !1; )
                ;
            return Z
        }
        function Bx(Z, _e) {
            for (var de = -1, nt = Z == null ? 0 : Z.length; ++de < nt; )
                if (!_e(Z[de], de, Z))
                    return !1;
            return !0
        }
        function zo(Z, _e) {
            for (var de = -1, nt = Z == null ? 0 : Z.length, Nt = 0, cn = []; ++de < nt; ) {
                var oi = Z[de];
                _e(oi, de, Z) && (cn[Nt++] = oi)
            }
            return cn
        }
        function ph(Z, _e) {
            var de = Z == null ? 0 : Z.length;
            return !!de && Gl(Z, _e, 0) > -1
        }
        function Cm(Z, _e, de) {
            for (var nt = -1, Nt = Z == null ? 0 : Z.length; ++nt < Nt; )
                if (de(_e, Z[nt]))
                    return !0;
            return !1
        }
        function In(Z, _e) {
            for (var de = -1, nt = Z == null ? 0 : Z.length, Nt = Array(nt); ++de < nt; )
                Nt[de] = _e(Z[de], de, Z);
            return Nt
        }
        function Ho(Z, _e) {
            for (var de = -1, nt = _e.length, Nt = Z.length; ++de < nt; )
                Z[Nt + de] = _e[de];
            return Z
        }
        function Rm(Z, _e, de, nt) {
            var Nt = -1
              , cn = Z == null ? 0 : Z.length;
            for (nt && cn && (de = Z[++Nt]); ++Nt < cn; )
                de = _e(de, Z[Nt], Nt, Z);
            return de
        }
        function FL(Z, _e, de, nt) {
            var Nt = Z == null ? 0 : Z.length;
            for (nt && Nt && (de = Z[--Nt]); Nt--; )
                de = _e(de, Z[Nt], Nt, Z);
            return de
        }
        function Pm(Z, _e) {
            for (var de = -1, nt = Z == null ? 0 : Z.length; ++de < nt; )
                if (_e(Z[de], de, Z))
                    return !0;
            return !1
        }
        var BL = Lm("length");
        function kL(Z) {
            return Z.split("")
        }
        function zL(Z) {
            return Z.match(Kn) || []
        }
        function kx(Z, _e, de) {
            var nt;
            return de(Z, function(Nt, cn, oi) {
                if (_e(Nt, cn, oi))
                    return nt = cn,
                    !1
            }),
            nt
        }
        function mh(Z, _e, de, nt) {
            for (var Nt = Z.length, cn = de + (nt ? 1 : -1); nt ? cn-- : ++cn < Nt; )
                if (_e(Z[cn], cn, Z))
                    return cn;
            return -1
        }
        function Gl(Z, _e, de) {
            return _e === _e ? JL(Z, _e, de) : mh(Z, zx, de)
        }
        function HL(Z, _e, de, nt) {
            for (var Nt = de - 1, cn = Z.length; ++Nt < cn; )
                if (nt(Z[Nt], _e))
                    return Nt;
            return -1
        }
        function zx(Z) {
            return Z !== Z
        }
        function Hx(Z, _e) {
            var de = Z == null ? 0 : Z.length;
            return de ? Im(Z, _e) / de : k
        }
        function Lm(Z) {
            return function(_e) {
                return _e == null ? t : _e[Z]
            }
        }
        function Dm(Z) {
            return function(_e) {
                return Z == null ? t : Z[_e]
            }
        }
        function Gx(Z, _e, de, nt, Nt) {
            return Nt(Z, function(cn, oi, yn) {
                de = nt ? (nt = !1,
                cn) : _e(de, cn, oi, yn)
            }),
            de
        }
        function GL(Z, _e) {
            var de = Z.length;
            for (Z.sort(_e); de--; )
                Z[de] = Z[de].value;
            return Z
        }
        function Im(Z, _e) {
            for (var de, nt = -1, Nt = Z.length; ++nt < Nt; ) {
                var cn = _e(Z[nt]);
                cn !== t && (de = de === t ? cn : de + cn)
            }
            return de
        }
        function Om(Z, _e) {
            for (var de = -1, nt = Array(Z); ++de < Z; )
                nt[de] = _e(de);
            return nt
        }
        function VL(Z, _e) {
            return In(_e, function(de) {
                return [de, Z[de]]
            })
        }
        function Vx(Z) {
            return Z && Z.slice(0, qx(Z) + 1).replace(yt, "")
        }
        function Nr(Z) {
            return function(_e) {
                return Z(_e)
            }
        }
        function Nm(Z, _e) {
            return In(_e, function(de) {
                return Z[de]
            })
        }
        function du(Z, _e) {
            return Z.has(_e)
        }
        function Wx(Z, _e) {
            for (var de = -1, nt = Z.length; ++de < nt && Gl(_e, Z[de], 0) > -1; )
                ;
            return de
        }
        function $x(Z, _e) {
            for (var de = Z.length; de-- && Gl(_e, Z[de], 0) > -1; )
                ;
            return de
        }
        function WL(Z, _e) {
            for (var de = Z.length, nt = 0; de--; )
                Z[de] === _e && ++nt;
            return nt
        }
        var $L = Dm(CL)
          , XL = Dm(RL);
        function qL(Z) {
            return "\\" + LL[Z]
        }
        function jL(Z, _e) {
            return Z == null ? t : Z[_e]
        }
        function Vl(Z) {
            return EL.test(Z)
        }
        function YL(Z) {
            return AL.test(Z)
        }
        function KL(Z) {
            for (var _e, de = []; !(_e = Z.next()).done; )
                de.push(_e.value);
            return de
        }
        function Um(Z) {
            var _e = -1
              , de = Array(Z.size);
            return Z.forEach(function(nt, Nt) {
                de[++_e] = [Nt, nt]
            }),
            de
        }
        function Xx(Z, _e) {
            return function(de) {
                return Z(_e(de))
            }
        }
        function Go(Z, _e) {
            for (var de = -1, nt = Z.length, Nt = 0, cn = []; ++de < nt; ) {
                var oi = Z[de];
                (oi === _e || oi === h) && (Z[de] = h,
                cn[Nt++] = de)
            }
            return cn
        }
        function gh(Z) {
            var _e = -1
              , de = Array(Z.size);
            return Z.forEach(function(nt) {
                de[++_e] = nt
            }),
            de
        }
        function ZL(Z) {
            var _e = -1
              , de = Array(Z.size);
            return Z.forEach(function(nt) {
                de[++_e] = [nt, nt]
            }),
            de
        }
        function JL(Z, _e, de) {
            for (var nt = de - 1, Nt = Z.length; ++nt < Nt; )
                if (Z[nt] === _e)
                    return nt;
            return -1
        }
        function QL(Z, _e, de) {
            for (var nt = de + 1; nt--; )
                if (Z[nt] === _e)
                    return nt;
            return nt
        }
        function Wl(Z) {
            return Vl(Z) ? t3(Z) : BL(Z)
        }
        function bs(Z) {
            return Vl(Z) ? n3(Z) : kL(Z)
        }
        function qx(Z) {
            for (var _e = Z.length; _e-- && kt.test(Z.charAt(_e)); )
                ;
            return _e
        }
        var e3 = Dm(PL);
        function t3(Z) {
            for (var _e = Am.lastIndex = 0; Am.test(Z); )
                ++_e;
            return _e
        }
        function n3(Z) {
            return Z.match(Am) || []
        }
        function i3(Z) {
            return Z.match(wL) || []
        }
        var r3 = function Z(_e) {
            _e = _e == null ? Ai : $l.defaults(Ai.Object(), _e, $l.pick(Ai, ML));
            var de = _e.Array
              , nt = _e.Date
              , Nt = _e.Error
              , cn = _e.Function
              , oi = _e.Math
              , yn = _e.Object
              , Fm = _e.RegExp
              , s3 = _e.String
              , is = _e.TypeError
              , _h = de.prototype
              , o3 = cn.prototype
              , Xl = yn.prototype
              , vh = _e["__core-js_shared__"]
              , yh = o3.toString
              , hn = Xl.hasOwnProperty
              , a3 = 0
              , jx = function() {
                var l = /[^.]+$/.exec(vh && vh.keys && vh.keys.IE_PROTO || "");
                return l ? "Symbol(src)_1." + l : ""
            }()
              , xh = Xl.toString
              , l3 = yh.call(yn)
              , c3 = Ai._
              , u3 = Fm("^" + yh.call(hn).replace(Be, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$")
              , bh = Lx ? _e.Buffer : t
              , Vo = _e.Symbol
              , Sh = _e.Uint8Array
              , Yx = bh ? bh.allocUnsafe : t
              , wh = Xx(yn.getPrototypeOf, yn)
              , Kx = yn.create
              , Zx = Xl.propertyIsEnumerable
              , Eh = _h.splice
              , Jx = Vo ? Vo.isConcatSpreadable : t
              , pu = Vo ? Vo.iterator : t
              , Ua = Vo ? Vo.toStringTag : t
              , Ah = function() {
                try {
                    var l = Ha(yn, "defineProperty");
                    return l({}, "", {}),
                    l
                } catch {}
            }()
              , f3 = _e.clearTimeout !== Ai.clearTimeout && _e.clearTimeout
              , h3 = nt && nt.now !== Ai.Date.now && nt.now
              , d3 = _e.setTimeout !== Ai.setTimeout && _e.setTimeout
              , Mh = oi.ceil
              , Th = oi.floor
              , Bm = yn.getOwnPropertySymbols
              , p3 = bh ? bh.isBuffer : t
              , Qx = _e.isFinite
              , m3 = _h.join
              , g3 = Xx(yn.keys, yn)
              , ai = oi.max
              , Ii = oi.min
              , _3 = nt.now
              , v3 = _e.parseInt
              , eb = oi.random
              , y3 = _h.reverse
              , km = Ha(_e, "DataView")
              , mu = Ha(_e, "Map")
              , zm = Ha(_e, "Promise")
              , ql = Ha(_e, "Set")
              , gu = Ha(_e, "WeakMap")
              , _u = Ha(yn, "create")
              , Ch = gu && new gu
              , jl = {}
              , x3 = Ga(km)
              , b3 = Ga(mu)
              , S3 = Ga(zm)
              , w3 = Ga(ql)
              , E3 = Ga(gu)
              , Rh = Vo ? Vo.prototype : t
              , vu = Rh ? Rh.valueOf : t
              , tb = Rh ? Rh.toString : t;
            function O(l) {
                if (Hn(l) && !Ft(l) && !(l instanceof Qt)) {
                    if (l instanceof rs)
                        return l;
                    if (hn.call(l, "__wrapped__"))
                        return nS(l)
                }
                return new rs(l)
            }
            var Yl = function() {
                function l() {}
                return function(p) {
                    if (!Nn(p))
                        return {};
                    if (Kx)
                        return Kx(p);
                    l.prototype = p;
                    var x = new l;
                    return l.prototype = t,
                    x
                }
            }();
            function Ph() {}
            function rs(l, p) {
                this.__wrapped__ = l,
                this.__actions__ = [],
                this.__chain__ = !!p,
                this.__index__ = 0,
                this.__values__ = t
            }
            O.templateSettings = {
                escape: Fe,
                evaluate: ut,
                interpolate: Ge,
                variable: "",
                imports: {
                    _: O
                }
            },
            O.prototype = Ph.prototype,
            O.prototype.constructor = O,
            rs.prototype = Yl(Ph.prototype),
            rs.prototype.constructor = rs;
            function Qt(l) {
                this.__wrapped__ = l,
                this.__actions__ = [],
                this.__dir__ = 1,
                this.__filtered__ = !1,
                this.__iteratees__ = [],
                this.__takeCount__ = oe,
                this.__views__ = []
            }
            function A3() {
                var l = new Qt(this.__wrapped__);
                return l.__actions__ = mr(this.__actions__),
                l.__dir__ = this.__dir__,
                l.__filtered__ = this.__filtered__,
                l.__iteratees__ = mr(this.__iteratees__),
                l.__takeCount__ = this.__takeCount__,
                l.__views__ = mr(this.__views__),
                l
            }
            function M3() {
                if (this.__filtered__) {
                    var l = new Qt(this);
                    l.__dir__ = -1,
                    l.__filtered__ = !0
                } else
                    l = this.clone(),
                    l.__dir__ *= -1;
                return l
            }
            function T3() {
                var l = this.__wrapped__.value()
                  , p = this.__dir__
                  , x = Ft(l)
                  , M = p < 0
                  , L = x ? l.length : 0
                  , U = kD(0, L, this.__views__)
                  , $ = U.start
                  , q = U.end
                  , Q = q - $
                  , ye = M ? q : $ - 1
                  , be = this.__iteratees__
                  , Ce = be.length
                  , $e = 0
                  , ct = Ii(Q, this.__takeCount__);
                if (!x || !M && L == Q && ct == Q)
                    return Ab(l, this.__actions__);
                var St = [];
                e: for (; Q-- && $e < ct; ) {
                    ye += p;
                    for (var Ht = -1, wt = l[ye]; ++Ht < Ce; ) {
                        var Yt = be[Ht]
                          , nn = Yt.iteratee
                          , Br = Yt.type
                          , Yi = nn(wt);
                        if (Br == G)
                            wt = Yi;
                        else if (!Yi) {
                            if (Br == B)
                                continue e;
                            break e
                        }
                    }
                    St[$e++] = wt
                }
                return St
            }
            Qt.prototype = Yl(Ph.prototype),
            Qt.prototype.constructor = Qt;
            function Fa(l) {
                var p = -1
                  , x = l == null ? 0 : l.length;
                for (this.clear(); ++p < x; ) {
                    var M = l[p];
                    this.set(M[0], M[1])
                }
            }
            function C3() {
                this.__data__ = _u ? _u(null) : {},
                this.size = 0
            }
            function R3(l) {
                var p = this.has(l) && delete this.__data__[l];
                return this.size -= p ? 1 : 0,
                p
            }
            function P3(l) {
                var p = this.__data__;
                if (_u) {
                    var x = p[l];
                    return x === c ? t : x
                }
                return hn.call(p, l) ? p[l] : t
            }
            function L3(l) {
                var p = this.__data__;
                return _u ? p[l] !== t : hn.call(p, l)
            }
            function D3(l, p) {
                var x = this.__data__;
                return this.size += this.has(l) ? 0 : 1,
                x[l] = _u && p === t ? c : p,
                this
            }
            Fa.prototype.clear = C3,
            Fa.prototype.delete = R3,
            Fa.prototype.get = P3,
            Fa.prototype.has = L3,
            Fa.prototype.set = D3;
            function lo(l) {
                var p = -1
                  , x = l == null ? 0 : l.length;
                for (this.clear(); ++p < x; ) {
                    var M = l[p];
                    this.set(M[0], M[1])
                }
            }
            function I3() {
                this.__data__ = [],
                this.size = 0
            }
            function O3(l) {
                var p = this.__data__
                  , x = Lh(p, l);
                if (x < 0)
                    return !1;
                var M = p.length - 1;
                return x == M ? p.pop() : Eh.call(p, x, 1),
                --this.size,
                !0
            }
            function N3(l) {
                var p = this.__data__
                  , x = Lh(p, l);
                return x < 0 ? t : p[x][1]
            }
            function U3(l) {
                return Lh(this.__data__, l) > -1
            }
            function F3(l, p) {
                var x = this.__data__
                  , M = Lh(x, l);
                return M < 0 ? (++this.size,
                x.push([l, p])) : x[M][1] = p,
                this
            }
            lo.prototype.clear = I3,
            lo.prototype.delete = O3,
            lo.prototype.get = N3,
            lo.prototype.has = U3,
            lo.prototype.set = F3;
            function co(l) {
                var p = -1
                  , x = l == null ? 0 : l.length;
                for (this.clear(); ++p < x; ) {
                    var M = l[p];
                    this.set(M[0], M[1])
                }
            }
            function B3() {
                this.size = 0,
                this.__data__ = {
                    hash: new Fa,
                    map: new (mu || lo),
                    string: new Fa
                }
            }
            function k3(l) {
                var p = Vh(this, l).delete(l);
                return this.size -= p ? 1 : 0,
                p
            }
            function z3(l) {
                return Vh(this, l).get(l)
            }
            function H3(l) {
                return Vh(this, l).has(l)
            }
            function G3(l, p) {
                var x = Vh(this, l)
                  , M = x.size;
                return x.set(l, p),
                this.size += x.size == M ? 0 : 1,
                this
            }
            co.prototype.clear = B3,
            co.prototype.delete = k3,
            co.prototype.get = z3,
            co.prototype.has = H3,
            co.prototype.set = G3;
            function Ba(l) {
                var p = -1
                  , x = l == null ? 0 : l.length;
                for (this.__data__ = new co; ++p < x; )
                    this.add(l[p])
            }
            function V3(l) {
                return this.__data__.set(l, c),
                this
            }
            function W3(l) {
                return this.__data__.has(l)
            }
            Ba.prototype.add = Ba.prototype.push = V3,
            Ba.prototype.has = W3;
            function Ss(l) {
                var p = this.__data__ = new lo(l);
                this.size = p.size
            }
            function $3() {
                this.__data__ = new lo,
                this.size = 0
            }
            function X3(l) {
                var p = this.__data__
                  , x = p.delete(l);
                return this.size = p.size,
                x
            }
            function q3(l) {
                return this.__data__.get(l)
            }
            function j3(l) {
                return this.__data__.has(l)
            }
            function Y3(l, p) {
                var x = this.__data__;
                if (x instanceof lo) {
                    var M = x.__data__;
                    if (!mu || M.length < r - 1)
                        return M.push([l, p]),
                        this.size = ++x.size,
                        this;
                    x = this.__data__ = new co(M)
                }
                return x.set(l, p),
                this.size = x.size,
                this
            }
            Ss.prototype.clear = $3,
            Ss.prototype.delete = X3,
            Ss.prototype.get = q3,
            Ss.prototype.has = j3,
            Ss.prototype.set = Y3;
            function nb(l, p) {
                var x = Ft(l)
                  , M = !x && Va(l)
                  , L = !x && !M && jo(l)
                  , U = !x && !M && !L && Ql(l)
                  , $ = x || M || L || U
                  , q = $ ? Om(l.length, s3) : []
                  , Q = q.length;
                for (var ye in l)
                    (p || hn.call(l, ye)) && !($ && (ye == "length" || L && (ye == "offset" || ye == "parent") || U && (ye == "buffer" || ye == "byteLength" || ye == "byteOffset") || po(ye, Q))) && q.push(ye);
                return q
            }
            function ib(l) {
                var p = l.length;
                return p ? l[Zm(0, p - 1)] : t
            }
            function K3(l, p) {
                return Wh(mr(l), ka(p, 0, l.length))
            }
            function Z3(l) {
                return Wh(mr(l))
            }
            function Hm(l, p, x) {
                (x !== t && !ws(l[p], x) || x === t && !(p in l)) && uo(l, p, x)
            }
            function yu(l, p, x) {
                var M = l[p];
                (!(hn.call(l, p) && ws(M, x)) || x === t && !(p in l)) && uo(l, p, x)
            }
            function Lh(l, p) {
                for (var x = l.length; x--; )
                    if (ws(l[x][0], p))
                        return x;
                return -1
            }
            function J3(l, p, x, M) {
                return Wo(l, function(L, U, $) {
                    p(M, L, x(L), $)
                }),
                M
            }
            function rb(l, p) {
                return l && Vs(p, hi(p), l)
            }
            function Q3(l, p) {
                return l && Vs(p, _r(p), l)
            }
            function uo(l, p, x) {
                p == "__proto__" && Ah ? Ah(l, p, {
                    configurable: !0,
                    enumerable: !0,
                    value: x,
                    writable: !0
                }) : l[p] = x
            }
            function Gm(l, p) {
                for (var x = -1, M = p.length, L = de(M), U = l == null; ++x < M; )
                    L[x] = U ? t : Sg(l, p[x]);
                return L
            }
            function ka(l, p, x) {
                return l === l && (x !== t && (l = l <= x ? l : x),
                p !== t && (l = l >= p ? l : p)),
                l
            }
            function ss(l, p, x, M, L, U) {
                var $, q = p & m, Q = p & d, ye = p & f;
                if (x && ($ = L ? x(l, M, L, U) : x(l)),
                $ !== t)
                    return $;
                if (!Nn(l))
                    return l;
                var be = Ft(l);
                if (be) {
                    if ($ = HD(l),
                    !q)
                        return mr(l, $)
                } else {
                    var Ce = Oi(l)
                      , $e = Ce == ie || Ce == dt;
                    if (jo(l))
                        return Cb(l, q);
                    if (Ce == te || Ce == xe || $e && !L) {
                        if ($ = Q || $e ? {} : qb(l),
                        !q)
                            return Q ? PD(l, Q3($, l)) : RD(l, rb($, l))
                    } else {
                        if (!wn[Ce])
                            return L ? l : {};
                        $ = GD(l, Ce, q)
                    }
                }
                U || (U = new Ss);
                var ct = U.get(l);
                if (ct)
                    return ct;
                U.set(l, $),
                SS(l) ? l.forEach(function(wt) {
                    $.add(ss(wt, p, x, wt, l, U))
                }) : xS(l) && l.forEach(function(wt, Yt) {
                    $.set(Yt, ss(wt, p, x, Yt, l, U))
                });
                var St = ye ? Q ? lg : ag : Q ? _r : hi
                  , Ht = be ? t : St(l);
                return ns(Ht || l, function(wt, Yt) {
                    Ht && (Yt = wt,
                    wt = l[Yt]),
                    yu($, Yt, ss(wt, p, x, Yt, l, U))
                }),
                $
            }
            function eD(l) {
                var p = hi(l);
                return function(x) {
                    return sb(x, l, p)
                }
            }
            function sb(l, p, x) {
                var M = x.length;
                if (l == null)
                    return !M;
                for (l = yn(l); M--; ) {
                    var L = x[M]
                      , U = p[L]
                      , $ = l[L];
                    if ($ === t && !(L in l) || !U($))
                        return !1
                }
                return !0
            }
            function ob(l, p, x) {
                if (typeof l != "function")
                    throw new is(o);
                return Mu(function() {
                    l.apply(t, x)
                }, p)
            }
            function xu(l, p, x, M) {
                var L = -1
                  , U = ph
                  , $ = !0
                  , q = l.length
                  , Q = []
                  , ye = p.length;
                if (!q)
                    return Q;
                x && (p = In(p, Nr(x))),
                M ? (U = Cm,
                $ = !1) : p.length >= r && (U = du,
                $ = !1,
                p = new Ba(p));
                e: for (; ++L < q; ) {
                    var be = l[L]
                      , Ce = x == null ? be : x(be);
                    if (be = M || be !== 0 ? be : 0,
                    $ && Ce === Ce) {
                        for (var $e = ye; $e--; )
                            if (p[$e] === Ce)
                                continue e;
                        Q.push(be)
                    } else
                        U(p, Ce, M) || Q.push(be)
                }
                return Q
            }
            var Wo = Ib(Gs)
              , ab = Ib(Wm, !0);
            function tD(l, p) {
                var x = !0;
                return Wo(l, function(M, L, U) {
                    return x = !!p(M, L, U),
                    x
                }),
                x
            }
            function Dh(l, p, x) {
                for (var M = -1, L = l.length; ++M < L; ) {
                    var U = l[M]
                      , $ = p(U);
                    if ($ != null && (q === t ? $ === $ && !Fr($) : x($, q)))
                        var q = $
                          , Q = U
                }
                return Q
            }
            function nD(l, p, x, M) {
                var L = l.length;
                for (x = zt(x),
                x < 0 && (x = -x > L ? 0 : L + x),
                M = M === t || M > L ? L : zt(M),
                M < 0 && (M += L),
                M = x > M ? 0 : ES(M); x < M; )
                    l[x++] = p;
                return l
            }
            function lb(l, p) {
                var x = [];
                return Wo(l, function(M, L, U) {
                    p(M, L, U) && x.push(M)
                }),
                x
            }
            function Mi(l, p, x, M, L) {
                var U = -1
                  , $ = l.length;
                for (x || (x = WD),
                L || (L = []); ++U < $; ) {
                    var q = l[U];
                    p > 0 && x(q) ? p > 1 ? Mi(q, p - 1, x, M, L) : Ho(L, q) : M || (L[L.length] = q)
                }
                return L
            }
            var Vm = Ob()
              , cb = Ob(!0);
            function Gs(l, p) {
                return l && Vm(l, p, hi)
            }
            function Wm(l, p) {
                return l && cb(l, p, hi)
            }
            function Ih(l, p) {
                return zo(p, function(x) {
                    return mo(l[x])
                })
            }
            function za(l, p) {
                p = Xo(p, l);
                for (var x = 0, M = p.length; l != null && x < M; )
                    l = l[Ws(p[x++])];
                return x && x == M ? l : t
            }
            function ub(l, p, x) {
                var M = p(l);
                return Ft(l) ? M : Ho(M, x(l))
            }
            function qi(l) {
                return l == null ? l === t ? N : Qe : Ua && Ua in yn(l) ? BD(l) : ZD(l)
            }
            function $m(l, p) {
                return l > p
            }
            function iD(l, p) {
                return l != null && hn.call(l, p)
            }
            function rD(l, p) {
                return l != null && p in yn(l)
            }
            function sD(l, p, x) {
                return l >= Ii(p, x) && l < ai(p, x)
            }
            function Xm(l, p, x) {
                for (var M = x ? Cm : ph, L = l[0].length, U = l.length, $ = U, q = de(U), Q = 1 / 0, ye = []; $--; ) {
                    var be = l[$];
                    $ && p && (be = In(be, Nr(p))),
                    Q = Ii(be.length, Q),
                    q[$] = !x && (p || L >= 120 && be.length >= 120) ? new Ba($ && be) : t
                }
                be = l[0];
                var Ce = -1
                  , $e = q[0];
                e: for (; ++Ce < L && ye.length < Q; ) {
                    var ct = be[Ce]
                      , St = p ? p(ct) : ct;
                    if (ct = x || ct !== 0 ? ct : 0,
                    !($e ? du($e, St) : M(ye, St, x))) {
                        for ($ = U; --$; ) {
                            var Ht = q[$];
                            if (!(Ht ? du(Ht, St) : M(l[$], St, x)))
                                continue e
                        }
                        $e && $e.push(St),
                        ye.push(ct)
                    }
                }
                return ye
            }
            function oD(l, p, x, M) {
                return Gs(l, function(L, U, $) {
                    p(M, x(L), U, $)
                }),
                M
            }
            function bu(l, p, x) {
                p = Xo(p, l),
                l = Zb(l, p);
                var M = l == null ? l : l[Ws(as(p))];
                return M == null ? t : Or(M, l, x)
            }
            function fb(l) {
                return Hn(l) && qi(l) == xe
            }
            function aD(l) {
                return Hn(l) && qi(l) == le
            }
            function lD(l) {
                return Hn(l) && qi(l) == qe
            }
            function Su(l, p, x, M, L) {
                return l === p ? !0 : l == null || p == null || !Hn(l) && !Hn(p) ? l !== l && p !== p : cD(l, p, x, M, Su, L)
            }
            function cD(l, p, x, M, L, U) {
                var $ = Ft(l)
                  , q = Ft(p)
                  , Q = $ ? Re : Oi(l)
                  , ye = q ? Re : Oi(p);
                Q = Q == xe ? te : Q,
                ye = ye == xe ? te : ye;
                var be = Q == te
                  , Ce = ye == te
                  , $e = Q == ye;
                if ($e && jo(l)) {
                    if (!jo(p))
                        return !1;
                    $ = !0,
                    be = !1
                }
                if ($e && !be)
                    return U || (U = new Ss),
                    $ || Ql(l) ? Wb(l, p, x, M, L, U) : UD(l, p, Q, x, M, L, U);
                if (!(x & _)) {
                    var ct = be && hn.call(l, "__wrapped__")
                      , St = Ce && hn.call(p, "__wrapped__");
                    if (ct || St) {
                        var Ht = ct ? l.value() : l
                          , wt = St ? p.value() : p;
                        return U || (U = new Ss),
                        L(Ht, wt, x, M, U)
                    }
                }
                return $e ? (U || (U = new Ss),
                FD(l, p, x, M, L, U)) : !1
            }
            function uD(l) {
                return Hn(l) && Oi(l) == Ne
            }
            function qm(l, p, x, M) {
                var L = x.length
                  , U = L
                  , $ = !M;
                if (l == null)
                    return !U;
                for (l = yn(l); L--; ) {
                    var q = x[L];
                    if ($ && q[2] ? q[1] !== l[q[0]] : !(q[0]in l))
                        return !1
                }
                for (; ++L < U; ) {
                    q = x[L];
                    var Q = q[0]
                      , ye = l[Q]
                      , be = q[1];
                    if ($ && q[2]) {
                        if (ye === t && !(Q in l))
                            return !1
                    } else {
                        var Ce = new Ss;
                        if (M)
                            var $e = M(ye, be, Q, l, p, Ce);
                        if (!($e === t ? Su(be, ye, _ | g, M, Ce) : $e))
                            return !1
                    }
                }
                return !0
            }
            function hb(l) {
                if (!Nn(l) || XD(l))
                    return !1;
                var p = mo(l) ? u3 : ce;
                return p.test(Ga(l))
            }
            function fD(l) {
                return Hn(l) && qi(l) == Tt
            }
            function hD(l) {
                return Hn(l) && Oi(l) == pt
            }
            function dD(l) {
                return Hn(l) && Kh(l.length) && !!Cn[qi(l)]
            }
            function db(l) {
                return typeof l == "function" ? l : l == null ? vr : typeof l == "object" ? Ft(l) ? gb(l[0], l[1]) : mb(l) : NS(l)
            }
            function jm(l) {
                if (!Au(l))
                    return g3(l);
                var p = [];
                for (var x in yn(l))
                    hn.call(l, x) && x != "constructor" && p.push(x);
                return p
            }
            function pD(l) {
                if (!Nn(l))
                    return KD(l);
                var p = Au(l)
                  , x = [];
                for (var M in l)
                    M == "constructor" && (p || !hn.call(l, M)) || x.push(M);
                return x
            }
            function Ym(l, p) {
                return l < p
            }
            function pb(l, p) {
                var x = -1
                  , M = gr(l) ? de(l.length) : [];
                return Wo(l, function(L, U, $) {
                    M[++x] = p(L, U, $)
                }),
                M
            }
            function mb(l) {
                var p = ug(l);
                return p.length == 1 && p[0][2] ? Yb(p[0][0], p[0][1]) : function(x) {
                    return x === l || qm(x, l, p)
                }
            }
            function gb(l, p) {
                return hg(l) && jb(p) ? Yb(Ws(l), p) : function(x) {
                    var M = Sg(x, l);
                    return M === t && M === p ? wg(x, l) : Su(p, M, _ | g)
                }
            }
            function Oh(l, p, x, M, L) {
                l !== p && Vm(p, function(U, $) {
                    if (L || (L = new Ss),
                    Nn(U))
                        mD(l, p, $, x, Oh, M, L);
                    else {
                        var q = M ? M(pg(l, $), U, $ + "", l, p, L) : t;
                        q === t && (q = U),
                        Hm(l, $, q)
                    }
                }, _r)
            }
            function mD(l, p, x, M, L, U, $) {
                var q = pg(l, x)
                  , Q = pg(p, x)
                  , ye = $.get(Q);
                if (ye) {
                    Hm(l, x, ye);
                    return
                }
                var be = U ? U(q, Q, x + "", l, p, $) : t
                  , Ce = be === t;
                if (Ce) {
                    var $e = Ft(Q)
                      , ct = !$e && jo(Q)
                      , St = !$e && !ct && Ql(Q);
                    be = Q,
                    $e || ct || St ? Ft(q) ? be = q : $n(q) ? be = mr(q) : ct ? (Ce = !1,
                    be = Cb(Q, !0)) : St ? (Ce = !1,
                    be = Rb(Q, !0)) : be = [] : Tu(Q) || Va(Q) ? (be = q,
                    Va(q) ? be = AS(q) : (!Nn(q) || mo(q)) && (be = qb(Q))) : Ce = !1
                }
                Ce && ($.set(Q, be),
                L(be, Q, M, U, $),
                $.delete(Q)),
                Hm(l, x, be)
            }
            function _b(l, p) {
                var x = l.length;
                if (x)
                    return p += p < 0 ? x : 0,
                    po(p, x) ? l[p] : t
            }
            function vb(l, p, x) {
                p.length ? p = In(p, function(U) {
                    return Ft(U) ? function($) {
                        return za($, U.length === 1 ? U[0] : U)
                    }
                    : U
                }) : p = [vr];
                var M = -1;
                p = In(p, Nr(xt()));
                var L = pb(l, function(U, $, q) {
                    var Q = In(p, function(ye) {
                        return ye(U)
                    });
                    return {
                        criteria: Q,
                        index: ++M,
                        value: U
                    }
                });
                return GL(L, function(U, $) {
                    return CD(U, $, x)
                })
            }
            function gD(l, p) {
                return yb(l, p, function(x, M) {
                    return wg(l, M)
                })
            }
            function yb(l, p, x) {
                for (var M = -1, L = p.length, U = {}; ++M < L; ) {
                    var $ = p[M]
                      , q = za(l, $);
                    x(q, $) && wu(U, Xo($, l), q)
                }
                return U
            }
            function _D(l) {
                return function(p) {
                    return za(p, l)
                }
            }
            function Km(l, p, x, M) {
                var L = M ? HL : Gl
                  , U = -1
                  , $ = p.length
                  , q = l;
                for (l === p && (p = mr(p)),
                x && (q = In(l, Nr(x))); ++U < $; )
                    for (var Q = 0, ye = p[U], be = x ? x(ye) : ye; (Q = L(q, be, Q, M)) > -1; )
                        q !== l && Eh.call(q, Q, 1),
                        Eh.call(l, Q, 1);
                return l
            }
            function xb(l, p) {
                for (var x = l ? p.length : 0, M = x - 1; x--; ) {
                    var L = p[x];
                    if (x == M || L !== U) {
                        var U = L;
                        po(L) ? Eh.call(l, L, 1) : eg(l, L)
                    }
                }
                return l
            }
            function Zm(l, p) {
                return l + Th(eb() * (p - l + 1))
            }
            function vD(l, p, x, M) {
                for (var L = -1, U = ai(Mh((p - l) / (x || 1)), 0), $ = de(U); U--; )
                    $[M ? U : ++L] = l,
                    l += x;
                return $
            }
            function Jm(l, p) {
                var x = "";
                if (!l || p < 1 || p > ee)
                    return x;
                do
                    p % 2 && (x += l),
                    p = Th(p / 2),
                    p && (l += l);
                while (p);
                return x
            }
            function Wt(l, p) {
                return mg(Kb(l, p, vr), l + "")
            }
            function yD(l) {
                return ib(ec(l))
            }
            function xD(l, p) {
                var x = ec(l);
                return Wh(x, ka(p, 0, x.length))
            }
            function wu(l, p, x, M) {
                if (!Nn(l))
                    return l;
                p = Xo(p, l);
                for (var L = -1, U = p.length, $ = U - 1, q = l; q != null && ++L < U; ) {
                    var Q = Ws(p[L])
                      , ye = x;
                    if (Q === "__proto__" || Q === "constructor" || Q === "prototype")
                        return l;
                    if (L != $) {
                        var be = q[Q];
                        ye = M ? M(be, Q, q) : t,
                        ye === t && (ye = Nn(be) ? be : po(p[L + 1]) ? [] : {})
                    }
                    yu(q, Q, ye),
                    q = q[Q]
                }
                return l
            }
            var bb = Ch ? function(l, p) {
                return Ch.set(l, p),
                l
            }
            : vr
              , bD = Ah ? function(l, p) {
                return Ah(l, "toString", {
                    configurable: !0,
                    enumerable: !1,
                    value: Ag(p),
                    writable: !0
                })
            }
            : vr;
            function SD(l) {
                return Wh(ec(l))
            }
            function os(l, p, x) {
                var M = -1
                  , L = l.length;
                p < 0 && (p = -p > L ? 0 : L + p),
                x = x > L ? L : x,
                x < 0 && (x += L),
                L = p > x ? 0 : x - p >>> 0,
                p >>>= 0;
                for (var U = de(L); ++M < L; )
                    U[M] = l[M + p];
                return U
            }
            function wD(l, p) {
                var x;
                return Wo(l, function(M, L, U) {
                    return x = p(M, L, U),
                    !x
                }),
                !!x
            }
            function Nh(l, p, x) {
                var M = 0
                  , L = l == null ? M : l.length;
                if (typeof p == "number" && p === p && L <= ne) {
                    for (; M < L; ) {
                        var U = M + L >>> 1
                          , $ = l[U];
                        $ !== null && !Fr($) && (x ? $ <= p : $ < p) ? M = U + 1 : L = U
                    }
                    return L
                }
                return Qm(l, p, vr, x)
            }
            function Qm(l, p, x, M) {
                var L = 0
                  , U = l == null ? 0 : l.length;
                if (U === 0)
                    return 0;
                p = x(p);
                for (var $ = p !== p, q = p === null, Q = Fr(p), ye = p === t; L < U; ) {
                    var be = Th((L + U) / 2)
                      , Ce = x(l[be])
                      , $e = Ce !== t
                      , ct = Ce === null
                      , St = Ce === Ce
                      , Ht = Fr(Ce);
                    if ($)
                        var wt = M || St;
                    else
                        ye ? wt = St && (M || $e) : q ? wt = St && $e && (M || !ct) : Q ? wt = St && $e && !ct && (M || !Ht) : ct || Ht ? wt = !1 : wt = M ? Ce <= p : Ce < p;
                    wt ? L = be + 1 : U = be
                }
                return Ii(U, ae)
            }
            function Sb(l, p) {
                for (var x = -1, M = l.length, L = 0, U = []; ++x < M; ) {
                    var $ = l[x]
                      , q = p ? p($) : $;
                    if (!x || !ws(q, Q)) {
                        var Q = q;
                        U[L++] = $ === 0 ? 0 : $
                    }
                }
                return U
            }
            function wb(l) {
                return typeof l == "number" ? l : Fr(l) ? k : +l
            }
            function Ur(l) {
                if (typeof l == "string")
                    return l;
                if (Ft(l))
                    return In(l, Ur) + "";
                if (Fr(l))
                    return tb ? tb.call(l) : "";
                var p = l + "";
                return p == "0" && 1 / l == -V ? "-0" : p
            }
            function $o(l, p, x) {
                var M = -1
                  , L = ph
                  , U = l.length
                  , $ = !0
                  , q = []
                  , Q = q;
                if (x)
                    $ = !1,
                    L = Cm;
                else if (U >= r) {
                    var ye = p ? null : OD(l);
                    if (ye)
                        return gh(ye);
                    $ = !1,
                    L = du,
                    Q = new Ba
                } else
                    Q = p ? [] : q;
                e: for (; ++M < U; ) {
                    var be = l[M]
                      , Ce = p ? p(be) : be;
                    if (be = x || be !== 0 ? be : 0,
                    $ && Ce === Ce) {
                        for (var $e = Q.length; $e--; )
                            if (Q[$e] === Ce)
                                continue e;
                        p && Q.push(Ce),
                        q.push(be)
                    } else
                        L(Q, Ce, x) || (Q !== q && Q.push(Ce),
                        q.push(be))
                }
                return q
            }
            function eg(l, p) {
                return p = Xo(p, l),
                l = Zb(l, p),
                l == null || delete l[Ws(as(p))]
            }
            function Eb(l, p, x, M) {
                return wu(l, p, x(za(l, p)), M)
            }
            function Uh(l, p, x, M) {
                for (var L = l.length, U = M ? L : -1; (M ? U-- : ++U < L) && p(l[U], U, l); )
                    ;
                return x ? os(l, M ? 0 : U, M ? U + 1 : L) : os(l, M ? U + 1 : 0, M ? L : U)
            }
            function Ab(l, p) {
                var x = l;
                return x instanceof Qt && (x = x.value()),
                Rm(p, function(M, L) {
                    return L.func.apply(L.thisArg, Ho([M], L.args))
                }, x)
            }
            function tg(l, p, x) {
                var M = l.length;
                if (M < 2)
                    return M ? $o(l[0]) : [];
                for (var L = -1, U = de(M); ++L < M; )
                    for (var $ = l[L], q = -1; ++q < M; )
                        q != L && (U[L] = xu(U[L] || $, l[q], p, x));
                return $o(Mi(U, 1), p, x)
            }
            function Mb(l, p, x) {
                for (var M = -1, L = l.length, U = p.length, $ = {}; ++M < L; ) {
                    var q = M < U ? p[M] : t;
                    x($, l[M], q)
                }
                return $
            }
            function ng(l) {
                return $n(l) ? l : []
            }
            function ig(l) {
                return typeof l == "function" ? l : vr
            }
            function Xo(l, p) {
                return Ft(l) ? l : hg(l, p) ? [l] : tS(fn(l))
            }
            var ED = Wt;
            function qo(l, p, x) {
                var M = l.length;
                return x = x === t ? M : x,
                !p && x >= M ? l : os(l, p, x)
            }
            var Tb = f3 || function(l) {
                return Ai.clearTimeout(l)
            }
            ;
            function Cb(l, p) {
                if (p)
                    return l.slice();
                var x = l.length
                  , M = Yx ? Yx(x) : new l.constructor(x);
                return l.copy(M),
                M
            }
            function rg(l) {
                var p = new l.constructor(l.byteLength);
                return new Sh(p).set(new Sh(l)),
                p
            }
            function AD(l, p) {
                var x = p ? rg(l.buffer) : l.buffer;
                return new l.constructor(x,l.byteOffset,l.byteLength)
            }
            function MD(l) {
                var p = new l.constructor(l.source,Di.exec(l));
                return p.lastIndex = l.lastIndex,
                p
            }
            function TD(l) {
                return vu ? yn(vu.call(l)) : {}
            }
            function Rb(l, p) {
                var x = p ? rg(l.buffer) : l.buffer;
                return new l.constructor(x,l.byteOffset,l.length)
            }
            function Pb(l, p) {
                if (l !== p) {
                    var x = l !== t
                      , M = l === null
                      , L = l === l
                      , U = Fr(l)
                      , $ = p !== t
                      , q = p === null
                      , Q = p === p
                      , ye = Fr(p);
                    if (!q && !ye && !U && l > p || U && $ && Q && !q && !ye || M && $ && Q || !x && Q || !L)
                        return 1;
                    if (!M && !U && !ye && l < p || ye && x && L && !M && !U || q && x && L || !$ && L || !Q)
                        return -1
                }
                return 0
            }
            function CD(l, p, x) {
                for (var M = -1, L = l.criteria, U = p.criteria, $ = L.length, q = x.length; ++M < $; ) {
                    var Q = Pb(L[M], U[M]);
                    if (Q) {
                        if (M >= q)
                            return Q;
                        var ye = x[M];
                        return Q * (ye == "desc" ? -1 : 1)
                    }
                }
                return l.index - p.index
            }
            function Lb(l, p, x, M) {
                for (var L = -1, U = l.length, $ = x.length, q = -1, Q = p.length, ye = ai(U - $, 0), be = de(Q + ye), Ce = !M; ++q < Q; )
                    be[q] = p[q];
                for (; ++L < $; )
                    (Ce || L < U) && (be[x[L]] = l[L]);
                for (; ye--; )
                    be[q++] = l[L++];
                return be
            }
            function Db(l, p, x, M) {
                for (var L = -1, U = l.length, $ = -1, q = x.length, Q = -1, ye = p.length, be = ai(U - q, 0), Ce = de(be + ye), $e = !M; ++L < be; )
                    Ce[L] = l[L];
                for (var ct = L; ++Q < ye; )
                    Ce[ct + Q] = p[Q];
                for (; ++$ < q; )
                    ($e || L < U) && (Ce[ct + x[$]] = l[L++]);
                return Ce
            }
            function mr(l, p) {
                var x = -1
                  , M = l.length;
                for (p || (p = de(M)); ++x < M; )
                    p[x] = l[x];
                return p
            }
            function Vs(l, p, x, M) {
                var L = !x;
                x || (x = {});
                for (var U = -1, $ = p.length; ++U < $; ) {
                    var q = p[U]
                      , Q = M ? M(x[q], l[q], q, x, l) : t;
                    Q === t && (Q = l[q]),
                    L ? uo(x, q, Q) : yu(x, q, Q)
                }
                return x
            }
            function RD(l, p) {
                return Vs(l, fg(l), p)
            }
            function PD(l, p) {
                return Vs(l, $b(l), p)
            }
            function Fh(l, p) {
                return function(x, M) {
                    var L = Ft(x) ? NL : J3
                      , U = p ? p() : {};
                    return L(x, l, xt(M, 2), U)
                }
            }
            function Kl(l) {
                return Wt(function(p, x) {
                    var M = -1
                      , L = x.length
                      , U = L > 1 ? x[L - 1] : t
                      , $ = L > 2 ? x[2] : t;
                    for (U = l.length > 3 && typeof U == "function" ? (L--,
                    U) : t,
                    $ && ji(x[0], x[1], $) && (U = L < 3 ? t : U,
                    L = 1),
                    p = yn(p); ++M < L; ) {
                        var q = x[M];
                        q && l(p, q, M, U)
                    }
                    return p
                })
            }
            function Ib(l, p) {
                return function(x, M) {
                    if (x == null)
                        return x;
                    if (!gr(x))
                        return l(x, M);
                    for (var L = x.length, U = p ? L : -1, $ = yn(x); (p ? U-- : ++U < L) && M($[U], U, $) !== !1; )
                        ;
                    return x
                }
            }
            function Ob(l) {
                return function(p, x, M) {
                    for (var L = -1, U = yn(p), $ = M(p), q = $.length; q--; ) {
                        var Q = $[l ? q : ++L];
                        if (x(U[Q], Q, U) === !1)
                            break
                    }
                    return p
                }
            }
            function LD(l, p, x) {
                var M = p & v
                  , L = Eu(l);
                function U() {
                    var $ = this && this !== Ai && this instanceof U ? L : l;
                    return $.apply(M ? x : this, arguments)
                }
                return U
            }
            function Nb(l) {
                return function(p) {
                    p = fn(p);
                    var x = Vl(p) ? bs(p) : t
                      , M = x ? x[0] : p.charAt(0)
                      , L = x ? qo(x, 1).join("") : p.slice(1);
                    return M[l]() + L
                }
            }
            function Zl(l) {
                return function(p) {
                    return Rm(IS(DS(p).replace(bL, "")), l, "")
                }
            }
            function Eu(l) {
                return function() {
                    var p = arguments;
                    switch (p.length) {
                    case 0:
                        return new l;
                    case 1:
                        return new l(p[0]);
                    case 2:
                        return new l(p[0],p[1]);
                    case 3:
                        return new l(p[0],p[1],p[2]);
                    case 4:
                        return new l(p[0],p[1],p[2],p[3]);
                    case 5:
                        return new l(p[0],p[1],p[2],p[3],p[4]);
                    case 6:
                        return new l(p[0],p[1],p[2],p[3],p[4],p[5]);
                    case 7:
                        return new l(p[0],p[1],p[2],p[3],p[4],p[5],p[6])
                    }
                    var x = Yl(l.prototype)
                      , M = l.apply(x, p);
                    return Nn(M) ? M : x
                }
            }
            function DD(l, p, x) {
                var M = Eu(l);
                function L() {
                    for (var U = arguments.length, $ = de(U), q = U, Q = Jl(L); q--; )
                        $[q] = arguments[q];
                    var ye = U < 3 && $[0] !== Q && $[U - 1] !== Q ? [] : Go($, Q);
                    if (U -= ye.length,
                    U < x)
                        return zb(l, p, Bh, L.placeholder, t, $, ye, t, t, x - U);
                    var be = this && this !== Ai && this instanceof L ? M : l;
                    return Or(be, this, $)
                }
                return L
            }
            function Ub(l) {
                return function(p, x, M) {
                    var L = yn(p);
                    if (!gr(p)) {
                        var U = xt(x, 3);
                        p = hi(p),
                        x = function(q) {
                            return U(L[q], q, L)
                        }
                    }
                    var $ = l(p, x, M);
                    return $ > -1 ? L[U ? p[$] : $] : t
                }
            }
            function Fb(l) {
                return ho(function(p) {
                    var x = p.length
                      , M = x
                      , L = rs.prototype.thru;
                    for (l && p.reverse(); M--; ) {
                        var U = p[M];
                        if (typeof U != "function")
                            throw new is(o);
                        if (L && !$ && Gh(U) == "wrapper")
                            var $ = new rs([],!0)
                    }
                    for (M = $ ? M : x; ++M < x; ) {
                        U = p[M];
                        var q = Gh(U)
                          , Q = q == "wrapper" ? cg(U) : t;
                        Q && dg(Q[0]) && Q[1] == (C | S | b | P) && !Q[4].length && Q[9] == 1 ? $ = $[Gh(Q[0])].apply($, Q[3]) : $ = U.length == 1 && dg(U) ? $[q]() : $.thru(U)
                    }
                    return function() {
                        var ye = arguments
                          , be = ye[0];
                        if ($ && ye.length == 1 && Ft(be))
                            return $.plant(be).value();
                        for (var Ce = 0, $e = x ? p[Ce].apply(this, ye) : be; ++Ce < x; )
                            $e = p[Ce].call(this, $e);
                        return $e
                    }
                })
            }
            function Bh(l, p, x, M, L, U, $, q, Q, ye) {
                var be = p & C
                  , Ce = p & v
                  , $e = p & y
                  , ct = p & (S | E)
                  , St = p & A
                  , Ht = $e ? t : Eu(l);
                function wt() {
                    for (var Yt = arguments.length, nn = de(Yt), Br = Yt; Br--; )
                        nn[Br] = arguments[Br];
                    if (ct)
                        var Yi = Jl(wt)
                          , kr = WL(nn, Yi);
                    if (M && (nn = Lb(nn, M, L, ct)),
                    U && (nn = Db(nn, U, $, ct)),
                    Yt -= kr,
                    ct && Yt < ye) {
                        var Xn = Go(nn, Yi);
                        return zb(l, p, Bh, wt.placeholder, x, nn, Xn, q, Q, ye - Yt)
                    }
                    var Es = Ce ? x : this
                      , _o = $e ? Es[l] : l;
                    return Yt = nn.length,
                    q ? nn = JD(nn, q) : St && Yt > 1 && nn.reverse(),
                    be && Q < Yt && (nn.length = Q),
                    this && this !== Ai && this instanceof wt && (_o = Ht || Eu(_o)),
                    _o.apply(Es, nn)
                }
                return wt
            }
            function Bb(l, p) {
                return function(x, M) {
                    return oD(x, l, p(M), {})
                }
            }
            function kh(l, p) {
                return function(x, M) {
                    var L;
                    if (x === t && M === t)
                        return p;
                    if (x !== t && (L = x),
                    M !== t) {
                        if (L === t)
                            return M;
                        typeof x == "string" || typeof M == "string" ? (x = Ur(x),
                        M = Ur(M)) : (x = wb(x),
                        M = wb(M)),
                        L = l(x, M)
                    }
                    return L
                }
            }
            function sg(l) {
                return ho(function(p) {
                    return p = In(p, Nr(xt())),
                    Wt(function(x) {
                        var M = this;
                        return l(p, function(L) {
                            return Or(L, M, x)
                        })
                    })
                })
            }
            function zh(l, p) {
                p = p === t ? " " : Ur(p);
                var x = p.length;
                if (x < 2)
                    return x ? Jm(p, l) : p;
                var M = Jm(p, Mh(l / Wl(p)));
                return Vl(p) ? qo(bs(M), 0, l).join("") : M.slice(0, l)
            }
            function ID(l, p, x, M) {
                var L = p & v
                  , U = Eu(l);
                function $() {
                    for (var q = -1, Q = arguments.length, ye = -1, be = M.length, Ce = de(be + Q), $e = this && this !== Ai && this instanceof $ ? U : l; ++ye < be; )
                        Ce[ye] = M[ye];
                    for (; Q--; )
                        Ce[ye++] = arguments[++q];
                    return Or($e, L ? x : this, Ce)
                }
                return $
            }
            function kb(l) {
                return function(p, x, M) {
                    return M && typeof M != "number" && ji(p, x, M) && (x = M = t),
                    p = go(p),
                    x === t ? (x = p,
                    p = 0) : x = go(x),
                    M = M === t ? p < x ? 1 : -1 : go(M),
                    vD(p, x, M, l)
                }
            }
            function Hh(l) {
                return function(p, x) {
                    return typeof p == "string" && typeof x == "string" || (p = ls(p),
                    x = ls(x)),
                    l(p, x)
                }
            }
            function zb(l, p, x, M, L, U, $, q, Q, ye) {
                var be = p & S
                  , Ce = be ? $ : t
                  , $e = be ? t : $
                  , ct = be ? U : t
                  , St = be ? t : U;
                p |= be ? b : T,
                p &= ~(be ? T : b),
                p & w || (p &= ~(v | y));
                var Ht = [l, p, L, ct, Ce, St, $e, q, Q, ye]
                  , wt = x.apply(t, Ht);
                return dg(l) && Jb(wt, Ht),
                wt.placeholder = M,
                Qb(wt, l, p)
            }
            function og(l) {
                var p = oi[l];
                return function(x, M) {
                    if (x = ls(x),
                    M = M == null ? 0 : Ii(zt(M), 292),
                    M && Qx(x)) {
                        var L = (fn(x) + "e").split("e")
                          , U = p(L[0] + "e" + (+L[1] + M));
                        return L = (fn(U) + "e").split("e"),
                        +(L[0] + "e" + (+L[1] - M))
                    }
                    return p(x)
                }
            }
            var OD = ql && 1 / gh(new ql([, -0]))[1] == V ? function(l) {
                return new ql(l)
            }
            : Cg;
            function Hb(l) {
                return function(p) {
                    var x = Oi(p);
                    return x == Ne ? Um(p) : x == pt ? ZL(p) : VL(p, l(p))
                }
            }
            function fo(l, p, x, M, L, U, $, q) {
                var Q = p & y;
                if (!Q && typeof l != "function")
                    throw new is(o);
                var ye = M ? M.length : 0;
                if (ye || (p &= ~(b | T),
                M = L = t),
                $ = $ === t ? $ : ai(zt($), 0),
                q = q === t ? q : zt(q),
                ye -= L ? L.length : 0,
                p & T) {
                    var be = M
                      , Ce = L;
                    M = L = t
                }
                var $e = Q ? t : cg(l)
                  , ct = [l, p, x, M, L, be, Ce, U, $, q];
                if ($e && YD(ct, $e),
                l = ct[0],
                p = ct[1],
                x = ct[2],
                M = ct[3],
                L = ct[4],
                q = ct[9] = ct[9] === t ? Q ? 0 : l.length : ai(ct[9] - ye, 0),
                !q && p & (S | E) && (p &= ~(S | E)),
                !p || p == v)
                    var St = LD(l, p, x);
                else
                    p == S || p == E ? St = DD(l, p, q) : (p == b || p == (v | b)) && !L.length ? St = ID(l, p, x, M) : St = Bh.apply(t, ct);
                var Ht = $e ? bb : Jb;
                return Qb(Ht(St, ct), l, p)
            }
            function Gb(l, p, x, M) {
                return l === t || ws(l, Xl[x]) && !hn.call(M, x) ? p : l
            }
            function Vb(l, p, x, M, L, U) {
                return Nn(l) && Nn(p) && (U.set(p, l),
                Oh(l, p, t, Vb, U),
                U.delete(p)),
                l
            }
            function ND(l) {
                return Tu(l) ? t : l
            }
            function Wb(l, p, x, M, L, U) {
                var $ = x & _
                  , q = l.length
                  , Q = p.length;
                if (q != Q && !($ && Q > q))
                    return !1;
                var ye = U.get(l)
                  , be = U.get(p);
                if (ye && be)
                    return ye == p && be == l;
                var Ce = -1
                  , $e = !0
                  , ct = x & g ? new Ba : t;
                for (U.set(l, p),
                U.set(p, l); ++Ce < q; ) {
                    var St = l[Ce]
                      , Ht = p[Ce];
                    if (M)
                        var wt = $ ? M(Ht, St, Ce, p, l, U) : M(St, Ht, Ce, l, p, U);
                    if (wt !== t) {
                        if (wt)
                            continue;
                        $e = !1;
                        break
                    }
                    if (ct) {
                        if (!Pm(p, function(Yt, nn) {
                            if (!du(ct, nn) && (St === Yt || L(St, Yt, x, M, U)))
                                return ct.push(nn)
                        })) {
                            $e = !1;
                            break
                        }
                    } else if (!(St === Ht || L(St, Ht, x, M, U))) {
                        $e = !1;
                        break
                    }
                }
                return U.delete(l),
                U.delete(p),
                $e
            }
            function UD(l, p, x, M, L, U, $) {
                switch (x) {
                case me:
                    if (l.byteLength != p.byteLength || l.byteOffset != p.byteOffset)
                        return !1;
                    l = l.buffer,
                    p = p.buffer;
                case le:
                    return !(l.byteLength != p.byteLength || !U(new Sh(l), new Sh(p)));
                case He:
                case qe:
                case Ye:
                    return ws(+l, +p);
                case st:
                    return l.name == p.name && l.message == p.message;
                case Tt:
                case Ct:
                    return l == p + "";
                case Ne:
                    var q = Um;
                case pt:
                    var Q = M & _;
                    if (q || (q = gh),
                    l.size != p.size && !Q)
                        return !1;
                    var ye = $.get(l);
                    if (ye)
                        return ye == p;
                    M |= g,
                    $.set(l, p);
                    var be = Wb(q(l), q(p), M, L, U, $);
                    return $.delete(l),
                    be;
                case z:
                    if (vu)
                        return vu.call(l) == vu.call(p)
                }
                return !1
            }
            function FD(l, p, x, M, L, U) {
                var $ = x & _
                  , q = ag(l)
                  , Q = q.length
                  , ye = ag(p)
                  , be = ye.length;
                if (Q != be && !$)
                    return !1;
                for (var Ce = Q; Ce--; ) {
                    var $e = q[Ce];
                    if (!($ ? $e in p : hn.call(p, $e)))
                        return !1
                }
                var ct = U.get(l)
                  , St = U.get(p);
                if (ct && St)
                    return ct == p && St == l;
                var Ht = !0;
                U.set(l, p),
                U.set(p, l);
                for (var wt = $; ++Ce < Q; ) {
                    $e = q[Ce];
                    var Yt = l[$e]
                      , nn = p[$e];
                    if (M)
                        var Br = $ ? M(nn, Yt, $e, p, l, U) : M(Yt, nn, $e, l, p, U);
                    if (!(Br === t ? Yt === nn || L(Yt, nn, x, M, U) : Br)) {
                        Ht = !1;
                        break
                    }
                    wt || (wt = $e == "constructor")
                }
                if (Ht && !wt) {
                    var Yi = l.constructor
                      , kr = p.constructor;
                    Yi != kr && "constructor"in l && "constructor"in p && !(typeof Yi == "function" && Yi instanceof Yi && typeof kr == "function" && kr instanceof kr) && (Ht = !1)
                }
                return U.delete(l),
                U.delete(p),
                Ht
            }
            function ho(l) {
                return mg(Kb(l, t, sS), l + "")
            }
            function ag(l) {
                return ub(l, hi, fg)
            }
            function lg(l) {
                return ub(l, _r, $b)
            }
            var cg = Ch ? function(l) {
                return Ch.get(l)
            }
            : Cg;
            function Gh(l) {
                for (var p = l.name + "", x = jl[p], M = hn.call(jl, p) ? x.length : 0; M--; ) {
                    var L = x[M]
                      , U = L.func;
                    if (U == null || U == l)
                        return L.name
                }
                return p
            }
            function Jl(l) {
                var p = hn.call(O, "placeholder") ? O : l;
                return p.placeholder
            }
            function xt() {
                var l = O.iteratee || Mg;
                return l = l === Mg ? db : l,
                arguments.length ? l(arguments[0], arguments[1]) : l
            }
            function Vh(l, p) {
                var x = l.__data__;
                return $D(p) ? x[typeof p == "string" ? "string" : "hash"] : x.map
            }
            function ug(l) {
                for (var p = hi(l), x = p.length; x--; ) {
                    var M = p[x]
                      , L = l[M];
                    p[x] = [M, L, jb(L)]
                }
                return p
            }
            function Ha(l, p) {
                var x = jL(l, p);
                return hb(x) ? x : t
            }
            function BD(l) {
                var p = hn.call(l, Ua)
                  , x = l[Ua];
                try {
                    l[Ua] = t;
                    var M = !0
                } catch {}
                var L = xh.call(l);
                return M && (p ? l[Ua] = x : delete l[Ua]),
                L
            }
            var fg = Bm ? function(l) {
                return l == null ? [] : (l = yn(l),
                zo(Bm(l), function(p) {
                    return Zx.call(l, p)
                }))
            }
            : Rg
              , $b = Bm ? function(l) {
                for (var p = []; l; )
                    Ho(p, fg(l)),
                    l = wh(l);
                return p
            }
            : Rg
              , Oi = qi;
            (km && Oi(new km(new ArrayBuffer(1))) != me || mu && Oi(new mu) != Ne || zm && Oi(zm.resolve()) != ot || ql && Oi(new ql) != pt || gu && Oi(new gu) != j) && (Oi = function(l) {
                var p = qi(l)
                  , x = p == te ? l.constructor : t
                  , M = x ? Ga(x) : "";
                if (M)
                    switch (M) {
                    case x3:
                        return me;
                    case b3:
                        return Ne;
                    case S3:
                        return ot;
                    case w3:
                        return pt;
                    case E3:
                        return j
                    }
                return p
            }
            );
            function kD(l, p, x) {
                for (var M = -1, L = x.length; ++M < L; ) {
                    var U = x[M]
                      , $ = U.size;
                    switch (U.type) {
                    case "drop":
                        l += $;
                        break;
                    case "dropRight":
                        p -= $;
                        break;
                    case "take":
                        p = Ii(p, l + $);
                        break;
                    case "takeRight":
                        l = ai(l, p - $);
                        break
                    }
                }
                return {
                    start: l,
                    end: p
                }
            }
            function zD(l) {
                var p = l.match($t);
                return p ? p[1].split(dn) : []
            }
            function Xb(l, p, x) {
                p = Xo(p, l);
                for (var M = -1, L = p.length, U = !1; ++M < L; ) {
                    var $ = Ws(p[M]);
                    if (!(U = l != null && x(l, $)))
                        break;
                    l = l[$]
                }
                return U || ++M != L ? U : (L = l == null ? 0 : l.length,
                !!L && Kh(L) && po($, L) && (Ft(l) || Va(l)))
            }
            function HD(l) {
                var p = l.length
                  , x = new l.constructor(p);
                return p && typeof l[0] == "string" && hn.call(l, "index") && (x.index = l.index,
                x.input = l.input),
                x
            }
            function qb(l) {
                return typeof l.constructor == "function" && !Au(l) ? Yl(wh(l)) : {}
            }
            function GD(l, p, x) {
                var M = l.constructor;
                switch (p) {
                case le:
                    return rg(l);
                case He:
                case qe:
                    return new M(+l);
                case me:
                    return AD(l, x);
                case We:
                case Te:
                case Ee:
                case Ae:
                case _t:
                case Pe:
                case Bt:
                case vt:
                case ht:
                    return Rb(l, x);
                case Ne:
                    return new M;
                case Ye:
                case Ct:
                    return new M(l);
                case Tt:
                    return MD(l);
                case pt:
                    return new M;
                case z:
                    return TD(l)
                }
            }
            function VD(l, p) {
                var x = p.length;
                if (!x)
                    return l;
                var M = x - 1;
                return p[M] = (x > 1 ? "& " : "") + p[M],
                p = p.join(x > 2 ? ", " : " "),
                l.replace(Mn, `{
/* [wrapped with ` + p + `] */
`)
            }
            function WD(l) {
                return Ft(l) || Va(l) || !!(Jx && l && l[Jx])
            }
            function po(l, p) {
                var x = typeof l;
                return p = p ?? ee,
                !!p && (x == "number" || x != "symbol" && se.test(l)) && l > -1 && l % 1 == 0 && l < p
            }
            function ji(l, p, x) {
                if (!Nn(x))
                    return !1;
                var M = typeof p;
                return (M == "number" ? gr(x) && po(p, x.length) : M == "string" && p in x) ? ws(x[p], l) : !1
            }
            function hg(l, p) {
                if (Ft(l))
                    return !1;
                var x = typeof l;
                return x == "number" || x == "symbol" || x == "boolean" || l == null || Fr(l) ? !0 : Et.test(l) || !je.test(l) || p != null && l in yn(p)
            }
            function $D(l) {
                var p = typeof l;
                return p == "string" || p == "number" || p == "symbol" || p == "boolean" ? l !== "__proto__" : l === null
            }
            function dg(l) {
                var p = Gh(l)
                  , x = O[p];
                if (typeof x != "function" || !(p in Qt.prototype))
                    return !1;
                if (l === x)
                    return !0;
                var M = cg(x);
                return !!M && l === M[0]
            }
            function XD(l) {
                return !!jx && jx in l
            }
            var qD = vh ? mo : Pg;
            function Au(l) {
                var p = l && l.constructor
                  , x = typeof p == "function" && p.prototype || Xl;
                return l === x
            }
            function jb(l) {
                return l === l && !Nn(l)
            }
            function Yb(l, p) {
                return function(x) {
                    return x == null ? !1 : x[l] === p && (p !== t || l in yn(x))
                }
            }
            function jD(l) {
                var p = jh(l, function(M) {
                    return x.size === u && x.clear(),
                    M
                })
                  , x = p.cache;
                return p
            }
            function YD(l, p) {
                var x = l[1]
                  , M = p[1]
                  , L = x | M
                  , U = L < (v | y | C)
                  , $ = M == C && x == S || M == C && x == P && l[7].length <= p[8] || M == (C | P) && p[7].length <= p[8] && x == S;
                if (!(U || $))
                    return l;
                M & v && (l[2] = p[2],
                L |= x & v ? 0 : w);
                var q = p[3];
                if (q) {
                    var Q = l[3];
                    l[3] = Q ? Lb(Q, q, p[4]) : q,
                    l[4] = Q ? Go(l[3], h) : p[4]
                }
                return q = p[5],
                q && (Q = l[5],
                l[5] = Q ? Db(Q, q, p[6]) : q,
                l[6] = Q ? Go(l[5], h) : p[6]),
                q = p[7],
                q && (l[7] = q),
                M & C && (l[8] = l[8] == null ? p[8] : Ii(l[8], p[8])),
                l[9] == null && (l[9] = p[9]),
                l[0] = p[0],
                l[1] = L,
                l
            }
            function KD(l) {
                var p = [];
                if (l != null)
                    for (var x in yn(l))
                        p.push(x);
                return p
            }
            function ZD(l) {
                return xh.call(l)
            }
            function Kb(l, p, x) {
                return p = ai(p === t ? l.length - 1 : p, 0),
                function() {
                    for (var M = arguments, L = -1, U = ai(M.length - p, 0), $ = de(U); ++L < U; )
                        $[L] = M[p + L];
                    L = -1;
                    for (var q = de(p + 1); ++L < p; )
                        q[L] = M[L];
                    return q[p] = x($),
                    Or(l, this, q)
                }
            }
            function Zb(l, p) {
                return p.length < 2 ? l : za(l, os(p, 0, -1))
            }
            function JD(l, p) {
                for (var x = l.length, M = Ii(p.length, x), L = mr(l); M--; ) {
                    var U = p[M];
                    l[M] = po(U, x) ? L[U] : t
                }
                return l
            }
            function pg(l, p) {
                if (!(p === "constructor" && typeof l[p] == "function") && p != "__proto__")
                    return l[p]
            }
            var Jb = eS(bb)
              , Mu = d3 || function(l, p) {
                return Ai.setTimeout(l, p)
            }
              , mg = eS(bD);
            function Qb(l, p, x) {
                var M = p + "";
                return mg(l, VD(M, QD(zD(M), x)))
            }
            function eS(l) {
                var p = 0
                  , x = 0;
                return function() {
                    var M = _3()
                      , L = H - (M - x);
                    if (x = M,
                    L > 0) {
                        if (++p >= D)
                            return arguments[0]
                    } else
                        p = 0;
                    return l.apply(t, arguments)
                }
            }
            function Wh(l, p) {
                var x = -1
                  , M = l.length
                  , L = M - 1;
                for (p = p === t ? M : p; ++x < p; ) {
                    var U = Zm(x, L)
                      , $ = l[U];
                    l[U] = l[x],
                    l[x] = $
                }
                return l.length = p,
                l
            }
            var tS = jD(function(l) {
                var p = [];
                return l.charCodeAt(0) === 46 && p.push(""),
                l.replace(At, function(x, M, L, U) {
                    p.push(L ? U.replace(_n, "$1") : M || x)
                }),
                p
            });
            function Ws(l) {
                if (typeof l == "string" || Fr(l))
                    return l;
                var p = l + "";
                return p == "0" && 1 / l == -V ? "-0" : p
            }
            function Ga(l) {
                if (l != null) {
                    try {
                        return yh.call(l)
                    } catch {}
                    try {
                        return l + ""
                    } catch {}
                }
                return ""
            }
            function QD(l, p) {
                return ns(fe, function(x) {
                    var M = "_." + x[0];
                    p & x[1] && !ph(l, M) && l.push(M)
                }),
                l.sort()
            }
            function nS(l) {
                if (l instanceof Qt)
                    return l.clone();
                var p = new rs(l.__wrapped__,l.__chain__);
                return p.__actions__ = mr(l.__actions__),
                p.__index__ = l.__index__,
                p.__values__ = l.__values__,
                p
            }
            function eI(l, p, x) {
                (x ? ji(l, p, x) : p === t) ? p = 1 : p = ai(zt(p), 0);
                var M = l == null ? 0 : l.length;
                if (!M || p < 1)
                    return [];
                for (var L = 0, U = 0, $ = de(Mh(M / p)); L < M; )
                    $[U++] = os(l, L, L += p);
                return $
            }
            function tI(l) {
                for (var p = -1, x = l == null ? 0 : l.length, M = 0, L = []; ++p < x; ) {
                    var U = l[p];
                    U && (L[M++] = U)
                }
                return L
            }
            function nI() {
                var l = arguments.length;
                if (!l)
                    return [];
                for (var p = de(l - 1), x = arguments[0], M = l; M--; )
                    p[M - 1] = arguments[M];
                return Ho(Ft(x) ? mr(x) : [x], Mi(p, 1))
            }
            var iI = Wt(function(l, p) {
                return $n(l) ? xu(l, Mi(p, 1, $n, !0)) : []
            })
              , rI = Wt(function(l, p) {
                var x = as(p);
                return $n(x) && (x = t),
                $n(l) ? xu(l, Mi(p, 1, $n, !0), xt(x, 2)) : []
            })
              , sI = Wt(function(l, p) {
                var x = as(p);
                return $n(x) && (x = t),
                $n(l) ? xu(l, Mi(p, 1, $n, !0), t, x) : []
            });
            function oI(l, p, x) {
                var M = l == null ? 0 : l.length;
                return M ? (p = x || p === t ? 1 : zt(p),
                os(l, p < 0 ? 0 : p, M)) : []
            }
            function aI(l, p, x) {
                var M = l == null ? 0 : l.length;
                return M ? (p = x || p === t ? 1 : zt(p),
                p = M - p,
                os(l, 0, p < 0 ? 0 : p)) : []
            }
            function lI(l, p) {
                return l && l.length ? Uh(l, xt(p, 3), !0, !0) : []
            }
            function cI(l, p) {
                return l && l.length ? Uh(l, xt(p, 3), !0) : []
            }
            function uI(l, p, x, M) {
                var L = l == null ? 0 : l.length;
                return L ? (x && typeof x != "number" && ji(l, p, x) && (x = 0,
                M = L),
                nD(l, p, x, M)) : []
            }
            function iS(l, p, x) {
                var M = l == null ? 0 : l.length;
                if (!M)
                    return -1;
                var L = x == null ? 0 : zt(x);
                return L < 0 && (L = ai(M + L, 0)),
                mh(l, xt(p, 3), L)
            }
            function rS(l, p, x) {
                var M = l == null ? 0 : l.length;
                if (!M)
                    return -1;
                var L = M - 1;
                return x !== t && (L = zt(x),
                L = x < 0 ? ai(M + L, 0) : Ii(L, M - 1)),
                mh(l, xt(p, 3), L, !0)
            }
            function sS(l) {
                var p = l == null ? 0 : l.length;
                return p ? Mi(l, 1) : []
            }
            function fI(l) {
                var p = l == null ? 0 : l.length;
                return p ? Mi(l, V) : []
            }
            function hI(l, p) {
                var x = l == null ? 0 : l.length;
                return x ? (p = p === t ? 1 : zt(p),
                Mi(l, p)) : []
            }
            function dI(l) {
                for (var p = -1, x = l == null ? 0 : l.length, M = {}; ++p < x; ) {
                    var L = l[p];
                    M[L[0]] = L[1]
                }
                return M
            }
            function oS(l) {
                return l && l.length ? l[0] : t
            }
            function pI(l, p, x) {
                var M = l == null ? 0 : l.length;
                if (!M)
                    return -1;
                var L = x == null ? 0 : zt(x);
                return L < 0 && (L = ai(M + L, 0)),
                Gl(l, p, L)
            }
            function mI(l) {
                var p = l == null ? 0 : l.length;
                return p ? os(l, 0, -1) : []
            }
            var gI = Wt(function(l) {
                var p = In(l, ng);
                return p.length && p[0] === l[0] ? Xm(p) : []
            })
              , _I = Wt(function(l) {
                var p = as(l)
                  , x = In(l, ng);
                return p === as(x) ? p = t : x.pop(),
                x.length && x[0] === l[0] ? Xm(x, xt(p, 2)) : []
            })
              , vI = Wt(function(l) {
                var p = as(l)
                  , x = In(l, ng);
                return p = typeof p == "function" ? p : t,
                p && x.pop(),
                x.length && x[0] === l[0] ? Xm(x, t, p) : []
            });
            function yI(l, p) {
                return l == null ? "" : m3.call(l, p)
            }
            function as(l) {
                var p = l == null ? 0 : l.length;
                return p ? l[p - 1] : t
            }
            function xI(l, p, x) {
                var M = l == null ? 0 : l.length;
                if (!M)
                    return -1;
                var L = M;
                return x !== t && (L = zt(x),
                L = L < 0 ? ai(M + L, 0) : Ii(L, M - 1)),
                p === p ? QL(l, p, L) : mh(l, zx, L, !0)
            }
            function bI(l, p) {
                return l && l.length ? _b(l, zt(p)) : t
            }
            var SI = Wt(aS);
            function aS(l, p) {
                return l && l.length && p && p.length ? Km(l, p) : l
            }
            function wI(l, p, x) {
                return l && l.length && p && p.length ? Km(l, p, xt(x, 2)) : l
            }
            function EI(l, p, x) {
                return l && l.length && p && p.length ? Km(l, p, t, x) : l
            }
            var AI = ho(function(l, p) {
                var x = l == null ? 0 : l.length
                  , M = Gm(l, p);
                return xb(l, In(p, function(L) {
                    return po(L, x) ? +L : L
                }).sort(Pb)),
                M
            });
            function MI(l, p) {
                var x = [];
                if (!(l && l.length))
                    return x;
                var M = -1
                  , L = []
                  , U = l.length;
                for (p = xt(p, 3); ++M < U; ) {
                    var $ = l[M];
                    p($, M, l) && (x.push($),
                    L.push(M))
                }
                return xb(l, L),
                x
            }
            function gg(l) {
                return l == null ? l : y3.call(l)
            }
            function TI(l, p, x) {
                var M = l == null ? 0 : l.length;
                return M ? (x && typeof x != "number" && ji(l, p, x) ? (p = 0,
                x = M) : (p = p == null ? 0 : zt(p),
                x = x === t ? M : zt(x)),
                os(l, p, x)) : []
            }
            function CI(l, p) {
                return Nh(l, p)
            }
            function RI(l, p, x) {
                return Qm(l, p, xt(x, 2))
            }
            function PI(l, p) {
                var x = l == null ? 0 : l.length;
                if (x) {
                    var M = Nh(l, p);
                    if (M < x && ws(l[M], p))
                        return M
                }
                return -1
            }
            function LI(l, p) {
                return Nh(l, p, !0)
            }
            function DI(l, p, x) {
                return Qm(l, p, xt(x, 2), !0)
            }
            function II(l, p) {
                var x = l == null ? 0 : l.length;
                if (x) {
                    var M = Nh(l, p, !0) - 1;
                    if (ws(l[M], p))
                        return M
                }
                return -1
            }
            function OI(l) {
                return l && l.length ? Sb(l) : []
            }
            function NI(l, p) {
                return l && l.length ? Sb(l, xt(p, 2)) : []
            }
            function UI(l) {
                var p = l == null ? 0 : l.length;
                return p ? os(l, 1, p) : []
            }
            function FI(l, p, x) {
                return l && l.length ? (p = x || p === t ? 1 : zt(p),
                os(l, 0, p < 0 ? 0 : p)) : []
            }
            function BI(l, p, x) {
                var M = l == null ? 0 : l.length;
                return M ? (p = x || p === t ? 1 : zt(p),
                p = M - p,
                os(l, p < 0 ? 0 : p, M)) : []
            }
            function kI(l, p) {
                return l && l.length ? Uh(l, xt(p, 3), !1, !0) : []
            }
            function zI(l, p) {
                return l && l.length ? Uh(l, xt(p, 3)) : []
            }
            var HI = Wt(function(l) {
                return $o(Mi(l, 1, $n, !0))
            })
              , GI = Wt(function(l) {
                var p = as(l);
                return $n(p) && (p = t),
                $o(Mi(l, 1, $n, !0), xt(p, 2))
            })
              , VI = Wt(function(l) {
                var p = as(l);
                return p = typeof p == "function" ? p : t,
                $o(Mi(l, 1, $n, !0), t, p)
            });
            function WI(l) {
                return l && l.length ? $o(l) : []
            }
            function $I(l, p) {
                return l && l.length ? $o(l, xt(p, 2)) : []
            }
            function XI(l, p) {
                return p = typeof p == "function" ? p : t,
                l && l.length ? $o(l, t, p) : []
            }
            function _g(l) {
                if (!(l && l.length))
                    return [];
                var p = 0;
                return l = zo(l, function(x) {
                    if ($n(x))
                        return p = ai(x.length, p),
                        !0
                }),
                Om(p, function(x) {
                    return In(l, Lm(x))
                })
            }
            function lS(l, p) {
                if (!(l && l.length))
                    return [];
                var x = _g(l);
                return p == null ? x : In(x, function(M) {
                    return Or(p, t, M)
                })
            }
            var qI = Wt(function(l, p) {
                return $n(l) ? xu(l, p) : []
            })
              , jI = Wt(function(l) {
                return tg(zo(l, $n))
            })
              , YI = Wt(function(l) {
                var p = as(l);
                return $n(p) && (p = t),
                tg(zo(l, $n), xt(p, 2))
            })
              , KI = Wt(function(l) {
                var p = as(l);
                return p = typeof p == "function" ? p : t,
                tg(zo(l, $n), t, p)
            })
              , ZI = Wt(_g);
            function JI(l, p) {
                return Mb(l || [], p || [], yu)
            }
            function QI(l, p) {
                return Mb(l || [], p || [], wu)
            }
            var eO = Wt(function(l) {
                var p = l.length
                  , x = p > 1 ? l[p - 1] : t;
                return x = typeof x == "function" ? (l.pop(),
                x) : t,
                lS(l, x)
            });
            function cS(l) {
                var p = O(l);
                return p.__chain__ = !0,
                p
            }
            function tO(l, p) {
                return p(l),
                l
            }
            function $h(l, p) {
                return p(l)
            }
            var nO = ho(function(l) {
                var p = l.length
                  , x = p ? l[0] : 0
                  , M = this.__wrapped__
                  , L = function(U) {
                    return Gm(U, l)
                };
                return p > 1 || this.__actions__.length || !(M instanceof Qt) || !po(x) ? this.thru(L) : (M = M.slice(x, +x + (p ? 1 : 0)),
                M.__actions__.push({
                    func: $h,
                    args: [L],
                    thisArg: t
                }),
                new rs(M,this.__chain__).thru(function(U) {
                    return p && !U.length && U.push(t),
                    U
                }))
            });
            function iO() {
                return cS(this)
            }
            function rO() {
                return new rs(this.value(),this.__chain__)
            }
            function sO() {
                this.__values__ === t && (this.__values__ = wS(this.value()));
                var l = this.__index__ >= this.__values__.length
                  , p = l ? t : this.__values__[this.__index__++];
                return {
                    done: l,
                    value: p
                }
            }
            function oO() {
                return this
            }
            function aO(l) {
                for (var p, x = this; x instanceof Ph; ) {
                    var M = nS(x);
                    M.__index__ = 0,
                    M.__values__ = t,
                    p ? L.__wrapped__ = M : p = M;
                    var L = M;
                    x = x.__wrapped__
                }
                return L.__wrapped__ = l,
                p
            }
            function lO() {
                var l = this.__wrapped__;
                if (l instanceof Qt) {
                    var p = l;
                    return this.__actions__.length && (p = new Qt(this)),
                    p = p.reverse(),
                    p.__actions__.push({
                        func: $h,
                        args: [gg],
                        thisArg: t
                    }),
                    new rs(p,this.__chain__)
                }
                return this.thru(gg)
            }
            function cO() {
                return Ab(this.__wrapped__, this.__actions__)
            }
            var uO = Fh(function(l, p, x) {
                hn.call(l, x) ? ++l[x] : uo(l, x, 1)
            });
            function fO(l, p, x) {
                var M = Ft(l) ? Bx : tD;
                return x && ji(l, p, x) && (p = t),
                M(l, xt(p, 3))
            }
            function hO(l, p) {
                var x = Ft(l) ? zo : lb;
                return x(l, xt(p, 3))
            }
            var dO = Ub(iS)
              , pO = Ub(rS);
            function mO(l, p) {
                return Mi(Xh(l, p), 1)
            }
            function gO(l, p) {
                return Mi(Xh(l, p), V)
            }
            function _O(l, p, x) {
                return x = x === t ? 1 : zt(x),
                Mi(Xh(l, p), x)
            }
            function uS(l, p) {
                var x = Ft(l) ? ns : Wo;
                return x(l, xt(p, 3))
            }
            function fS(l, p) {
                var x = Ft(l) ? UL : ab;
                return x(l, xt(p, 3))
            }
            var vO = Fh(function(l, p, x) {
                hn.call(l, x) ? l[x].push(p) : uo(l, x, [p])
            });
            function yO(l, p, x, M) {
                l = gr(l) ? l : ec(l),
                x = x && !M ? zt(x) : 0;
                var L = l.length;
                return x < 0 && (x = ai(L + x, 0)),
                Zh(l) ? x <= L && l.indexOf(p, x) > -1 : !!L && Gl(l, p, x) > -1
            }
            var xO = Wt(function(l, p, x) {
                var M = -1
                  , L = typeof p == "function"
                  , U = gr(l) ? de(l.length) : [];
                return Wo(l, function($) {
                    U[++M] = L ? Or(p, $, x) : bu($, p, x)
                }),
                U
            })
              , bO = Fh(function(l, p, x) {
                uo(l, x, p)
            });
            function Xh(l, p) {
                var x = Ft(l) ? In : pb;
                return x(l, xt(p, 3))
            }
            function SO(l, p, x, M) {
                return l == null ? [] : (Ft(p) || (p = p == null ? [] : [p]),
                x = M ? t : x,
                Ft(x) || (x = x == null ? [] : [x]),
                vb(l, p, x))
            }
            var wO = Fh(function(l, p, x) {
                l[x ? 0 : 1].push(p)
            }, function() {
                return [[], []]
            });
            function EO(l, p, x) {
                var M = Ft(l) ? Rm : Gx
                  , L = arguments.length < 3;
                return M(l, xt(p, 4), x, L, Wo)
            }
            function AO(l, p, x) {
                var M = Ft(l) ? FL : Gx
                  , L = arguments.length < 3;
                return M(l, xt(p, 4), x, L, ab)
            }
            function MO(l, p) {
                var x = Ft(l) ? zo : lb;
                return x(l, Yh(xt(p, 3)))
            }
            function TO(l) {
                var p = Ft(l) ? ib : yD;
                return p(l)
            }
            function CO(l, p, x) {
                (x ? ji(l, p, x) : p === t) ? p = 1 : p = zt(p);
                var M = Ft(l) ? K3 : xD;
                return M(l, p)
            }
            function RO(l) {
                var p = Ft(l) ? Z3 : SD;
                return p(l)
            }
            function PO(l) {
                if (l == null)
                    return 0;
                if (gr(l))
                    return Zh(l) ? Wl(l) : l.length;
                var p = Oi(l);
                return p == Ne || p == pt ? l.size : jm(l).length
            }
            function LO(l, p, x) {
                var M = Ft(l) ? Pm : wD;
                return x && ji(l, p, x) && (p = t),
                M(l, xt(p, 3))
            }
            var DO = Wt(function(l, p) {
                if (l == null)
                    return [];
                var x = p.length;
                return x > 1 && ji(l, p[0], p[1]) ? p = [] : x > 2 && ji(p[0], p[1], p[2]) && (p = [p[0]]),
                vb(l, Mi(p, 1), [])
            })
              , qh = h3 || function() {
                return Ai.Date.now()
            }
            ;
            function IO(l, p) {
                if (typeof p != "function")
                    throw new is(o);
                return l = zt(l),
                function() {
                    if (--l < 1)
                        return p.apply(this, arguments)
                }
            }
            function hS(l, p, x) {
                return p = x ? t : p,
                p = l && p == null ? l.length : p,
                fo(l, C, t, t, t, t, p)
            }
            function dS(l, p) {
                var x;
                if (typeof p != "function")
                    throw new is(o);
                return l = zt(l),
                function() {
                    return --l > 0 && (x = p.apply(this, arguments)),
                    l <= 1 && (p = t),
                    x
                }
            }
            var vg = Wt(function(l, p, x) {
                var M = v;
                if (x.length) {
                    var L = Go(x, Jl(vg));
                    M |= b
                }
                return fo(l, M, p, x, L)
            })
              , pS = Wt(function(l, p, x) {
                var M = v | y;
                if (x.length) {
                    var L = Go(x, Jl(pS));
                    M |= b
                }
                return fo(p, M, l, x, L)
            });
            function mS(l, p, x) {
                p = x ? t : p;
                var M = fo(l, S, t, t, t, t, t, p);
                return M.placeholder = mS.placeholder,
                M
            }
            function gS(l, p, x) {
                p = x ? t : p;
                var M = fo(l, E, t, t, t, t, t, p);
                return M.placeholder = gS.placeholder,
                M
            }
            function _S(l, p, x) {
                var M, L, U, $, q, Q, ye = 0, be = !1, Ce = !1, $e = !0;
                if (typeof l != "function")
                    throw new is(o);
                p = ls(p) || 0,
                Nn(x) && (be = !!x.leading,
                Ce = "maxWait"in x,
                U = Ce ? ai(ls(x.maxWait) || 0, p) : U,
                $e = "trailing"in x ? !!x.trailing : $e);
                function ct(Xn) {
                    var Es = M
                      , _o = L;
                    return M = L = t,
                    ye = Xn,
                    $ = l.apply(_o, Es),
                    $
                }
                function St(Xn) {
                    return ye = Xn,
                    q = Mu(Yt, p),
                    be ? ct(Xn) : $
                }
                function Ht(Xn) {
                    var Es = Xn - Q
                      , _o = Xn - ye
                      , US = p - Es;
                    return Ce ? Ii(US, U - _o) : US
                }
                function wt(Xn) {
                    var Es = Xn - Q
                      , _o = Xn - ye;
                    return Q === t || Es >= p || Es < 0 || Ce && _o >= U
                }
                function Yt() {
                    var Xn = qh();
                    if (wt(Xn))
                        return nn(Xn);
                    q = Mu(Yt, Ht(Xn))
                }
                function nn(Xn) {
                    return q = t,
                    $e && M ? ct(Xn) : (M = L = t,
                    $)
                }
                function Br() {
                    q !== t && Tb(q),
                    ye = 0,
                    M = Q = L = q = t
                }
                function Yi() {
                    return q === t ? $ : nn(qh())
                }
                function kr() {
                    var Xn = qh()
                      , Es = wt(Xn);
                    if (M = arguments,
                    L = this,
                    Q = Xn,
                    Es) {
                        if (q === t)
                            return St(Q);
                        if (Ce)
                            return Tb(q),
                            q = Mu(Yt, p),
                            ct(Q)
                    }
                    return q === t && (q = Mu(Yt, p)),
                    $
                }
                return kr.cancel = Br,
                kr.flush = Yi,
                kr
            }
            var OO = Wt(function(l, p) {
                return ob(l, 1, p)
            })
              , NO = Wt(function(l, p, x) {
                return ob(l, ls(p) || 0, x)
            });
            function UO(l) {
                return fo(l, A)
            }
            function jh(l, p) {
                if (typeof l != "function" || p != null && typeof p != "function")
                    throw new is(o);
                var x = function() {
                    var M = arguments
                      , L = p ? p.apply(this, M) : M[0]
                      , U = x.cache;
                    if (U.has(L))
                        return U.get(L);
                    var $ = l.apply(this, M);
                    return x.cache = U.set(L, $) || U,
                    $
                };
                return x.cache = new (jh.Cache || co),
                x
            }
            jh.Cache = co;
            function Yh(l) {
                if (typeof l != "function")
                    throw new is(o);
                return function() {
                    var p = arguments;
                    switch (p.length) {
                    case 0:
                        return !l.call(this);
                    case 1:
                        return !l.call(this, p[0]);
                    case 2:
                        return !l.call(this, p[0], p[1]);
                    case 3:
                        return !l.call(this, p[0], p[1], p[2])
                    }
                    return !l.apply(this, p)
                }
            }
            function FO(l) {
                return dS(2, l)
            }
            var BO = ED(function(l, p) {
                p = p.length == 1 && Ft(p[0]) ? In(p[0], Nr(xt())) : In(Mi(p, 1), Nr(xt()));
                var x = p.length;
                return Wt(function(M) {
                    for (var L = -1, U = Ii(M.length, x); ++L < U; )
                        M[L] = p[L].call(this, M[L]);
                    return Or(l, this, M)
                })
            })
              , yg = Wt(function(l, p) {
                var x = Go(p, Jl(yg));
                return fo(l, b, t, p, x)
            })
              , vS = Wt(function(l, p) {
                var x = Go(p, Jl(vS));
                return fo(l, T, t, p, x)
            })
              , kO = ho(function(l, p) {
                return fo(l, P, t, t, t, p)
            });
            function zO(l, p) {
                if (typeof l != "function")
                    throw new is(o);
                return p = p === t ? p : zt(p),
                Wt(l, p)
            }
            function HO(l, p) {
                if (typeof l != "function")
                    throw new is(o);
                return p = p == null ? 0 : ai(zt(p), 0),
                Wt(function(x) {
                    var M = x[p]
                      , L = qo(x, 0, p);
                    return M && Ho(L, M),
                    Or(l, this, L)
                })
            }
            function GO(l, p, x) {
                var M = !0
                  , L = !0;
                if (typeof l != "function")
                    throw new is(o);
                return Nn(x) && (M = "leading"in x ? !!x.leading : M,
                L = "trailing"in x ? !!x.trailing : L),
                _S(l, p, {
                    leading: M,
                    maxWait: p,
                    trailing: L
                })
            }
            function VO(l) {
                return hS(l, 1)
            }
            function WO(l, p) {
                return yg(ig(p), l)
            }
            function $O() {
                if (!arguments.length)
                    return [];
                var l = arguments[0];
                return Ft(l) ? l : [l]
            }
            function XO(l) {
                return ss(l, f)
            }
            function qO(l, p) {
                return p = typeof p == "function" ? p : t,
                ss(l, f, p)
            }
            function jO(l) {
                return ss(l, m | f)
            }
            function YO(l, p) {
                return p = typeof p == "function" ? p : t,
                ss(l, m | f, p)
            }
            function KO(l, p) {
                return p == null || sb(l, p, hi(p))
            }
            function ws(l, p) {
                return l === p || l !== l && p !== p
            }
            var ZO = Hh($m)
              , JO = Hh(function(l, p) {
                return l >= p
            })
              , Va = fb(function() {
                return arguments
            }()) ? fb : function(l) {
                return Hn(l) && hn.call(l, "callee") && !Zx.call(l, "callee")
            }
              , Ft = de.isArray
              , QO = Dx ? Nr(Dx) : aD;
            function gr(l) {
                return l != null && Kh(l.length) && !mo(l)
            }
            function $n(l) {
                return Hn(l) && gr(l)
            }
            function eN(l) {
                return l === !0 || l === !1 || Hn(l) && qi(l) == He
            }
            var jo = p3 || Pg
              , tN = Ix ? Nr(Ix) : lD;
            function nN(l) {
                return Hn(l) && l.nodeType === 1 && !Tu(l)
            }
            function iN(l) {
                if (l == null)
                    return !0;
                if (gr(l) && (Ft(l) || typeof l == "string" || typeof l.splice == "function" || jo(l) || Ql(l) || Va(l)))
                    return !l.length;
                var p = Oi(l);
                if (p == Ne || p == pt)
                    return !l.size;
                if (Au(l))
                    return !jm(l).length;
                for (var x in l)
                    if (hn.call(l, x))
                        return !1;
                return !0
            }
            function rN(l, p) {
                return Su(l, p)
            }
            function sN(l, p, x) {
                x = typeof x == "function" ? x : t;
                var M = x ? x(l, p) : t;
                return M === t ? Su(l, p, t, x) : !!M
            }
            function xg(l) {
                if (!Hn(l))
                    return !1;
                var p = qi(l);
                return p == st || p == Xe || typeof l.message == "string" && typeof l.name == "string" && !Tu(l)
            }
            function oN(l) {
                return typeof l == "number" && Qx(l)
            }
            function mo(l) {
                if (!Nn(l))
                    return !1;
                var p = qi(l);
                return p == ie || p == dt || p == Ue || p == ft
            }
            function yS(l) {
                return typeof l == "number" && l == zt(l)
            }
            function Kh(l) {
                return typeof l == "number" && l > -1 && l % 1 == 0 && l <= ee
            }
            function Nn(l) {
                var p = typeof l;
                return l != null && (p == "object" || p == "function")
            }
            function Hn(l) {
                return l != null && typeof l == "object"
            }
            var xS = Ox ? Nr(Ox) : uD;
            function aN(l, p) {
                return l === p || qm(l, p, ug(p))
            }
            function lN(l, p, x) {
                return x = typeof x == "function" ? x : t,
                qm(l, p, ug(p), x)
            }
            function cN(l) {
                return bS(l) && l != +l
            }
            function uN(l) {
                if (qD(l))
                    throw new Nt(s);
                return hb(l)
            }
            function fN(l) {
                return l === null
            }
            function hN(l) {
                return l == null
            }
            function bS(l) {
                return typeof l == "number" || Hn(l) && qi(l) == Ye
            }
            function Tu(l) {
                if (!Hn(l) || qi(l) != te)
                    return !1;
                var p = wh(l);
                if (p === null)
                    return !0;
                var x = hn.call(p, "constructor") && p.constructor;
                return typeof x == "function" && x instanceof x && yh.call(x) == l3
            }
            var bg = Nx ? Nr(Nx) : fD;
            function dN(l) {
                return yS(l) && l >= -ee && l <= ee
            }
            var SS = Ux ? Nr(Ux) : hD;
            function Zh(l) {
                return typeof l == "string" || !Ft(l) && Hn(l) && qi(l) == Ct
            }
            function Fr(l) {
                return typeof l == "symbol" || Hn(l) && qi(l) == z
            }
            var Ql = Fx ? Nr(Fx) : dD;
            function pN(l) {
                return l === t
            }
            function mN(l) {
                return Hn(l) && Oi(l) == j
            }
            function gN(l) {
                return Hn(l) && qi(l) == he
            }
            var _N = Hh(Ym)
              , vN = Hh(function(l, p) {
                return l <= p
            });
            function wS(l) {
                if (!l)
                    return [];
                if (gr(l))
                    return Zh(l) ? bs(l) : mr(l);
                if (pu && l[pu])
                    return KL(l[pu]());
                var p = Oi(l)
                  , x = p == Ne ? Um : p == pt ? gh : ec;
                return x(l)
            }
            function go(l) {
                if (!l)
                    return l === 0 ? l : 0;
                if (l = ls(l),
                l === V || l === -V) {
                    var p = l < 0 ? -1 : 1;
                    return p * re
                }
                return l === l ? l : 0
            }
            function zt(l) {
                var p = go(l)
                  , x = p % 1;
                return p === p ? x ? p - x : p : 0
            }
            function ES(l) {
                return l ? ka(zt(l), 0, oe) : 0
            }
            function ls(l) {
                if (typeof l == "number")
                    return l;
                if (Fr(l))
                    return k;
                if (Nn(l)) {
                    var p = typeof l.valueOf == "function" ? l.valueOf() : l;
                    l = Nn(p) ? p + "" : p
                }
                if (typeof l != "string")
                    return l === 0 ? l : +l;
                l = Vx(l);
                var x = J.test(l);
                return x || ue.test(l) ? IL(l.slice(2), x ? 2 : 8) : F.test(l) ? k : +l
            }
            function AS(l) {
                return Vs(l, _r(l))
            }
            function yN(l) {
                return l ? ka(zt(l), -ee, ee) : l === 0 ? l : 0
            }
            function fn(l) {
                return l == null ? "" : Ur(l)
            }
            var xN = Kl(function(l, p) {
                if (Au(p) || gr(p)) {
                    Vs(p, hi(p), l);
                    return
                }
                for (var x in p)
                    hn.call(p, x) && yu(l, x, p[x])
            })
              , MS = Kl(function(l, p) {
                Vs(p, _r(p), l)
            })
              , Jh = Kl(function(l, p, x, M) {
                Vs(p, _r(p), l, M)
            })
              , bN = Kl(function(l, p, x, M) {
                Vs(p, hi(p), l, M)
            })
              , SN = ho(Gm);
            function wN(l, p) {
                var x = Yl(l);
                return p == null ? x : rb(x, p)
            }
            var EN = Wt(function(l, p) {
                l = yn(l);
                var x = -1
                  , M = p.length
                  , L = M > 2 ? p[2] : t;
                for (L && ji(p[0], p[1], L) && (M = 1); ++x < M; )
                    for (var U = p[x], $ = _r(U), q = -1, Q = $.length; ++q < Q; ) {
                        var ye = $[q]
                          , be = l[ye];
                        (be === t || ws(be, Xl[ye]) && !hn.call(l, ye)) && (l[ye] = U[ye])
                    }
                return l
            })
              , AN = Wt(function(l) {
                return l.push(t, Vb),
                Or(TS, t, l)
            });
            function MN(l, p) {
                return kx(l, xt(p, 3), Gs)
            }
            function TN(l, p) {
                return kx(l, xt(p, 3), Wm)
            }
            function CN(l, p) {
                return l == null ? l : Vm(l, xt(p, 3), _r)
            }
            function RN(l, p) {
                return l == null ? l : cb(l, xt(p, 3), _r)
            }
            function PN(l, p) {
                return l && Gs(l, xt(p, 3))
            }
            function LN(l, p) {
                return l && Wm(l, xt(p, 3))
            }
            function DN(l) {
                return l == null ? [] : Ih(l, hi(l))
            }
            function IN(l) {
                return l == null ? [] : Ih(l, _r(l))
            }
            function Sg(l, p, x) {
                var M = l == null ? t : za(l, p);
                return M === t ? x : M
            }
            function ON(l, p) {
                return l != null && Xb(l, p, iD)
            }
            function wg(l, p) {
                return l != null && Xb(l, p, rD)
            }
            var NN = Bb(function(l, p, x) {
                p != null && typeof p.toString != "function" && (p = xh.call(p)),
                l[p] = x
            }, Ag(vr))
              , UN = Bb(function(l, p, x) {
                p != null && typeof p.toString != "function" && (p = xh.call(p)),
                hn.call(l, p) ? l[p].push(x) : l[p] = [x]
            }, xt)
              , FN = Wt(bu);
            function hi(l) {
                return gr(l) ? nb(l) : jm(l)
            }
            function _r(l) {
                return gr(l) ? nb(l, !0) : pD(l)
            }
            function BN(l, p) {
                var x = {};
                return p = xt(p, 3),
                Gs(l, function(M, L, U) {
                    uo(x, p(M, L, U), M)
                }),
                x
            }
            function kN(l, p) {
                var x = {};
                return p = xt(p, 3),
                Gs(l, function(M, L, U) {
                    uo(x, L, p(M, L, U))
                }),
                x
            }
            var zN = Kl(function(l, p, x) {
                Oh(l, p, x)
            })
              , TS = Kl(function(l, p, x, M) {
                Oh(l, p, x, M)
            })
              , HN = ho(function(l, p) {
                var x = {};
                if (l == null)
                    return x;
                var M = !1;
                p = In(p, function(U) {
                    return U = Xo(U, l),
                    M || (M = U.length > 1),
                    U
                }),
                Vs(l, lg(l), x),
                M && (x = ss(x, m | d | f, ND));
                for (var L = p.length; L--; )
                    eg(x, p[L]);
                return x
            });
            function GN(l, p) {
                return CS(l, Yh(xt(p)))
            }
            var VN = ho(function(l, p) {
                return l == null ? {} : gD(l, p)
            });
            function CS(l, p) {
                if (l == null)
                    return {};
                var x = In(lg(l), function(M) {
                    return [M]
                });
                return p = xt(p),
                yb(l, x, function(M, L) {
                    return p(M, L[0])
                })
            }
            function WN(l, p, x) {
                p = Xo(p, l);
                var M = -1
                  , L = p.length;
                for (L || (L = 1,
                l = t); ++M < L; ) {
                    var U = l == null ? t : l[Ws(p[M])];
                    U === t && (M = L,
                    U = x),
                    l = mo(U) ? U.call(l) : U
                }
                return l
            }
            function $N(l, p, x) {
                return l == null ? l : wu(l, p, x)
            }
            function XN(l, p, x, M) {
                return M = typeof M == "function" ? M : t,
                l == null ? l : wu(l, p, x, M)
            }
            var RS = Hb(hi)
              , PS = Hb(_r);
            function qN(l, p, x) {
                var M = Ft(l)
                  , L = M || jo(l) || Ql(l);
                if (p = xt(p, 4),
                x == null) {
                    var U = l && l.constructor;
                    L ? x = M ? new U : [] : Nn(l) ? x = mo(U) ? Yl(wh(l)) : {} : x = {}
                }
                return (L ? ns : Gs)(l, function($, q, Q) {
                    return p(x, $, q, Q)
                }),
                x
            }
            function jN(l, p) {
                return l == null ? !0 : eg(l, p)
            }
            function YN(l, p, x) {
                return l == null ? l : Eb(l, p, ig(x))
            }
            function KN(l, p, x, M) {
                return M = typeof M == "function" ? M : t,
                l == null ? l : Eb(l, p, ig(x), M)
            }
            function ec(l) {
                return l == null ? [] : Nm(l, hi(l))
            }
            function ZN(l) {
                return l == null ? [] : Nm(l, _r(l))
            }
            function JN(l, p, x) {
                return x === t && (x = p,
                p = t),
                x !== t && (x = ls(x),
                x = x === x ? x : 0),
                p !== t && (p = ls(p),
                p = p === p ? p : 0),
                ka(ls(l), p, x)
            }
            function QN(l, p, x) {
                return p = go(p),
                x === t ? (x = p,
                p = 0) : x = go(x),
                l = ls(l),
                sD(l, p, x)
            }
            function eU(l, p, x) {
                if (x && typeof x != "boolean" && ji(l, p, x) && (p = x = t),
                x === t && (typeof p == "boolean" ? (x = p,
                p = t) : typeof l == "boolean" && (x = l,
                l = t)),
                l === t && p === t ? (l = 0,
                p = 1) : (l = go(l),
                p === t ? (p = l,
                l = 0) : p = go(p)),
                l > p) {
                    var M = l;
                    l = p,
                    p = M
                }
                if (x || l % 1 || p % 1) {
                    var L = eb();
                    return Ii(l + L * (p - l + DL("1e-" + ((L + "").length - 1))), p)
                }
                return Zm(l, p)
            }
            var tU = Zl(function(l, p, x) {
                return p = p.toLowerCase(),
                l + (x ? LS(p) : p)
            });
            function LS(l) {
                return Eg(fn(l).toLowerCase())
            }
            function DS(l) {
                return l = fn(l),
                l && l.replace(ke, $L).replace(SL, "")
            }
            function nU(l, p, x) {
                l = fn(l),
                p = Ur(p);
                var M = l.length;
                x = x === t ? M : ka(zt(x), 0, M);
                var L = x;
                return x -= p.length,
                x >= 0 && l.slice(x, L) == p
            }
            function iU(l) {
                return l = fn(l),
                l && ge.test(l) ? l.replace(ze, XL) : l
            }
            function rU(l) {
                return l = fn(l),
                l && bt.test(l) ? l.replace(Be, "\\$&") : l
            }
            var sU = Zl(function(l, p, x) {
                return l + (x ? "-" : "") + p.toLowerCase()
            })
              , oU = Zl(function(l, p, x) {
                return l + (x ? " " : "") + p.toLowerCase()
            })
              , aU = Nb("toLowerCase");
            function lU(l, p, x) {
                l = fn(l),
                p = zt(p);
                var M = p ? Wl(l) : 0;
                if (!p || M >= p)
                    return l;
                var L = (p - M) / 2;
                return zh(Th(L), x) + l + zh(Mh(L), x)
            }
            function cU(l, p, x) {
                l = fn(l),
                p = zt(p);
                var M = p ? Wl(l) : 0;
                return p && M < p ? l + zh(p - M, x) : l
            }
            function uU(l, p, x) {
                l = fn(l),
                p = zt(p);
                var M = p ? Wl(l) : 0;
                return p && M < p ? zh(p - M, x) + l : l
            }
            function fU(l, p, x) {
                return x || p == null ? p = 0 : p && (p = +p),
                v3(fn(l).replace(yt, ""), p || 0)
            }
            function hU(l, p, x) {
                return (x ? ji(l, p, x) : p === t) ? p = 1 : p = zt(p),
                Jm(fn(l), p)
            }
            function dU() {
                var l = arguments
                  , p = fn(l[0]);
                return l.length < 3 ? p : p.replace(l[1], l[2])
            }
            var pU = Zl(function(l, p, x) {
                return l + (x ? "_" : "") + p.toLowerCase()
            });
            function mU(l, p, x) {
                return x && typeof x != "number" && ji(l, p, x) && (p = x = t),
                x = x === t ? oe : x >>> 0,
                x ? (l = fn(l),
                l && (typeof p == "string" || p != null && !bg(p)) && (p = Ur(p),
                !p && Vl(l)) ? qo(bs(l), 0, x) : l.split(p, x)) : []
            }
            var gU = Zl(function(l, p, x) {
                return l + (x ? " " : "") + Eg(p)
            });
            function _U(l, p, x) {
                return l = fn(l),
                x = x == null ? 0 : ka(zt(x), 0, l.length),
                p = Ur(p),
                l.slice(x, x + p.length) == p
            }
            function vU(l, p, x) {
                var M = O.templateSettings;
                x && ji(l, p, x) && (p = t),
                l = fn(l),
                p = Jh({}, p, M, Gb);
                var L = Jh({}, p.imports, M.imports, Gb), U = hi(L), $ = Nm(L, U), q, Q, ye = 0, be = p.interpolate || et, Ce = "__p += '", $e = Fm((p.escape || et).source + "|" + be.source + "|" + (be === Ge ? ln : et).source + "|" + (p.evaluate || et).source + "|$", "g"), ct = "//# sourceURL=" + (hn.call(p, "sourceURL") ? (p.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++TL + "]") + `
`;
                l.replace($e, function(wt, Yt, nn, Br, Yi, kr) {
                    return nn || (nn = Br),
                    Ce += l.slice(ye, kr).replace(mt, qL),
                    Yt && (q = !0,
                    Ce += `' +
__e(` + Yt + `) +
'`),
                    Yi && (Q = !0,
                    Ce += `';
` + Yi + `;
__p += '`),
                    nn && (Ce += `' +
((__t = (` + nn + `)) == null ? '' : __t) +
'`),
                    ye = kr + wt.length,
                    wt
                }),
                Ce += `';
`;
                var St = hn.call(p, "variable") && p.variable;
                if (!St)
                    Ce = `with (obj) {
` + Ce + `
}
`;
                else if (On.test(St))
                    throw new Nt(a);
                Ce = (Q ? Ce.replace(at, "") : Ce).replace(Le, "$1").replace(Lt, "$1;"),
                Ce = "function(" + (St || "obj") + `) {
` + (St ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (q ? ", __e = _.escape" : "") + (Q ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Ce + `return __p
}`;
                var Ht = OS(function() {
                    return cn(U, ct + "return " + Ce).apply(t, $)
                });
                if (Ht.source = Ce,
                xg(Ht))
                    throw Ht;
                return Ht
            }
            function yU(l) {
                return fn(l).toLowerCase()
            }
            function xU(l) {
                return fn(l).toUpperCase()
            }
            function bU(l, p, x) {
                if (l = fn(l),
                l && (x || p === t))
                    return Vx(l);
                if (!l || !(p = Ur(p)))
                    return l;
                var M = bs(l)
                  , L = bs(p)
                  , U = Wx(M, L)
                  , $ = $x(M, L) + 1;
                return qo(M, U, $).join("")
            }
            function SU(l, p, x) {
                if (l = fn(l),
                l && (x || p === t))
                    return l.slice(0, qx(l) + 1);
                if (!l || !(p = Ur(p)))
                    return l;
                var M = bs(l)
                  , L = $x(M, bs(p)) + 1;
                return qo(M, 0, L).join("")
            }
            function wU(l, p, x) {
                if (l = fn(l),
                l && (x || p === t))
                    return l.replace(yt, "");
                if (!l || !(p = Ur(p)))
                    return l;
                var M = bs(l)
                  , L = Wx(M, bs(p));
                return qo(M, L).join("")
            }
            function EU(l, p) {
                var x = R
                  , M = I;
                if (Nn(p)) {
                    var L = "separator"in p ? p.separator : L;
                    x = "length"in p ? zt(p.length) : x,
                    M = "omission"in p ? Ur(p.omission) : M
                }
                l = fn(l);
                var U = l.length;
                if (Vl(l)) {
                    var $ = bs(l);
                    U = $.length
                }
                if (x >= U)
                    return l;
                var q = x - Wl(M);
                if (q < 1)
                    return M;
                var Q = $ ? qo($, 0, q).join("") : l.slice(0, q);
                if (L === t)
                    return Q + M;
                if ($ && (q += Q.length - q),
                bg(L)) {
                    if (l.slice(q).search(L)) {
                        var ye, be = Q;
                        for (L.global || (L = Fm(L.source, fn(Di.exec(L)) + "g")),
                        L.lastIndex = 0; ye = L.exec(be); )
                            var Ce = ye.index;
                        Q = Q.slice(0, Ce === t ? q : Ce)
                    }
                } else if (l.indexOf(Ur(L), q) != q) {
                    var $e = Q.lastIndexOf(L);
                    $e > -1 && (Q = Q.slice(0, $e))
                }
                return Q + M
            }
            function AU(l) {
                return l = fn(l),
                l && De.test(l) ? l.replace(Y, e3) : l
            }
            var MU = Zl(function(l, p, x) {
                return l + (x ? " " : "") + p.toUpperCase()
            })
              , Eg = Nb("toUpperCase");
            function IS(l, p, x) {
                return l = fn(l),
                p = x ? t : p,
                p === t ? YL(l) ? i3(l) : zL(l) : l.match(p) || []
            }
            var OS = Wt(function(l, p) {
                try {
                    return Or(l, t, p)
                } catch (x) {
                    return xg(x) ? x : new Nt(x)
                }
            })
              , TU = ho(function(l, p) {
                return ns(p, function(x) {
                    x = Ws(x),
                    uo(l, x, vg(l[x], l))
                }),
                l
            });
            function CU(l) {
                var p = l == null ? 0 : l.length
                  , x = xt();
                return l = p ? In(l, function(M) {
                    if (typeof M[1] != "function")
                        throw new is(o);
                    return [x(M[0]), M[1]]
                }) : [],
                Wt(function(M) {
                    for (var L = -1; ++L < p; ) {
                        var U = l[L];
                        if (Or(U[0], this, M))
                            return Or(U[1], this, M)
                    }
                })
            }
            function RU(l) {
                return eD(ss(l, m))
            }
            function Ag(l) {
                return function() {
                    return l
                }
            }
            function PU(l, p) {
                return l == null || l !== l ? p : l
            }
            var LU = Fb()
              , DU = Fb(!0);
            function vr(l) {
                return l
            }
            function Mg(l) {
                return db(typeof l == "function" ? l : ss(l, m))
            }
            function IU(l) {
                return mb(ss(l, m))
            }
            function OU(l, p) {
                return gb(l, ss(p, m))
            }
            var NU = Wt(function(l, p) {
                return function(x) {
                    return bu(x, l, p)
                }
            })
              , UU = Wt(function(l, p) {
                return function(x) {
                    return bu(l, x, p)
                }
            });
            function Tg(l, p, x) {
                var M = hi(p)
                  , L = Ih(p, M);
                x == null && !(Nn(p) && (L.length || !M.length)) && (x = p,
                p = l,
                l = this,
                L = Ih(p, hi(p)));
                var U = !(Nn(x) && "chain"in x) || !!x.chain
                  , $ = mo(l);
                return ns(L, function(q) {
                    var Q = p[q];
                    l[q] = Q,
                    $ && (l.prototype[q] = function() {
                        var ye = this.__chain__;
                        if (U || ye) {
                            var be = l(this.__wrapped__)
                              , Ce = be.__actions__ = mr(this.__actions__);
                            return Ce.push({
                                func: Q,
                                args: arguments,
                                thisArg: l
                            }),
                            be.__chain__ = ye,
                            be
                        }
                        return Q.apply(l, Ho([this.value()], arguments))
                    }
                    )
                }),
                l
            }
            function FU() {
                return Ai._ === this && (Ai._ = c3),
                this
            }
            function Cg() {}
            function BU(l) {
                return l = zt(l),
                Wt(function(p) {
                    return _b(p, l)
                })
            }
            var kU = sg(In)
              , zU = sg(Bx)
              , HU = sg(Pm);
            function NS(l) {
                return hg(l) ? Lm(Ws(l)) : _D(l)
            }
            function GU(l) {
                return function(p) {
                    return l == null ? t : za(l, p)
                }
            }
            var VU = kb()
              , WU = kb(!0);
            function Rg() {
                return []
            }
            function Pg() {
                return !1
            }
            function $U() {
                return {}
            }
            function XU() {
                return ""
            }
            function qU() {
                return !0
            }
            function jU(l, p) {
                if (l = zt(l),
                l < 1 || l > ee)
                    return [];
                var x = oe
                  , M = Ii(l, oe);
                p = xt(p),
                l -= oe;
                for (var L = Om(M, p); ++x < l; )
                    p(x);
                return L
            }
            function YU(l) {
                return Ft(l) ? In(l, Ws) : Fr(l) ? [l] : mr(tS(fn(l)))
            }
            function KU(l) {
                var p = ++a3;
                return fn(l) + p
            }
            var ZU = kh(function(l, p) {
                return l + p
            }, 0)
              , JU = og("ceil")
              , QU = kh(function(l, p) {
                return l / p
            }, 1)
              , eF = og("floor");
            function tF(l) {
                return l && l.length ? Dh(l, vr, $m) : t
            }
            function nF(l, p) {
                return l && l.length ? Dh(l, xt(p, 2), $m) : t
            }
            function iF(l) {
                return Hx(l, vr)
            }
            function rF(l, p) {
                return Hx(l, xt(p, 2))
            }
            function sF(l) {
                return l && l.length ? Dh(l, vr, Ym) : t
            }
            function oF(l, p) {
                return l && l.length ? Dh(l, xt(p, 2), Ym) : t
            }
            var aF = kh(function(l, p) {
                return l * p
            }, 1)
              , lF = og("round")
              , cF = kh(function(l, p) {
                return l - p
            }, 0);
            function uF(l) {
                return l && l.length ? Im(l, vr) : 0
            }
            function fF(l, p) {
                return l && l.length ? Im(l, xt(p, 2)) : 0
            }
            return O.after = IO,
            O.ary = hS,
            O.assign = xN,
            O.assignIn = MS,
            O.assignInWith = Jh,
            O.assignWith = bN,
            O.at = SN,
            O.before = dS,
            O.bind = vg,
            O.bindAll = TU,
            O.bindKey = pS,
            O.castArray = $O,
            O.chain = cS,
            O.chunk = eI,
            O.compact = tI,
            O.concat = nI,
            O.cond = CU,
            O.conforms = RU,
            O.constant = Ag,
            O.countBy = uO,
            O.create = wN,
            O.curry = mS,
            O.curryRight = gS,
            O.debounce = _S,
            O.defaults = EN,
            O.defaultsDeep = AN,
            O.defer = OO,
            O.delay = NO,
            O.difference = iI,
            O.differenceBy = rI,
            O.differenceWith = sI,
            O.drop = oI,
            O.dropRight = aI,
            O.dropRightWhile = lI,
            O.dropWhile = cI,
            O.fill = uI,
            O.filter = hO,
            O.flatMap = mO,
            O.flatMapDeep = gO,
            O.flatMapDepth = _O,
            O.flatten = sS,
            O.flattenDeep = fI,
            O.flattenDepth = hI,
            O.flip = UO,
            O.flow = LU,
            O.flowRight = DU,
            O.fromPairs = dI,
            O.functions = DN,
            O.functionsIn = IN,
            O.groupBy = vO,
            O.initial = mI,
            O.intersection = gI,
            O.intersectionBy = _I,
            O.intersectionWith = vI,
            O.invert = NN,
            O.invertBy = UN,
            O.invokeMap = xO,
            O.iteratee = Mg,
            O.keyBy = bO,
            O.keys = hi,
            O.keysIn = _r,
            O.map = Xh,
            O.mapKeys = BN,
            O.mapValues = kN,
            O.matches = IU,
            O.matchesProperty = OU,
            O.memoize = jh,
            O.merge = zN,
            O.mergeWith = TS,
            O.method = NU,
            O.methodOf = UU,
            O.mixin = Tg,
            O.negate = Yh,
            O.nthArg = BU,
            O.omit = HN,
            O.omitBy = GN,
            O.once = FO,
            O.orderBy = SO,
            O.over = kU,
            O.overArgs = BO,
            O.overEvery = zU,
            O.overSome = HU,
            O.partial = yg,
            O.partialRight = vS,
            O.partition = wO,
            O.pick = VN,
            O.pickBy = CS,
            O.property = NS,
            O.propertyOf = GU,
            O.pull = SI,
            O.pullAll = aS,
            O.pullAllBy = wI,
            O.pullAllWith = EI,
            O.pullAt = AI,
            O.range = VU,
            O.rangeRight = WU,
            O.rearg = kO,
            O.reject = MO,
            O.remove = MI,
            O.rest = zO,
            O.reverse = gg,
            O.sampleSize = CO,
            O.set = $N,
            O.setWith = XN,
            O.shuffle = RO,
            O.slice = TI,
            O.sortBy = DO,
            O.sortedUniq = OI,
            O.sortedUniqBy = NI,
            O.split = mU,
            O.spread = HO,
            O.tail = UI,
            O.take = FI,
            O.takeRight = BI,
            O.takeRightWhile = kI,
            O.takeWhile = zI,
            O.tap = tO,
            O.throttle = GO,
            O.thru = $h,
            O.toArray = wS,
            O.toPairs = RS,
            O.toPairsIn = PS,
            O.toPath = YU,
            O.toPlainObject = AS,
            O.transform = qN,
            O.unary = VO,
            O.union = HI,
            O.unionBy = GI,
            O.unionWith = VI,
            O.uniq = WI,
            O.uniqBy = $I,
            O.uniqWith = XI,
            O.unset = jN,
            O.unzip = _g,
            O.unzipWith = lS,
            O.update = YN,
            O.updateWith = KN,
            O.values = ec,
            O.valuesIn = ZN,
            O.without = qI,
            O.words = IS,
            O.wrap = WO,
            O.xor = jI,
            O.xorBy = YI,
            O.xorWith = KI,
            O.zip = ZI,
            O.zipObject = JI,
            O.zipObjectDeep = QI,
            O.zipWith = eO,
            O.entries = RS,
            O.entriesIn = PS,
            O.extend = MS,
            O.extendWith = Jh,
            Tg(O, O),
            O.add = ZU,
            O.attempt = OS,
            O.camelCase = tU,
            O.capitalize = LS,
            O.ceil = JU,
            O.clamp = JN,
            O.clone = XO,
            O.cloneDeep = jO,
            O.cloneDeepWith = YO,
            O.cloneWith = qO,
            O.conformsTo = KO,
            O.deburr = DS,
            O.defaultTo = PU,
            O.divide = QU,
            O.endsWith = nU,
            O.eq = ws,
            O.escape = iU,
            O.escapeRegExp = rU,
            O.every = fO,
            O.find = dO,
            O.findIndex = iS,
            O.findKey = MN,
            O.findLast = pO,
            O.findLastIndex = rS,
            O.findLastKey = TN,
            O.floor = eF,
            O.forEach = uS,
            O.forEachRight = fS,
            O.forIn = CN,
            O.forInRight = RN,
            O.forOwn = PN,
            O.forOwnRight = LN,
            O.get = Sg,
            O.gt = ZO,
            O.gte = JO,
            O.has = ON,
            O.hasIn = wg,
            O.head = oS,
            O.identity = vr,
            O.includes = yO,
            O.indexOf = pI,
            O.inRange = QN,
            O.invoke = FN,
            O.isArguments = Va,
            O.isArray = Ft,
            O.isArrayBuffer = QO,
            O.isArrayLike = gr,
            O.isArrayLikeObject = $n,
            O.isBoolean = eN,
            O.isBuffer = jo,
            O.isDate = tN,
            O.isElement = nN,
            O.isEmpty = iN,
            O.isEqual = rN,
            O.isEqualWith = sN,
            O.isError = xg,
            O.isFinite = oN,
            O.isFunction = mo,
            O.isInteger = yS,
            O.isLength = Kh,
            O.isMap = xS,
            O.isMatch = aN,
            O.isMatchWith = lN,
            O.isNaN = cN,
            O.isNative = uN,
            O.isNil = hN,
            O.isNull = fN,
            O.isNumber = bS,
            O.isObject = Nn,
            O.isObjectLike = Hn,
            O.isPlainObject = Tu,
            O.isRegExp = bg,
            O.isSafeInteger = dN,
            O.isSet = SS,
            O.isString = Zh,
            O.isSymbol = Fr,
            O.isTypedArray = Ql,
            O.isUndefined = pN,
            O.isWeakMap = mN,
            O.isWeakSet = gN,
            O.join = yI,
            O.kebabCase = sU,
            O.last = as,
            O.lastIndexOf = xI,
            O.lowerCase = oU,
            O.lowerFirst = aU,
            O.lt = _N,
            O.lte = vN,
            O.max = tF,
            O.maxBy = nF,
            O.mean = iF,
            O.meanBy = rF,
            O.min = sF,
            O.minBy = oF,
            O.stubArray = Rg,
            O.stubFalse = Pg,
            O.stubObject = $U,
            O.stubString = XU,
            O.stubTrue = qU,
            O.multiply = aF,
            O.nth = bI,
            O.noConflict = FU,
            O.noop = Cg,
            O.now = qh,
            O.pad = lU,
            O.padEnd = cU,
            O.padStart = uU,
            O.parseInt = fU,
            O.random = eU,
            O.reduce = EO,
            O.reduceRight = AO,
            O.repeat = hU,
            O.replace = dU,
            O.result = WN,
            O.round = lF,
            O.runInContext = Z,
            O.sample = TO,
            O.size = PO,
            O.snakeCase = pU,
            O.some = LO,
            O.sortedIndex = CI,
            O.sortedIndexBy = RI,
            O.sortedIndexOf = PI,
            O.sortedLastIndex = LI,
            O.sortedLastIndexBy = DI,
            O.sortedLastIndexOf = II,
            O.startCase = gU,
            O.startsWith = _U,
            O.subtract = cF,
            O.sum = uF,
            O.sumBy = fF,
            O.template = vU,
            O.times = jU,
            O.toFinite = go,
            O.toInteger = zt,
            O.toLength = ES,
            O.toLower = yU,
            O.toNumber = ls,
            O.toSafeInteger = yN,
            O.toString = fn,
            O.toUpper = xU,
            O.trim = bU,
            O.trimEnd = SU,
            O.trimStart = wU,
            O.truncate = EU,
            O.unescape = AU,
            O.uniqueId = KU,
            O.upperCase = MU,
            O.upperFirst = Eg,
            O.each = uS,
            O.eachRight = fS,
            O.first = oS,
            Tg(O, function() {
                var l = {};
                return Gs(O, function(p, x) {
                    hn.call(O.prototype, x) || (l[x] = p)
                }),
                l
            }(), {
                chain: !1
            }),
            O.VERSION = i,
            ns(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(l) {
                O[l].placeholder = O
            }),
            ns(["drop", "take"], function(l, p) {
                Qt.prototype[l] = function(x) {
                    x = x === t ? 1 : ai(zt(x), 0);
                    var M = this.__filtered__ && !p ? new Qt(this) : this.clone();
                    return M.__filtered__ ? M.__takeCount__ = Ii(x, M.__takeCount__) : M.__views__.push({
                        size: Ii(x, oe),
                        type: l + (M.__dir__ < 0 ? "Right" : "")
                    }),
                    M
                }
                ,
                Qt.prototype[l + "Right"] = function(x) {
                    return this.reverse()[l](x).reverse()
                }
            }),
            ns(["filter", "map", "takeWhile"], function(l, p) {
                var x = p + 1
                  , M = x == B || x == X;
                Qt.prototype[l] = function(L) {
                    var U = this.clone();
                    return U.__iteratees__.push({
                        iteratee: xt(L, 3),
                        type: x
                    }),
                    U.__filtered__ = U.__filtered__ || M,
                    U
                }
            }),
            ns(["head", "last"], function(l, p) {
                var x = "take" + (p ? "Right" : "");
                Qt.prototype[l] = function() {
                    return this[x](1).value()[0]
                }
            }),
            ns(["initial", "tail"], function(l, p) {
                var x = "drop" + (p ? "" : "Right");
                Qt.prototype[l] = function() {
                    return this.__filtered__ ? new Qt(this) : this[x](1)
                }
            }),
            Qt.prototype.compact = function() {
                return this.filter(vr)
            }
            ,
            Qt.prototype.find = function(l) {
                return this.filter(l).head()
            }
            ,
            Qt.prototype.findLast = function(l) {
                return this.reverse().find(l)
            }
            ,
            Qt.prototype.invokeMap = Wt(function(l, p) {
                return typeof l == "function" ? new Qt(this) : this.map(function(x) {
                    return bu(x, l, p)
                })
            }),
            Qt.prototype.reject = function(l) {
                return this.filter(Yh(xt(l)))
            }
            ,
            Qt.prototype.slice = function(l, p) {
                l = zt(l);
                var x = this;
                return x.__filtered__ && (l > 0 || p < 0) ? new Qt(x) : (l < 0 ? x = x.takeRight(-l) : l && (x = x.drop(l)),
                p !== t && (p = zt(p),
                x = p < 0 ? x.dropRight(-p) : x.take(p - l)),
                x)
            }
            ,
            Qt.prototype.takeRightWhile = function(l) {
                return this.reverse().takeWhile(l).reverse()
            }
            ,
            Qt.prototype.toArray = function() {
                return this.take(oe)
            }
            ,
            Gs(Qt.prototype, function(l, p) {
                var x = /^(?:filter|find|map|reject)|While$/.test(p)
                  , M = /^(?:head|last)$/.test(p)
                  , L = O[M ? "take" + (p == "last" ? "Right" : "") : p]
                  , U = M || /^find/.test(p);
                L && (O.prototype[p] = function() {
                    var $ = this.__wrapped__
                      , q = M ? [1] : arguments
                      , Q = $ instanceof Qt
                      , ye = q[0]
                      , be = Q || Ft($)
                      , Ce = function(Yt) {
                        var nn = L.apply(O, Ho([Yt], q));
                        return M && $e ? nn[0] : nn
                    };
                    be && x && typeof ye == "function" && ye.length != 1 && (Q = be = !1);
                    var $e = this.__chain__
                      , ct = !!this.__actions__.length
                      , St = U && !$e
                      , Ht = Q && !ct;
                    if (!U && be) {
                        $ = Ht ? $ : new Qt(this);
                        var wt = l.apply($, q);
                        return wt.__actions__.push({
                            func: $h,
                            args: [Ce],
                            thisArg: t
                        }),
                        new rs(wt,$e)
                    }
                    return St && Ht ? l.apply(this, q) : (wt = this.thru(Ce),
                    St ? M ? wt.value()[0] : wt.value() : wt)
                }
                )
            }),
            ns(["pop", "push", "shift", "sort", "splice", "unshift"], function(l) {
                var p = _h[l]
                  , x = /^(?:push|sort|unshift)$/.test(l) ? "tap" : "thru"
                  , M = /^(?:pop|shift)$/.test(l);
                O.prototype[l] = function() {
                    var L = arguments;
                    if (M && !this.__chain__) {
                        var U = this.value();
                        return p.apply(Ft(U) ? U : [], L)
                    }
                    return this[x](function($) {
                        return p.apply(Ft($) ? $ : [], L)
                    })
                }
            }),
            Gs(Qt.prototype, function(l, p) {
                var x = O[p];
                if (x) {
                    var M = x.name + "";
                    hn.call(jl, M) || (jl[M] = []),
                    jl[M].push({
                        name: p,
                        func: x
                    })
                }
            }),
            jl[Bh(t, y).name] = [{
                name: "wrapper",
                func: t
            }],
            Qt.prototype.clone = A3,
            Qt.prototype.reverse = M3,
            Qt.prototype.value = T3,
            O.prototype.at = nO,
            O.prototype.chain = iO,
            O.prototype.commit = rO,
            O.prototype.next = sO,
            O.prototype.plant = aO,
            O.prototype.reverse = lO,
            O.prototype.toJSON = O.prototype.valueOf = O.prototype.value = cO,
            O.prototype.first = O.prototype.head,
            pu && (O.prototype[pu] = oO),
            O
        }
          , $l = r3();
        Na ? ((Na.exports = $l)._ = $l,
        Mm._ = $l) : Ai._ = $l
    }
    ).call(lr)
}
)(wp, wp.exports);
var Jt = wp.exports
  , $C = {
    exports: {}
};
(function(n) {
    (function() {
        function e(g, v) {
            document.addEventListener ? g.addEventListener("scroll", v, !1) : g.attachEvent("scroll", v)
        }
        function t(g) {
            document.body ? g() : document.addEventListener ? document.addEventListener("DOMContentLoaded", function v() {
                document.removeEventListener("DOMContentLoaded", v),
                g()
            }) : document.attachEvent("onreadystatechange", function v() {
                (document.readyState == "interactive" || document.readyState == "complete") && (document.detachEvent("onreadystatechange", v),
                g())
            })
        }
        function i(g) {
            this.g = document.createElement("div"),
            this.g.setAttribute("aria-hidden", "true"),
            this.g.appendChild(document.createTextNode(g)),
            this.h = document.createElement("span"),
            this.i = document.createElement("span"),
            this.m = document.createElement("span"),
            this.j = document.createElement("span"),
            this.l = -1,
            this.h.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",
            this.i.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",
            this.j.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",
            this.m.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;",
            this.h.appendChild(this.m),
            this.i.appendChild(this.j),
            this.g.appendChild(this.h),
            this.g.appendChild(this.i)
        }
        function r(g, v) {
            g.g.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + v + ";"
        }
        function s(g) {
            var v = g.g.offsetWidth
              , y = v + 100;
            return g.j.style.width = y + "px",
            g.i.scrollLeft = y,
            g.h.scrollLeft = g.h.scrollWidth + 100,
            g.l !== v ? (g.l = v,
            !0) : !1
        }
        function o(g, v) {
            function y() {
                var S = w;
                s(S) && S.g.parentNode !== null && v(S.l)
            }
            var w = g;
            e(g.h, y),
            e(g.i, y),
            s(g)
        }
        function a(g, v, y) {
            v = v || {},
            y = y || window,
            this.family = g,
            this.style = v.style || "normal",
            this.weight = v.weight || "normal",
            this.stretch = v.stretch || "normal",
            this.context = y
        }
        var c = null
          , u = null
          , h = null
          , m = null;
        function d(g) {
            return u === null && (f(g) && /Apple/.test(window.navigator.vendor) ? (g = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent),
            u = !!g && 603 > parseInt(g[1], 10)) : u = !1),
            u
        }
        function f(g) {
            return m === null && (m = !!g.document.fonts),
            m
        }
        function _(g, v) {
            var y = g.style
              , w = g.weight;
            if (h === null) {
                var S = document.createElement("div");
                try {
                    S.style.font = "condensed 100px sans-serif"
                } catch {}
                h = S.style.font !== ""
            }
            return [y, w, h ? g.stretch : "", "100px", v].join(" ")
        }
        a.prototype.load = function(g, v) {
            var y = this
              , w = g || "BESbswy"
              , S = 0
              , E = v || 3e3
              , b = new Date().getTime();
            return new Promise(function(T, C) {
                if (f(y.context) && !d(y.context)) {
                    var P = new Promise(function(R, I) {
                        function D() {
                            new Date().getTime() - b >= E ? I(Error("" + E + "ms timeout exceeded")) : y.context.document.fonts.load(_(y, '"' + y.family + '"'), w).then(function(H) {
                                1 <= H.length ? R() : setTimeout(D, 25)
                            }, I)
                        }
                        D()
                    }
                    )
                      , A = new Promise(function(R, I) {
                        S = setTimeout(function() {
                            I(Error("" + E + "ms timeout exceeded"))
                        }, E)
                    }
                    );
                    Promise.race([A, P]).then(function() {
                        clearTimeout(S),
                        T(y)
                    }, C)
                } else
                    t(function() {
                        function R() {
                            var ae;
                            (ae = G != -1 && X != -1 || G != -1 && V != -1 || X != -1 && V != -1) && ((ae = G != X && G != V && X != V) || (c === null && (ae = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent),
                            c = !!ae && (536 > parseInt(ae[1], 10) || parseInt(ae[1], 10) === 536 && 11 >= parseInt(ae[2], 10))),
                            ae = c && (G == ee && X == ee && V == ee || G == re && X == re && V == re || G == k && X == k && V == k)),
                            ae = !ae),
                            ae && (oe.parentNode !== null && oe.parentNode.removeChild(oe),
                            clearTimeout(S),
                            T(y))
                        }
                        function I() {
                            if (new Date().getTime() - b >= E)
                                oe.parentNode !== null && oe.parentNode.removeChild(oe),
                                C(Error("" + E + "ms timeout exceeded"));
                            else {
                                var ae = y.context.document.hidden;
                                (ae === !0 || ae === void 0) && (G = D.g.offsetWidth,
                                X = H.g.offsetWidth,
                                V = B.g.offsetWidth,
                                R()),
                                S = setTimeout(I, 50)
                            }
                        }
                        var D = new i(w)
                          , H = new i(w)
                          , B = new i(w)
                          , G = -1
                          , X = -1
                          , V = -1
                          , ee = -1
                          , re = -1
                          , k = -1
                          , oe = document.createElement("div");
                        oe.dir = "ltr",
                        r(D, _(y, "sans-serif")),
                        r(H, _(y, "serif")),
                        r(B, _(y, "monospace")),
                        oe.appendChild(D.g),
                        oe.appendChild(H.g),
                        oe.appendChild(B.g),
                        y.context.document.body.appendChild(oe),
                        ee = D.g.offsetWidth,
                        re = H.g.offsetWidth,
                        k = B.g.offsetWidth,
                        I(),
                        o(D, function(ae) {
                            G = ae,
                            R()
                        }),
                        r(D, _(y, '"' + y.family + '",sans-serif')),
                        o(H, function(ae) {
                            X = ae,
                            R()
                        }),
                        r(H, _(y, '"' + y.family + '",serif')),
                        o(B, function(ae) {
                            V = ae,
                            R()
                        }),
                        r(B, _(y, '"' + y.family + '",monospace'))
                    })
            }
            )
        }
        ,
        n.exports = a
    }
    )()
}
)($C);
var pk = $C.exports;
const Yp = Uo(pk);
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Dy = "159"
  , mk = 0
  , Ew = 1
  , gk = 2
  , XC = 1
  , _k = 2
  , wo = 3
  , Ma = 0
  , Lr = 1
  , Co = 2
  , ya = 0
  , Uc = 1
  , Aw = 2
  , Mw = 3
  , Tw = 4
  , vk = 5
  , ol = 100
  , yk = 101
  , xk = 102
  , Cw = 103
  , Rw = 104
  , bk = 200
  , Sk = 201
  , wk = 202
  , Ek = 203
  , rv = 204
  , sv = 205
  , Ak = 206
  , Mk = 207
  , Tk = 208
  , Ck = 209
  , Rk = 210
  , Pk = 211
  , Lk = 212
  , Dk = 213
  , Ik = 214
  , Ok = 0
  , Nk = 1
  , Uk = 2
  , Ep = 3
  , Fk = 4
  , Bk = 5
  , kk = 6
  , zk = 7
  , qC = 0
  , Hk = 1
  , Gk = 2
  , xa = 0
  , Vk = 1
  , Wk = 2
  , $k = 3
  , Xk = 4
  , qk = 5
  , jC = 300
  , qc = 301
  , jc = 302
  , ov = 303
  , av = 304
  , Kp = 306
  , lv = 1e3
  , Os = 1001
  , cv = 1002
  , sr = 1003
  , Pw = 1004
  , qg = 1005
  , Er = 1006
  , jk = 1007
  , Hf = 1008
  , ba = 1009
  , Yk = 1010
  , Kk = 1011
  , Iy = 1012
  , YC = 1013
  , da = 1014
  , pa = 1015
  , Gf = 1016
  , KC = 1017
  , ZC = 1018
  , bl = 1020
  , Zk = 1021
  , Ns = 1023
  , Jk = 1024
  , Qk = 1025
  , Sl = 1026
  , Yc = 1027
  , e4 = 1028
  , JC = 1029
  , t4 = 1030
  , QC = 1031
  , eR = 1033
  , jg = 33776
  , Yg = 33777
  , Kg = 33778
  , Zg = 33779
  , Lw = 35840
  , Dw = 35841
  , Iw = 35842
  , Ow = 35843
  , tR = 36196
  , Nw = 37492
  , Uw = 37496
  , Fw = 37808
  , Bw = 37809
  , kw = 37810
  , zw = 37811
  , Hw = 37812
  , Gw = 37813
  , Vw = 37814
  , Ww = 37815
  , $w = 37816
  , Xw = 37817
  , qw = 37818
  , jw = 37819
  , Yw = 37820
  , Kw = 37821
  , Jg = 36492
  , Zw = 36494
  , Jw = 36495
  , n4 = 36283
  , Qw = 36284
  , e1 = 36285
  , t1 = 36286
  , nR = 3e3
  , wl = 3001
  , i4 = 3200
  , r4 = 3201
  , s4 = 0
  , o4 = 1
  , ms = ""
  , Ci = "srgb"
  , No = "srgb-linear"
  , Oy = "display-p3"
  , Zp = "display-p3-linear"
  , Ap = "linear"
  , Rn = "srgb"
  , Mp = "rec709"
  , Tp = "p3"
  , rc = 7680
  , n1 = 519
  , a4 = 512
  , l4 = 513
  , c4 = 514
  , iR = 515
  , u4 = 516
  , f4 = 517
  , h4 = 518
  , d4 = 519
  , i1 = 35044
  , r1 = "300 es"
  , uv = 1035
  , Po = 2e3
  , Cp = 2001;
class Qc {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const i = this._listeners;
        i[e] === void 0 && (i[e] = []),
        i[e].indexOf(t) === -1 && i[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const i = this._listeners;
        return i[e] !== void 0 && i[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const r = this._listeners[e];
        if (r !== void 0) {
            const s = r.indexOf(t);
            s !== -1 && r.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[e.type];
        if (i !== void 0) {
            e.target = this;
            const r = i.slice(0);
            for (let s = 0, o = r.length; s < o; s++)
                r[s].call(this, e);
            e.target = null
        }
    }
}
const Ni = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]
  , Qg = Math.PI / 180
  , fv = 180 / Math.PI;
function nh() {
    const n = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , i = Math.random() * 4294967295 | 0;
    return (Ni[n & 255] + Ni[n >> 8 & 255] + Ni[n >> 16 & 255] + Ni[n >> 24 & 255] + "-" + Ni[e & 255] + Ni[e >> 8 & 255] + "-" + Ni[e >> 16 & 15 | 64] + Ni[e >> 24 & 255] + "-" + Ni[t & 63 | 128] + Ni[t >> 8 & 255] + "-" + Ni[t >> 16 & 255] + Ni[t >> 24 & 255] + Ni[i & 255] + Ni[i >> 8 & 255] + Ni[i >> 16 & 255] + Ni[i >> 24 & 255]).toLowerCase()
}
function Ar(n, e, t) {
    return Math.max(e, Math.min(t, n))
}
function p4(n, e) {
    return (n % e + e) % e
}
function e0(n, e, t) {
    return (1 - t) * n + t * e
}
function s1(n) {
    return (n & n - 1) === 0 && n !== 0
}
function hv(n) {
    return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}
function Du(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint32Array:
        return n / 4294967295;
    case Uint16Array:
        return n / 65535;
    case Uint8Array:
        return n / 255;
    case Int32Array:
        return Math.max(n / 2147483647, -1);
    case Int16Array:
        return Math.max(n / 32767, -1);
    case Int8Array:
        return Math.max(n / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function xr(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint32Array:
        return Math.round(n * 4294967295);
    case Uint16Array:
        return Math.round(n * 65535);
    case Uint8Array:
        return Math.round(n * 255);
    case Int32Array:
        return Math.round(n * 2147483647);
    case Int16Array:
        return Math.round(n * 32767);
    case Int8Array:
        return Math.round(n * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
class on {
    constructor(e=0, t=0) {
        on.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , r = e.elements;
        return this.x = r[0] * t + r[3] * i + r[6],
        this.y = r[1] * t + r[4] * i + r[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(Ar(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y;
        return t * t + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const i = Math.cos(t)
          , r = Math.sin(t)
          , s = this.x - e.x
          , o = this.y - e.y;
        return this.x = s * i - o * r + e.x,
        this.y = s * r + o * i + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class jt {
    constructor(e, t, i, r, s, o, a, c, u) {
        jt.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, i, r, s, o, a, c, u)
    }
    set(e, t, i, r, s, o, a, c, u) {
        const h = this.elements;
        return h[0] = e,
        h[1] = r,
        h[2] = a,
        h[3] = t,
        h[4] = s,
        h[5] = c,
        h[6] = i,
        h[7] = o,
        h[8] = u,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        i.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , r = t.elements
          , s = this.elements
          , o = i[0]
          , a = i[3]
          , c = i[6]
          , u = i[1]
          , h = i[4]
          , m = i[7]
          , d = i[2]
          , f = i[5]
          , _ = i[8]
          , g = r[0]
          , v = r[3]
          , y = r[6]
          , w = r[1]
          , S = r[4]
          , E = r[7]
          , b = r[2]
          , T = r[5]
          , C = r[8];
        return s[0] = o * g + a * w + c * b,
        s[3] = o * v + a * S + c * T,
        s[6] = o * y + a * E + c * C,
        s[1] = u * g + h * w + m * b,
        s[4] = u * v + h * S + m * T,
        s[7] = u * y + h * E + m * C,
        s[2] = d * g + f * w + _ * b,
        s[5] = d * v + f * S + _ * T,
        s[8] = d * y + f * E + _ * C,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , c = e[6]
          , u = e[7]
          , h = e[8];
        return t * o * h - t * a * u - i * s * h + i * a * c + r * s * u - r * o * c
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , c = e[6]
          , u = e[7]
          , h = e[8]
          , m = h * o - a * u
          , d = a * c - h * s
          , f = u * s - o * c
          , _ = t * m + i * d + r * f;
        if (_ === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const g = 1 / _;
        return e[0] = m * g,
        e[1] = (r * u - h * i) * g,
        e[2] = (a * i - r * o) * g,
        e[3] = d * g,
        e[4] = (h * t - r * c) * g,
        e[5] = (r * s - a * t) * g,
        e[6] = f * g,
        e[7] = (i * c - u * t) * g,
        e[8] = (o * t - i * s) * g,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, i, r, s, o, a) {
        const c = Math.cos(s)
          , u = Math.sin(s);
        return this.set(i * c, i * u, -i * (c * o + u * a) + o + e, -r * u, r * c, -r * (-u * o + c * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(t0.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(t0.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(t0.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, i, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let r = 0; r < 9; r++)
            if (t[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 9; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const t0 = new jt;
function rR(n) {
    for (let e = n.length - 1; e >= 0; --e)
        if (n[e] >= 65535)
            return !0;
    return !1
}
function Vf(n) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}
function m4() {
    const n = Vf("canvas");
    return n.style.display = "block",
    n
}
const o1 = {};
function Tf(n) {
    n in o1 || (o1[n] = !0,
    console.warn(n))
}
const a1 = new jt().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
  , l1 = new jt().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
  , gd = {
    [No]: {
        transfer: Ap,
        primaries: Mp,
        toReference: n=>n,
        fromReference: n=>n
    },
    [Ci]: {
        transfer: Rn,
        primaries: Mp,
        toReference: n=>n.convertSRGBToLinear(),
        fromReference: n=>n.convertLinearToSRGB()
    },
    [Zp]: {
        transfer: Ap,
        primaries: Tp,
        toReference: n=>n.applyMatrix3(l1),
        fromReference: n=>n.applyMatrix3(a1)
    },
    [Oy]: {
        transfer: Rn,
        primaries: Tp,
        toReference: n=>n.convertSRGBToLinear().applyMatrix3(l1),
        fromReference: n=>n.applyMatrix3(a1).convertLinearToSRGB()
    }
}
  , g4 = new Set([No, Zp])
  , pn = {
    enabled: !0,
    _workingColorSpace: No,
    get legacyMode() {
        return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
        !this.enabled
    },
    set legacyMode(n) {
        console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
        this.enabled = !n
    },
    get workingColorSpace() {
        return this._workingColorSpace
    },
    set workingColorSpace(n) {
        if (!g4.has(n))
            throw new Error(`Unsupported working color space, "${n}".`);
        this._workingColorSpace = n
    },
    convert: function(n, e, t) {
        if (this.enabled === !1 || e === t || !e || !t)
            return n;
        const i = gd[e].toReference
          , r = gd[t].fromReference;
        return r(i(n))
    },
    fromWorkingColorSpace: function(n, e) {
        return this.convert(n, this._workingColorSpace, e)
    },
    toWorkingColorSpace: function(n, e) {
        return this.convert(n, e, this._workingColorSpace)
    },
    getPrimaries: function(n) {
        return gd[n].primaries
    },
    getTransfer: function(n) {
        return n === ms ? Ap : gd[n].transfer
    }
};
function Fc(n) {
    return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4)
}
function n0(n) {
    return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055
}
let sc;
class sR {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            sc === void 0 && (sc = Vf("canvas")),
            sc.width = e.width,
            sc.height = e.height;
            const i = sc.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
            t = sc
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = Vf("canvas");
            t.width = e.width,
            t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const r = i.getImageData(0, 0, e.width, e.height)
              , s = r.data;
            for (let o = 0; o < s.length; o++)
                s[o] = Fc(s[o] / 255) * 255;
            return i.putImageData(r, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(Fc(t[i] / 255) * 255) : t[i] = Fc(t[i]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let _4 = 0;
class oR {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: _4++
        }),
        this.uuid = nh(),
        this.data = e,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const i = {
            uuid: this.uuid,
            url: ""
        }
          , r = this.data;
        if (r !== null) {
            let s;
            if (Array.isArray(r)) {
                s = [];
                for (let o = 0, a = r.length; o < a; o++)
                    r[o].isDataTexture ? s.push(i0(r[o].image)) : s.push(i0(r[o]))
            } else
                s = i0(r);
            i.url = s
        }
        return t || (e.images[this.uuid] = i),
        i
    }
}
function i0(n) {
    return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? sR.getDataURL(n) : n.data ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let v4 = 0;
class hr extends Qc {
    constructor(e=hr.DEFAULT_IMAGE, t=hr.DEFAULT_MAPPING, i=Os, r=Os, s=Er, o=Hf, a=Ns, c=ba, u=hr.DEFAULT_ANISOTROPY, h=ms) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: v4++
        }),
        this.uuid = nh(),
        this.name = "",
        this.source = new oR(e),
        this.mipmaps = [],
        this.mapping = t,
        this.channel = 0,
        this.wrapS = i,
        this.wrapT = r,
        this.magFilter = s,
        this.minFilter = o,
        this.anisotropy = u,
        this.format = a,
        this.internalFormat = null,
        this.type = c,
        this.offset = new on(0,0),
        this.repeat = new on(1,1),
        this.center = new on(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new jt,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        typeof h == "string" ? this.colorSpace = h : (Tf("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace = h === wl ? Ci : ms),
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const i = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        t || (e.textures[this.uuid] = i),
        i
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== jC)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case lv:
                e.x = e.x - Math.floor(e.x);
                break;
            case Os:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case cv:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case lv:
                e.y = e.y - Math.floor(e.y);
                break;
            case Os:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case cv:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    get encoding() {
        return Tf("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace === Ci ? wl : nR
    }
    set encoding(e) {
        Tf("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace = e === wl ? Ci : ms
    }
}
hr.DEFAULT_IMAGE = null;
hr.DEFAULT_MAPPING = jC;
hr.DEFAULT_ANISOTROPY = 1;
class Pi {
    constructor(e=0, t=0, i=0, r=1) {
        Pi.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = i,
        this.w = r
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, i, r) {
        return this.x = e,
        this.y = t,
        this.z = i,
        this.w = r,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s,
        this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s,
        this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s,
        this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, i, r, s;
        const c = e.elements
          , u = c[0]
          , h = c[4]
          , m = c[8]
          , d = c[1]
          , f = c[5]
          , _ = c[9]
          , g = c[2]
          , v = c[6]
          , y = c[10];
        if (Math.abs(h - d) < .01 && Math.abs(m - g) < .01 && Math.abs(_ - v) < .01) {
            if (Math.abs(h + d) < .1 && Math.abs(m + g) < .1 && Math.abs(_ + v) < .1 && Math.abs(u + f + y - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const S = (u + 1) / 2
              , E = (f + 1) / 2
              , b = (y + 1) / 2
              , T = (h + d) / 4
              , C = (m + g) / 4
              , P = (_ + v) / 4;
            return S > E && S > b ? S < .01 ? (i = 0,
            r = .707106781,
            s = .707106781) : (i = Math.sqrt(S),
            r = T / i,
            s = C / i) : E > b ? E < .01 ? (i = .707106781,
            r = 0,
            s = .707106781) : (r = Math.sqrt(E),
            i = T / r,
            s = P / r) : b < .01 ? (i = .707106781,
            r = .707106781,
            s = 0) : (s = Math.sqrt(b),
            i = C / s,
            r = P / s),
            this.set(i, r, s, t),
            this
        }
        let w = Math.sqrt((v - _) * (v - _) + (m - g) * (m - g) + (d - h) * (d - h));
        return Math.abs(w) < .001 && (w = 1),
        this.x = (v - _) / w,
        this.y = (m - g) / w,
        this.z = (d - h) / w,
        this.w = Math.acos((u + f + y - 1) / 2),
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this.w = e.w + (t.w - e.w) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class y4 extends Qc {
    constructor(e=1, t=1, i={}) {
        super(),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new Pi(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new Pi(0,0,e,t);
        const r = {
            width: e,
            height: t,
            depth: 1
        };
        i.encoding !== void 0 && (Tf("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),
        i.colorSpace = i.encoding === wl ? Ci : ms),
        i = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: Er,
            depthBuffer: !0,
            stencilBuffer: !1,
            depthTexture: null,
            samples: 0
        }, i),
        this.texture = new hr(r,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.flipY = !1,
        this.texture.generateMipmaps = i.generateMipmaps,
        this.texture.internalFormat = i.internalFormat,
        this.depthBuffer = i.depthBuffer,
        this.stencilBuffer = i.stencilBuffer,
        this.depthTexture = i.depthTexture,
        this.samples = i.samples
    }
    setSize(e, t, i=1) {
        (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e,
        this.height = t,
        this.depth = i,
        this.texture.image.width = e,
        this.texture.image.height = t,
        this.texture.image.depth = i,
        this.dispose()),
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.texture = e.texture.clone(),
        this.texture.isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new oR(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class Ll extends y4 {
    constructor(e=1, t=1, i={}) {
        super(e, t, i),
        this.isWebGLRenderTarget = !0
    }
}
class aR extends hr {
    constructor(e=null, t=1, i=1, r=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        },
        this.magFilter = sr,
        this.minFilter = sr,
        this.wrapR = Os,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class x4 extends hr {
    constructor(e=null, t=1, i=1, r=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        },
        this.magFilter = sr,
        this.minFilter = sr,
        this.wrapR = Os,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class ih {
    constructor(e=0, t=0, i=0, r=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._w = r
    }
    static slerpFlat(e, t, i, r, s, o, a) {
        let c = i[r + 0]
          , u = i[r + 1]
          , h = i[r + 2]
          , m = i[r + 3];
        const d = s[o + 0]
          , f = s[o + 1]
          , _ = s[o + 2]
          , g = s[o + 3];
        if (a === 0) {
            e[t + 0] = c,
            e[t + 1] = u,
            e[t + 2] = h,
            e[t + 3] = m;
            return
        }
        if (a === 1) {
            e[t + 0] = d,
            e[t + 1] = f,
            e[t + 2] = _,
            e[t + 3] = g;
            return
        }
        if (m !== g || c !== d || u !== f || h !== _) {
            let v = 1 - a;
            const y = c * d + u * f + h * _ + m * g
              , w = y >= 0 ? 1 : -1
              , S = 1 - y * y;
            if (S > Number.EPSILON) {
                const b = Math.sqrt(S)
                  , T = Math.atan2(b, y * w);
                v = Math.sin(v * T) / b,
                a = Math.sin(a * T) / b
            }
            const E = a * w;
            if (c = c * v + d * E,
            u = u * v + f * E,
            h = h * v + _ * E,
            m = m * v + g * E,
            v === 1 - a) {
                const b = 1 / Math.sqrt(c * c + u * u + h * h + m * m);
                c *= b,
                u *= b,
                h *= b,
                m *= b
            }
        }
        e[t] = c,
        e[t + 1] = u,
        e[t + 2] = h,
        e[t + 3] = m
    }
    static multiplyQuaternionsFlat(e, t, i, r, s, o) {
        const a = i[r]
          , c = i[r + 1]
          , u = i[r + 2]
          , h = i[r + 3]
          , m = s[o]
          , d = s[o + 1]
          , f = s[o + 2]
          , _ = s[o + 3];
        return e[t] = a * _ + h * m + c * f - u * d,
        e[t + 1] = c * _ + h * d + u * m - a * f,
        e[t + 2] = u * _ + h * f + a * d - c * m,
        e[t + 3] = h * _ - a * m - c * d - u * f,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, i, r) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._w = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._order
          , a = Math.cos
          , c = Math.sin
          , u = a(i / 2)
          , h = a(r / 2)
          , m = a(s / 2)
          , d = c(i / 2)
          , f = c(r / 2)
          , _ = c(s / 2);
        switch (o) {
        case "XYZ":
            this._x = d * h * m + u * f * _,
            this._y = u * f * m - d * h * _,
            this._z = u * h * _ + d * f * m,
            this._w = u * h * m - d * f * _;
            break;
        case "YXZ":
            this._x = d * h * m + u * f * _,
            this._y = u * f * m - d * h * _,
            this._z = u * h * _ - d * f * m,
            this._w = u * h * m + d * f * _;
            break;
        case "ZXY":
            this._x = d * h * m - u * f * _,
            this._y = u * f * m + d * h * _,
            this._z = u * h * _ + d * f * m,
            this._w = u * h * m - d * f * _;
            break;
        case "ZYX":
            this._x = d * h * m - u * f * _,
            this._y = u * f * m + d * h * _,
            this._z = u * h * _ - d * f * m,
            this._w = u * h * m + d * f * _;
            break;
        case "YZX":
            this._x = d * h * m + u * f * _,
            this._y = u * f * m + d * h * _,
            this._z = u * h * _ - d * f * m,
            this._w = u * h * m - d * f * _;
            break;
        case "XZY":
            this._x = d * h * m - u * f * _,
            this._y = u * f * m - d * h * _,
            this._z = u * h * _ + d * f * m,
            this._w = u * h * m + d * f * _;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t !== !1 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const i = t / 2
          , r = Math.sin(i);
        return this._x = e.x * r,
        this._y = e.y * r,
        this._z = e.z * r,
        this._w = Math.cos(i),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , i = t[0]
          , r = t[4]
          , s = t[8]
          , o = t[1]
          , a = t[5]
          , c = t[9]
          , u = t[2]
          , h = t[6]
          , m = t[10]
          , d = i + a + m;
        if (d > 0) {
            const f = .5 / Math.sqrt(d + 1);
            this._w = .25 / f,
            this._x = (h - c) * f,
            this._y = (s - u) * f,
            this._z = (o - r) * f
        } else if (i > a && i > m) {
            const f = 2 * Math.sqrt(1 + i - a - m);
            this._w = (h - c) / f,
            this._x = .25 * f,
            this._y = (r + o) / f,
            this._z = (s + u) / f
        } else if (a > m) {
            const f = 2 * Math.sqrt(1 + a - i - m);
            this._w = (s - u) / f,
            this._x = (r + o) / f,
            this._y = .25 * f,
            this._z = (c + h) / f
        } else {
            const f = 2 * Math.sqrt(1 + m - i - a);
            this._w = (o - r) / f,
            this._x = (s + u) / f,
            this._y = (c + h) / f,
            this._z = .25 * f
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return i < Number.EPSILON ? (i = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = i) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = i)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = i),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(Ar(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const i = this.angleTo(e);
        if (i === 0)
            return this;
        const r = Math.min(1, t / i);
        return this.slerp(e, r),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._w
          , a = t._x
          , c = t._y
          , u = t._z
          , h = t._w;
        return this._x = i * h + o * a + r * u - s * c,
        this._y = r * h + o * c + s * a - i * u,
        this._z = s * h + o * u + i * c - r * a,
        this._w = o * h - i * a - r * c - s * u,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const i = this._x
          , r = this._y
          , s = this._z
          , o = this._w;
        let a = o * e._w + i * e._x + r * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = i,
            this._y = r,
            this._z = s,
            this;
        const c = 1 - a * a;
        if (c <= Number.EPSILON) {
            const f = 1 - t;
            return this._w = f * o + t * this._w,
            this._x = f * i + t * this._x,
            this._y = f * r + t * this._y,
            this._z = f * s + t * this._z,
            this.normalize(),
            this._onChangeCallback(),
            this
        }
        const u = Math.sqrt(c)
          , h = Math.atan2(u, a)
          , m = Math.sin((1 - t) * h) / u
          , d = Math.sin(t * h) / u;
        return this._w = o * m + this._w * d,
        this._x = i * m + this._x * d,
        this._y = r * m + this._y * d,
        this._z = s * m + this._z * d,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i)
    }
    random() {
        const e = Math.random()
          , t = Math.sqrt(1 - e)
          , i = Math.sqrt(e)
          , r = 2 * Math.PI * Math.random()
          , s = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(r), i * Math.sin(s), i * Math.cos(s), t * Math.sin(r))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class pe {
    constructor(e=0, t=0, i=0) {
        pe.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = i
    }
    set(e, t, i) {
        return i === void 0 && (i = this.z),
        this.x = e,
        this.y = t,
        this.z = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(c1.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(c1.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[3] * i + s[6] * r,
        this.y = s[1] * t + s[4] * i + s[7] * r,
        this.z = s[2] * t + s[5] * i + s[8] * r,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements
          , o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
        return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o,
        this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o,
        this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.x
          , o = e.y
          , a = e.z
          , c = e.w
          , u = 2 * (o * r - a * i)
          , h = 2 * (a * t - s * r)
          , m = 2 * (s * i - o * t);
        return this.x = t + c * u + o * m - a * h,
        this.y = i + c * h + a * u - s * m,
        this.z = r + c * m + s * h - o * u,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[4] * i + s[8] * r,
        this.y = s[1] * t + s[5] * i + s[9] * r,
        this.z = s[2] * t + s[6] * i + s[10] * r,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = t.x
          , a = t.y
          , c = t.z;
        return this.x = r * c - s * a,
        this.y = s * o - i * c,
        this.z = i * a - r * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i)
    }
    projectOnPlane(e) {
        return r0.copy(this).projectOnVector(e),
        this.sub(r0)
    }
    reflect(e) {
        return this.sub(r0.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(Ar(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y
          , r = this.z - e.z;
        return t * t + i * i + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, i) {
        const r = Math.sin(t) * e;
        return this.x = r * Math.sin(i),
        this.y = Math.cos(t) * e,
        this.z = r * Math.cos(i),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, i) {
        return this.x = e * Math.sin(t),
        this.y = i,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , i = this.setFromMatrixColumn(e, 1).length()
          , r = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = i,
        this.z = r,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = (Math.random() - .5) * 2
          , t = Math.random() * Math.PI * 2
          , i = Math.sqrt(1 - e ** 2);
        return this.x = i * Math.cos(t),
        this.y = i * Math.sin(t),
        this.z = e,
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const r0 = new pe
  , c1 = new ih;
class rh {
    constructor(e=new pe(1 / 0,1 / 0,1 / 0), t=new pe(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t += 3)
            this.expandByPoint(As.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, i = e.count; t < i; t++)
            this.expandByPoint(As.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = As.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const i = e.geometry;
        if (i !== void 0) {
            const s = i.getAttribute("position");
            if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, a = s.count; o < a; o++)
                    e.isMesh === !0 ? e.getVertexPosition(o, As) : As.fromBufferAttribute(s, o),
                    As.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(As);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                _d.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(),
                _d.copy(i.boundingBox)),
                _d.applyMatrix4(e.matrixWorld),
                this.union(_d)
        }
        const r = e.children;
        for (let s = 0, o = r.length; s < o; s++)
            this.expandByObject(r[s], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, As),
        As.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, i;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        i = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        i += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        i += e.normal.z * this.min.z),
        t <= -e.constant && i >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(Iu),
        vd.subVectors(this.max, Iu),
        oc.subVectors(e.a, Iu),
        ac.subVectors(e.b, Iu),
        lc.subVectors(e.c, Iu),
        Ko.subVectors(ac, oc),
        Zo.subVectors(lc, ac),
        Xa.subVectors(oc, lc);
        let t = [0, -Ko.z, Ko.y, 0, -Zo.z, Zo.y, 0, -Xa.z, Xa.y, Ko.z, 0, -Ko.x, Zo.z, 0, -Zo.x, Xa.z, 0, -Xa.x, -Ko.y, Ko.x, 0, -Zo.y, Zo.x, 0, -Xa.y, Xa.x, 0];
        return !s0(t, oc, ac, lc, vd) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !s0(t, oc, ac, lc, vd)) ? !1 : (yd.crossVectors(Ko, Zo),
        t = [yd.x, yd.y, yd.z],
        s0(t, oc, ac, lc, vd))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, As).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(As).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (vo[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        vo[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        vo[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        vo[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        vo[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        vo[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        vo[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        vo[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(vo),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const vo = [new pe, new pe, new pe, new pe, new pe, new pe, new pe, new pe]
  , As = new pe
  , _d = new rh
  , oc = new pe
  , ac = new pe
  , lc = new pe
  , Ko = new pe
  , Zo = new pe
  , Xa = new pe
  , Iu = new pe
  , vd = new pe
  , yd = new pe
  , qa = new pe;
function s0(n, e, t, i, r) {
    for (let s = 0, o = n.length - 3; s <= o; s += 3) {
        qa.fromArray(n, s);
        const a = r.x * Math.abs(qa.x) + r.y * Math.abs(qa.y) + r.z * Math.abs(qa.z)
          , c = e.dot(qa)
          , u = t.dot(qa)
          , h = i.dot(qa);
        if (Math.max(-Math.max(c, u, h), Math.min(c, u, h)) > a)
            return !1
    }
    return !0
}
const b4 = new rh
  , Ou = new pe
  , o0 = new pe;
class Ny {
    constructor(e=new pe, t=-1) {
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const i = this.center;
        t !== void 0 ? i.copy(t) : b4.setFromPoints(e).getCenter(i);
        let r = 0;
        for (let s = 0, o = e.length; s < o; s++)
            r = Math.max(r, i.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(r),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const i = this.center.distanceToSquared(e);
        return t.copy(e),
        i > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        Ou.subVectors(e, this.center);
        const t = Ou.lengthSq();
        if (t > this.radius * this.radius) {
            const i = Math.sqrt(t)
              , r = (i - this.radius) * .5;
            this.center.addScaledVector(Ou, r / i),
            this.radius += r
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (o0.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(Ou.copy(e.center).add(o0)),
        this.expandByPoint(Ou.copy(e.center).sub(o0))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const yo = new pe
  , a0 = new pe
  , xd = new pe
  , Jo = new pe
  , l0 = new pe
  , bd = new pe
  , c0 = new pe;
class S4 {
    constructor(e=new pe, t=new pe(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, yo)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const i = t.dot(this.direction);
        return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = yo.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (yo.copy(this.origin).addScaledVector(this.direction, t),
        yo.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, i, r) {
        a0.copy(e).add(t).multiplyScalar(.5),
        xd.copy(t).sub(e).normalize(),
        Jo.copy(this.origin).sub(a0);
        const s = e.distanceTo(t) * .5
          , o = -this.direction.dot(xd)
          , a = Jo.dot(this.direction)
          , c = -Jo.dot(xd)
          , u = Jo.lengthSq()
          , h = Math.abs(1 - o * o);
        let m, d, f, _;
        if (h > 0)
            if (m = o * c - a,
            d = o * a - c,
            _ = s * h,
            m >= 0)
                if (d >= -_)
                    if (d <= _) {
                        const g = 1 / h;
                        m *= g,
                        d *= g,
                        f = m * (m + o * d + 2 * a) + d * (o * m + d + 2 * c) + u
                    } else
                        d = s,
                        m = Math.max(0, -(o * d + a)),
                        f = -m * m + d * (d + 2 * c) + u;
                else
                    d = -s,
                    m = Math.max(0, -(o * d + a)),
                    f = -m * m + d * (d + 2 * c) + u;
            else
                d <= -_ ? (m = Math.max(0, -(-o * s + a)),
                d = m > 0 ? -s : Math.min(Math.max(-s, -c), s),
                f = -m * m + d * (d + 2 * c) + u) : d <= _ ? (m = 0,
                d = Math.min(Math.max(-s, -c), s),
                f = d * (d + 2 * c) + u) : (m = Math.max(0, -(o * s + a)),
                d = m > 0 ? s : Math.min(Math.max(-s, -c), s),
                f = -m * m + d * (d + 2 * c) + u);
        else
            d = o > 0 ? -s : s,
            m = Math.max(0, -(o * d + a)),
            f = -m * m + d * (d + 2 * c) + u;
        return i && i.copy(this.origin).addScaledVector(this.direction, m),
        r && r.copy(a0).addScaledVector(xd, d),
        f
    }
    intersectSphere(e, t) {
        yo.subVectors(e.center, this.origin);
        const i = yo.dot(this.direction)
          , r = yo.dot(yo) - i * i
          , s = e.radius * e.radius;
        if (r > s)
            return null;
        const o = Math.sqrt(s - r)
          , a = i - o
          , c = i + o;
        return c < 0 ? null : a < 0 ? this.at(c, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null
    }
    intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let i, r, s, o, a, c;
        const u = 1 / this.direction.x
          , h = 1 / this.direction.y
          , m = 1 / this.direction.z
          , d = this.origin;
        return u >= 0 ? (i = (e.min.x - d.x) * u,
        r = (e.max.x - d.x) * u) : (i = (e.max.x - d.x) * u,
        r = (e.min.x - d.x) * u),
        h >= 0 ? (s = (e.min.y - d.y) * h,
        o = (e.max.y - d.y) * h) : (s = (e.max.y - d.y) * h,
        o = (e.min.y - d.y) * h),
        i > o || s > r || ((s > i || isNaN(i)) && (i = s),
        (o < r || isNaN(r)) && (r = o),
        m >= 0 ? (a = (e.min.z - d.z) * m,
        c = (e.max.z - d.z) * m) : (a = (e.max.z - d.z) * m,
        c = (e.min.z - d.z) * m),
        i > c || a > r) || ((a > i || i !== i) && (i = a),
        (c < r || r !== r) && (r = c),
        r < 0) ? null : this.at(i >= 0 ? i : r, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, yo) !== null
    }
    intersectTriangle(e, t, i, r, s) {
        l0.subVectors(t, e),
        bd.subVectors(i, e),
        c0.crossVectors(l0, bd);
        let o = this.direction.dot(c0), a;
        if (o > 0) {
            if (r)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        Jo.subVectors(this.origin, e);
        const c = a * this.direction.dot(bd.crossVectors(Jo, bd));
        if (c < 0)
            return null;
        const u = a * this.direction.dot(l0.cross(Jo));
        if (u < 0 || c + u > o)
            return null;
        const h = -a * Jo.dot(c0);
        return h < 0 ? null : this.at(h / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Li {
    constructor(e, t, i, r, s, o, a, c, u, h, m, d, f, _, g, v) {
        Li.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, i, r, s, o, a, c, u, h, m, d, f, _, g, v)
    }
    set(e, t, i, r, s, o, a, c, u, h, m, d, f, _, g, v) {
        const y = this.elements;
        return y[0] = e,
        y[4] = t,
        y[8] = i,
        y[12] = r,
        y[1] = s,
        y[5] = o,
        y[9] = a,
        y[13] = c,
        y[2] = u,
        y[6] = h,
        y[10] = m,
        y[14] = d,
        y[3] = f,
        y[7] = _,
        y[11] = g,
        y[15] = v,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new Li().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        t[9] = i[9],
        t[10] = i[10],
        t[11] = i[11],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , i = e.elements;
        return t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        i.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, i) {
        return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , i = e.elements
          , r = 1 / cc.setFromMatrixColumn(e, 0).length()
          , s = 1 / cc.setFromMatrixColumn(e, 1).length()
          , o = 1 / cc.setFromMatrixColumn(e, 2).length();
        return t[0] = i[0] * r,
        t[1] = i[1] * r,
        t[2] = i[2] * r,
        t[3] = 0,
        t[4] = i[4] * s,
        t[5] = i[5] * s,
        t[6] = i[6] * s,
        t[7] = 0,
        t[8] = i[8] * o,
        t[9] = i[9] * o,
        t[10] = i[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , i = e.x
          , r = e.y
          , s = e.z
          , o = Math.cos(i)
          , a = Math.sin(i)
          , c = Math.cos(r)
          , u = Math.sin(r)
          , h = Math.cos(s)
          , m = Math.sin(s);
        if (e.order === "XYZ") {
            const d = o * h
              , f = o * m
              , _ = a * h
              , g = a * m;
            t[0] = c * h,
            t[4] = -c * m,
            t[8] = u,
            t[1] = f + _ * u,
            t[5] = d - g * u,
            t[9] = -a * c,
            t[2] = g - d * u,
            t[6] = _ + f * u,
            t[10] = o * c
        } else if (e.order === "YXZ") {
            const d = c * h
              , f = c * m
              , _ = u * h
              , g = u * m;
            t[0] = d + g * a,
            t[4] = _ * a - f,
            t[8] = o * u,
            t[1] = o * m,
            t[5] = o * h,
            t[9] = -a,
            t[2] = f * a - _,
            t[6] = g + d * a,
            t[10] = o * c
        } else if (e.order === "ZXY") {
            const d = c * h
              , f = c * m
              , _ = u * h
              , g = u * m;
            t[0] = d - g * a,
            t[4] = -o * m,
            t[8] = _ + f * a,
            t[1] = f + _ * a,
            t[5] = o * h,
            t[9] = g - d * a,
            t[2] = -o * u,
            t[6] = a,
            t[10] = o * c
        } else if (e.order === "ZYX") {
            const d = o * h
              , f = o * m
              , _ = a * h
              , g = a * m;
            t[0] = c * h,
            t[4] = _ * u - f,
            t[8] = d * u + g,
            t[1] = c * m,
            t[5] = g * u + d,
            t[9] = f * u - _,
            t[2] = -u,
            t[6] = a * c,
            t[10] = o * c
        } else if (e.order === "YZX") {
            const d = o * c
              , f = o * u
              , _ = a * c
              , g = a * u;
            t[0] = c * h,
            t[4] = g - d * m,
            t[8] = _ * m + f,
            t[1] = m,
            t[5] = o * h,
            t[9] = -a * h,
            t[2] = -u * h,
            t[6] = f * m + _,
            t[10] = d - g * m
        } else if (e.order === "XZY") {
            const d = o * c
              , f = o * u
              , _ = a * c
              , g = a * u;
            t[0] = c * h,
            t[4] = -m,
            t[8] = u * h,
            t[1] = d * m + g,
            t[5] = o * h,
            t[9] = f * m - _,
            t[2] = _ * m - f,
            t[6] = a * h,
            t[10] = g * m + d
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(w4, e, E4)
    }
    lookAt(e, t, i) {
        const r = this.elements;
        return zr.subVectors(e, t),
        zr.lengthSq() === 0 && (zr.z = 1),
        zr.normalize(),
        Qo.crossVectors(i, zr),
        Qo.lengthSq() === 0 && (Math.abs(i.z) === 1 ? zr.x += 1e-4 : zr.z += 1e-4,
        zr.normalize(),
        Qo.crossVectors(i, zr)),
        Qo.normalize(),
        Sd.crossVectors(zr, Qo),
        r[0] = Qo.x,
        r[4] = Sd.x,
        r[8] = zr.x,
        r[1] = Qo.y,
        r[5] = Sd.y,
        r[9] = zr.y,
        r[2] = Qo.z,
        r[6] = Sd.z,
        r[10] = zr.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , r = t.elements
          , s = this.elements
          , o = i[0]
          , a = i[4]
          , c = i[8]
          , u = i[12]
          , h = i[1]
          , m = i[5]
          , d = i[9]
          , f = i[13]
          , _ = i[2]
          , g = i[6]
          , v = i[10]
          , y = i[14]
          , w = i[3]
          , S = i[7]
          , E = i[11]
          , b = i[15]
          , T = r[0]
          , C = r[4]
          , P = r[8]
          , A = r[12]
          , R = r[1]
          , I = r[5]
          , D = r[9]
          , H = r[13]
          , B = r[2]
          , G = r[6]
          , X = r[10]
          , V = r[14]
          , ee = r[3]
          , re = r[7]
          , k = r[11]
          , oe = r[15];
        return s[0] = o * T + a * R + c * B + u * ee,
        s[4] = o * C + a * I + c * G + u * re,
        s[8] = o * P + a * D + c * X + u * k,
        s[12] = o * A + a * H + c * V + u * oe,
        s[1] = h * T + m * R + d * B + f * ee,
        s[5] = h * C + m * I + d * G + f * re,
        s[9] = h * P + m * D + d * X + f * k,
        s[13] = h * A + m * H + d * V + f * oe,
        s[2] = _ * T + g * R + v * B + y * ee,
        s[6] = _ * C + g * I + v * G + y * re,
        s[10] = _ * P + g * D + v * X + y * k,
        s[14] = _ * A + g * H + v * V + y * oe,
        s[3] = w * T + S * R + E * B + b * ee,
        s[7] = w * C + S * I + E * G + b * re,
        s[11] = w * P + S * D + E * X + b * k,
        s[15] = w * A + S * H + E * V + b * oe,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[4]
          , r = e[8]
          , s = e[12]
          , o = e[1]
          , a = e[5]
          , c = e[9]
          , u = e[13]
          , h = e[2]
          , m = e[6]
          , d = e[10]
          , f = e[14]
          , _ = e[3]
          , g = e[7]
          , v = e[11]
          , y = e[15];
        return _ * (+s * c * m - r * u * m - s * a * d + i * u * d + r * a * f - i * c * f) + g * (+t * c * f - t * u * d + s * o * d - r * o * f + r * u * h - s * c * h) + v * (+t * u * m - t * a * f - s * o * m + i * o * f + s * a * h - i * u * h) + y * (-r * a * h - t * c * m + t * a * d + r * o * m - i * o * d + i * c * h)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, i) {
        const r = this.elements;
        return e.isVector3 ? (r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z) : (r[12] = e,
        r[13] = t,
        r[14] = i),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , c = e[6]
          , u = e[7]
          , h = e[8]
          , m = e[9]
          , d = e[10]
          , f = e[11]
          , _ = e[12]
          , g = e[13]
          , v = e[14]
          , y = e[15]
          , w = m * v * u - g * d * u + g * c * f - a * v * f - m * c * y + a * d * y
          , S = _ * d * u - h * v * u - _ * c * f + o * v * f + h * c * y - o * d * y
          , E = h * g * u - _ * m * u + _ * a * f - o * g * f - h * a * y + o * m * y
          , b = _ * m * c - h * g * c - _ * a * d + o * g * d + h * a * v - o * m * v
          , T = t * w + i * S + r * E + s * b;
        if (T === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const C = 1 / T;
        return e[0] = w * C,
        e[1] = (g * d * s - m * v * s - g * r * f + i * v * f + m * r * y - i * d * y) * C,
        e[2] = (a * v * s - g * c * s + g * r * u - i * v * u - a * r * y + i * c * y) * C,
        e[3] = (m * c * s - a * d * s - m * r * u + i * d * u + a * r * f - i * c * f) * C,
        e[4] = S * C,
        e[5] = (h * v * s - _ * d * s + _ * r * f - t * v * f - h * r * y + t * d * y) * C,
        e[6] = (_ * c * s - o * v * s - _ * r * u + t * v * u + o * r * y - t * c * y) * C,
        e[7] = (o * d * s - h * c * s + h * r * u - t * d * u - o * r * f + t * c * f) * C,
        e[8] = E * C,
        e[9] = (_ * m * s - h * g * s - _ * i * f + t * g * f + h * i * y - t * m * y) * C,
        e[10] = (o * g * s - _ * a * s + _ * i * u - t * g * u - o * i * y + t * a * y) * C,
        e[11] = (h * a * s - o * m * s - h * i * u + t * m * u + o * i * f - t * a * f) * C,
        e[12] = b * C,
        e[13] = (h * g * r - _ * m * r + _ * i * d - t * g * d - h * i * v + t * m * v) * C,
        e[14] = (_ * a * r - o * g * r - _ * i * c + t * g * c + o * i * v - t * a * v) * C,
        e[15] = (o * m * r - h * a * r + h * i * c - t * m * c - o * i * d + t * a * d) * C,
        this
    }
    scale(e) {
        const t = this.elements
          , i = e.x
          , r = e.y
          , s = e.z;
        return t[0] *= i,
        t[4] *= r,
        t[8] *= s,
        t[1] *= i,
        t[5] *= r,
        t[9] *= s,
        t[2] *= i,
        t[6] *= r,
        t[10] *= s,
        t[3] *= i,
        t[7] *= r,
        t[11] *= s,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, r))
    }
    makeTranslation(e, t, i) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const i = Math.cos(t)
          , r = Math.sin(t)
          , s = 1 - i
          , o = e.x
          , a = e.y
          , c = e.z
          , u = s * o
          , h = s * a;
        return this.set(u * o + i, u * a - r * c, u * c + r * a, 0, u * a + r * c, h * a + i, h * c - r * o, 0, u * c - r * a, h * c + r * o, s * c * c + i, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, i, r, s, o) {
        return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, i) {
        const r = this.elements
          , s = t._x
          , o = t._y
          , a = t._z
          , c = t._w
          , u = s + s
          , h = o + o
          , m = a + a
          , d = s * u
          , f = s * h
          , _ = s * m
          , g = o * h
          , v = o * m
          , y = a * m
          , w = c * u
          , S = c * h
          , E = c * m
          , b = i.x
          , T = i.y
          , C = i.z;
        return r[0] = (1 - (g + y)) * b,
        r[1] = (f + E) * b,
        r[2] = (_ - S) * b,
        r[3] = 0,
        r[4] = (f - E) * T,
        r[5] = (1 - (d + y)) * T,
        r[6] = (v + w) * T,
        r[7] = 0,
        r[8] = (_ + S) * C,
        r[9] = (v - w) * C,
        r[10] = (1 - (d + g)) * C,
        r[11] = 0,
        r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z,
        r[15] = 1,
        this
    }
    decompose(e, t, i) {
        const r = this.elements;
        let s = cc.set(r[0], r[1], r[2]).length();
        const o = cc.set(r[4], r[5], r[6]).length()
          , a = cc.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (s = -s),
        e.x = r[12],
        e.y = r[13],
        e.z = r[14],
        Ms.copy(this);
        const u = 1 / s
          , h = 1 / o
          , m = 1 / a;
        return Ms.elements[0] *= u,
        Ms.elements[1] *= u,
        Ms.elements[2] *= u,
        Ms.elements[4] *= h,
        Ms.elements[5] *= h,
        Ms.elements[6] *= h,
        Ms.elements[8] *= m,
        Ms.elements[9] *= m,
        Ms.elements[10] *= m,
        t.setFromRotationMatrix(Ms),
        i.x = s,
        i.y = o,
        i.z = a,
        this
    }
    makePerspective(e, t, i, r, s, o, a=Po) {
        const c = this.elements
          , u = 2 * s / (t - e)
          , h = 2 * s / (i - r)
          , m = (t + e) / (t - e)
          , d = (i + r) / (i - r);
        let f, _;
        if (a === Po)
            f = -(o + s) / (o - s),
            _ = -2 * o * s / (o - s);
        else if (a === Cp)
            f = -o / (o - s),
            _ = -o * s / (o - s);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return c[0] = u,
        c[4] = 0,
        c[8] = m,
        c[12] = 0,
        c[1] = 0,
        c[5] = h,
        c[9] = d,
        c[13] = 0,
        c[2] = 0,
        c[6] = 0,
        c[10] = f,
        c[14] = _,
        c[3] = 0,
        c[7] = 0,
        c[11] = -1,
        c[15] = 0,
        this
    }
    makeOrthographic(e, t, i, r, s, o, a=Po) {
        const c = this.elements
          , u = 1 / (t - e)
          , h = 1 / (i - r)
          , m = 1 / (o - s)
          , d = (t + e) * u
          , f = (i + r) * h;
        let _, g;
        if (a === Po)
            _ = (o + s) * m,
            g = -2 * m;
        else if (a === Cp)
            _ = s * m,
            g = -1 * m;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return c[0] = 2 * u,
        c[4] = 0,
        c[8] = 0,
        c[12] = -d,
        c[1] = 0,
        c[5] = 2 * h,
        c[9] = 0,
        c[13] = -f,
        c[2] = 0,
        c[6] = 0,
        c[10] = g,
        c[14] = -_,
        c[3] = 0,
        c[7] = 0,
        c[11] = 0,
        c[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let r = 0; r < 16; r++)
            if (t[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 16; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e[t + 9] = i[9],
        e[t + 10] = i[10],
        e[t + 11] = i[11],
        e[t + 12] = i[12],
        e[t + 13] = i[13],
        e[t + 14] = i[14],
        e[t + 15] = i[15],
        e
    }
}
const cc = new pe
  , Ms = new Li
  , w4 = new pe(0,0,0)
  , E4 = new pe(1,1,1)
  , Qo = new pe
  , Sd = new pe
  , zr = new pe
  , u1 = new Li
  , f1 = new ih;
class Jp {
    constructor(e=0, t=0, i=0, r=Jp.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._order = r
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, i, r=this._order) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._order = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, i=!0) {
        const r = e.elements
          , s = r[0]
          , o = r[4]
          , a = r[8]
          , c = r[1]
          , u = r[5]
          , h = r[9]
          , m = r[2]
          , d = r[6]
          , f = r[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(Ar(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, f),
            this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(d, u),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-Ar(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, f),
            this._z = Math.atan2(c, u)) : (this._y = Math.atan2(-m, s),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(Ar(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._y = Math.atan2(-m, f),
            this._z = Math.atan2(-o, u)) : (this._y = 0,
            this._z = Math.atan2(c, s));
            break;
        case "ZYX":
            this._y = Math.asin(-Ar(m, -1, 1)),
            Math.abs(m) < .9999999 ? (this._x = Math.atan2(d, f),
            this._z = Math.atan2(c, s)) : (this._x = 0,
            this._z = Math.atan2(-o, u));
            break;
        case "YZX":
            this._z = Math.asin(Ar(c, -1, 1)),
            Math.abs(c) < .9999999 ? (this._x = Math.atan2(-h, u),
            this._y = Math.atan2(-m, s)) : (this._x = 0,
            this._y = Math.atan2(a, f));
            break;
        case "XZY":
            this._z = Math.asin(-Ar(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, u),
            this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-h, f),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        i === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, i) {
        return u1.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(u1, t, i)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return f1.setFromEuler(this),
        this.setFromQuaternion(f1, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
Jp.DEFAULT_ORDER = "XYZ";
class lR {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let A4 = 0;
const h1 = new pe
  , uc = new ih
  , xo = new Li
  , wd = new pe
  , Nu = new pe
  , M4 = new pe
  , T4 = new ih
  , d1 = new pe(1,0,0)
  , p1 = new pe(0,1,0)
  , m1 = new pe(0,0,1)
  , C4 = {
    type: "added"
}
  , R4 = {
    type: "removed"
};
class Zr extends Qc {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: A4++
        }),
        this.uuid = nh(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = Zr.DEFAULT_UP.clone();
        const e = new pe
          , t = new Jp
          , i = new ih
          , r = new pe(1,1,1);
        function s() {
            i.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(i, void 0, !1)
        }
        t._onChange(s),
        i._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new Li
            },
            normalMatrix: {
                value: new jt
            }
        }),
        this.matrix = new Li,
        this.matrixWorld = new Li,
        this.matrixAutoUpdate = Zr.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = Zr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new lR,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return uc.setFromAxisAngle(e, t),
        this.quaternion.multiply(uc),
        this
    }
    rotateOnWorldAxis(e, t) {
        return uc.setFromAxisAngle(e, t),
        this.quaternion.premultiply(uc),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(d1, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(p1, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(m1, e)
    }
    translateOnAxis(e, t) {
        return h1.copy(e).applyQuaternion(this.quaternion),
        this.position.add(h1.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(d1, e)
    }
    translateY(e) {
        return this.translateOnAxis(p1, e)
    }
    translateZ(e) {
        return this.translateOnAxis(m1, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(xo.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, i) {
        e.isVector3 ? wd.copy(e) : wd.set(e, t, i);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1),
        Nu.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? xo.lookAt(Nu, wd, this.up) : xo.lookAt(wd, Nu, this.up),
        this.quaternion.setFromRotationMatrix(xo),
        r && (xo.extractRotation(r.matrixWorld),
        uc.setFromRotationMatrix(xo),
        this.quaternion.premultiply(uc.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(C4)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++)
                this.remove(arguments[i]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(R4)),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        xo.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        xo.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(xo),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let i = 0, r = this.children.length; i < r; i++) {
            const o = this.children[i].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t, i=[]) {
        this[e] === t && i.push(this);
        const r = this.children;
        for (let s = 0, o = r.length; s < o; s++)
            r[s].getObjectsByProperty(e, t, i);
        return i
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Nu, e, M4),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Nu, T4, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, t) {
        const i = this.parent;
        if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        t === !0) {
            const r = this.children;
            for (let s = 0, o = r.length; s < o; s++) {
                const a = r[s];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , i = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        i.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const r = {};
        r.uuid = this.uuid,
        r.type = this.type,
        this.name !== "" && (r.name = this.name),
        this.castShadow === !0 && (r.castShadow = !0),
        this.receiveShadow === !0 && (r.receiveShadow = !0),
        this.visible === !1 && (r.visible = !1),
        this.frustumCulled === !1 && (r.frustumCulled = !1),
        this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        r.layers = this.layers.mask,
        r.matrix = this.matrix.toArray(),
        r.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
        this.isInstancedMesh && (r.type = "InstancedMesh",
        r.count = this.count,
        r.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (r.type = "BatchedMesh",
        r.perObjectFrustumCulled = this.perObjectFrustumCulled,
        r.sortObjects = this.sortObjects,
        r.drawRanges = this._drawRanges,
        r.reservedRanges = this._reservedRanges,
        r.visibility = this._visibility,
        r.active = this._active,
        r.bounds = this._bounds.map(a=>({
            boxInitialized: a.boxInitialized,
            boxMin: a.box.min.toArray(),
            boxMax: a.box.max.toArray(),
            sphereInitialized: a.sphereInitialized,
            sphereRadius: a.sphere.radius,
            sphereCenter: a.sphere.center.toArray()
        })),
        r.maxGeometryCount = this._maxGeometryCount,
        r.maxVertexCount = this._maxVertexCount,
        r.maxIndexCount = this._maxIndexCount,
        r.geometryInitialized = this._geometryInitialized,
        r.geometryCount = this._geometryCount,
        r.matricesTexture = this._matricesTexture.toJSON(e),
        this.boundingSphere !== null && (r.boundingSphere = {
            center: r.boundingSphere.center.toArray(),
            radius: r.boundingSphere.radius
        }),
        this.boundingBox !== null && (r.boundingBox = {
            min: r.boundingBox.min.toArray(),
            max: r.boundingBox.max.toArray()
        }));
        function s(a, c) {
            return a[c.uuid] === void 0 && (a[c.uuid] = c.toJSON(e)),
            c.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const c = a.shapes;
                if (Array.isArray(c))
                    for (let u = 0, h = c.length; u < h; u++) {
                        const m = c[u];
                        s(e.shapes, m)
                    }
                else
                    s(e.shapes, c)
            }
        }
        if (this.isSkinnedMesh && (r.bindMode = this.bindMode,
        r.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (s(e.skeletons, this.skeleton),
        r.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let c = 0, u = this.material.length; c < u; c++)
                    a.push(s(e.materials, this.material[c]));
                r.material = a
            } else
                r.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            r.children = [];
            for (let a = 0; a < this.children.length; a++)
                r.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            r.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const c = this.animations[a];
                r.animations.push(s(e.animations, c))
            }
        }
        if (t) {
            const a = o(e.geometries)
              , c = o(e.materials)
              , u = o(e.textures)
              , h = o(e.images)
              , m = o(e.shapes)
              , d = o(e.skeletons)
              , f = o(e.animations)
              , _ = o(e.nodes);
            a.length > 0 && (i.geometries = a),
            c.length > 0 && (i.materials = c),
            u.length > 0 && (i.textures = u),
            h.length > 0 && (i.images = h),
            m.length > 0 && (i.shapes = m),
            d.length > 0 && (i.skeletons = d),
            f.length > 0 && (i.animations = f),
            _.length > 0 && (i.nodes = _)
        }
        return i.object = r,
        i;
        function o(a) {
            const c = [];
            for (const u in a) {
                const h = a[u];
                delete h.metadata,
                c.push(h)
            }
            return c
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let i = 0; i < e.children.length; i++) {
                const r = e.children[i];
                this.add(r.clone())
            }
        return this
    }
}
Zr.DEFAULT_UP = new pe(0,1,0);
Zr.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Zr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Ts = new pe
  , bo = new pe
  , u0 = new pe
  , So = new pe
  , fc = new pe
  , hc = new pe
  , g1 = new pe
  , f0 = new pe
  , h0 = new pe
  , d0 = new pe;
let Ed = !1;
class Is {
    constructor(e=new pe, t=new pe, i=new pe) {
        this.a = e,
        this.b = t,
        this.c = i
    }
    static getNormal(e, t, i, r) {
        r.subVectors(i, t),
        Ts.subVectors(e, t),
        r.cross(Ts);
        const s = r.lengthSq();
        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
    }
    static getBarycoord(e, t, i, r, s) {
        Ts.subVectors(r, t),
        bo.subVectors(i, t),
        u0.subVectors(e, t);
        const o = Ts.dot(Ts)
          , a = Ts.dot(bo)
          , c = Ts.dot(u0)
          , u = bo.dot(bo)
          , h = bo.dot(u0)
          , m = o * u - a * a;
        if (m === 0)
            return s.set(-2, -1, -1);
        const d = 1 / m
          , f = (u * c - a * h) * d
          , _ = (o * h - a * c) * d;
        return s.set(1 - f - _, _, f)
    }
    static containsPoint(e, t, i, r) {
        return this.getBarycoord(e, t, i, r, So),
        So.x >= 0 && So.y >= 0 && So.x + So.y <= 1
    }
    static getUV(e, t, i, r, s, o, a, c) {
        return Ed === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
        Ed = !0),
        this.getInterpolation(e, t, i, r, s, o, a, c)
    }
    static getInterpolation(e, t, i, r, s, o, a, c) {
        return this.getBarycoord(e, t, i, r, So),
        c.setScalar(0),
        c.addScaledVector(s, So.x),
        c.addScaledVector(o, So.y),
        c.addScaledVector(a, So.z),
        c
    }
    static isFrontFacing(e, t, i, r) {
        return Ts.subVectors(i, t),
        bo.subVectors(e, t),
        Ts.cross(bo).dot(r) < 0
    }
    set(e, t, i) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(i),
        this
    }
    setFromPointsAndIndices(e, t, i, r) {
        return this.a.copy(e[t]),
        this.b.copy(e[i]),
        this.c.copy(e[r]),
        this
    }
    setFromAttributeAndIndices(e, t, i, r) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, i),
        this.c.fromBufferAttribute(e, r),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return Ts.subVectors(this.c, this.b),
        bo.subVectors(this.a, this.b),
        Ts.cross(bo).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return Is.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return Is.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getUV(e, t, i, r, s) {
        return Ed === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
        Ed = !0),
        Is.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
    }
    getInterpolation(e, t, i, r, s) {
        return Is.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
    }
    containsPoint(e) {
        return Is.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return Is.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const i = this.a
          , r = this.b
          , s = this.c;
        let o, a;
        fc.subVectors(r, i),
        hc.subVectors(s, i),
        f0.subVectors(e, i);
        const c = fc.dot(f0)
          , u = hc.dot(f0);
        if (c <= 0 && u <= 0)
            return t.copy(i);
        h0.subVectors(e, r);
        const h = fc.dot(h0)
          , m = hc.dot(h0);
        if (h >= 0 && m <= h)
            return t.copy(r);
        const d = c * m - h * u;
        if (d <= 0 && c >= 0 && h <= 0)
            return o = c / (c - h),
            t.copy(i).addScaledVector(fc, o);
        d0.subVectors(e, s);
        const f = fc.dot(d0)
          , _ = hc.dot(d0);
        if (_ >= 0 && f <= _)
            return t.copy(s);
        const g = f * u - c * _;
        if (g <= 0 && u >= 0 && _ <= 0)
            return a = u / (u - _),
            t.copy(i).addScaledVector(hc, a);
        const v = h * _ - f * m;
        if (v <= 0 && m - h >= 0 && f - _ >= 0)
            return g1.subVectors(s, r),
            a = (m - h) / (m - h + (f - _)),
            t.copy(r).addScaledVector(g1, a);
        const y = 1 / (v + g + d);
        return o = g * y,
        a = d * y,
        t.copy(i).addScaledVector(fc, o).addScaledVector(hc, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const cR = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , ea = {
    h: 0,
    s: 0,
    l: 0
}
  , Ad = {
    h: 0,
    s: 0,
    l: 0
};
function p0(n, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
}
class mn {
    constructor(e, t, i) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, t, i)
    }
    set(e, t, i) {
        if (t === void 0 && i === void 0) {
            const r = e;
            r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r)
        } else
            this.setRGB(e, t, i);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=Ci) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        pn.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, i, r=pn.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = i,
        pn.toWorkingColorSpace(this, r),
        this
    }
    setHSL(e, t, i, r=pn.workingColorSpace) {
        if (e = p4(e, 1),
        t = Ar(t, 0, 1),
        i = Ar(i, 0, 1),
        t === 0)
            this.r = this.g = this.b = i;
        else {
            const s = i <= .5 ? i * (1 + t) : i + t - i * t
              , o = 2 * i - s;
            this.r = p0(o, s, e + 1 / 3),
            this.g = p0(o, s, e),
            this.b = p0(o, s, e - 1 / 3)
        }
        return pn.toWorkingColorSpace(this, r),
        this
    }
    setStyle(e, t=Ci) {
        function i(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let r;
        if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = r[1]
              , a = r[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = r[1]
              , o = s.length;
            if (o === 3)
                return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
            if (o === 6)
                return this.setHex(parseInt(s, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=Ci) {
        const i = cR[e.toLowerCase()];
        return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = Fc(e.r),
        this.g = Fc(e.g),
        this.b = Fc(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = n0(e.r),
        this.g = n0(e.g),
        this.b = n0(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=Ci) {
        return pn.fromWorkingColorSpace(Ui.copy(this), e),
        Math.round(Ar(Ui.r * 255, 0, 255)) * 65536 + Math.round(Ar(Ui.g * 255, 0, 255)) * 256 + Math.round(Ar(Ui.b * 255, 0, 255))
    }
    getHexString(e=Ci) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=pn.workingColorSpace) {
        pn.fromWorkingColorSpace(Ui.copy(this), t);
        const i = Ui.r
          , r = Ui.g
          , s = Ui.b
          , o = Math.max(i, r, s)
          , a = Math.min(i, r, s);
        let c, u;
        const h = (a + o) / 2;
        if (a === o)
            c = 0,
            u = 0;
        else {
            const m = o - a;
            switch (u = h <= .5 ? m / (o + a) : m / (2 - o - a),
            o) {
            case i:
                c = (r - s) / m + (r < s ? 6 : 0);
                break;
            case r:
                c = (s - i) / m + 2;
                break;
            case s:
                c = (i - r) / m + 4;
                break
            }
            c /= 6
        }
        return e.h = c,
        e.s = u,
        e.l = h,
        e
    }
    getRGB(e, t=pn.workingColorSpace) {
        return pn.fromWorkingColorSpace(Ui.copy(this), t),
        e.r = Ui.r,
        e.g = Ui.g,
        e.b = Ui.b,
        e
    }
    getStyle(e=Ci) {
        pn.fromWorkingColorSpace(Ui.copy(this), e);
        const t = Ui.r
          , i = Ui.g
          , r = Ui.b;
        return e !== Ci ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`
    }
    offsetHSL(e, t, i) {
        return this.getHSL(ea),
        this.setHSL(ea.h + e, ea.s + t, ea.l + i)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, i) {
        return this.r = e.r + (t.r - e.r) * i,
        this.g = e.g + (t.g - e.g) * i,
        this.b = e.b + (t.b - e.b) * i,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(ea),
        e.getHSL(Ad);
        const i = e0(ea.h, Ad.h, t)
          , r = e0(ea.s, Ad.s, t)
          , s = e0(ea.l, Ad.l, t);
        return this.setHSL(i, r, s),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const t = this.r
          , i = this.g
          , r = this.b
          , s = e.elements;
        return this.r = s[0] * t + s[3] * i + s[6] * r,
        this.g = s[1] * t + s[4] * i + s[7] * r,
        this.b = s[2] * t + s[5] * i + s[8] * r,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const Ui = new mn;
mn.NAMES = cR;
let P4 = 0;
class Qp extends Qc {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: P4++
        }),
        this.uuid = nh(),
        this.name = "",
        this.type = "Material",
        this.blending = Uc,
        this.side = Ma,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = rv,
        this.blendDst = sv,
        this.blendEquation = ol,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new mn(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = Ep,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = n1,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = rc,
        this.stencilZFail = rc,
        this.stencilZPass = rc,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const i = e[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const r = this[t];
                if (r === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const i = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.color && this.color.isColor && (i.color = this.color.getHex()),
        this.roughness !== void 0 && (i.roughness = this.roughness),
        this.metalness !== void 0 && (i.metalness = this.metalness),
        this.sheen !== void 0 && (i.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
        this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (i.shininess = this.shininess),
        this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.iridescence !== void 0 && (i.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid,
        i.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid,
        i.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid,
        i.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid,
        i.normalMapType = this.normalMapType,
        i.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid,
        i.displacementScale = this.displacementScale,
        i.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (i.combine = this.combine)),
        this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (i.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (i.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (i.size = this.size),
        this.shadowSide !== null && (i.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation),
        this.blending !== Uc && (i.blending = this.blending),
        this.side !== Ma && (i.side = this.side),
        this.vertexColors === !0 && (i.vertexColors = !0),
        this.opacity < 1 && (i.opacity = this.opacity),
        this.transparent === !0 && (i.transparent = !0),
        this.blendSrc !== rv && (i.blendSrc = this.blendSrc),
        this.blendDst !== sv && (i.blendDst = this.blendDst),
        this.blendEquation !== ol && (i.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
        this.depthFunc !== Ep && (i.depthFunc = this.depthFunc),
        this.depthTest === !1 && (i.depthTest = this.depthTest),
        this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== n1 && (i.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== rc && (i.stencilFail = this.stencilFail),
        this.stencilZFail !== rc && (i.stencilZFail = this.stencilZFail),
        this.stencilZPass !== rc && (i.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation),
        this.polygonOffset === !0 && (i.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth),
        this.dashSize !== void 0 && (i.dashSize = this.dashSize),
        this.gapSize !== void 0 && (i.gapSize = this.gapSize),
        this.scale !== void 0 && (i.scale = this.scale),
        this.dithering === !0 && (i.dithering = !0),
        this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (i.alphaHash = !0),
        this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (i.forceSinglePass = !0),
        this.wireframe === !0 && (i.wireframe = !0),
        this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (i.flatShading = !0),
        this.visible === !1 && (i.visible = !1),
        this.toneMapped === !1 && (i.toneMapped = !1),
        this.fog === !1 && (i.fog = !1),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData);
        function r(s) {
            const o = [];
            for (const a in s) {
                const c = s[a];
                delete c.metadata,
                o.push(c)
            }
            return o
        }
        if (t) {
            const s = r(e.textures)
              , o = r(e.images);
            s.length > 0 && (i.textures = s),
            o.length > 0 && (i.images = o)
        }
        return i
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let i = null;
        if (t !== null) {
            const r = t.length;
            i = new Array(r);
            for (let s = 0; s !== r; ++s)
                i[s] = t[s].clone()
        }
        return this.clippingPlanes = i,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class uR extends Qp {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new mn(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = qC,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const Zn = new pe
  , Md = new on;
class to {
    constructor(e, t, i=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = i,
        this.usage = i1,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.gpuType = pa,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return console.warn('THREE.BufferAttribute: "updateRange" is deprecated and removed in r169. Use "addUpdateRange()" instead.'),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, t, i) {
        e *= this.itemSize,
        i *= t.itemSize;
        for (let r = 0, s = this.itemSize; r < s; r++)
            this.array[e + r] = t.array[i + r];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, i = this.count; t < i; t++)
                Md.fromBufferAttribute(this, t),
                Md.applyMatrix3(e),
                this.setXY(t, Md.x, Md.y);
        else if (this.itemSize === 3)
            for (let t = 0, i = this.count; t < i; t++)
                Zn.fromBufferAttribute(this, t),
                Zn.applyMatrix3(e),
                this.setXYZ(t, Zn.x, Zn.y, Zn.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++)
            Zn.fromBufferAttribute(this, t),
            Zn.applyMatrix4(e),
            this.setXYZ(t, Zn.x, Zn.y, Zn.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            Zn.fromBufferAttribute(this, t),
            Zn.applyNormalMatrix(e),
            this.setXYZ(t, Zn.x, Zn.y, Zn.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            Zn.fromBufferAttribute(this, t),
            Zn.transformDirection(e),
            this.setXYZ(t, Zn.x, Zn.y, Zn.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getComponent(e, t) {
        let i = this.array[e * this.itemSize + t];
        return this.normalized && (i = Du(i, this.array)),
        i
    }
    setComponent(e, t, i) {
        return this.normalized && (i = xr(i, this.array)),
        this.array[e * this.itemSize + t] = i,
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Du(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = xr(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Du(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = xr(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Du(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = xr(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Du(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = xr(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, i) {
        return e *= this.itemSize,
        this.normalized && (t = xr(t, this.array),
        i = xr(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, r) {
        return e *= this.itemSize,
        this.normalized && (t = xr(t, this.array),
        i = xr(i, this.array),
        r = xr(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this
    }
    setXYZW(e, t, i, r, s) {
        return e *= this.itemSize,
        this.normalized && (t = xr(t, this.array),
        i = xr(i, this.array),
        r = xr(r, this.array),
        s = xr(s, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this.array[e + 3] = s,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== i1 && (e.usage = this.usage),
        e
    }
}
class fR extends to {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i)
    }
}
class hR extends to {
    constructor(e, t, i) {
        super(new Uint32Array(e), t, i)
    }
}
class El extends to {
    constructor(e, t, i) {
        super(new Float32Array(e), t, i)
    }
}
let L4 = 0;
const cs = new Li
  , m0 = new Zr
  , dc = new pe
  , Hr = new rh
  , Uu = new rh
  , di = new pe;
class Nl extends Qc {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: L4++
        }),
        this.uuid = nh(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (rR(e) ? hR : fR)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, i=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: i
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const i = this.attributes.normal;
        if (i !== void 0) {
            const s = new jt().getNormalMatrix(e);
            i.applyNormalMatrix(s),
            i.needsUpdate = !0
        }
        const r = this.attributes.tangent;
        return r !== void 0 && (r.transformDirection(e),
        r.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return cs.makeRotationFromQuaternion(e),
        this.applyMatrix4(cs),
        this
    }
    rotateX(e) {
        return cs.makeRotationX(e),
        this.applyMatrix4(cs),
        this
    }
    rotateY(e) {
        return cs.makeRotationY(e),
        this.applyMatrix4(cs),
        this
    }
    rotateZ(e) {
        return cs.makeRotationZ(e),
        this.applyMatrix4(cs),
        this
    }
    translate(e, t, i) {
        return cs.makeTranslation(e, t, i),
        this.applyMatrix4(cs),
        this
    }
    scale(e, t, i) {
        return cs.makeScale(e, t, i),
        this.applyMatrix4(cs),
        this
    }
    lookAt(e) {
        return m0.lookAt(e),
        m0.updateMatrix(),
        this.applyMatrix4(m0.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(dc).negate(),
        this.translate(dc.x, dc.y, dc.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let i = 0, r = e.length; i < r; i++) {
            const s = e[i];
            t.push(s.x, s.y, s.z || 0)
        }
        return this.setAttribute("position", new El(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new rh);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingBox.set(new pe(-1 / 0,-1 / 0,-1 / 0), new pe(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let i = 0, r = t.length; i < r; i++) {
                    const s = t[i];
                    Hr.setFromBufferAttribute(s),
                    this.morphTargetsRelative ? (di.addVectors(this.boundingBox.min, Hr.min),
                    this.boundingBox.expandByPoint(di),
                    di.addVectors(this.boundingBox.max, Hr.max),
                    this.boundingBox.expandByPoint(di)) : (this.boundingBox.expandByPoint(Hr.min),
                    this.boundingBox.expandByPoint(Hr.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Ny);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingSphere.set(new pe, 1 / 0);
            return
        }
        if (e) {
            const i = this.boundingSphere.center;
            if (Hr.setFromBufferAttribute(e),
            t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s];
                    Uu.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (di.addVectors(Hr.min, Uu.min),
                    Hr.expandByPoint(di),
                    di.addVectors(Hr.max, Uu.max),
                    Hr.expandByPoint(di)) : (Hr.expandByPoint(Uu.min),
                    Hr.expandByPoint(Uu.max))
                }
            Hr.getCenter(i);
            let r = 0;
            for (let s = 0, o = e.count; s < o; s++)
                di.fromBufferAttribute(e, s),
                r = Math.max(r, i.distanceToSquared(di));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s]
                      , c = this.morphTargetsRelative;
                    for (let u = 0, h = a.count; u < h; u++)
                        di.fromBufferAttribute(a, u),
                        c && (dc.fromBufferAttribute(e, u),
                        di.add(dc)),
                        r = Math.max(r, i.distanceToSquared(di))
                }
            this.boundingSphere.radius = Math.sqrt(r),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const i = e.array
          , r = t.position.array
          , s = t.normal.array
          , o = t.uv.array
          , a = r.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new to(new Float32Array(4 * a),4));
        const c = this.getAttribute("tangent").array
          , u = []
          , h = [];
        for (let R = 0; R < a; R++)
            u[R] = new pe,
            h[R] = new pe;
        const m = new pe
          , d = new pe
          , f = new pe
          , _ = new on
          , g = new on
          , v = new on
          , y = new pe
          , w = new pe;
        function S(R, I, D) {
            m.fromArray(r, R * 3),
            d.fromArray(r, I * 3),
            f.fromArray(r, D * 3),
            _.fromArray(o, R * 2),
            g.fromArray(o, I * 2),
            v.fromArray(o, D * 2),
            d.sub(m),
            f.sub(m),
            g.sub(_),
            v.sub(_);
            const H = 1 / (g.x * v.y - v.x * g.y);
            isFinite(H) && (y.copy(d).multiplyScalar(v.y).addScaledVector(f, -g.y).multiplyScalar(H),
            w.copy(f).multiplyScalar(g.x).addScaledVector(d, -v.x).multiplyScalar(H),
            u[R].add(y),
            u[I].add(y),
            u[D].add(y),
            h[R].add(w),
            h[I].add(w),
            h[D].add(w))
        }
        let E = this.groups;
        E.length === 0 && (E = [{
            start: 0,
            count: i.length
        }]);
        for (let R = 0, I = E.length; R < I; ++R) {
            const D = E[R]
              , H = D.start
              , B = D.count;
            for (let G = H, X = H + B; G < X; G += 3)
                S(i[G + 0], i[G + 1], i[G + 2])
        }
        const b = new pe
          , T = new pe
          , C = new pe
          , P = new pe;
        function A(R) {
            C.fromArray(s, R * 3),
            P.copy(C);
            const I = u[R];
            b.copy(I),
            b.sub(C.multiplyScalar(C.dot(I))).normalize(),
            T.crossVectors(P, I);
            const H = T.dot(h[R]) < 0 ? -1 : 1;
            c[R * 4] = b.x,
            c[R * 4 + 1] = b.y,
            c[R * 4 + 2] = b.z,
            c[R * 4 + 3] = H
        }
        for (let R = 0, I = E.length; R < I; ++R) {
            const D = E[R]
              , H = D.start
              , B = D.count;
            for (let G = H, X = H + B; G < X; G += 3)
                A(i[G + 0]),
                A(i[G + 1]),
                A(i[G + 2])
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0)
                i = new to(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", i);
            else
                for (let d = 0, f = i.count; d < f; d++)
                    i.setXYZ(d, 0, 0, 0);
            const r = new pe
              , s = new pe
              , o = new pe
              , a = new pe
              , c = new pe
              , u = new pe
              , h = new pe
              , m = new pe;
            if (e)
                for (let d = 0, f = e.count; d < f; d += 3) {
                    const _ = e.getX(d + 0)
                      , g = e.getX(d + 1)
                      , v = e.getX(d + 2);
                    r.fromBufferAttribute(t, _),
                    s.fromBufferAttribute(t, g),
                    o.fromBufferAttribute(t, v),
                    h.subVectors(o, s),
                    m.subVectors(r, s),
                    h.cross(m),
                    a.fromBufferAttribute(i, _),
                    c.fromBufferAttribute(i, g),
                    u.fromBufferAttribute(i, v),
                    a.add(h),
                    c.add(h),
                    u.add(h),
                    i.setXYZ(_, a.x, a.y, a.z),
                    i.setXYZ(g, c.x, c.y, c.z),
                    i.setXYZ(v, u.x, u.y, u.z)
                }
            else
                for (let d = 0, f = t.count; d < f; d += 3)
                    r.fromBufferAttribute(t, d + 0),
                    s.fromBufferAttribute(t, d + 1),
                    o.fromBufferAttribute(t, d + 2),
                    h.subVectors(o, s),
                    m.subVectors(r, s),
                    h.cross(m),
                    i.setXYZ(d + 0, h.x, h.y, h.z),
                    i.setXYZ(d + 1, h.x, h.y, h.z),
                    i.setXYZ(d + 2, h.x, h.y, h.z);
            this.normalizeNormals(),
            i.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++)
            di.fromBufferAttribute(e, t),
            di.normalize(),
            e.setXYZ(t, di.x, di.y, di.z)
    }
    toNonIndexed() {
        function e(a, c) {
            const u = a.array
              , h = a.itemSize
              , m = a.normalized
              , d = new u.constructor(c.length * h);
            let f = 0
              , _ = 0;
            for (let g = 0, v = c.length; g < v; g++) {
                a.isInterleavedBufferAttribute ? f = c[g] * a.data.stride + a.offset : f = c[g] * h;
                for (let y = 0; y < h; y++)
                    d[_++] = u[f++]
            }
            return new to(d,h,m)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new Nl
          , i = this.index.array
          , r = this.attributes;
        for (const a in r) {
            const c = r[a]
              , u = e(c, i);
            t.setAttribute(a, u)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const c = []
              , u = s[a];
            for (let h = 0, m = u.length; h < m; h++) {
                const d = u[h]
                  , f = e(d, i);
                c.push(f)
            }
            t.morphAttributes[a] = c
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, c = o.length; a < c; a++) {
            const u = o[a];
            t.addGroup(u.start, u.count, u.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const c = this.parameters;
            for (const u in c)
                c[u] !== void 0 && (e[u] = c[u]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const i = this.attributes;
        for (const c in i) {
            const u = i[c];
            e.data.attributes[c] = u.toJSON(e.data)
        }
        const r = {};
        let s = !1;
        for (const c in this.morphAttributes) {
            const u = this.morphAttributes[c]
              , h = [];
            for (let m = 0, d = u.length; m < d; m++) {
                const f = u[m];
                h.push(f.toJSON(e.data))
            }
            h.length > 0 && (r[c] = h,
            s = !0)
        }
        s && (e.data.morphAttributes = r,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const i = e.index;
        i !== null && this.setIndex(i.clone(t));
        const r = e.attributes;
        for (const u in r) {
            const h = r[u];
            this.setAttribute(u, h.clone(t))
        }
        const s = e.morphAttributes;
        for (const u in s) {
            const h = []
              , m = s[u];
            for (let d = 0, f = m.length; d < f; d++)
                h.push(m[d].clone(t));
            this.morphAttributes[u] = h
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let u = 0, h = o.length; u < h; u++) {
            const m = o[u];
            this.addGroup(m.start, m.count, m.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const c = e.boundingSphere;
        return c !== null && (this.boundingSphere = c.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const _1 = new Li
  , ja = new S4
  , Td = new Ny
  , v1 = new pe
  , pc = new pe
  , mc = new pe
  , gc = new pe
  , g0 = new pe
  , Cd = new pe
  , Rd = new on
  , Pd = new on
  , Ld = new on
  , y1 = new pe
  , x1 = new pe
  , b1 = new pe
  , Dd = new pe
  , Id = new pe;
class Lo extends Zr {
    constructor(e=new Nl, t=new uR) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const i = this.geometry
          , r = i.attributes.position
          , s = i.morphAttributes.position
          , o = i.morphTargetsRelative;
        t.fromBufferAttribute(r, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            Cd.set(0, 0, 0);
            for (let c = 0, u = s.length; c < u; c++) {
                const h = a[c]
                  , m = s[c];
                h !== 0 && (g0.fromBufferAttribute(m, e),
                o ? Cd.addScaledVector(g0, h) : Cd.addScaledVector(g0.sub(t), h))
            }
            t.add(Cd)
        }
        return t
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.material
          , s = this.matrixWorld;
        r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(),
        Td.copy(i.boundingSphere),
        Td.applyMatrix4(s),
        ja.copy(e.ray).recast(e.near),
        !(Td.containsPoint(ja.origin) === !1 && (ja.intersectSphere(Td, v1) === null || ja.origin.distanceToSquared(v1) > (e.far - e.near) ** 2)) && (_1.copy(s).invert(),
        ja.copy(e.ray).applyMatrix4(_1),
        !(i.boundingBox !== null && ja.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t, ja)))
    }
    _computeIntersections(e, t, i) {
        let r;
        const s = this.geometry
          , o = this.material
          , a = s.index
          , c = s.attributes.position
          , u = s.attributes.uv
          , h = s.attributes.uv1
          , m = s.attributes.normal
          , d = s.groups
          , f = s.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let _ = 0, g = d.length; _ < g; _++) {
                    const v = d[_]
                      , y = o[v.materialIndex]
                      , w = Math.max(v.start, f.start)
                      , S = Math.min(a.count, Math.min(v.start + v.count, f.start + f.count));
                    for (let E = w, b = S; E < b; E += 3) {
                        const T = a.getX(E)
                          , C = a.getX(E + 1)
                          , P = a.getX(E + 2);
                        r = Od(this, y, e, i, u, h, m, T, C, P),
                        r && (r.faceIndex = Math.floor(E / 3),
                        r.face.materialIndex = v.materialIndex,
                        t.push(r))
                    }
                }
            else {
                const _ = Math.max(0, f.start)
                  , g = Math.min(a.count, f.start + f.count);
                for (let v = _, y = g; v < y; v += 3) {
                    const w = a.getX(v)
                      , S = a.getX(v + 1)
                      , E = a.getX(v + 2);
                    r = Od(this, o, e, i, u, h, m, w, S, E),
                    r && (r.faceIndex = Math.floor(v / 3),
                    t.push(r))
                }
            }
        else if (c !== void 0)
            if (Array.isArray(o))
                for (let _ = 0, g = d.length; _ < g; _++) {
                    const v = d[_]
                      , y = o[v.materialIndex]
                      , w = Math.max(v.start, f.start)
                      , S = Math.min(c.count, Math.min(v.start + v.count, f.start + f.count));
                    for (let E = w, b = S; E < b; E += 3) {
                        const T = E
                          , C = E + 1
                          , P = E + 2;
                        r = Od(this, y, e, i, u, h, m, T, C, P),
                        r && (r.faceIndex = Math.floor(E / 3),
                        r.face.materialIndex = v.materialIndex,
                        t.push(r))
                    }
                }
            else {
                const _ = Math.max(0, f.start)
                  , g = Math.min(c.count, f.start + f.count);
                for (let v = _, y = g; v < y; v += 3) {
                    const w = v
                      , S = v + 1
                      , E = v + 2;
                    r = Od(this, o, e, i, u, h, m, w, S, E),
                    r && (r.faceIndex = Math.floor(v / 3),
                    t.push(r))
                }
            }
    }
}
function D4(n, e, t, i, r, s, o, a) {
    let c;
    if (e.side === Lr ? c = i.intersectTriangle(o, s, r, !0, a) : c = i.intersectTriangle(r, s, o, e.side === Ma, a),
    c === null)
        return null;
    Id.copy(a),
    Id.applyMatrix4(n.matrixWorld);
    const u = t.ray.origin.distanceTo(Id);
    return u < t.near || u > t.far ? null : {
        distance: u,
        point: Id.clone(),
        object: n
    }
}
function Od(n, e, t, i, r, s, o, a, c, u) {
    n.getVertexPosition(a, pc),
    n.getVertexPosition(c, mc),
    n.getVertexPosition(u, gc);
    const h = D4(n, e, t, i, pc, mc, gc, Dd);
    if (h) {
        r && (Rd.fromBufferAttribute(r, a),
        Pd.fromBufferAttribute(r, c),
        Ld.fromBufferAttribute(r, u),
        h.uv = Is.getInterpolation(Dd, pc, mc, gc, Rd, Pd, Ld, new on)),
        s && (Rd.fromBufferAttribute(s, a),
        Pd.fromBufferAttribute(s, c),
        Ld.fromBufferAttribute(s, u),
        h.uv1 = Is.getInterpolation(Dd, pc, mc, gc, Rd, Pd, Ld, new on),
        h.uv2 = h.uv1),
        o && (y1.fromBufferAttribute(o, a),
        x1.fromBufferAttribute(o, c),
        b1.fromBufferAttribute(o, u),
        h.normal = Is.getInterpolation(Dd, pc, mc, gc, y1, x1, b1, new pe),
        h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
        const m = {
            a,
            b: c,
            c: u,
            normal: new pe,
            materialIndex: 0
        };
        Is.getNormal(pc, mc, gc, m.normal),
        h.face = m
    }
    return h
}
class sh extends Nl {
    constructor(e=1, t=1, i=1, r=1, s=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: r,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        r = Math.floor(r),
        s = Math.floor(s),
        o = Math.floor(o);
        const c = []
          , u = []
          , h = []
          , m = [];
        let d = 0
          , f = 0;
        _("z", "y", "x", -1, -1, i, t, e, o, s, 0),
        _("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
        _("x", "z", "y", 1, 1, e, i, t, r, o, 2),
        _("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
        _("x", "y", "z", 1, -1, e, t, i, r, s, 4),
        _("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
        this.setIndex(c),
        this.setAttribute("position", new El(u,3)),
        this.setAttribute("normal", new El(h,3)),
        this.setAttribute("uv", new El(m,2));
        function _(g, v, y, w, S, E, b, T, C, P, A) {
            const R = E / C
              , I = b / P
              , D = E / 2
              , H = b / 2
              , B = T / 2
              , G = C + 1
              , X = P + 1;
            let V = 0
              , ee = 0;
            const re = new pe;
            for (let k = 0; k < X; k++) {
                const oe = k * I - H;
                for (let ae = 0; ae < G; ae++) {
                    const ne = ae * R - D;
                    re[g] = ne * w,
                    re[v] = oe * S,
                    re[y] = B,
                    u.push(re.x, re.y, re.z),
                    re[g] = 0,
                    re[v] = 0,
                    re[y] = T > 0 ? 1 : -1,
                    h.push(re.x, re.y, re.z),
                    m.push(ae / C),
                    m.push(1 - k / P),
                    V += 1
                }
            }
            for (let k = 0; k < P; k++)
                for (let oe = 0; oe < C; oe++) {
                    const ae = d + oe + G * k
                      , ne = d + oe + G * (k + 1)
                      , fe = d + (oe + 1) + G * (k + 1)
                      , xe = d + (oe + 1) + G * k;
                    c.push(ae, ne, xe),
                    c.push(ne, fe, xe),
                    ee += 6
                }
            a.addGroup(f, ee, A),
            f += ee,
            d += V
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new sh(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function Kc(n) {
    const e = {};
    for (const t in n) {
        e[t] = {};
        for (const i in n[t]) {
            const r = n[t][i];
            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[t][i] = null) : e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r
        }
    }
    return e
}
function er(n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const i = Kc(n[t]);
        for (const r in i)
            e[r] = i[r]
    }
    return e
}
function I4(n) {
    const e = [];
    for (let t = 0; t < n.length; t++)
        e.push(n[t].clone());
    return e
}
function dR(n) {
    return n.getRenderTarget() === null ? n.outputColorSpace : pn.workingColorSpace
}
const O4 = {
    clone: Kc,
    merge: er
};
var N4 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , U4 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Ta extends Qp {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = N4,
        this.fragmentShader = U4,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = Kc(e.uniforms),
        this.uniformsGroups = I4(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const r in this.uniforms) {
            const o = this.uniforms[r].value;
            o && o.isTexture ? t.uniforms[r] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[r] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[r] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[r] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[r] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[r] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[r] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[r] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t.lights = this.lights,
        t.clipping = this.clipping;
        const i = {};
        for (const r in this.extensions)
            this.extensions[r] === !0 && (i[r] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i),
        t
    }
}
class pR extends Zr {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new Li,
        this.projectionMatrix = new Li,
        this.projectionMatrixInverse = new Li,
        this.coordinateSystem = Po
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class ps extends pR {
    constructor(e=50, t=1, i=.1, r=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = i,
        this.far = r,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = fv * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(Qg * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return fv * 2 * Math.atan(Math.tan(Qg * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(e, t, i, r, s, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(Qg * .5 * this.fov) / this.zoom
          , i = 2 * t
          , r = this.aspect * i
          , s = -.5 * r;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const c = o.fullWidth
              , u = o.fullHeight;
            s += o.offsetX * r / c,
            t -= o.offsetY * i / u,
            r *= o.width / c,
            i *= o.height / u
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const _c = -90
  , vc = 1;
class F4 extends Zr {
    constructor(e, t, i) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = i,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const r = new ps(_c,vc,e,t);
        r.layers = this.layers,
        this.add(r);
        const s = new ps(_c,vc,e,t);
        s.layers = this.layers,
        this.add(s);
        const o = new ps(_c,vc,e,t);
        o.layers = this.layers,
        this.add(o);
        const a = new ps(_c,vc,e,t);
        a.layers = this.layers,
        this.add(a);
        const c = new ps(_c,vc,e,t);
        c.layers = this.layers,
        this.add(c);
        const u = new ps(_c,vc,e,t);
        u.layers = this.layers,
        this.add(u)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , t = this.children.concat()
          , [i,r,s,o,a,c] = t;
        for (const u of t)
            this.remove(u);
        if (e === Po)
            i.up.set(0, 1, 0),
            i.lookAt(1, 0, 0),
            r.up.set(0, 1, 0),
            r.lookAt(-1, 0, 0),
            s.up.set(0, 0, -1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, 1),
            o.lookAt(0, -1, 0),
            a.up.set(0, 1, 0),
            a.lookAt(0, 0, 1),
            c.up.set(0, 1, 0),
            c.lookAt(0, 0, -1);
        else if (e === Cp)
            i.up.set(0, -1, 0),
            i.lookAt(-1, 0, 0),
            r.up.set(0, -1, 0),
            r.lookAt(1, 0, 0),
            s.up.set(0, 0, 1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, -1),
            o.lookAt(0, -1, 0),
            a.up.set(0, -1, 0),
            a.lookAt(0, 0, 1),
            c.up.set(0, -1, 0),
            c.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const u of t)
            this.add(u),
            u.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: i, activeMipmapLevel: r} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [s,o,a,c,u,h] = this.children
          , m = e.getRenderTarget()
          , d = e.getActiveCubeFace()
          , f = e.getActiveMipmapLevel()
          , _ = e.xr.enabled;
        e.xr.enabled = !1;
        const g = i.texture.generateMipmaps;
        i.texture.generateMipmaps = !1,
        e.setRenderTarget(i, 0, r),
        e.render(t, s),
        e.setRenderTarget(i, 1, r),
        e.render(t, o),
        e.setRenderTarget(i, 2, r),
        e.render(t, a),
        e.setRenderTarget(i, 3, r),
        e.render(t, c),
        e.setRenderTarget(i, 4, r),
        e.render(t, u),
        i.texture.generateMipmaps = g,
        e.setRenderTarget(i, 5, r),
        e.render(t, h),
        e.setRenderTarget(m, d, f),
        e.xr.enabled = _,
        i.texture.needsPMREMUpdate = !0
    }
}
class mR extends hr {
    constructor(e, t, i, r, s, o, a, c, u, h) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : qc,
        super(e, t, i, r, s, o, a, c, u, h),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class B4 extends Ll {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const i = {
            width: e,
            height: e,
            depth: 1
        }
          , r = [i, i, i, i, i, i];
        t.encoding !== void 0 && (Tf("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),
        t.colorSpace = t.encoding === wl ? Ci : ms),
        this.texture = new mR(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Er
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.colorSpace = t.colorSpace,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const i = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , r = new sh(5,5,5)
          , s = new Ta({
            name: "CubemapFromEquirect",
            uniforms: Kc(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: Lr,
            blending: ya
        });
        s.uniforms.tEquirect.value = t;
        const o = new Lo(r,s)
          , a = t.minFilter;
        return t.minFilter === Hf && (t.minFilter = Er),
        new F4(1,10,this).update(e, o),
        t.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, t, i, r) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(t, i, r);
        e.setRenderTarget(s)
    }
}
const _0 = new pe
  , k4 = new pe
  , z4 = new jt;
class tl {
    constructor(e=new pe(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, i, r) {
        return this.normal.set(e, t, i),
        this.constant = r,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, i) {
        const r = _0.subVectors(i, t).cross(k4.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const i = e.delta(_0)
          , r = this.normal.dot(i);
        if (r === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / r;
        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , i = this.distanceToPoint(e.end);
        return t < 0 && i > 0 || i < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const i = t || z4.getNormalMatrix(e)
          , r = this.coplanarPoint(_0).applyMatrix4(e)
          , s = this.normal.applyMatrix3(i).normalize();
        return this.constant = -r.dot(s),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Ya = new Ny
  , Nd = new pe;
class gR {
    constructor(e=new tl, t=new tl, i=new tl, r=new tl, s=new tl, o=new tl) {
        this.planes = [e, t, i, r, s, o]
    }
    set(e, t, i, r, s, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(i),
        a[3].copy(r),
        a[4].copy(s),
        a[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            t[i].copy(e.planes[i]);
        return this
    }
    setFromProjectionMatrix(e, t=Po) {
        const i = this.planes
          , r = e.elements
          , s = r[0]
          , o = r[1]
          , a = r[2]
          , c = r[3]
          , u = r[4]
          , h = r[5]
          , m = r[6]
          , d = r[7]
          , f = r[8]
          , _ = r[9]
          , g = r[10]
          , v = r[11]
          , y = r[12]
          , w = r[13]
          , S = r[14]
          , E = r[15];
        if (i[0].setComponents(c - s, d - u, v - f, E - y).normalize(),
        i[1].setComponents(c + s, d + u, v + f, E + y).normalize(),
        i[2].setComponents(c + o, d + h, v + _, E + w).normalize(),
        i[3].setComponents(c - o, d - h, v - _, E - w).normalize(),
        i[4].setComponents(c - a, d - m, v - g, E - S).normalize(),
        t === Po)
            i[5].setComponents(c + a, d + m, v + g, E + S).normalize();
        else if (t === Cp)
            i[5].setComponents(a, m, g, S).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            Ya.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
            Ya.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(Ya)
    }
    intersectsSprite(e) {
        return Ya.center.set(0, 0, 0),
        Ya.radius = .7071067811865476,
        Ya.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Ya)
    }
    intersectsSphere(e) {
        const t = this.planes
          , i = e.center
          , r = -e.radius;
        for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(i) < r)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) {
            const r = t[i];
            if (Nd.x = r.normal.x > 0 ? e.max.x : e.min.x,
            Nd.y = r.normal.y > 0 ? e.max.y : e.min.y,
            Nd.z = r.normal.z > 0 ? e.max.z : e.min.z,
            r.distanceToPoint(Nd) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            if (t[i].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function _R() {
    let n = null
      , e = !1
      , t = null
      , i = null;
    function r(s, o) {
        t(s, o),
        i = n.requestAnimationFrame(r)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (i = n.requestAnimationFrame(r),
            e = !0)
        },
        stop: function() {
            n.cancelAnimationFrame(i),
            e = !1
        },
        setAnimationLoop: function(s) {
            t = s
        },
        setContext: function(s) {
            n = s
        }
    }
}
function H4(n, e) {
    const t = e.isWebGL2
      , i = new WeakMap;
    function r(u, h) {
        const m = u.array
          , d = u.usage
          , f = m.byteLength
          , _ = n.createBuffer();
        n.bindBuffer(h, _),
        n.bufferData(h, m, d),
        u.onUploadCallback();
        let g;
        if (m instanceof Float32Array)
            g = n.FLOAT;
        else if (m instanceof Uint16Array)
            if (u.isFloat16BufferAttribute)
                if (t)
                    g = n.HALF_FLOAT;
                else
                    throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            else
                g = n.UNSIGNED_SHORT;
        else if (m instanceof Int16Array)
            g = n.SHORT;
        else if (m instanceof Uint32Array)
            g = n.UNSIGNED_INT;
        else if (m instanceof Int32Array)
            g = n.INT;
        else if (m instanceof Int8Array)
            g = n.BYTE;
        else if (m instanceof Uint8Array)
            g = n.UNSIGNED_BYTE;
        else if (m instanceof Uint8ClampedArray)
            g = n.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + m);
        return {
            buffer: _,
            type: g,
            bytesPerElement: m.BYTES_PER_ELEMENT,
            version: u.version,
            size: f
        }
    }
    function s(u, h, m) {
        const d = h.array
          , f = h._updateRange
          , _ = h.updateRanges;
        if (n.bindBuffer(m, u),
        f.count === -1 && _.length === 0 && n.bufferSubData(m, 0, d),
        _.length !== 0) {
            for (let g = 0, v = _.length; g < v; g++) {
                const y = _[g];
                t ? n.bufferSubData(m, y.start * d.BYTES_PER_ELEMENT, d, y.start, y.count) : n.bufferSubData(m, y.start * d.BYTES_PER_ELEMENT, d.subarray(y.start, y.start + y.count))
            }
            h.clearUpdateRanges()
        }
        f.count !== -1 && (t ? n.bufferSubData(m, f.offset * d.BYTES_PER_ELEMENT, d, f.offset, f.count) : n.bufferSubData(m, f.offset * d.BYTES_PER_ELEMENT, d.subarray(f.offset, f.offset + f.count)),
        f.count = -1),
        h.onUploadCallback()
    }
    function o(u) {
        return u.isInterleavedBufferAttribute && (u = u.data),
        i.get(u)
    }
    function a(u) {
        u.isInterleavedBufferAttribute && (u = u.data);
        const h = i.get(u);
        h && (n.deleteBuffer(h.buffer),
        i.delete(u))
    }
    function c(u, h) {
        if (u.isGLBufferAttribute) {
            const d = i.get(u);
            (!d || d.version < u.version) && i.set(u, {
                buffer: u.buffer,
                type: u.type,
                bytesPerElement: u.elementSize,
                version: u.version
            });
            return
        }
        u.isInterleavedBufferAttribute && (u = u.data);
        const m = i.get(u);
        if (m === void 0)
            i.set(u, r(u, h));
        else if (m.version < u.version) {
            if (m.size !== u.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            s(m.buffer, u, h),
            m.version = u.version
        }
    }
    return {
        get: o,
        remove: a,
        update: c
    }
}
class em extends Nl {
    constructor(e=1, t=1, i=1, r=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: r
        };
        const s = e / 2
          , o = t / 2
          , a = Math.floor(i)
          , c = Math.floor(r)
          , u = a + 1
          , h = c + 1
          , m = e / a
          , d = t / c
          , f = []
          , _ = []
          , g = []
          , v = [];
        for (let y = 0; y < h; y++) {
            const w = y * d - o;
            for (let S = 0; S < u; S++) {
                const E = S * m - s;
                _.push(E, -w, 0),
                g.push(0, 0, 1),
                v.push(S / a),
                v.push(1 - y / c)
            }
        }
        for (let y = 0; y < c; y++)
            for (let w = 0; w < a; w++) {
                const S = w + u * y
                  , E = w + u * (y + 1)
                  , b = w + 1 + u * (y + 1)
                  , T = w + 1 + u * y;
                f.push(S, E, T),
                f.push(E, b, T)
            }
        this.setIndex(f),
        this.setAttribute("position", new El(_,3)),
        this.setAttribute("normal", new El(g,3)),
        this.setAttribute("uv", new El(v,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new em(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
var G4 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`
  , V4 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`
  , W4 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
  , $4 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , X4 = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`
  , q4 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , j4 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , Y4 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , K4 = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , Z4 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`
  , J4 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`
  , Q4 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , e5 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
  , t5 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , n5 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , i5 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`
  , r5 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , s5 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , o5 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , a5 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , l5 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , c5 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`
  , u5 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`
  , f5 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
  , h5 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , d5 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , p5 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , m5 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
  , g5 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , _5 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , v5 = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , y5 = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`
  , x5 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , b5 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , S5 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , w5 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , E5 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , A5 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , M5 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , T5 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , C5 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , R5 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , P5 = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`
  , L5 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , D5 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , I5 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , O5 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , N5 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`
  , U5 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , F5 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , B5 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , k5 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , z5 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`
  , H5 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , G5 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , V5 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , W5 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`
  , $5 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , X5 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , q5 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`
  , j5 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`
  , Y5 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , K5 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , Z5 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , J5 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , Q5 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , ez = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , tz = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , nz = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`
  , iz = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`
  , rz = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`
  , sz = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`
  , oz = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , az = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , lz = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , cz = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , uz = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
  , fz = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`
  , hz = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
  , dz = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
  , pz = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , mz = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , gz = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
  , _z = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , vz = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , yz = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , xz = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , bz = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , Sz = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , wz = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`
  , Ez = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , Az = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , Mz = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , Tz = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , Cz = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , Rz = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , Pz = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , Lz = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , Dz = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , Iz = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , Oz = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , Nz = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`
  , Uz = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`
  , Fz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , Bz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , kz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
  , zz = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Hz = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , Gz = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , Vz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , Wz = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , $z = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , Xz = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , qz = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , jz = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`
  , Yz = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , Kz = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , Zz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , Jz = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , Qz = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , eH = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , tH = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , nH = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , iH = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , rH = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , sH = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , oH = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , aH = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , lH = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , cH = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , uH = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , fH = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , hH = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , dH = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , pH = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , mH = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , gH = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , _H = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , vH = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , yH = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , xH = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , Vt = {
    alphahash_fragment: G4,
    alphahash_pars_fragment: V4,
    alphamap_fragment: W4,
    alphamap_pars_fragment: $4,
    alphatest_fragment: X4,
    alphatest_pars_fragment: q4,
    aomap_fragment: j4,
    aomap_pars_fragment: Y4,
    batching_pars_vertex: K4,
    batching_vertex: Z4,
    begin_vertex: J4,
    beginnormal_vertex: Q4,
    bsdfs: e5,
    iridescence_fragment: t5,
    bumpmap_pars_fragment: n5,
    clipping_planes_fragment: i5,
    clipping_planes_pars_fragment: r5,
    clipping_planes_pars_vertex: s5,
    clipping_planes_vertex: o5,
    color_fragment: a5,
    color_pars_fragment: l5,
    color_pars_vertex: c5,
    color_vertex: u5,
    common: f5,
    cube_uv_reflection_fragment: h5,
    defaultnormal_vertex: d5,
    displacementmap_pars_vertex: p5,
    displacementmap_vertex: m5,
    emissivemap_fragment: g5,
    emissivemap_pars_fragment: _5,
    colorspace_fragment: v5,
    colorspace_pars_fragment: y5,
    envmap_fragment: x5,
    envmap_common_pars_fragment: b5,
    envmap_pars_fragment: S5,
    envmap_pars_vertex: w5,
    envmap_physical_pars_fragment: N5,
    envmap_vertex: E5,
    fog_vertex: A5,
    fog_pars_vertex: M5,
    fog_fragment: T5,
    fog_pars_fragment: C5,
    gradientmap_pars_fragment: R5,
    lightmap_fragment: P5,
    lightmap_pars_fragment: L5,
    lights_lambert_fragment: D5,
    lights_lambert_pars_fragment: I5,
    lights_pars_begin: O5,
    lights_toon_fragment: U5,
    lights_toon_pars_fragment: F5,
    lights_phong_fragment: B5,
    lights_phong_pars_fragment: k5,
    lights_physical_fragment: z5,
    lights_physical_pars_fragment: H5,
    lights_fragment_begin: G5,
    lights_fragment_maps: V5,
    lights_fragment_end: W5,
    logdepthbuf_fragment: $5,
    logdepthbuf_pars_fragment: X5,
    logdepthbuf_pars_vertex: q5,
    logdepthbuf_vertex: j5,
    map_fragment: Y5,
    map_pars_fragment: K5,
    map_particle_fragment: Z5,
    map_particle_pars_fragment: J5,
    metalnessmap_fragment: Q5,
    metalnessmap_pars_fragment: ez,
    morphcolor_vertex: tz,
    morphnormal_vertex: nz,
    morphtarget_pars_vertex: iz,
    morphtarget_vertex: rz,
    normal_fragment_begin: sz,
    normal_fragment_maps: oz,
    normal_pars_fragment: az,
    normal_pars_vertex: lz,
    normal_vertex: cz,
    normalmap_pars_fragment: uz,
    clearcoat_normal_fragment_begin: fz,
    clearcoat_normal_fragment_maps: hz,
    clearcoat_pars_fragment: dz,
    iridescence_pars_fragment: pz,
    opaque_fragment: mz,
    packing: gz,
    premultiplied_alpha_fragment: _z,
    project_vertex: vz,
    dithering_fragment: yz,
    dithering_pars_fragment: xz,
    roughnessmap_fragment: bz,
    roughnessmap_pars_fragment: Sz,
    shadowmap_pars_fragment: wz,
    shadowmap_pars_vertex: Ez,
    shadowmap_vertex: Az,
    shadowmask_pars_fragment: Mz,
    skinbase_vertex: Tz,
    skinning_pars_vertex: Cz,
    skinning_vertex: Rz,
    skinnormal_vertex: Pz,
    specularmap_fragment: Lz,
    specularmap_pars_fragment: Dz,
    tonemapping_fragment: Iz,
    tonemapping_pars_fragment: Oz,
    transmission_fragment: Nz,
    transmission_pars_fragment: Uz,
    uv_pars_fragment: Fz,
    uv_pars_vertex: Bz,
    uv_vertex: kz,
    worldpos_vertex: zz,
    background_vert: Hz,
    background_frag: Gz,
    backgroundCube_vert: Vz,
    backgroundCube_frag: Wz,
    cube_vert: $z,
    cube_frag: Xz,
    depth_vert: qz,
    depth_frag: jz,
    distanceRGBA_vert: Yz,
    distanceRGBA_frag: Kz,
    equirect_vert: Zz,
    equirect_frag: Jz,
    linedashed_vert: Qz,
    linedashed_frag: eH,
    meshbasic_vert: tH,
    meshbasic_frag: nH,
    meshlambert_vert: iH,
    meshlambert_frag: rH,
    meshmatcap_vert: sH,
    meshmatcap_frag: oH,
    meshnormal_vert: aH,
    meshnormal_frag: lH,
    meshphong_vert: cH,
    meshphong_frag: uH,
    meshphysical_vert: fH,
    meshphysical_frag: hH,
    meshtoon_vert: dH,
    meshtoon_frag: pH,
    points_vert: mH,
    points_frag: gH,
    shadow_vert: _H,
    shadow_frag: vH,
    sprite_vert: yH,
    sprite_frag: xH
}
  , Ve = {
    common: {
        diffuse: {
            value: new mn(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new jt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new jt
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new jt
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new jt
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new jt
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new jt
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new jt
        },
        normalScale: {
            value: new on(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new jt
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new jt
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new jt
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new jt
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new mn(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new mn(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new jt
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new jt
        }
    },
    sprite: {
        diffuse: {
            value: new mn(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new on(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new jt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new jt
        },
        alphaTest: {
            value: 0
        }
    }
}
  , qs = {
    basic: {
        uniforms: er([Ve.common, Ve.specularmap, Ve.envmap, Ve.aomap, Ve.lightmap, Ve.fog]),
        vertexShader: Vt.meshbasic_vert,
        fragmentShader: Vt.meshbasic_frag
    },
    lambert: {
        uniforms: er([Ve.common, Ve.specularmap, Ve.envmap, Ve.aomap, Ve.lightmap, Ve.emissivemap, Ve.bumpmap, Ve.normalmap, Ve.displacementmap, Ve.fog, Ve.lights, {
            emissive: {
                value: new mn(0)
            }
        }]),
        vertexShader: Vt.meshlambert_vert,
        fragmentShader: Vt.meshlambert_frag
    },
    phong: {
        uniforms: er([Ve.common, Ve.specularmap, Ve.envmap, Ve.aomap, Ve.lightmap, Ve.emissivemap, Ve.bumpmap, Ve.normalmap, Ve.displacementmap, Ve.fog, Ve.lights, {
            emissive: {
                value: new mn(0)
            },
            specular: {
                value: new mn(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: Vt.meshphong_vert,
        fragmentShader: Vt.meshphong_frag
    },
    standard: {
        uniforms: er([Ve.common, Ve.envmap, Ve.aomap, Ve.lightmap, Ve.emissivemap, Ve.bumpmap, Ve.normalmap, Ve.displacementmap, Ve.roughnessmap, Ve.metalnessmap, Ve.fog, Ve.lights, {
            emissive: {
                value: new mn(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: Vt.meshphysical_vert,
        fragmentShader: Vt.meshphysical_frag
    },
    toon: {
        uniforms: er([Ve.common, Ve.aomap, Ve.lightmap, Ve.emissivemap, Ve.bumpmap, Ve.normalmap, Ve.displacementmap, Ve.gradientmap, Ve.fog, Ve.lights, {
            emissive: {
                value: new mn(0)
            }
        }]),
        vertexShader: Vt.meshtoon_vert,
        fragmentShader: Vt.meshtoon_frag
    },
    matcap: {
        uniforms: er([Ve.common, Ve.bumpmap, Ve.normalmap, Ve.displacementmap, Ve.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: Vt.meshmatcap_vert,
        fragmentShader: Vt.meshmatcap_frag
    },
    points: {
        uniforms: er([Ve.points, Ve.fog]),
        vertexShader: Vt.points_vert,
        fragmentShader: Vt.points_frag
    },
    dashed: {
        uniforms: er([Ve.common, Ve.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: Vt.linedashed_vert,
        fragmentShader: Vt.linedashed_frag
    },
    depth: {
        uniforms: er([Ve.common, Ve.displacementmap]),
        vertexShader: Vt.depth_vert,
        fragmentShader: Vt.depth_frag
    },
    normal: {
        uniforms: er([Ve.common, Ve.bumpmap, Ve.normalmap, Ve.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Vt.meshnormal_vert,
        fragmentShader: Vt.meshnormal_frag
    },
    sprite: {
        uniforms: er([Ve.sprite, Ve.fog]),
        vertexShader: Vt.sprite_vert,
        fragmentShader: Vt.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new jt
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: Vt.background_vert,
        fragmentShader: Vt.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: Vt.backgroundCube_vert,
        fragmentShader: Vt.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: Vt.cube_vert,
        fragmentShader: Vt.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: Vt.equirect_vert,
        fragmentShader: Vt.equirect_frag
    },
    distanceRGBA: {
        uniforms: er([Ve.common, Ve.displacementmap, {
            referencePosition: {
                value: new pe
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: Vt.distanceRGBA_vert,
        fragmentShader: Vt.distanceRGBA_frag
    },
    shadow: {
        uniforms: er([Ve.lights, Ve.fog, {
            color: {
                value: new mn(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Vt.shadow_vert,
        fragmentShader: Vt.shadow_frag
    }
};
qs.physical = {
    uniforms: er([qs.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new jt
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new jt
        },
        clearcoatNormalScale: {
            value: new on(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new jt
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new jt
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new jt
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new mn(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new jt
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new jt
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new jt
        },
        transmissionSamplerSize: {
            value: new on
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new jt
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new mn(0)
        },
        specularColor: {
            value: new mn(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new jt
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new jt
        },
        anisotropyVector: {
            value: new on
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new jt
        }
    }]),
    vertexShader: Vt.meshphysical_vert,
    fragmentShader: Vt.meshphysical_frag
};
const Ud = {
    r: 0,
    b: 0,
    g: 0
};
function bH(n, e, t, i, r, s, o) {
    const a = new mn(0);
    let c = s === !0 ? 0 : 1, u, h, m = null, d = 0, f = null;
    function _(v, y) {
        let w = !1
          , S = y.isScene === !0 ? y.background : null;
        S && S.isTexture && (S = (y.backgroundBlurriness > 0 ? t : e).get(S)),
        S === null ? g(a, c) : S && S.isColor && (g(S, 1),
        w = !0);
        const E = n.xr.getEnvironmentBlendMode();
        E === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, o) : E === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o),
        (n.autoClear || w) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
        S && (S.isCubeTexture || S.mapping === Kp) ? (h === void 0 && (h = new Lo(new sh(1,1,1),new Ta({
            name: "BackgroundCubeMaterial",
            uniforms: Kc(qs.backgroundCube.uniforms),
            vertexShader: qs.backgroundCube.vertexShader,
            fragmentShader: qs.backgroundCube.fragmentShader,
            side: Lr,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        h.geometry.deleteAttribute("normal"),
        h.geometry.deleteAttribute("uv"),
        h.onBeforeRender = function(b, T, C) {
            this.matrixWorld.copyPosition(C.matrixWorld)
        }
        ,
        Object.defineProperty(h.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        r.update(h)),
        h.material.uniforms.envMap.value = S,
        h.material.uniforms.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1,
        h.material.uniforms.backgroundBlurriness.value = y.backgroundBlurriness,
        h.material.uniforms.backgroundIntensity.value = y.backgroundIntensity,
        h.material.toneMapped = pn.getTransfer(S.colorSpace) !== Rn,
        (m !== S || d !== S.version || f !== n.toneMapping) && (h.material.needsUpdate = !0,
        m = S,
        d = S.version,
        f = n.toneMapping),
        h.layers.enableAll(),
        v.unshift(h, h.geometry, h.material, 0, 0, null)) : S && S.isTexture && (u === void 0 && (u = new Lo(new em(2,2),new Ta({
            name: "BackgroundMaterial",
            uniforms: Kc(qs.background.uniforms),
            vertexShader: qs.background.vertexShader,
            fragmentShader: qs.background.fragmentShader,
            side: Ma,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        u.geometry.deleteAttribute("normal"),
        Object.defineProperty(u.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        r.update(u)),
        u.material.uniforms.t2D.value = S,
        u.material.uniforms.backgroundIntensity.value = y.backgroundIntensity,
        u.material.toneMapped = pn.getTransfer(S.colorSpace) !== Rn,
        S.matrixAutoUpdate === !0 && S.updateMatrix(),
        u.material.uniforms.uvTransform.value.copy(S.matrix),
        (m !== S || d !== S.version || f !== n.toneMapping) && (u.material.needsUpdate = !0,
        m = S,
        d = S.version,
        f = n.toneMapping),
        u.layers.enableAll(),
        v.unshift(u, u.geometry, u.material, 0, 0, null))
    }
    function g(v, y) {
        v.getRGB(Ud, dR(n)),
        i.buffers.color.setClear(Ud.r, Ud.g, Ud.b, y, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(v, y=1) {
            a.set(v),
            c = y,
            g(a, c)
        },
        getClearAlpha: function() {
            return c
        },
        setClearAlpha: function(v) {
            c = v,
            g(a, c)
        },
        render: _
    }
}
function SH(n, e, t, i) {
    const r = n.getParameter(n.MAX_VERTEX_ATTRIBS)
      , s = i.isWebGL2 ? null : e.get("OES_vertex_array_object")
      , o = i.isWebGL2 || s !== null
      , a = {}
      , c = v(null);
    let u = c
      , h = !1;
    function m(B, G, X, V, ee) {
        let re = !1;
        if (o) {
            const k = g(V, X, G);
            u !== k && (u = k,
            f(u.object)),
            re = y(B, V, X, ee),
            re && w(B, V, X, ee)
        } else {
            const k = G.wireframe === !0;
            (u.geometry !== V.id || u.program !== X.id || u.wireframe !== k) && (u.geometry = V.id,
            u.program = X.id,
            u.wireframe = k,
            re = !0)
        }
        ee !== null && t.update(ee, n.ELEMENT_ARRAY_BUFFER),
        (re || h) && (h = !1,
        P(B, G, X, V),
        ee !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(ee).buffer))
    }
    function d() {
        return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES()
    }
    function f(B) {
        return i.isWebGL2 ? n.bindVertexArray(B) : s.bindVertexArrayOES(B)
    }
    function _(B) {
        return i.isWebGL2 ? n.deleteVertexArray(B) : s.deleteVertexArrayOES(B)
    }
    function g(B, G, X) {
        const V = X.wireframe === !0;
        let ee = a[B.id];
        ee === void 0 && (ee = {},
        a[B.id] = ee);
        let re = ee[G.id];
        re === void 0 && (re = {},
        ee[G.id] = re);
        let k = re[V];
        return k === void 0 && (k = v(d()),
        re[V] = k),
        k
    }
    function v(B) {
        const G = []
          , X = []
          , V = [];
        for (let ee = 0; ee < r; ee++)
            G[ee] = 0,
            X[ee] = 0,
            V[ee] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: G,
            enabledAttributes: X,
            attributeDivisors: V,
            object: B,
            attributes: {},
            index: null
        }
    }
    function y(B, G, X, V) {
        const ee = u.attributes
          , re = G.attributes;
        let k = 0;
        const oe = X.getAttributes();
        for (const ae in oe)
            if (oe[ae].location >= 0) {
                const fe = ee[ae];
                let xe = re[ae];
                if (xe === void 0 && (ae === "instanceMatrix" && B.instanceMatrix && (xe = B.instanceMatrix),
                ae === "instanceColor" && B.instanceColor && (xe = B.instanceColor)),
                fe === void 0 || fe.attribute !== xe || xe && fe.data !== xe.data)
                    return !0;
                k++
            }
        return u.attributesNum !== k || u.index !== V
    }
    function w(B, G, X, V) {
        const ee = {}
          , re = G.attributes;
        let k = 0;
        const oe = X.getAttributes();
        for (const ae in oe)
            if (oe[ae].location >= 0) {
                let fe = re[ae];
                fe === void 0 && (ae === "instanceMatrix" && B.instanceMatrix && (fe = B.instanceMatrix),
                ae === "instanceColor" && B.instanceColor && (fe = B.instanceColor));
                const xe = {};
                xe.attribute = fe,
                fe && fe.data && (xe.data = fe.data),
                ee[ae] = xe,
                k++
            }
        u.attributes = ee,
        u.attributesNum = k,
        u.index = V
    }
    function S() {
        const B = u.newAttributes;
        for (let G = 0, X = B.length; G < X; G++)
            B[G] = 0
    }
    function E(B) {
        b(B, 0)
    }
    function b(B, G) {
        const X = u.newAttributes
          , V = u.enabledAttributes
          , ee = u.attributeDivisors;
        X[B] = 1,
        V[B] === 0 && (n.enableVertexAttribArray(B),
        V[B] = 1),
        ee[B] !== G && ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](B, G),
        ee[B] = G)
    }
    function T() {
        const B = u.newAttributes
          , G = u.enabledAttributes;
        for (let X = 0, V = G.length; X < V; X++)
            G[X] !== B[X] && (n.disableVertexAttribArray(X),
            G[X] = 0)
    }
    function C(B, G, X, V, ee, re, k) {
        k === !0 ? n.vertexAttribIPointer(B, G, X, ee, re) : n.vertexAttribPointer(B, G, X, V, ee, re)
    }
    function P(B, G, X, V) {
        if (i.isWebGL2 === !1 && (B.isInstancedMesh || V.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
            return;
        S();
        const ee = V.attributes
          , re = X.getAttributes()
          , k = G.defaultAttributeValues;
        for (const oe in re) {
            const ae = re[oe];
            if (ae.location >= 0) {
                let ne = ee[oe];
                if (ne === void 0 && (oe === "instanceMatrix" && B.instanceMatrix && (ne = B.instanceMatrix),
                oe === "instanceColor" && B.instanceColor && (ne = B.instanceColor)),
                ne !== void 0) {
                    const fe = ne.normalized
                      , xe = ne.itemSize
                      , Re = t.get(ne);
                    if (Re === void 0)
                        continue;
                    const Ue = Re.buffer
                      , He = Re.type
                      , qe = Re.bytesPerElement
                      , Xe = i.isWebGL2 === !0 && (He === n.INT || He === n.UNSIGNED_INT || ne.gpuType === YC);
                    if (ne.isInterleavedBufferAttribute) {
                        const st = ne.data
                          , ie = st.stride
                          , dt = ne.offset;
                        if (st.isInstancedInterleavedBuffer) {
                            for (let Ne = 0; Ne < ae.locationSize; Ne++)
                                b(ae.location + Ne, st.meshPerAttribute);
                            B.isInstancedMesh !== !0 && V._maxInstanceCount === void 0 && (V._maxInstanceCount = st.meshPerAttribute * st.count)
                        } else
                            for (let Ne = 0; Ne < ae.locationSize; Ne++)
                                E(ae.location + Ne);
                        n.bindBuffer(n.ARRAY_BUFFER, Ue);
                        for (let Ne = 0; Ne < ae.locationSize; Ne++)
                            C(ae.location + Ne, xe / ae.locationSize, He, fe, ie * qe, (dt + xe / ae.locationSize * Ne) * qe, Xe)
                    } else {
                        if (ne.isInstancedBufferAttribute) {
                            for (let st = 0; st < ae.locationSize; st++)
                                b(ae.location + st, ne.meshPerAttribute);
                            B.isInstancedMesh !== !0 && V._maxInstanceCount === void 0 && (V._maxInstanceCount = ne.meshPerAttribute * ne.count)
                        } else
                            for (let st = 0; st < ae.locationSize; st++)
                                E(ae.location + st);
                        n.bindBuffer(n.ARRAY_BUFFER, Ue);
                        for (let st = 0; st < ae.locationSize; st++)
                            C(ae.location + st, xe / ae.locationSize, He, fe, xe * qe, xe / ae.locationSize * st * qe, Xe)
                    }
                } else if (k !== void 0) {
                    const fe = k[oe];
                    if (fe !== void 0)
                        switch (fe.length) {
                        case 2:
                            n.vertexAttrib2fv(ae.location, fe);
                            break;
                        case 3:
                            n.vertexAttrib3fv(ae.location, fe);
                            break;
                        case 4:
                            n.vertexAttrib4fv(ae.location, fe);
                            break;
                        default:
                            n.vertexAttrib1fv(ae.location, fe)
                        }
                }
            }
        }
        T()
    }
    function A() {
        D();
        for (const B in a) {
            const G = a[B];
            for (const X in G) {
                const V = G[X];
                for (const ee in V)
                    _(V[ee].object),
                    delete V[ee];
                delete G[X]
            }
            delete a[B]
        }
    }
    function R(B) {
        if (a[B.id] === void 0)
            return;
        const G = a[B.id];
        for (const X in G) {
            const V = G[X];
            for (const ee in V)
                _(V[ee].object),
                delete V[ee];
            delete G[X]
        }
        delete a[B.id]
    }
    function I(B) {
        for (const G in a) {
            const X = a[G];
            if (X[B.id] === void 0)
                continue;
            const V = X[B.id];
            for (const ee in V)
                _(V[ee].object),
                delete V[ee];
            delete X[B.id]
        }
    }
    function D() {
        H(),
        h = !0,
        u !== c && (u = c,
        f(u.object))
    }
    function H() {
        c.geometry = null,
        c.program = null,
        c.wireframe = !1
    }
    return {
        setup: m,
        reset: D,
        resetDefaultState: H,
        dispose: A,
        releaseStatesOfGeometry: R,
        releaseStatesOfProgram: I,
        initAttributes: S,
        enableAttribute: E,
        disableUnusedAttributes: T
    }
}
function wH(n, e, t, i) {
    const r = i.isWebGL2;
    let s;
    function o(h) {
        s = h
    }
    function a(h, m) {
        n.drawArrays(s, h, m),
        t.update(m, s, 1)
    }
    function c(h, m, d) {
        if (d === 0)
            return;
        let f, _;
        if (r)
            f = n,
            _ = "drawArraysInstanced";
        else if (f = e.get("ANGLE_instanced_arrays"),
        _ = "drawArraysInstancedANGLE",
        f === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        f[_](s, h, m, d),
        t.update(m, s, d)
    }
    function u(h, m, d) {
        if (d === 0)
            return;
        const f = e.get("WEBGL_multi_draw");
        if (f === null)
            for (let _ = 0; _ < d; _++)
                this.render(h[_], m[_]);
        else {
            f.multiDrawArraysWEBGL(s, h, 0, m, 0, d);
            let _ = 0;
            for (let g = 0; g < d; g++)
                _ += m[g];
            t.update(_, s, 1)
        }
    }
    this.setMode = o,
    this.render = a,
    this.renderInstances = c,
    this.renderMultiDraw = u
}
function EH(n, e, t) {
    let i;
    function r() {
        if (i !== void 0)
            return i;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const C = e.get("EXT_texture_filter_anisotropic");
            i = n.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            i = 0;
        return i
    }
    function s(C) {
        if (C === "highp") {
            if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0)
                return "highp";
            C = "mediump"
        }
        return C === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    const o = typeof WebGL2RenderingContext < "u" && n.constructor.name === "WebGL2RenderingContext";
    let a = t.precision !== void 0 ? t.precision : "highp";
    const c = s(a);
    c !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", c, "instead."),
    a = c);
    const u = o || e.has("WEBGL_draw_buffers")
      , h = t.logarithmicDepthBuffer === !0
      , m = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)
      , d = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , f = n.getParameter(n.MAX_TEXTURE_SIZE)
      , _ = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)
      , g = n.getParameter(n.MAX_VERTEX_ATTRIBS)
      , v = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)
      , y = n.getParameter(n.MAX_VARYING_VECTORS)
      , w = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)
      , S = d > 0
      , E = o || e.has("OES_texture_float")
      , b = S && E
      , T = o ? n.getParameter(n.MAX_SAMPLES) : 0;
    return {
        isWebGL2: o,
        drawBuffers: u,
        getMaxAnisotropy: r,
        getMaxPrecision: s,
        precision: a,
        logarithmicDepthBuffer: h,
        maxTextures: m,
        maxVertexTextures: d,
        maxTextureSize: f,
        maxCubemapSize: _,
        maxAttributes: g,
        maxVertexUniforms: v,
        maxVaryings: y,
        maxFragmentUniforms: w,
        vertexTextures: S,
        floatFragmentTextures: E,
        floatVertexTextures: b,
        maxSamples: T
    }
}
function AH(n) {
    const e = this;
    let t = null
      , i = 0
      , r = !1
      , s = !1;
    const o = new tl
      , a = new jt
      , c = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = c,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(m, d) {
        const f = m.length !== 0 || d || i !== 0 || r;
        return r = d,
        i = m.length,
        f
    }
    ,
    this.beginShadows = function() {
        s = !0,
        h(null)
    }
    ,
    this.endShadows = function() {
        s = !1
    }
    ,
    this.setGlobalState = function(m, d) {
        t = h(m, d, 0)
    }
    ,
    this.setState = function(m, d, f) {
        const _ = m.clippingPlanes
          , g = m.clipIntersection
          , v = m.clipShadows
          , y = n.get(m);
        if (!r || _ === null || _.length === 0 || s && !v)
            s ? h(null) : u();
        else {
            const w = s ? 0 : i
              , S = w * 4;
            let E = y.clippingState || null;
            c.value = E,
            E = h(_, d, S, f);
            for (let b = 0; b !== S; ++b)
                E[b] = t[b];
            y.clippingState = E,
            this.numIntersection = g ? this.numPlanes : 0,
            this.numPlanes += w
        }
    }
    ;
    function u() {
        c.value !== t && (c.value = t,
        c.needsUpdate = i > 0),
        e.numPlanes = i,
        e.numIntersection = 0
    }
    function h(m, d, f, _) {
        const g = m !== null ? m.length : 0;
        let v = null;
        if (g !== 0) {
            if (v = c.value,
            _ !== !0 || v === null) {
                const y = f + g * 4
                  , w = d.matrixWorldInverse;
                a.getNormalMatrix(w),
                (v === null || v.length < y) && (v = new Float32Array(y));
                for (let S = 0, E = f; S !== g; ++S,
                E += 4)
                    o.copy(m[S]).applyMatrix4(w, a),
                    o.normal.toArray(v, E),
                    v[E + 3] = o.constant
            }
            c.value = v,
            c.needsUpdate = !0
        }
        return e.numPlanes = g,
        e.numIntersection = 0,
        v
    }
}
function MH(n) {
    let e = new WeakMap;
    function t(o, a) {
        return a === ov ? o.mapping = qc : a === av && (o.mapping = jc),
        o
    }
    function i(o) {
        if (o && o.isTexture) {
            const a = o.mapping;
            if (a === ov || a === av)
                if (e.has(o)) {
                    const c = e.get(o).texture;
                    return t(c, o.mapping)
                } else {
                    const c = o.image;
                    if (c && c.height > 0) {
                        const u = new B4(c.height / 2);
                        return u.fromEquirectangularTexture(n, o),
                        e.set(o, u),
                        o.addEventListener("dispose", r),
                        t(u.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function r(o) {
        const a = o.target;
        a.removeEventListener("dispose", r);
        const c = e.get(a);
        c !== void 0 && (e.delete(a),
        c.dispose())
    }
    function s() {
        e = new WeakMap
    }
    return {
        get: i,
        dispose: s
    }
}
class TH extends pR {
    constructor(e=-1, t=1, i=1, r=-1, s=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = i,
        this.bottom = r,
        this.near = s,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, i, r, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , i = (this.right + this.left) / 2
          , r = (this.top + this.bottom) / 2;
        let s = i - e
          , o = i + e
          , a = r + t
          , c = r - t;
        if (this.view !== null && this.view.enabled) {
            const u = (this.right - this.left) / this.view.fullWidth / this.zoom
              , h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += u * this.view.offsetX,
            o = s + u * this.view.width,
            a -= h * this.view.offsetY,
            c = a - h * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, c, this.near, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const Rc = 4
  , S1 = [.125, .215, .35, .446, .526, .582]
  , al = 20
  , v0 = new TH
  , w1 = new mn;
let y0 = null
  , x0 = 0
  , b0 = 0;
const nl = (1 + Math.sqrt(5)) / 2
  , yc = 1 / nl
  , E1 = [new pe(1,1,1), new pe(-1,1,1), new pe(1,1,-1), new pe(-1,1,-1), new pe(0,nl,yc), new pe(0,nl,-yc), new pe(yc,0,nl), new pe(-yc,0,nl), new pe(nl,yc,0), new pe(-nl,yc,0)];
class A1 {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, i=.1, r=100) {
        y0 = this._renderer.getRenderTarget(),
        x0 = this._renderer.getActiveCubeFace(),
        b0 = this._renderer.getActiveMipmapLevel(),
        this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0,
        this._sceneToCubeUV(e, i, r, s),
        t > 0 && this._blur(s, 0, 0, t),
        this._applyPMREM(s),
        this._cleanup(s),
        s
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = C1(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = T1(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(y0, x0, b0),
        e.scissorTest = !1,
        Fd(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === qc || e.mapping === jc ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        y0 = this._renderer.getRenderTarget(),
        x0 = this._renderer.getActiveCubeFace(),
        b0 = this._renderer.getActiveMipmapLevel();
        const i = t || this._allocateTargets();
        return this._textureToCubeUV(e, i),
        this._applyPMREM(i),
        this._cleanup(i),
        i
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , i = {
            magFilter: Er,
            minFilter: Er,
            generateMipmaps: !1,
            type: Gf,
            format: Ns,
            colorSpace: No,
            depthBuffer: !1
        }
          , r = M1(e, t, i);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = M1(e, t, i);
            const {_lodMax: s} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = CH(s)),
            this._blurMaterial = RH(s, e, t)
        }
        return r
    }
    _compileMaterial(e) {
        const t = new Lo(this._lodPlanes[0],e);
        this._renderer.compile(t, v0)
    }
    _sceneToCubeUV(e, t, i, r) {
        const a = new ps(90,1,t,i)
          , c = [1, -1, 1, 1, 1, 1]
          , u = [1, 1, 1, -1, -1, -1]
          , h = this._renderer
          , m = h.autoClear
          , d = h.toneMapping;
        h.getClearColor(w1),
        h.toneMapping = xa,
        h.autoClear = !1;
        const f = new uR({
            name: "PMREM.Background",
            side: Lr,
            depthWrite: !1,
            depthTest: !1
        })
          , _ = new Lo(new sh,f);
        let g = !1;
        const v = e.background;
        v ? v.isColor && (f.color.copy(v),
        e.background = null,
        g = !0) : (f.color.copy(w1),
        g = !0);
        for (let y = 0; y < 6; y++) {
            const w = y % 3;
            w === 0 ? (a.up.set(0, c[y], 0),
            a.lookAt(u[y], 0, 0)) : w === 1 ? (a.up.set(0, 0, c[y]),
            a.lookAt(0, u[y], 0)) : (a.up.set(0, c[y], 0),
            a.lookAt(0, 0, u[y]));
            const S = this._cubeSize;
            Fd(r, w * S, y > 2 ? S : 0, S, S),
            h.setRenderTarget(r),
            g && h.render(_, a),
            h.render(e, a)
        }
        _.geometry.dispose(),
        _.material.dispose(),
        h.toneMapping = d,
        h.autoClear = m,
        e.background = v
    }
    _textureToCubeUV(e, t) {
        const i = this._renderer
          , r = e.mapping === qc || e.mapping === jc;
        r ? (this._cubemapMaterial === null && (this._cubemapMaterial = C1()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = T1());
        const s = r ? this._cubemapMaterial : this._equirectMaterial
          , o = new Lo(this._lodPlanes[0],s)
          , a = s.uniforms;
        a.envMap.value = e;
        const c = this._cubeSize;
        Fd(t, 0, 0, 3 * c, 2 * c),
        i.setRenderTarget(t),
        i.render(o, v0)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , i = t.autoClear;
        t.autoClear = !1;
        for (let r = 1; r < this._lodPlanes.length; r++) {
            const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1])
              , o = E1[(r - 1) % E1.length];
            this._blur(e, r - 1, r, s, o)
        }
        t.autoClear = i
    }
    _blur(e, t, i, r, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, i, r, "latitudinal", s),
        this._halfBlur(o, e, i, i, r, "longitudinal", s)
    }
    _halfBlur(e, t, i, r, s, o, a) {
        const c = this._renderer
          , u = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const h = 3
          , m = new Lo(this._lodPlanes[r],u)
          , d = u.uniforms
          , f = this._sizeLods[i] - 1
          , _ = isFinite(s) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * al - 1)
          , g = s / _
          , v = isFinite(s) ? 1 + Math.floor(h * g) : al;
        v > al && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${al}`);
        const y = [];
        let w = 0;
        for (let C = 0; C < al; ++C) {
            const P = C / g
              , A = Math.exp(-P * P / 2);
            y.push(A),
            C === 0 ? w += A : C < v && (w += 2 * A)
        }
        for (let C = 0; C < y.length; C++)
            y[C] = y[C] / w;
        d.envMap.value = e.texture,
        d.samples.value = v,
        d.weights.value = y,
        d.latitudinal.value = o === "latitudinal",
        a && (d.poleAxis.value = a);
        const {_lodMax: S} = this;
        d.dTheta.value = _,
        d.mipInt.value = S - i;
        const E = this._sizeLods[r]
          , b = 3 * E * (r > S - Rc ? r - S + Rc : 0)
          , T = 4 * (this._cubeSize - E);
        Fd(t, b, T, 3 * E, 2 * E),
        c.setRenderTarget(t),
        c.render(m, v0)
    }
}
function CH(n) {
    const e = []
      , t = []
      , i = [];
    let r = n;
    const s = n - Rc + 1 + S1.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, r);
        t.push(a);
        let c = 1 / a;
        o > n - Rc ? c = S1[o - n + Rc - 1] : o === 0 && (c = 0),
        i.push(c);
        const u = 1 / (a - 2)
          , h = -u
          , m = 1 + u
          , d = [h, h, m, h, m, m, h, h, m, m, h, m]
          , f = 6
          , _ = 6
          , g = 3
          , v = 2
          , y = 1
          , w = new Float32Array(g * _ * f)
          , S = new Float32Array(v * _ * f)
          , E = new Float32Array(y * _ * f);
        for (let T = 0; T < f; T++) {
            const C = T % 3 * 2 / 3 - 1
              , P = T > 2 ? 0 : -1
              , A = [C, P, 0, C + 2 / 3, P, 0, C + 2 / 3, P + 1, 0, C, P, 0, C + 2 / 3, P + 1, 0, C, P + 1, 0];
            w.set(A, g * _ * T),
            S.set(d, v * _ * T);
            const R = [T, T, T, T, T, T];
            E.set(R, y * _ * T)
        }
        const b = new Nl;
        b.setAttribute("position", new to(w,g)),
        b.setAttribute("uv", new to(S,v)),
        b.setAttribute("faceIndex", new to(E,y)),
        e.push(b),
        r > Rc && r--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: i
    }
}
function M1(n, e, t) {
    const i = new Ll(n,e,t);
    return i.texture.mapping = Kp,
    i.texture.name = "PMREM.cubeUv",
    i.scissorTest = !0,
    i
}
function Fd(n, e, t, i, r) {
    n.viewport.set(e, t, i, r),
    n.scissor.set(e, t, i, r)
}
function RH(n, e, t) {
    const i = new Float32Array(al)
      , r = new pe(0,1,0);
    return new Ta({
        name: "SphericalGaussianBlur",
        defines: {
            n: al,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: i
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: r
            }
        },
        vertexShader: Uy(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: ya,
        depthTest: !1,
        depthWrite: !1
    })
}
function T1() {
    return new Ta({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: Uy(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: ya,
        depthTest: !1,
        depthWrite: !1
    })
}
function C1() {
    return new Ta({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: Uy(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: ya,
        depthTest: !1,
        depthWrite: !1
    })
}
function Uy() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function PH(n) {
    let e = new WeakMap
      , t = null;
    function i(a) {
        if (a && a.isTexture) {
            const c = a.mapping
              , u = c === ov || c === av
              , h = c === qc || c === jc;
            if (u || h)
                if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                    a.needsPMREMUpdate = !1;
                    let m = e.get(a);
                    return t === null && (t = new A1(n)),
                    m = u ? t.fromEquirectangular(a, m) : t.fromCubemap(a, m),
                    e.set(a, m),
                    m.texture
                } else {
                    if (e.has(a))
                        return e.get(a).texture;
                    {
                        const m = a.image;
                        if (u && m && m.height > 0 || h && m && r(m)) {
                            t === null && (t = new A1(n));
                            const d = u ? t.fromEquirectangular(a) : t.fromCubemap(a);
                            return e.set(a, d),
                            a.addEventListener("dispose", s),
                            d.texture
                        } else
                            return null
                    }
                }
        }
        return a
    }
    function r(a) {
        let c = 0;
        const u = 6;
        for (let h = 0; h < u; h++)
            a[h] !== void 0 && c++;
        return c === u
    }
    function s(a) {
        const c = a.target;
        c.removeEventListener("dispose", s);
        const u = e.get(c);
        u !== void 0 && (e.delete(c),
        u.dispose())
    }
    function o() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: i,
        dispose: o
    }
}
function LH(n) {
    const e = {};
    function t(i) {
        if (e[i] !== void 0)
            return e[i];
        let r;
        switch (i) {
        case "WEBGL_depth_texture":
            r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            r = n.getExtension(i)
        }
        return e[i] = r,
        r
    }
    return {
        has: function(i) {
            return t(i) !== null
        },
        init: function(i) {
            i.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"),
            t("OES_texture_float"),
            t("OES_texture_half_float"),
            t("OES_texture_half_float_linear"),
            t("OES_standard_derivatives"),
            t("OES_element_index_uint"),
            t("OES_vertex_array_object"),
            t("ANGLE_instanced_arrays")),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture")
        },
        get: function(i) {
            const r = t(i);
            return r === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."),
            r
        }
    }
}
function DH(n, e, t, i) {
    const r = {}
      , s = new WeakMap;
    function o(m) {
        const d = m.target;
        d.index !== null && e.remove(d.index);
        for (const _ in d.attributes)
            e.remove(d.attributes[_]);
        for (const _ in d.morphAttributes) {
            const g = d.morphAttributes[_];
            for (let v = 0, y = g.length; v < y; v++)
                e.remove(g[v])
        }
        d.removeEventListener("dispose", o),
        delete r[d.id];
        const f = s.get(d);
        f && (e.remove(f),
        s.delete(d)),
        i.releaseStatesOfGeometry(d),
        d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
        t.memory.geometries--
    }
    function a(m, d) {
        return r[d.id] === !0 || (d.addEventListener("dispose", o),
        r[d.id] = !0,
        t.memory.geometries++),
        d
    }
    function c(m) {
        const d = m.attributes;
        for (const _ in d)
            e.update(d[_], n.ARRAY_BUFFER);
        const f = m.morphAttributes;
        for (const _ in f) {
            const g = f[_];
            for (let v = 0, y = g.length; v < y; v++)
                e.update(g[v], n.ARRAY_BUFFER)
        }
    }
    function u(m) {
        const d = []
          , f = m.index
          , _ = m.attributes.position;
        let g = 0;
        if (f !== null) {
            const w = f.array;
            g = f.version;
            for (let S = 0, E = w.length; S < E; S += 3) {
                const b = w[S + 0]
                  , T = w[S + 1]
                  , C = w[S + 2];
                d.push(b, T, T, C, C, b)
            }
        } else if (_ !== void 0) {
            const w = _.array;
            g = _.version;
            for (let S = 0, E = w.length / 3 - 1; S < E; S += 3) {
                const b = S + 0
                  , T = S + 1
                  , C = S + 2;
                d.push(b, T, T, C, C, b)
            }
        } else
            return;
        const v = new (rR(d) ? hR : fR)(d,1);
        v.version = g;
        const y = s.get(m);
        y && e.remove(y),
        s.set(m, v)
    }
    function h(m) {
        const d = s.get(m);
        if (d) {
            const f = m.index;
            f !== null && d.version < f.version && u(m)
        } else
            u(m);
        return s.get(m)
    }
    return {
        get: a,
        update: c,
        getWireframeAttribute: h
    }
}
function IH(n, e, t, i) {
    const r = i.isWebGL2;
    let s;
    function o(f) {
        s = f
    }
    let a, c;
    function u(f) {
        a = f.type,
        c = f.bytesPerElement
    }
    function h(f, _) {
        n.drawElements(s, _, a, f * c),
        t.update(_, s, 1)
    }
    function m(f, _, g) {
        if (g === 0)
            return;
        let v, y;
        if (r)
            v = n,
            y = "drawElementsInstanced";
        else if (v = e.get("ANGLE_instanced_arrays"),
        y = "drawElementsInstancedANGLE",
        v === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        v[y](s, _, a, f * c, g),
        t.update(_, s, g)
    }
    function d(f, _, g) {
        if (g === 0)
            return;
        const v = e.get("WEBGL_multi_draw");
        if (v === null)
            for (let y = 0; y < g; y++)
                this.render(f[y] / c, _[y]);
        else {
            v.multiDrawElementsWEBGL(s, _, 0, a, f, 0, g);
            let y = 0;
            for (let w = 0; w < g; w++)
                y += _[w];
            t.update(y, s, 1)
        }
    }
    this.setMode = o,
    this.setIndex = u,
    this.render = h,
    this.renderInstances = m,
    this.renderMultiDraw = d
}
function OH(n) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function i(s, o, a) {
        switch (t.calls++,
        o) {
        case n.TRIANGLES:
            t.triangles += a * (s / 3);
            break;
        case n.LINES:
            t.lines += a * (s / 2);
            break;
        case n.LINE_STRIP:
            t.lines += a * (s - 1);
            break;
        case n.LINE_LOOP:
            t.lines += a * s;
            break;
        case n.POINTS:
            t.points += a * s;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function r() {
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: r,
        update: i
    }
}
function NH(n, e) {
    return n[0] - e[0]
}
function UH(n, e) {
    return Math.abs(e[1]) - Math.abs(n[1])
}
function FH(n, e, t) {
    const i = {}
      , r = new Float32Array(8)
      , s = new WeakMap
      , o = new Pi
      , a = [];
    for (let u = 0; u < 8; u++)
        a[u] = [u, 0];
    function c(u, h, m) {
        const d = u.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            const _ = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color
              , g = _ !== void 0 ? _.length : 0;
            let v = s.get(h);
            if (v === void 0 || v.count !== g) {
                let G = function() {
                    H.dispose(),
                    s.delete(h),
                    h.removeEventListener("dispose", G)
                };
                var f = G;
                v !== void 0 && v.texture.dispose();
                const S = h.morphAttributes.position !== void 0
                  , E = h.morphAttributes.normal !== void 0
                  , b = h.morphAttributes.color !== void 0
                  , T = h.morphAttributes.position || []
                  , C = h.morphAttributes.normal || []
                  , P = h.morphAttributes.color || [];
                let A = 0;
                S === !0 && (A = 1),
                E === !0 && (A = 2),
                b === !0 && (A = 3);
                let R = h.attributes.position.count * A
                  , I = 1;
                R > e.maxTextureSize && (I = Math.ceil(R / e.maxTextureSize),
                R = e.maxTextureSize);
                const D = new Float32Array(R * I * 4 * g)
                  , H = new aR(D,R,I,g);
                H.type = pa,
                H.needsUpdate = !0;
                const B = A * 4;
                for (let X = 0; X < g; X++) {
                    const V = T[X]
                      , ee = C[X]
                      , re = P[X]
                      , k = R * I * 4 * X;
                    for (let oe = 0; oe < V.count; oe++) {
                        const ae = oe * B;
                        S === !0 && (o.fromBufferAttribute(V, oe),
                        D[k + ae + 0] = o.x,
                        D[k + ae + 1] = o.y,
                        D[k + ae + 2] = o.z,
                        D[k + ae + 3] = 0),
                        E === !0 && (o.fromBufferAttribute(ee, oe),
                        D[k + ae + 4] = o.x,
                        D[k + ae + 5] = o.y,
                        D[k + ae + 6] = o.z,
                        D[k + ae + 7] = 0),
                        b === !0 && (o.fromBufferAttribute(re, oe),
                        D[k + ae + 8] = o.x,
                        D[k + ae + 9] = o.y,
                        D[k + ae + 10] = o.z,
                        D[k + ae + 11] = re.itemSize === 4 ? o.w : 1)
                    }
                }
                v = {
                    count: g,
                    texture: H,
                    size: new on(R,I)
                },
                s.set(h, v),
                h.addEventListener("dispose", G)
            }
            let y = 0;
            for (let S = 0; S < d.length; S++)
                y += d[S];
            const w = h.morphTargetsRelative ? 1 : 1 - y;
            m.getUniforms().setValue(n, "morphTargetBaseInfluence", w),
            m.getUniforms().setValue(n, "morphTargetInfluences", d),
            m.getUniforms().setValue(n, "morphTargetsTexture", v.texture, t),
            m.getUniforms().setValue(n, "morphTargetsTextureSize", v.size)
        } else {
            const _ = d === void 0 ? 0 : d.length;
            let g = i[h.id];
            if (g === void 0 || g.length !== _) {
                g = [];
                for (let E = 0; E < _; E++)
                    g[E] = [E, 0];
                i[h.id] = g
            }
            for (let E = 0; E < _; E++) {
                const b = g[E];
                b[0] = E,
                b[1] = d[E]
            }
            g.sort(UH);
            for (let E = 0; E < 8; E++)
                E < _ && g[E][1] ? (a[E][0] = g[E][0],
                a[E][1] = g[E][1]) : (a[E][0] = Number.MAX_SAFE_INTEGER,
                a[E][1] = 0);
            a.sort(NH);
            const v = h.morphAttributes.position
              , y = h.morphAttributes.normal;
            let w = 0;
            for (let E = 0; E < 8; E++) {
                const b = a[E]
                  , T = b[0]
                  , C = b[1];
                T !== Number.MAX_SAFE_INTEGER && C ? (v && h.getAttribute("morphTarget" + E) !== v[T] && h.setAttribute("morphTarget" + E, v[T]),
                y && h.getAttribute("morphNormal" + E) !== y[T] && h.setAttribute("morphNormal" + E, y[T]),
                r[E] = C,
                w += C) : (v && h.hasAttribute("morphTarget" + E) === !0 && h.deleteAttribute("morphTarget" + E),
                y && h.hasAttribute("morphNormal" + E) === !0 && h.deleteAttribute("morphNormal" + E),
                r[E] = 0)
            }
            const S = h.morphTargetsRelative ? 1 : 1 - w;
            m.getUniforms().setValue(n, "morphTargetBaseInfluence", S),
            m.getUniforms().setValue(n, "morphTargetInfluences", r)
        }
    }
    return {
        update: c
    }
}
function BH(n, e, t, i) {
    let r = new WeakMap;
    function s(c) {
        const u = i.render.frame
          , h = c.geometry
          , m = e.get(c, h);
        if (r.get(m) !== u && (e.update(m),
        r.set(m, u)),
        c.isInstancedMesh && (c.hasEventListener("dispose", a) === !1 && c.addEventListener("dispose", a),
        r.get(c) !== u && (t.update(c.instanceMatrix, n.ARRAY_BUFFER),
        c.instanceColor !== null && t.update(c.instanceColor, n.ARRAY_BUFFER),
        r.set(c, u))),
        c.isSkinnedMesh) {
            const d = c.skeleton;
            r.get(d) !== u && (d.update(),
            r.set(d, u))
        }
        return m
    }
    function o() {
        r = new WeakMap
    }
    function a(c) {
        const u = c.target;
        u.removeEventListener("dispose", a),
        t.remove(u.instanceMatrix),
        u.instanceColor !== null && t.remove(u.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
class vR extends hr {
    constructor(e, t, i, r, s, o, a, c, u, h) {
        if (h = h !== void 0 ? h : Sl,
        h !== Sl && h !== Yc)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        i === void 0 && h === Sl && (i = da),
        i === void 0 && h === Yc && (i = bl),
        super(null, r, s, o, a, c, h, i, u),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = a !== void 0 ? a : sr,
        this.minFilter = c !== void 0 ? c : sr,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
        t
    }
}
const yR = new hr
  , xR = new vR(1,1);
xR.compareFunction = iR;
const bR = new aR
  , SR = new x4
  , wR = new mR
  , R1 = []
  , P1 = []
  , L1 = new Float32Array(16)
  , D1 = new Float32Array(9)
  , I1 = new Float32Array(4);
function eu(n, e, t) {
    const i = n[0];
    if (i <= 0 || i > 0)
        return n;
    const r = e * t;
    let s = R1[r];
    if (s === void 0 && (s = new Float32Array(r),
    R1[r] = s),
    e !== 0) {
        i.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o)
            a += t,
            n[o].toArray(s, a)
    }
    return s
}
function ui(n, e) {
    if (n.length !== e.length)
        return !1;
    for (let t = 0, i = n.length; t < i; t++)
        if (n[t] !== e[t])
            return !1;
    return !0
}
function fi(n, e) {
    for (let t = 0, i = e.length; t < i; t++)
        n[t] = e[t]
}
function tm(n, e) {
    let t = P1[e];
    t === void 0 && (t = new Int32Array(e),
    P1[e] = t);
    for (let i = 0; i !== e; ++i)
        t[i] = n.allocateTextureUnit();
    return t
}
function kH(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1f(this.addr, e),
    t[0] = e)
}
function zH(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (ui(t, e))
            return;
        n.uniform2fv(this.addr, e),
        fi(t, e)
    }
}
function HH(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (ui(t, e))
            return;
        n.uniform3fv(this.addr, e),
        fi(t, e)
    }
}
function GH(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (ui(t, e))
            return;
        n.uniform4fv(this.addr, e),
        fi(t, e)
    }
}
function VH(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (ui(t, e))
            return;
        n.uniformMatrix2fv(this.addr, !1, e),
        fi(t, e)
    } else {
        if (ui(t, i))
            return;
        I1.set(i),
        n.uniformMatrix2fv(this.addr, !1, I1),
        fi(t, i)
    }
}
function WH(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (ui(t, e))
            return;
        n.uniformMatrix3fv(this.addr, !1, e),
        fi(t, e)
    } else {
        if (ui(t, i))
            return;
        D1.set(i),
        n.uniformMatrix3fv(this.addr, !1, D1),
        fi(t, i)
    }
}
function $H(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (ui(t, e))
            return;
        n.uniformMatrix4fv(this.addr, !1, e),
        fi(t, e)
    } else {
        if (ui(t, i))
            return;
        L1.set(i),
        n.uniformMatrix4fv(this.addr, !1, L1),
        fi(t, i)
    }
}
function XH(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1i(this.addr, e),
    t[0] = e)
}
function qH(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (ui(t, e))
            return;
        n.uniform2iv(this.addr, e),
        fi(t, e)
    }
}
function jH(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (ui(t, e))
            return;
        n.uniform3iv(this.addr, e),
        fi(t, e)
    }
}
function YH(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (ui(t, e))
            return;
        n.uniform4iv(this.addr, e),
        fi(t, e)
    }
}
function KH(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1ui(this.addr, e),
    t[0] = e)
}
function ZH(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (ui(t, e))
            return;
        n.uniform2uiv(this.addr, e),
        fi(t, e)
    }
}
function JH(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (ui(t, e))
            return;
        n.uniform3uiv(this.addr, e),
        fi(t, e)
    }
}
function QH(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (ui(t, e))
            return;
        n.uniform4uiv(this.addr, e),
        fi(t, e)
    }
}
function e6(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r);
    const s = this.type === n.SAMPLER_2D_SHADOW ? xR : yR;
    t.setTexture2D(e || s, r)
}
function t6(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture3D(e || SR, r)
}
function n6(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTextureCube(e || wR, r)
}
function i6(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture2DArray(e || bR, r)
}
function r6(n) {
    switch (n) {
    case 5126:
        return kH;
    case 35664:
        return zH;
    case 35665:
        return HH;
    case 35666:
        return GH;
    case 35674:
        return VH;
    case 35675:
        return WH;
    case 35676:
        return $H;
    case 5124:
    case 35670:
        return XH;
    case 35667:
    case 35671:
        return qH;
    case 35668:
    case 35672:
        return jH;
    case 35669:
    case 35673:
        return YH;
    case 5125:
        return KH;
    case 36294:
        return ZH;
    case 36295:
        return JH;
    case 36296:
        return QH;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return e6;
    case 35679:
    case 36299:
    case 36307:
        return t6;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return n6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return i6
    }
}
function s6(n, e) {
    n.uniform1fv(this.addr, e)
}
function o6(n, e) {
    const t = eu(e, this.size, 2);
    n.uniform2fv(this.addr, t)
}
function a6(n, e) {
    const t = eu(e, this.size, 3);
    n.uniform3fv(this.addr, t)
}
function l6(n, e) {
    const t = eu(e, this.size, 4);
    n.uniform4fv(this.addr, t)
}
function c6(n, e) {
    const t = eu(e, this.size, 4);
    n.uniformMatrix2fv(this.addr, !1, t)
}
function u6(n, e) {
    const t = eu(e, this.size, 9);
    n.uniformMatrix3fv(this.addr, !1, t)
}
function f6(n, e) {
    const t = eu(e, this.size, 16);
    n.uniformMatrix4fv(this.addr, !1, t)
}
function h6(n, e) {
    n.uniform1iv(this.addr, e)
}
function d6(n, e) {
    n.uniform2iv(this.addr, e)
}
function p6(n, e) {
    n.uniform3iv(this.addr, e)
}
function m6(n, e) {
    n.uniform4iv(this.addr, e)
}
function g6(n, e) {
    n.uniform1uiv(this.addr, e)
}
function _6(n, e) {
    n.uniform2uiv(this.addr, e)
}
function v6(n, e) {
    n.uniform3uiv(this.addr, e)
}
function y6(n, e) {
    n.uniform4uiv(this.addr, e)
}
function x6(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = tm(t, r);
    ui(i, s) || (n.uniform1iv(this.addr, s),
    fi(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2D(e[o] || yR, s[o])
}
function b6(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = tm(t, r);
    ui(i, s) || (n.uniform1iv(this.addr, s),
    fi(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture3D(e[o] || SR, s[o])
}
function S6(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = tm(t, r);
    ui(i, s) || (n.uniform1iv(this.addr, s),
    fi(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTextureCube(e[o] || wR, s[o])
}
function w6(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = tm(t, r);
    ui(i, s) || (n.uniform1iv(this.addr, s),
    fi(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2DArray(e[o] || bR, s[o])
}
function E6(n) {
    switch (n) {
    case 5126:
        return s6;
    case 35664:
        return o6;
    case 35665:
        return a6;
    case 35666:
        return l6;
    case 35674:
        return c6;
    case 35675:
        return u6;
    case 35676:
        return f6;
    case 5124:
    case 35670:
        return h6;
    case 35667:
    case 35671:
        return d6;
    case 35668:
    case 35672:
        return p6;
    case 35669:
    case 35673:
        return m6;
    case 5125:
        return g6;
    case 36294:
        return _6;
    case 36295:
        return v6;
    case 36296:
        return y6;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return x6;
    case 35679:
    case 36299:
    case 36307:
        return b6;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return S6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return w6
    }
}
class A6 {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.type = t.type,
        this.setValue = r6(t.type)
    }
}
class M6 {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.type = t.type,
        this.size = t.size,
        this.setValue = E6(t.type)
    }
}
class T6 {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, i) {
        const r = this.seq;
        for (let s = 0, o = r.length; s !== o; ++s) {
            const a = r[s];
            a.setValue(e, t[a.id], i)
        }
    }
}
const S0 = /(\w+)(\])?(\[|\.)?/g;
function O1(n, e) {
    n.seq.push(e),
    n.map[e.id] = e
}
function C6(n, e, t) {
    const i = n.name
      , r = i.length;
    for (S0.lastIndex = 0; ; ) {
        const s = S0.exec(i)
          , o = S0.lastIndex;
        let a = s[1];
        const c = s[2] === "]"
          , u = s[3];
        if (c && (a = a | 0),
        u === void 0 || u === "[" && o + 2 === r) {
            O1(t, u === void 0 ? new A6(a,n,e) : new M6(a,n,e));
            break
        } else {
            let m = t.map[a];
            m === void 0 && (m = new T6(a),
            O1(t, m)),
            t = m
        }
    }
}
class op {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let r = 0; r < i; ++r) {
            const s = e.getActiveUniform(t, r)
              , o = e.getUniformLocation(t, s.name);
            C6(s, o, this)
        }
    }
    setValue(e, t, i, r) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, i, r)
    }
    setOptional(e, t, i) {
        const r = t[i];
        r !== void 0 && this.setValue(e, i, r)
    }
    static upload(e, t, i, r) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s]
              , c = i[a.id];
            c.needsUpdate !== !1 && a.setValue(e, c.value, r)
        }
    }
    static seqWithValue(e, t) {
        const i = [];
        for (let r = 0, s = e.length; r !== s; ++r) {
            const o = e[r];
            o.id in t && i.push(o)
        }
        return i
    }
}
function N1(n, e, t) {
    const i = n.createShader(e);
    return n.shaderSource(i, t),
    n.compileShader(i),
    i
}
const R6 = 37297;
let P6 = 0;
function L6(n, e) {
    const t = n.split(`
`)
      , i = []
      , r = Math.max(e - 6, 0)
      , s = Math.min(e + 6, t.length);
    for (let o = r; o < s; o++) {
        const a = o + 1;
        i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`)
    }
    return i.join(`
`)
}
function D6(n) {
    const e = pn.getPrimaries(pn.workingColorSpace)
      , t = pn.getPrimaries(n);
    let i;
    switch (e === t ? i = "" : e === Tp && t === Mp ? i = "LinearDisplayP3ToLinearSRGB" : e === Mp && t === Tp && (i = "LinearSRGBToLinearDisplayP3"),
    n) {
    case No:
    case Zp:
        return [i, "LinearTransferOETF"];
    case Ci:
    case Oy:
        return [i, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        [i, "LinearTransferOETF"]
    }
}
function U1(n, e, t) {
    const i = n.getShaderParameter(e, n.COMPILE_STATUS)
      , r = n.getShaderInfoLog(e).trim();
    if (i && r === "")
        return "";
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
        const o = parseInt(s[1]);
        return t.toUpperCase() + `

` + r + `

` + L6(n.getShaderSource(e), o)
    } else
        return r
}
function I6(n, e) {
    const t = D6(e);
    return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`
}
function O6(n, e) {
    let t;
    switch (e) {
    case Vk:
        t = "Linear";
        break;
    case Wk:
        t = "Reinhard";
        break;
    case $k:
        t = "OptimizedCineon";
        break;
    case Xk:
        t = "ACESFilmic";
        break;
    case qk:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
function N6(n) {
    return [n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.normalMapTangentSpace || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(df).join(`
`)
}
function U6(n) {
    const e = [];
    for (const t in n) {
        const i = n[t];
        i !== !1 && e.push("#define " + t + " " + i)
    }
    return e.join(`
`)
}
function F6(n, e) {
    const t = {}
      , i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
    for (let r = 0; r < i; r++) {
        const s = n.getActiveAttrib(e, r)
          , o = s.name;
        let a = 1;
        s.type === n.FLOAT_MAT2 && (a = 2),
        s.type === n.FLOAT_MAT3 && (a = 3),
        s.type === n.FLOAT_MAT4 && (a = 4),
        t[o] = {
            type: s.type,
            location: n.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}
function df(n) {
    return n !== ""
}
function F1(n, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function B1(n, e) {
    return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const B6 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function dv(n) {
    return n.replace(B6, z6)
}
const k6 = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]);
function z6(n, e) {
    let t = Vt[e];
    if (t === void 0) {
        const i = k6.get(e);
        if (i !== void 0)
            t = Vt[i],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return dv(t)
}
const H6 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function k1(n) {
    return n.replace(H6, G6)
}
function G6(n, e, t, i) {
    let r = "";
    for (let s = parseInt(e); s < parseInt(t); s++)
        r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return r
}
function z1(n) {
    let e = "precision " + n.precision + ` float;
precision ` + n.precision + " int;";
    return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function V6(n) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return n.shadowMapType === XC ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === _k ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === wo && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function W6(n) {
    let e = "ENVMAP_TYPE_CUBE";
    if (n.envMap)
        switch (n.envMapMode) {
        case qc:
        case jc:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case Kp:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function $6(n) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (n.envMap)
        switch (n.envMapMode) {
        case jc:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function X6(n) {
    let e = "ENVMAP_BLENDING_NONE";
    if (n.envMap)
        switch (n.combine) {
        case qC:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case Hk:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case Gk:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function q6(n) {
    const e = n.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , i = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: i,
        maxMip: t
    }
}
function j6(n, e, t, i) {
    const r = n.getContext()
      , s = t.defines;
    let o = t.vertexShader
      , a = t.fragmentShader;
    const c = V6(t)
      , u = W6(t)
      , h = $6(t)
      , m = X6(t)
      , d = q6(t)
      , f = t.isWebGL2 ? "" : N6(t)
      , _ = U6(s)
      , g = r.createProgram();
    let v, y, w = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (v = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _].filter(df).join(`
`),
    v.length > 0 && (v += `
`),
    y = [f, "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _].filter(df).join(`
`),
    y.length > 0 && (y += `
`)) : (v = [z1(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _, t.batching ? "#define USE_BATCHING" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + h : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + c : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(df).join(`
`),
    y = [f, z1(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + h : "", t.envMap ? "#define " + m : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + c : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== xa ? "#define TONE_MAPPING" : "", t.toneMapping !== xa ? Vt.tonemapping_pars_fragment : "", t.toneMapping !== xa ? O6("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", Vt.colorspace_pars_fragment, I6("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(df).join(`
`)),
    o = dv(o),
    o = F1(o, t),
    o = B1(o, t),
    a = dv(a),
    a = F1(a, t),
    a = B1(a, t),
    o = k1(o),
    a = k1(a),
    t.isWebGL2 && t.isRawShaderMaterial !== !0 && (w = `#version 300 es
`,
    v = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + v,
    y = ["precision mediump sampler2DArray;", "#define varying in", t.glslVersion === r1 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === r1 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + y);
    const S = w + v + o
      , E = w + y + a
      , b = N1(r, r.VERTEX_SHADER, S)
      , T = N1(r, r.FRAGMENT_SHADER, E);
    r.attachShader(g, b),
    r.attachShader(g, T),
    t.index0AttributeName !== void 0 ? r.bindAttribLocation(g, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(g, 0, "position"),
    r.linkProgram(g);
    function C(I) {
        if (n.debug.checkShaderErrors) {
            const D = r.getProgramInfoLog(g).trim()
              , H = r.getShaderInfoLog(b).trim()
              , B = r.getShaderInfoLog(T).trim();
            let G = !0
              , X = !0;
            if (r.getProgramParameter(g, r.LINK_STATUS) === !1)
                if (G = !1,
                typeof n.debug.onShaderError == "function")
                    n.debug.onShaderError(r, g, b, T);
                else {
                    const V = U1(r, b, "vertex")
                      , ee = U1(r, T, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(g, r.VALIDATE_STATUS) + `

Program Info Log: ` + D + `
` + V + `
` + ee)
                }
            else
                D !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", D) : (H === "" || B === "") && (X = !1);
            X && (I.diagnostics = {
                runnable: G,
                programLog: D,
                vertexShader: {
                    log: H,
                    prefix: v
                },
                fragmentShader: {
                    log: B,
                    prefix: y
                }
            })
        }
        r.deleteShader(b),
        r.deleteShader(T),
        P = new op(r,g),
        A = F6(r, g)
    }
    let P;
    this.getUniforms = function() {
        return P === void 0 && C(this),
        P
    }
    ;
    let A;
    this.getAttributes = function() {
        return A === void 0 && C(this),
        A
    }
    ;
    let R = t.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return R === !1 && (R = r.getProgramParameter(g, R6)),
        R
    }
    ,
    this.destroy = function() {
        i.releaseStatesOfProgram(this),
        r.deleteProgram(g),
        this.program = void 0
    }
    ,
    this.type = t.shaderType,
    this.name = t.shaderName,
    this.id = P6++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = g,
    this.vertexShader = b,
    this.fragmentShader = T,
    this
}
let Y6 = 0;
class K6 {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , i = e.fragmentShader
          , r = this._getShaderStage(t)
          , s = this._getShaderStage(i)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(r) === !1 && (o.add(r),
        r.usedTimes++),
        o.has(s) === !1 && (o.add(s),
        s.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const i of t)
            i.usedTimes--,
            i.usedTimes === 0 && this.shaderCache.delete(i.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let i = t.get(e);
        return i === void 0 && (i = new Set,
        t.set(e, i)),
        i
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let i = t.get(e);
        return i === void 0 && (i = new Z6(e),
        t.set(e, i)),
        i
    }
}
class Z6 {
    constructor(e) {
        this.id = Y6++,
        this.code = e,
        this.usedTimes = 0
    }
}
function J6(n, e, t, i, r, s, o) {
    const a = new lR
      , c = new K6
      , u = []
      , h = r.isWebGL2
      , m = r.logarithmicDepthBuffer
      , d = r.vertexTextures;
    let f = r.precision;
    const _ = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function g(A) {
        return A === 0 ? "uv" : `uv${A}`
    }
    function v(A, R, I, D, H) {
        const B = D.fog
          , G = H.geometry
          , X = A.isMeshStandardMaterial ? D.environment : null
          , V = (A.isMeshStandardMaterial ? t : e).get(A.envMap || X)
          , ee = V && V.mapping === Kp ? V.image.height : null
          , re = _[A.type];
        A.precision !== null && (f = r.getMaxPrecision(A.precision),
        f !== A.precision && console.warn("THREE.WebGLProgram.getParameters:", A.precision, "not supported, using", f, "instead."));
        const k = G.morphAttributes.position || G.morphAttributes.normal || G.morphAttributes.color
          , oe = k !== void 0 ? k.length : 0;
        let ae = 0;
        G.morphAttributes.position !== void 0 && (ae = 1),
        G.morphAttributes.normal !== void 0 && (ae = 2),
        G.morphAttributes.color !== void 0 && (ae = 3);
        let ne, fe, xe, Re;
        if (re) {
            const Et = qs[re];
            ne = Et.vertexShader,
            fe = Et.fragmentShader
        } else
            ne = A.vertexShader,
            fe = A.fragmentShader,
            c.update(A),
            xe = c.getVertexShaderID(A),
            Re = c.getFragmentShaderID(A);
        const Ue = n.getRenderTarget()
          , He = H.isInstancedMesh === !0
          , qe = H.isBatchedMesh === !0
          , Xe = !!A.map
          , st = !!A.matcap
          , ie = !!V
          , dt = !!A.aoMap
          , Ne = !!A.lightMap
          , Ye = !!A.bumpMap
          , Qe = !!A.normalMap
          , te = !!A.displacementMap
          , ot = !!A.emissiveMap
          , ft = !!A.metalnessMap
          , Tt = !!A.roughnessMap
          , pt = A.anisotropy > 0
          , Ct = A.clearcoat > 0
          , z = A.iridescence > 0
          , N = A.sheen > 0
          , j = A.transmission > 0
          , he = pt && !!A.anisotropyMap
          , le = Ct && !!A.clearcoatMap
          , me = Ct && !!A.clearcoatNormalMap
          , We = Ct && !!A.clearcoatRoughnessMap
          , Te = z && !!A.iridescenceMap
          , Ee = z && !!A.iridescenceThicknessMap
          , Ae = N && !!A.sheenColorMap
          , _t = N && !!A.sheenRoughnessMap
          , Pe = !!A.specularMap
          , Bt = !!A.specularColorMap
          , vt = !!A.specularIntensityMap
          , ht = j && !!A.transmissionMap
          , at = j && !!A.thicknessMap
          , Le = !!A.gradientMap
          , Lt = !!A.alphaMap
          , Y = A.alphaTest > 0
          , ze = !!A.alphaHash
          , De = !!A.extensions
          , ge = !!G.attributes.uv1
          , Fe = !!G.attributes.uv2
          , ut = !!G.attributes.uv3;
        let Ge = xa;
        return A.toneMapped && (Ue === null || Ue.isXRRenderTarget === !0) && (Ge = n.toneMapping),
        {
            isWebGL2: h,
            shaderID: re,
            shaderType: A.type,
            shaderName: A.name,
            vertexShader: ne,
            fragmentShader: fe,
            defines: A.defines,
            customVertexShaderID: xe,
            customFragmentShaderID: Re,
            isRawShaderMaterial: A.isRawShaderMaterial === !0,
            glslVersion: A.glslVersion,
            precision: f,
            batching: qe,
            instancing: He,
            instancingColor: He && H.instanceColor !== null,
            supportsVertexTextures: d,
            outputColorSpace: Ue === null ? n.outputColorSpace : Ue.isXRRenderTarget === !0 ? Ue.texture.colorSpace : No,
            map: Xe,
            matcap: st,
            envMap: ie,
            envMapMode: ie && V.mapping,
            envMapCubeUVHeight: ee,
            aoMap: dt,
            lightMap: Ne,
            bumpMap: Ye,
            normalMap: Qe,
            displacementMap: d && te,
            emissiveMap: ot,
            normalMapObjectSpace: Qe && A.normalMapType === o4,
            normalMapTangentSpace: Qe && A.normalMapType === s4,
            metalnessMap: ft,
            roughnessMap: Tt,
            anisotropy: pt,
            anisotropyMap: he,
            clearcoat: Ct,
            clearcoatMap: le,
            clearcoatNormalMap: me,
            clearcoatRoughnessMap: We,
            iridescence: z,
            iridescenceMap: Te,
            iridescenceThicknessMap: Ee,
            sheen: N,
            sheenColorMap: Ae,
            sheenRoughnessMap: _t,
            specularMap: Pe,
            specularColorMap: Bt,
            specularIntensityMap: vt,
            transmission: j,
            transmissionMap: ht,
            thicknessMap: at,
            gradientMap: Le,
            opaque: A.transparent === !1 && A.blending === Uc,
            alphaMap: Lt,
            alphaTest: Y,
            alphaHash: ze,
            combine: A.combine,
            mapUv: Xe && g(A.map.channel),
            aoMapUv: dt && g(A.aoMap.channel),
            lightMapUv: Ne && g(A.lightMap.channel),
            bumpMapUv: Ye && g(A.bumpMap.channel),
            normalMapUv: Qe && g(A.normalMap.channel),
            displacementMapUv: te && g(A.displacementMap.channel),
            emissiveMapUv: ot && g(A.emissiveMap.channel),
            metalnessMapUv: ft && g(A.metalnessMap.channel),
            roughnessMapUv: Tt && g(A.roughnessMap.channel),
            anisotropyMapUv: he && g(A.anisotropyMap.channel),
            clearcoatMapUv: le && g(A.clearcoatMap.channel),
            clearcoatNormalMapUv: me && g(A.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: We && g(A.clearcoatRoughnessMap.channel),
            iridescenceMapUv: Te && g(A.iridescenceMap.channel),
            iridescenceThicknessMapUv: Ee && g(A.iridescenceThicknessMap.channel),
            sheenColorMapUv: Ae && g(A.sheenColorMap.channel),
            sheenRoughnessMapUv: _t && g(A.sheenRoughnessMap.channel),
            specularMapUv: Pe && g(A.specularMap.channel),
            specularColorMapUv: Bt && g(A.specularColorMap.channel),
            specularIntensityMapUv: vt && g(A.specularIntensityMap.channel),
            transmissionMapUv: ht && g(A.transmissionMap.channel),
            thicknessMapUv: at && g(A.thicknessMap.channel),
            alphaMapUv: Lt && g(A.alphaMap.channel),
            vertexTangents: !!G.attributes.tangent && (Qe || pt),
            vertexColors: A.vertexColors,
            vertexAlphas: A.vertexColors === !0 && !!G.attributes.color && G.attributes.color.itemSize === 4,
            vertexUv1s: ge,
            vertexUv2s: Fe,
            vertexUv3s: ut,
            pointsUvs: H.isPoints === !0 && !!G.attributes.uv && (Xe || Lt),
            fog: !!B,
            useFog: A.fog === !0,
            fogExp2: B && B.isFogExp2,
            flatShading: A.flatShading === !0,
            sizeAttenuation: A.sizeAttenuation === !0,
            logarithmicDepthBuffer: m,
            skinning: H.isSkinnedMesh === !0,
            morphTargets: G.morphAttributes.position !== void 0,
            morphNormals: G.morphAttributes.normal !== void 0,
            morphColors: G.morphAttributes.color !== void 0,
            morphTargetsCount: oe,
            morphTextureStride: ae,
            numDirLights: R.directional.length,
            numPointLights: R.point.length,
            numSpotLights: R.spot.length,
            numSpotLightMaps: R.spotLightMap.length,
            numRectAreaLights: R.rectArea.length,
            numHemiLights: R.hemi.length,
            numDirLightShadows: R.directionalShadowMap.length,
            numPointLightShadows: R.pointShadowMap.length,
            numSpotLightShadows: R.spotShadowMap.length,
            numSpotLightShadowsWithMaps: R.numSpotLightShadowsWithMaps,
            numLightProbes: R.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: A.dithering,
            shadowMapEnabled: n.shadowMap.enabled && I.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: Ge,
            useLegacyLights: n._useLegacyLights,
            decodeVideoTexture: Xe && A.map.isVideoTexture === !0 && pn.getTransfer(A.map.colorSpace) === Rn,
            premultipliedAlpha: A.premultipliedAlpha,
            doubleSided: A.side === Co,
            flipSided: A.side === Lr,
            useDepthPacking: A.depthPacking >= 0,
            depthPacking: A.depthPacking || 0,
            index0AttributeName: A.index0AttributeName,
            extensionDerivatives: De && A.extensions.derivatives === !0,
            extensionFragDepth: De && A.extensions.fragDepth === !0,
            extensionDrawBuffers: De && A.extensions.drawBuffers === !0,
            extensionShaderTextureLOD: De && A.extensions.shaderTextureLOD === !0,
            rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"),
            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: A.customProgramCacheKey()
        }
    }
    function y(A) {
        const R = [];
        if (A.shaderID ? R.push(A.shaderID) : (R.push(A.customVertexShaderID),
        R.push(A.customFragmentShaderID)),
        A.defines !== void 0)
            for (const I in A.defines)
                R.push(I),
                R.push(A.defines[I]);
        return A.isRawShaderMaterial === !1 && (w(R, A),
        S(R, A),
        R.push(n.outputColorSpace)),
        R.push(A.customProgramCacheKey),
        R.join()
    }
    function w(A, R) {
        A.push(R.precision),
        A.push(R.outputColorSpace),
        A.push(R.envMapMode),
        A.push(R.envMapCubeUVHeight),
        A.push(R.mapUv),
        A.push(R.alphaMapUv),
        A.push(R.lightMapUv),
        A.push(R.aoMapUv),
        A.push(R.bumpMapUv),
        A.push(R.normalMapUv),
        A.push(R.displacementMapUv),
        A.push(R.emissiveMapUv),
        A.push(R.metalnessMapUv),
        A.push(R.roughnessMapUv),
        A.push(R.anisotropyMapUv),
        A.push(R.clearcoatMapUv),
        A.push(R.clearcoatNormalMapUv),
        A.push(R.clearcoatRoughnessMapUv),
        A.push(R.iridescenceMapUv),
        A.push(R.iridescenceThicknessMapUv),
        A.push(R.sheenColorMapUv),
        A.push(R.sheenRoughnessMapUv),
        A.push(R.specularMapUv),
        A.push(R.specularColorMapUv),
        A.push(R.specularIntensityMapUv),
        A.push(R.transmissionMapUv),
        A.push(R.thicknessMapUv),
        A.push(R.combine),
        A.push(R.fogExp2),
        A.push(R.sizeAttenuation),
        A.push(R.morphTargetsCount),
        A.push(R.morphAttributeCount),
        A.push(R.numDirLights),
        A.push(R.numPointLights),
        A.push(R.numSpotLights),
        A.push(R.numSpotLightMaps),
        A.push(R.numHemiLights),
        A.push(R.numRectAreaLights),
        A.push(R.numDirLightShadows),
        A.push(R.numPointLightShadows),
        A.push(R.numSpotLightShadows),
        A.push(R.numSpotLightShadowsWithMaps),
        A.push(R.numLightProbes),
        A.push(R.shadowMapType),
        A.push(R.toneMapping),
        A.push(R.numClippingPlanes),
        A.push(R.numClipIntersection),
        A.push(R.depthPacking)
    }
    function S(A, R) {
        a.disableAll(),
        R.isWebGL2 && a.enable(0),
        R.supportsVertexTextures && a.enable(1),
        R.instancing && a.enable(2),
        R.instancingColor && a.enable(3),
        R.matcap && a.enable(4),
        R.envMap && a.enable(5),
        R.normalMapObjectSpace && a.enable(6),
        R.normalMapTangentSpace && a.enable(7),
        R.clearcoat && a.enable(8),
        R.iridescence && a.enable(9),
        R.alphaTest && a.enable(10),
        R.vertexColors && a.enable(11),
        R.vertexAlphas && a.enable(12),
        R.vertexUv1s && a.enable(13),
        R.vertexUv2s && a.enable(14),
        R.vertexUv3s && a.enable(15),
        R.vertexTangents && a.enable(16),
        R.anisotropy && a.enable(17),
        R.alphaHash && a.enable(18),
        R.batching && a.enable(19),
        A.push(a.mask),
        a.disableAll(),
        R.fog && a.enable(0),
        R.useFog && a.enable(1),
        R.flatShading && a.enable(2),
        R.logarithmicDepthBuffer && a.enable(3),
        R.skinning && a.enable(4),
        R.morphTargets && a.enable(5),
        R.morphNormals && a.enable(6),
        R.morphColors && a.enable(7),
        R.premultipliedAlpha && a.enable(8),
        R.shadowMapEnabled && a.enable(9),
        R.useLegacyLights && a.enable(10),
        R.doubleSided && a.enable(11),
        R.flipSided && a.enable(12),
        R.useDepthPacking && a.enable(13),
        R.dithering && a.enable(14),
        R.transmission && a.enable(15),
        R.sheen && a.enable(16),
        R.opaque && a.enable(17),
        R.pointsUvs && a.enable(18),
        R.decodeVideoTexture && a.enable(19),
        A.push(a.mask)
    }
    function E(A) {
        const R = _[A.type];
        let I;
        if (R) {
            const D = qs[R];
            I = O4.clone(D.uniforms)
        } else
            I = A.uniforms;
        return I
    }
    function b(A, R) {
        let I;
        for (let D = 0, H = u.length; D < H; D++) {
            const B = u[D];
            if (B.cacheKey === R) {
                I = B,
                ++I.usedTimes;
                break
            }
        }
        return I === void 0 && (I = new j6(n,R,A,s),
        u.push(I)),
        I
    }
    function T(A) {
        if (--A.usedTimes === 0) {
            const R = u.indexOf(A);
            u[R] = u[u.length - 1],
            u.pop(),
            A.destroy()
        }
    }
    function C(A) {
        c.remove(A)
    }
    function P() {
        c.dispose()
    }
    return {
        getParameters: v,
        getProgramCacheKey: y,
        getUniforms: E,
        acquireProgram: b,
        releaseProgram: T,
        releaseShaderCache: C,
        programs: u,
        dispose: P
    }
}
function Q6() {
    let n = new WeakMap;
    function e(s) {
        let o = n.get(s);
        return o === void 0 && (o = {},
        n.set(s, o)),
        o
    }
    function t(s) {
        n.delete(s)
    }
    function i(s, o, a) {
        n.get(s)[o] = a
    }
    function r() {
        n = new WeakMap
    }
    return {
        get: e,
        remove: t,
        update: i,
        dispose: r
    }
}
function eG(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id
}
function H1(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id
}
function G1() {
    const n = [];
    let e = 0;
    const t = []
      , i = []
      , r = [];
    function s() {
        e = 0,
        t.length = 0,
        i.length = 0,
        r.length = 0
    }
    function o(m, d, f, _, g, v) {
        let y = n[e];
        return y === void 0 ? (y = {
            id: m.id,
            object: m,
            geometry: d,
            material: f,
            groupOrder: _,
            renderOrder: m.renderOrder,
            z: g,
            group: v
        },
        n[e] = y) : (y.id = m.id,
        y.object = m,
        y.geometry = d,
        y.material = f,
        y.groupOrder = _,
        y.renderOrder = m.renderOrder,
        y.z = g,
        y.group = v),
        e++,
        y
    }
    function a(m, d, f, _, g, v) {
        const y = o(m, d, f, _, g, v);
        f.transmission > 0 ? i.push(y) : f.transparent === !0 ? r.push(y) : t.push(y)
    }
    function c(m, d, f, _, g, v) {
        const y = o(m, d, f, _, g, v);
        f.transmission > 0 ? i.unshift(y) : f.transparent === !0 ? r.unshift(y) : t.unshift(y)
    }
    function u(m, d) {
        t.length > 1 && t.sort(m || eG),
        i.length > 1 && i.sort(d || H1),
        r.length > 1 && r.sort(d || H1)
    }
    function h() {
        for (let m = e, d = n.length; m < d; m++) {
            const f = n[m];
            if (f.id === null)
                break;
            f.id = null,
            f.object = null,
            f.geometry = null,
            f.material = null,
            f.group = null
        }
    }
    return {
        opaque: t,
        transmissive: i,
        transparent: r,
        init: s,
        push: a,
        unshift: c,
        finish: h,
        sort: u
    }
}
function tG() {
    let n = new WeakMap;
    function e(i, r) {
        const s = n.get(i);
        let o;
        return s === void 0 ? (o = new G1,
        n.set(i, [o])) : r >= s.length ? (o = new G1,
        s.push(o)) : o = s[r],
        o
    }
    function t() {
        n = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function nG() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new pe,
                    color: new mn
                };
                break;
            case "SpotLight":
                t = {
                    position: new pe,
                    direction: new pe,
                    color: new mn,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new pe,
                    color: new mn,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new pe,
                    skyColor: new mn,
                    groundColor: new mn
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new mn,
                    position: new pe,
                    halfWidth: new pe,
                    halfHeight: new pe
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
function iG() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new on
                };
                break;
            case "SpotLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new on
                };
                break;
            case "PointLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new on,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
let rG = 0;
function sG(n, e) {
    return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}
function oG(n, e) {
    const t = new nG
      , i = iG()
      , r = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let h = 0; h < 9; h++)
        r.probe.push(new pe);
    const s = new pe
      , o = new Li
      , a = new Li;
    function c(h, m) {
        let d = 0
          , f = 0
          , _ = 0;
        for (let D = 0; D < 9; D++)
            r.probe[D].set(0, 0, 0);
        let g = 0
          , v = 0
          , y = 0
          , w = 0
          , S = 0
          , E = 0
          , b = 0
          , T = 0
          , C = 0
          , P = 0
          , A = 0;
        h.sort(sG);
        const R = m === !0 ? Math.PI : 1;
        for (let D = 0, H = h.length; D < H; D++) {
            const B = h[D]
              , G = B.color
              , X = B.intensity
              , V = B.distance
              , ee = B.shadow && B.shadow.map ? B.shadow.map.texture : null;
            if (B.isAmbientLight)
                d += G.r * X * R,
                f += G.g * X * R,
                _ += G.b * X * R;
            else if (B.isLightProbe) {
                for (let re = 0; re < 9; re++)
                    r.probe[re].addScaledVector(B.sh.coefficients[re], X);
                A++
            } else if (B.isDirectionalLight) {
                const re = t.get(B);
                if (re.color.copy(B.color).multiplyScalar(B.intensity * R),
                B.castShadow) {
                    const k = B.shadow
                      , oe = i.get(B);
                    oe.shadowBias = k.bias,
                    oe.shadowNormalBias = k.normalBias,
                    oe.shadowRadius = k.radius,
                    oe.shadowMapSize = k.mapSize,
                    r.directionalShadow[g] = oe,
                    r.directionalShadowMap[g] = ee,
                    r.directionalShadowMatrix[g] = B.shadow.matrix,
                    E++
                }
                r.directional[g] = re,
                g++
            } else if (B.isSpotLight) {
                const re = t.get(B);
                re.position.setFromMatrixPosition(B.matrixWorld),
                re.color.copy(G).multiplyScalar(X * R),
                re.distance = V,
                re.coneCos = Math.cos(B.angle),
                re.penumbraCos = Math.cos(B.angle * (1 - B.penumbra)),
                re.decay = B.decay,
                r.spot[y] = re;
                const k = B.shadow;
                if (B.map && (r.spotLightMap[C] = B.map,
                C++,
                k.updateMatrices(B),
                B.castShadow && P++),
                r.spotLightMatrix[y] = k.matrix,
                B.castShadow) {
                    const oe = i.get(B);
                    oe.shadowBias = k.bias,
                    oe.shadowNormalBias = k.normalBias,
                    oe.shadowRadius = k.radius,
                    oe.shadowMapSize = k.mapSize,
                    r.spotShadow[y] = oe,
                    r.spotShadowMap[y] = ee,
                    T++
                }
                y++
            } else if (B.isRectAreaLight) {
                const re = t.get(B);
                re.color.copy(G).multiplyScalar(X),
                re.halfWidth.set(B.width * .5, 0, 0),
                re.halfHeight.set(0, B.height * .5, 0),
                r.rectArea[w] = re,
                w++
            } else if (B.isPointLight) {
                const re = t.get(B);
                if (re.color.copy(B.color).multiplyScalar(B.intensity * R),
                re.distance = B.distance,
                re.decay = B.decay,
                B.castShadow) {
                    const k = B.shadow
                      , oe = i.get(B);
                    oe.shadowBias = k.bias,
                    oe.shadowNormalBias = k.normalBias,
                    oe.shadowRadius = k.radius,
                    oe.shadowMapSize = k.mapSize,
                    oe.shadowCameraNear = k.camera.near,
                    oe.shadowCameraFar = k.camera.far,
                    r.pointShadow[v] = oe,
                    r.pointShadowMap[v] = ee,
                    r.pointShadowMatrix[v] = B.shadow.matrix,
                    b++
                }
                r.point[v] = re,
                v++
            } else if (B.isHemisphereLight) {
                const re = t.get(B);
                re.skyColor.copy(B.color).multiplyScalar(X * R),
                re.groundColor.copy(B.groundColor).multiplyScalar(X * R),
                r.hemi[S] = re,
                S++
            }
        }
        w > 0 && (e.isWebGL2 || n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Ve.LTC_FLOAT_1,
        r.rectAreaLTC2 = Ve.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = Ve.LTC_HALF_1,
        r.rectAreaLTC2 = Ve.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
        r.ambient[0] = d,
        r.ambient[1] = f,
        r.ambient[2] = _;
        const I = r.hash;
        (I.directionalLength !== g || I.pointLength !== v || I.spotLength !== y || I.rectAreaLength !== w || I.hemiLength !== S || I.numDirectionalShadows !== E || I.numPointShadows !== b || I.numSpotShadows !== T || I.numSpotMaps !== C || I.numLightProbes !== A) && (r.directional.length = g,
        r.spot.length = y,
        r.rectArea.length = w,
        r.point.length = v,
        r.hemi.length = S,
        r.directionalShadow.length = E,
        r.directionalShadowMap.length = E,
        r.pointShadow.length = b,
        r.pointShadowMap.length = b,
        r.spotShadow.length = T,
        r.spotShadowMap.length = T,
        r.directionalShadowMatrix.length = E,
        r.pointShadowMatrix.length = b,
        r.spotLightMatrix.length = T + C - P,
        r.spotLightMap.length = C,
        r.numSpotLightShadowsWithMaps = P,
        r.numLightProbes = A,
        I.directionalLength = g,
        I.pointLength = v,
        I.spotLength = y,
        I.rectAreaLength = w,
        I.hemiLength = S,
        I.numDirectionalShadows = E,
        I.numPointShadows = b,
        I.numSpotShadows = T,
        I.numSpotMaps = C,
        I.numLightProbes = A,
        r.version = rG++)
    }
    function u(h, m) {
        let d = 0
          , f = 0
          , _ = 0
          , g = 0
          , v = 0;
        const y = m.matrixWorldInverse;
        for (let w = 0, S = h.length; w < S; w++) {
            const E = h[w];
            if (E.isDirectionalLight) {
                const b = r.directional[d];
                b.direction.setFromMatrixPosition(E.matrixWorld),
                s.setFromMatrixPosition(E.target.matrixWorld),
                b.direction.sub(s),
                b.direction.transformDirection(y),
                d++
            } else if (E.isSpotLight) {
                const b = r.spot[_];
                b.position.setFromMatrixPosition(E.matrixWorld),
                b.position.applyMatrix4(y),
                b.direction.setFromMatrixPosition(E.matrixWorld),
                s.setFromMatrixPosition(E.target.matrixWorld),
                b.direction.sub(s),
                b.direction.transformDirection(y),
                _++
            } else if (E.isRectAreaLight) {
                const b = r.rectArea[g];
                b.position.setFromMatrixPosition(E.matrixWorld),
                b.position.applyMatrix4(y),
                a.identity(),
                o.copy(E.matrixWorld),
                o.premultiply(y),
                a.extractRotation(o),
                b.halfWidth.set(E.width * .5, 0, 0),
                b.halfHeight.set(0, E.height * .5, 0),
                b.halfWidth.applyMatrix4(a),
                b.halfHeight.applyMatrix4(a),
                g++
            } else if (E.isPointLight) {
                const b = r.point[f];
                b.position.setFromMatrixPosition(E.matrixWorld),
                b.position.applyMatrix4(y),
                f++
            } else if (E.isHemisphereLight) {
                const b = r.hemi[v];
                b.direction.setFromMatrixPosition(E.matrixWorld),
                b.direction.transformDirection(y),
                v++
            }
        }
    }
    return {
        setup: c,
        setupView: u,
        state: r
    }
}
function V1(n, e) {
    const t = new oG(n,e)
      , i = []
      , r = [];
    function s() {
        i.length = 0,
        r.length = 0
    }
    function o(m) {
        i.push(m)
    }
    function a(m) {
        r.push(m)
    }
    function c(m) {
        t.setup(i, m)
    }
    function u(m) {
        t.setupView(i, m)
    }
    return {
        init: s,
        state: {
            lightsArray: i,
            shadowsArray: r,
            lights: t
        },
        setupLights: c,
        setupLightsView: u,
        pushLight: o,
        pushShadow: a
    }
}
function aG(n, e) {
    let t = new WeakMap;
    function i(s, o=0) {
        const a = t.get(s);
        let c;
        return a === void 0 ? (c = new V1(n,e),
        t.set(s, [c])) : o >= a.length ? (c = new V1(n,e),
        a.push(c)) : c = a[o],
        c
    }
    function r() {
        t = new WeakMap
    }
    return {
        get: i,
        dispose: r
    }
}
class lG extends Qp {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = i4,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class cG extends Qp {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const uG = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , fG = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function hG(n, e, t) {
    let i = new gR;
    const r = new on
      , s = new on
      , o = new Pi
      , a = new lG({
        depthPacking: r4
    })
      , c = new cG
      , u = {}
      , h = t.maxTextureSize
      , m = {
        [Ma]: Lr,
        [Lr]: Ma,
        [Co]: Co
    }
      , d = new Ta({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new on
            },
            radius: {
                value: 4
            }
        },
        vertexShader: uG,
        fragmentShader: fG
    })
      , f = d.clone();
    f.defines.HORIZONTAL_PASS = 1;
    const _ = new Nl;
    _.setAttribute("position", new to(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const g = new Lo(_,d)
      , v = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = XC;
    let y = this.type;
    this.render = function(b, T, C) {
        if (v.enabled === !1 || v.autoUpdate === !1 && v.needsUpdate === !1 || b.length === 0)
            return;
        const P = n.getRenderTarget()
          , A = n.getActiveCubeFace()
          , R = n.getActiveMipmapLevel()
          , I = n.state;
        I.setBlending(ya),
        I.buffers.color.setClear(1, 1, 1, 1),
        I.buffers.depth.setTest(!0),
        I.setScissorTest(!1);
        const D = y !== wo && this.type === wo
          , H = y === wo && this.type !== wo;
        for (let B = 0, G = b.length; B < G; B++) {
            const X = b[B]
              , V = X.shadow;
            if (V === void 0) {
                console.warn("THREE.WebGLShadowMap:", X, "has no shadow.");
                continue
            }
            if (V.autoUpdate === !1 && V.needsUpdate === !1)
                continue;
            r.copy(V.mapSize);
            const ee = V.getFrameExtents();
            if (r.multiply(ee),
            s.copy(V.mapSize),
            (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / ee.x),
            r.x = s.x * ee.x,
            V.mapSize.x = s.x),
            r.y > h && (s.y = Math.floor(h / ee.y),
            r.y = s.y * ee.y,
            V.mapSize.y = s.y)),
            V.map === null || D === !0 || H === !0) {
                const k = this.type !== wo ? {
                    minFilter: sr,
                    magFilter: sr
                } : {};
                V.map !== null && V.map.dispose(),
                V.map = new Ll(r.x,r.y,k),
                V.map.texture.name = X.name + ".shadowMap",
                V.camera.updateProjectionMatrix()
            }
            n.setRenderTarget(V.map),
            n.clear();
            const re = V.getViewportCount();
            for (let k = 0; k < re; k++) {
                const oe = V.getViewport(k);
                o.set(s.x * oe.x, s.y * oe.y, s.x * oe.z, s.y * oe.w),
                I.viewport(o),
                V.updateMatrices(X, k),
                i = V.getFrustum(),
                E(T, C, V.camera, X, this.type)
            }
            V.isPointLightShadow !== !0 && this.type === wo && w(V, C),
            V.needsUpdate = !1
        }
        y = this.type,
        v.needsUpdate = !1,
        n.setRenderTarget(P, A, R)
    }
    ;
    function w(b, T) {
        const C = e.update(g);
        d.defines.VSM_SAMPLES !== b.blurSamples && (d.defines.VSM_SAMPLES = b.blurSamples,
        f.defines.VSM_SAMPLES = b.blurSamples,
        d.needsUpdate = !0,
        f.needsUpdate = !0),
        b.mapPass === null && (b.mapPass = new Ll(r.x,r.y)),
        d.uniforms.shadow_pass.value = b.map.texture,
        d.uniforms.resolution.value = b.mapSize,
        d.uniforms.radius.value = b.radius,
        n.setRenderTarget(b.mapPass),
        n.clear(),
        n.renderBufferDirect(T, null, C, d, g, null),
        f.uniforms.shadow_pass.value = b.mapPass.texture,
        f.uniforms.resolution.value = b.mapSize,
        f.uniforms.radius.value = b.radius,
        n.setRenderTarget(b.map),
        n.clear(),
        n.renderBufferDirect(T, null, C, f, g, null)
    }
    function S(b, T, C, P) {
        let A = null;
        const R = C.isPointLight === !0 ? b.customDistanceMaterial : b.customDepthMaterial;
        if (R !== void 0)
            A = R;
        else if (A = C.isPointLight === !0 ? c : a,
        n.localClippingEnabled && T.clipShadows === !0 && Array.isArray(T.clippingPlanes) && T.clippingPlanes.length !== 0 || T.displacementMap && T.displacementScale !== 0 || T.alphaMap && T.alphaTest > 0 || T.map && T.alphaTest > 0) {
            const I = A.uuid
              , D = T.uuid;
            let H = u[I];
            H === void 0 && (H = {},
            u[I] = H);
            let B = H[D];
            B === void 0 && (B = A.clone(),
            H[D] = B),
            A = B
        }
        if (A.visible = T.visible,
        A.wireframe = T.wireframe,
        P === wo ? A.side = T.shadowSide !== null ? T.shadowSide : T.side : A.side = T.shadowSide !== null ? T.shadowSide : m[T.side],
        A.alphaMap = T.alphaMap,
        A.alphaTest = T.alphaTest,
        A.map = T.map,
        A.clipShadows = T.clipShadows,
        A.clippingPlanes = T.clippingPlanes,
        A.clipIntersection = T.clipIntersection,
        A.displacementMap = T.displacementMap,
        A.displacementScale = T.displacementScale,
        A.displacementBias = T.displacementBias,
        A.wireframeLinewidth = T.wireframeLinewidth,
        A.linewidth = T.linewidth,
        C.isPointLight === !0 && A.isMeshDistanceMaterial === !0) {
            const I = n.properties.get(A);
            I.light = C
        }
        return A
    }
    function E(b, T, C, P, A) {
        if (b.visible === !1)
            return;
        if (b.layers.test(T.layers) && (b.isMesh || b.isLine || b.isPoints) && (b.castShadow || b.receiveShadow && A === wo) && (!b.frustumCulled || i.intersectsObject(b))) {
            b.modelViewMatrix.multiplyMatrices(C.matrixWorldInverse, b.matrixWorld);
            const D = e.update(b)
              , H = b.material;
            if (Array.isArray(H)) {
                const B = D.groups;
                for (let G = 0, X = B.length; G < X; G++) {
                    const V = B[G]
                      , ee = H[V.materialIndex];
                    if (ee && ee.visible) {
                        const re = S(b, ee, P, A);
                        b.onBeforeShadow(n, b, T, C, D, re, V),
                        n.renderBufferDirect(C, null, D, re, b, V),
                        b.onAfterShadow(n, b, T, C, D, re, V)
                    }
                }
            } else if (H.visible) {
                const B = S(b, H, P, A);
                b.onBeforeShadow(n, b, T, C, D, B, null),
                n.renderBufferDirect(C, null, D, B, b, null),
                b.onAfterShadow(n, b, T, C, D, B, null)
            }
        }
        const I = b.children;
        for (let D = 0, H = I.length; D < H; D++)
            E(I[D], T, C, P, A)
    }
}
function dG(n, e, t) {
    const i = t.isWebGL2;
    function r() {
        let Y = !1;
        const ze = new Pi;
        let De = null;
        const ge = new Pi(0,0,0,0);
        return {
            setMask: function(Fe) {
                De !== Fe && !Y && (n.colorMask(Fe, Fe, Fe, Fe),
                De = Fe)
            },
            setLocked: function(Fe) {
                Y = Fe
            },
            setClear: function(Fe, ut, Ge, je, Et) {
                Et === !0 && (Fe *= je,
                ut *= je,
                Ge *= je),
                ze.set(Fe, ut, Ge, je),
                ge.equals(ze) === !1 && (n.clearColor(Fe, ut, Ge, je),
                ge.copy(ze))
            },
            reset: function() {
                Y = !1,
                De = null,
                ge.set(-1, 0, 0, 0)
            }
        }
    }
    function s() {
        let Y = !1
          , ze = null
          , De = null
          , ge = null;
        return {
            setTest: function(Fe) {
                Fe ? qe(n.DEPTH_TEST) : Xe(n.DEPTH_TEST)
            },
            setMask: function(Fe) {
                ze !== Fe && !Y && (n.depthMask(Fe),
                ze = Fe)
            },
            setFunc: function(Fe) {
                if (De !== Fe) {
                    switch (Fe) {
                    case Ok:
                        n.depthFunc(n.NEVER);
                        break;
                    case Nk:
                        n.depthFunc(n.ALWAYS);
                        break;
                    case Uk:
                        n.depthFunc(n.LESS);
                        break;
                    case Ep:
                        n.depthFunc(n.LEQUAL);
                        break;
                    case Fk:
                        n.depthFunc(n.EQUAL);
                        break;
                    case Bk:
                        n.depthFunc(n.GEQUAL);
                        break;
                    case kk:
                        n.depthFunc(n.GREATER);
                        break;
                    case zk:
                        n.depthFunc(n.NOTEQUAL);
                        break;
                    default:
                        n.depthFunc(n.LEQUAL)
                    }
                    De = Fe
                }
            },
            setLocked: function(Fe) {
                Y = Fe
            },
            setClear: function(Fe) {
                ge !== Fe && (n.clearDepth(Fe),
                ge = Fe)
            },
            reset: function() {
                Y = !1,
                ze = null,
                De = null,
                ge = null
            }
        }
    }
    function o() {
        let Y = !1
          , ze = null
          , De = null
          , ge = null
          , Fe = null
          , ut = null
          , Ge = null
          , je = null
          , Et = null;
        return {
            setTest: function(At) {
                Y || (At ? qe(n.STENCIL_TEST) : Xe(n.STENCIL_TEST))
            },
            setMask: function(At) {
                ze !== At && !Y && (n.stencilMask(At),
                ze = At)
            },
            setFunc: function(At, Be, bt) {
                (De !== At || ge !== Be || Fe !== bt) && (n.stencilFunc(At, Be, bt),
                De = At,
                ge = Be,
                Fe = bt)
            },
            setOp: function(At, Be, bt) {
                (ut !== At || Ge !== Be || je !== bt) && (n.stencilOp(At, Be, bt),
                ut = At,
                Ge = Be,
                je = bt)
            },
            setLocked: function(At) {
                Y = At
            },
            setClear: function(At) {
                Et !== At && (n.clearStencil(At),
                Et = At)
            },
            reset: function() {
                Y = !1,
                ze = null,
                De = null,
                ge = null,
                Fe = null,
                ut = null,
                Ge = null,
                je = null,
                Et = null
            }
        }
    }
    const a = new r
      , c = new s
      , u = new o
      , h = new WeakMap
      , m = new WeakMap;
    let d = {}
      , f = {}
      , _ = new WeakMap
      , g = []
      , v = null
      , y = !1
      , w = null
      , S = null
      , E = null
      , b = null
      , T = null
      , C = null
      , P = null
      , A = new mn(0,0,0)
      , R = 0
      , I = !1
      , D = null
      , H = null
      , B = null
      , G = null
      , X = null;
    const V = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let ee = !1
      , re = 0;
    const k = n.getParameter(n.VERSION);
    k.indexOf("WebGL") !== -1 ? (re = parseFloat(/^WebGL (\d)/.exec(k)[1]),
    ee = re >= 1) : k.indexOf("OpenGL ES") !== -1 && (re = parseFloat(/^OpenGL ES (\d)/.exec(k)[1]),
    ee = re >= 2);
    let oe = null
      , ae = {};
    const ne = n.getParameter(n.SCISSOR_BOX)
      , fe = n.getParameter(n.VIEWPORT)
      , xe = new Pi().fromArray(ne)
      , Re = new Pi().fromArray(fe);
    function Ue(Y, ze, De, ge) {
        const Fe = new Uint8Array(4)
          , ut = n.createTexture();
        n.bindTexture(Y, ut),
        n.texParameteri(Y, n.TEXTURE_MIN_FILTER, n.NEAREST),
        n.texParameteri(Y, n.TEXTURE_MAG_FILTER, n.NEAREST);
        for (let Ge = 0; Ge < De; Ge++)
            i && (Y === n.TEXTURE_3D || Y === n.TEXTURE_2D_ARRAY) ? n.texImage3D(ze, 0, n.RGBA, 1, 1, ge, 0, n.RGBA, n.UNSIGNED_BYTE, Fe) : n.texImage2D(ze + Ge, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, Fe);
        return ut
    }
    const He = {};
    He[n.TEXTURE_2D] = Ue(n.TEXTURE_2D, n.TEXTURE_2D, 1),
    He[n.TEXTURE_CUBE_MAP] = Ue(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    i && (He[n.TEXTURE_2D_ARRAY] = Ue(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1),
    He[n.TEXTURE_3D] = Ue(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)),
    a.setClear(0, 0, 0, 1),
    c.setClear(1),
    u.setClear(0),
    qe(n.DEPTH_TEST),
    c.setFunc(Ep),
    ot(!1),
    ft(Ew),
    qe(n.CULL_FACE),
    Qe(ya);
    function qe(Y) {
        d[Y] !== !0 && (n.enable(Y),
        d[Y] = !0)
    }
    function Xe(Y) {
        d[Y] !== !1 && (n.disable(Y),
        d[Y] = !1)
    }
    function st(Y, ze) {
        return f[Y] !== ze ? (n.bindFramebuffer(Y, ze),
        f[Y] = ze,
        i && (Y === n.DRAW_FRAMEBUFFER && (f[n.FRAMEBUFFER] = ze),
        Y === n.FRAMEBUFFER && (f[n.DRAW_FRAMEBUFFER] = ze)),
        !0) : !1
    }
    function ie(Y, ze) {
        let De = g
          , ge = !1;
        if (Y)
            if (De = _.get(ze),
            De === void 0 && (De = [],
            _.set(ze, De)),
            Y.isWebGLMultipleRenderTargets) {
                const Fe = Y.texture;
                if (De.length !== Fe.length || De[0] !== n.COLOR_ATTACHMENT0) {
                    for (let ut = 0, Ge = Fe.length; ut < Ge; ut++)
                        De[ut] = n.COLOR_ATTACHMENT0 + ut;
                    De.length = Fe.length,
                    ge = !0
                }
            } else
                De[0] !== n.COLOR_ATTACHMENT0 && (De[0] = n.COLOR_ATTACHMENT0,
                ge = !0);
        else
            De[0] !== n.BACK && (De[0] = n.BACK,
            ge = !0);
        ge && (t.isWebGL2 ? n.drawBuffers(De) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(De))
    }
    function dt(Y) {
        return v !== Y ? (n.useProgram(Y),
        v = Y,
        !0) : !1
    }
    const Ne = {
        [ol]: n.FUNC_ADD,
        [yk]: n.FUNC_SUBTRACT,
        [xk]: n.FUNC_REVERSE_SUBTRACT
    };
    if (i)
        Ne[Cw] = n.MIN,
        Ne[Rw] = n.MAX;
    else {
        const Y = e.get("EXT_blend_minmax");
        Y !== null && (Ne[Cw] = Y.MIN_EXT,
        Ne[Rw] = Y.MAX_EXT)
    }
    const Ye = {
        [bk]: n.ZERO,
        [Sk]: n.ONE,
        [wk]: n.SRC_COLOR,
        [rv]: n.SRC_ALPHA,
        [Rk]: n.SRC_ALPHA_SATURATE,
        [Tk]: n.DST_COLOR,
        [Ak]: n.DST_ALPHA,
        [Ek]: n.ONE_MINUS_SRC_COLOR,
        [sv]: n.ONE_MINUS_SRC_ALPHA,
        [Ck]: n.ONE_MINUS_DST_COLOR,
        [Mk]: n.ONE_MINUS_DST_ALPHA,
        [Pk]: n.CONSTANT_COLOR,
        [Lk]: n.ONE_MINUS_CONSTANT_COLOR,
        [Dk]: n.CONSTANT_ALPHA,
        [Ik]: n.ONE_MINUS_CONSTANT_ALPHA
    };
    function Qe(Y, ze, De, ge, Fe, ut, Ge, je, Et, At) {
        if (Y === ya) {
            y === !0 && (Xe(n.BLEND),
            y = !1);
            return
        }
        if (y === !1 && (qe(n.BLEND),
        y = !0),
        Y !== vk) {
            if (Y !== w || At !== I) {
                if ((S !== ol || T !== ol) && (n.blendEquation(n.FUNC_ADD),
                S = ol,
                T = ol),
                At)
                    switch (Y) {
                    case Uc:
                        n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Aw:
                        n.blendFunc(n.ONE, n.ONE);
                        break;
                    case Mw:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case Tw:
                        n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", Y);
                        break
                    }
                else
                    switch (Y) {
                    case Uc:
                        n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Aw:
                        n.blendFunc(n.SRC_ALPHA, n.ONE);
                        break;
                    case Mw:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case Tw:
                        n.blendFunc(n.ZERO, n.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", Y);
                        break
                    }
                E = null,
                b = null,
                C = null,
                P = null,
                A.set(0, 0, 0),
                R = 0,
                w = Y,
                I = At
            }
            return
        }
        Fe = Fe || ze,
        ut = ut || De,
        Ge = Ge || ge,
        (ze !== S || Fe !== T) && (n.blendEquationSeparate(Ne[ze], Ne[Fe]),
        S = ze,
        T = Fe),
        (De !== E || ge !== b || ut !== C || Ge !== P) && (n.blendFuncSeparate(Ye[De], Ye[ge], Ye[ut], Ye[Ge]),
        E = De,
        b = ge,
        C = ut,
        P = Ge),
        (je.equals(A) === !1 || Et !== R) && (n.blendColor(je.r, je.g, je.b, Et),
        A.copy(je),
        R = Et),
        w = Y,
        I = !1
    }
    function te(Y, ze) {
        Y.side === Co ? Xe(n.CULL_FACE) : qe(n.CULL_FACE);
        let De = Y.side === Lr;
        ze && (De = !De),
        ot(De),
        Y.blending === Uc && Y.transparent === !1 ? Qe(ya) : Qe(Y.blending, Y.blendEquation, Y.blendSrc, Y.blendDst, Y.blendEquationAlpha, Y.blendSrcAlpha, Y.blendDstAlpha, Y.blendColor, Y.blendAlpha, Y.premultipliedAlpha),
        c.setFunc(Y.depthFunc),
        c.setTest(Y.depthTest),
        c.setMask(Y.depthWrite),
        a.setMask(Y.colorWrite);
        const ge = Y.stencilWrite;
        u.setTest(ge),
        ge && (u.setMask(Y.stencilWriteMask),
        u.setFunc(Y.stencilFunc, Y.stencilRef, Y.stencilFuncMask),
        u.setOp(Y.stencilFail, Y.stencilZFail, Y.stencilZPass)),
        pt(Y.polygonOffset, Y.polygonOffsetFactor, Y.polygonOffsetUnits),
        Y.alphaToCoverage === !0 ? qe(n.SAMPLE_ALPHA_TO_COVERAGE) : Xe(n.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function ot(Y) {
        D !== Y && (Y ? n.frontFace(n.CW) : n.frontFace(n.CCW),
        D = Y)
    }
    function ft(Y) {
        Y !== mk ? (qe(n.CULL_FACE),
        Y !== H && (Y === Ew ? n.cullFace(n.BACK) : Y === gk ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : Xe(n.CULL_FACE),
        H = Y
    }
    function Tt(Y) {
        Y !== B && (ee && n.lineWidth(Y),
        B = Y)
    }
    function pt(Y, ze, De) {
        Y ? (qe(n.POLYGON_OFFSET_FILL),
        (G !== ze || X !== De) && (n.polygonOffset(ze, De),
        G = ze,
        X = De)) : Xe(n.POLYGON_OFFSET_FILL)
    }
    function Ct(Y) {
        Y ? qe(n.SCISSOR_TEST) : Xe(n.SCISSOR_TEST)
    }
    function z(Y) {
        Y === void 0 && (Y = n.TEXTURE0 + V - 1),
        oe !== Y && (n.activeTexture(Y),
        oe = Y)
    }
    function N(Y, ze, De) {
        De === void 0 && (oe === null ? De = n.TEXTURE0 + V - 1 : De = oe);
        let ge = ae[De];
        ge === void 0 && (ge = {
            type: void 0,
            texture: void 0
        },
        ae[De] = ge),
        (ge.type !== Y || ge.texture !== ze) && (oe !== De && (n.activeTexture(De),
        oe = De),
        n.bindTexture(Y, ze || He[Y]),
        ge.type = Y,
        ge.texture = ze)
    }
    function j() {
        const Y = ae[oe];
        Y !== void 0 && Y.type !== void 0 && (n.bindTexture(Y.type, null),
        Y.type = void 0,
        Y.texture = void 0)
    }
    function he() {
        try {
            n.compressedTexImage2D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function le() {
        try {
            n.compressedTexImage3D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function me() {
        try {
            n.texSubImage2D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function We() {
        try {
            n.texSubImage3D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function Te() {
        try {
            n.compressedTexSubImage2D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function Ee() {
        try {
            n.compressedTexSubImage3D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function Ae() {
        try {
            n.texStorage2D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function _t() {
        try {
            n.texStorage3D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function Pe() {
        try {
            n.texImage2D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function Bt() {
        try {
            n.texImage3D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function vt(Y) {
        xe.equals(Y) === !1 && (n.scissor(Y.x, Y.y, Y.z, Y.w),
        xe.copy(Y))
    }
    function ht(Y) {
        Re.equals(Y) === !1 && (n.viewport(Y.x, Y.y, Y.z, Y.w),
        Re.copy(Y))
    }
    function at(Y, ze) {
        let De = m.get(ze);
        De === void 0 && (De = new WeakMap,
        m.set(ze, De));
        let ge = De.get(Y);
        ge === void 0 && (ge = n.getUniformBlockIndex(ze, Y.name),
        De.set(Y, ge))
    }
    function Le(Y, ze) {
        const ge = m.get(ze).get(Y);
        h.get(ze) !== ge && (n.uniformBlockBinding(ze, ge, Y.__bindingPointIndex),
        h.set(ze, ge))
    }
    function Lt() {
        n.disable(n.BLEND),
        n.disable(n.CULL_FACE),
        n.disable(n.DEPTH_TEST),
        n.disable(n.POLYGON_OFFSET_FILL),
        n.disable(n.SCISSOR_TEST),
        n.disable(n.STENCIL_TEST),
        n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
        n.blendEquation(n.FUNC_ADD),
        n.blendFunc(n.ONE, n.ZERO),
        n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
        n.blendColor(0, 0, 0, 0),
        n.colorMask(!0, !0, !0, !0),
        n.clearColor(0, 0, 0, 0),
        n.depthMask(!0),
        n.depthFunc(n.LESS),
        n.clearDepth(1),
        n.stencilMask(4294967295),
        n.stencilFunc(n.ALWAYS, 0, 4294967295),
        n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
        n.clearStencil(0),
        n.cullFace(n.BACK),
        n.frontFace(n.CCW),
        n.polygonOffset(0, 0),
        n.activeTexture(n.TEXTURE0),
        n.bindFramebuffer(n.FRAMEBUFFER, null),
        i === !0 && (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        n.bindFramebuffer(n.READ_FRAMEBUFFER, null)),
        n.useProgram(null),
        n.lineWidth(1),
        n.scissor(0, 0, n.canvas.width, n.canvas.height),
        n.viewport(0, 0, n.canvas.width, n.canvas.height),
        d = {},
        oe = null,
        ae = {},
        f = {},
        _ = new WeakMap,
        g = [],
        v = null,
        y = !1,
        w = null,
        S = null,
        E = null,
        b = null,
        T = null,
        C = null,
        P = null,
        A = new mn(0,0,0),
        R = 0,
        I = !1,
        D = null,
        H = null,
        B = null,
        G = null,
        X = null,
        xe.set(0, 0, n.canvas.width, n.canvas.height),
        Re.set(0, 0, n.canvas.width, n.canvas.height),
        a.reset(),
        c.reset(),
        u.reset()
    }
    return {
        buffers: {
            color: a,
            depth: c,
            stencil: u
        },
        enable: qe,
        disable: Xe,
        bindFramebuffer: st,
        drawBuffers: ie,
        useProgram: dt,
        setBlending: Qe,
        setMaterial: te,
        setFlipSided: ot,
        setCullFace: ft,
        setLineWidth: Tt,
        setPolygonOffset: pt,
        setScissorTest: Ct,
        activeTexture: z,
        bindTexture: N,
        unbindTexture: j,
        compressedTexImage2D: he,
        compressedTexImage3D: le,
        texImage2D: Pe,
        texImage3D: Bt,
        updateUBOMapping: at,
        uniformBlockBinding: Le,
        texStorage2D: Ae,
        texStorage3D: _t,
        texSubImage2D: me,
        texSubImage3D: We,
        compressedTexSubImage2D: Te,
        compressedTexSubImage3D: Ee,
        scissor: vt,
        viewport: ht,
        reset: Lt
    }
}
function pG(n, e, t, i, r, s, o) {
    const a = r.isWebGL2
      , c = r.maxTextures
      , u = r.maxCubemapSize
      , h = r.maxTextureSize
      , m = r.maxSamples
      , d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , f = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , _ = new WeakMap;
    let g;
    const v = new WeakMap;
    let y = !1;
    try {
        y = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function w(z, N) {
        return y ? new OffscreenCanvas(z,N) : Vf("canvas")
    }
    function S(z, N, j, he) {
        let le = 1;
        if ((z.width > he || z.height > he) && (le = he / Math.max(z.width, z.height)),
        le < 1 || N === !0)
            if (typeof HTMLImageElement < "u" && z instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && z instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && z instanceof ImageBitmap) {
                const me = N ? hv : Math.floor
                  , We = me(le * z.width)
                  , Te = me(le * z.height);
                g === void 0 && (g = w(We, Te));
                const Ee = j ? w(We, Te) : g;
                return Ee.width = We,
                Ee.height = Te,
                Ee.getContext("2d").drawImage(z, 0, 0, We, Te),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + z.width + "x" + z.height + ") to (" + We + "x" + Te + ")."),
                Ee
            } else
                return "data"in z && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + z.width + "x" + z.height + ")."),
                z;
        return z
    }
    function E(z) {
        return s1(z.width) && s1(z.height)
    }
    function b(z) {
        return a ? !1 : z.wrapS !== Os || z.wrapT !== Os || z.minFilter !== sr && z.minFilter !== Er
    }
    function T(z, N) {
        return z.generateMipmaps && N && z.minFilter !== sr && z.minFilter !== Er
    }
    function C(z) {
        n.generateMipmap(z)
    }
    function P(z, N, j, he, le=!1) {
        if (a === !1)
            return N;
        if (z !== null) {
            if (n[z] !== void 0)
                return n[z];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + z + "'")
        }
        let me = N;
        if (N === n.RED && (j === n.FLOAT && (me = n.R32F),
        j === n.HALF_FLOAT && (me = n.R16F),
        j === n.UNSIGNED_BYTE && (me = n.R8)),
        N === n.RED_INTEGER && (j === n.UNSIGNED_BYTE && (me = n.R8UI),
        j === n.UNSIGNED_SHORT && (me = n.R16UI),
        j === n.UNSIGNED_INT && (me = n.R32UI),
        j === n.BYTE && (me = n.R8I),
        j === n.SHORT && (me = n.R16I),
        j === n.INT && (me = n.R32I)),
        N === n.RG && (j === n.FLOAT && (me = n.RG32F),
        j === n.HALF_FLOAT && (me = n.RG16F),
        j === n.UNSIGNED_BYTE && (me = n.RG8)),
        N === n.RGBA) {
            const We = le ? Ap : pn.getTransfer(he);
            j === n.FLOAT && (me = n.RGBA32F),
            j === n.HALF_FLOAT && (me = n.RGBA16F),
            j === n.UNSIGNED_BYTE && (me = We === Rn ? n.SRGB8_ALPHA8 : n.RGBA8),
            j === n.UNSIGNED_SHORT_4_4_4_4 && (me = n.RGBA4),
            j === n.UNSIGNED_SHORT_5_5_5_1 && (me = n.RGB5_A1)
        }
        return (me === n.R16F || me === n.R32F || me === n.RG16F || me === n.RG32F || me === n.RGBA16F || me === n.RGBA32F) && e.get("EXT_color_buffer_float"),
        me
    }
    function A(z, N, j) {
        return T(z, j) === !0 || z.isFramebufferTexture && z.minFilter !== sr && z.minFilter !== Er ? Math.log2(Math.max(N.width, N.height)) + 1 : z.mipmaps !== void 0 && z.mipmaps.length > 0 ? z.mipmaps.length : z.isCompressedTexture && Array.isArray(z.image) ? N.mipmaps.length : 1
    }
    function R(z) {
        return z === sr || z === Pw || z === qg ? n.NEAREST : n.LINEAR
    }
    function I(z) {
        const N = z.target;
        N.removeEventListener("dispose", I),
        H(N),
        N.isVideoTexture && _.delete(N)
    }
    function D(z) {
        const N = z.target;
        N.removeEventListener("dispose", D),
        G(N)
    }
    function H(z) {
        const N = i.get(z);
        if (N.__webglInit === void 0)
            return;
        const j = z.source
          , he = v.get(j);
        if (he) {
            const le = he[N.__cacheKey];
            le.usedTimes--,
            le.usedTimes === 0 && B(z),
            Object.keys(he).length === 0 && v.delete(j)
        }
        i.remove(z)
    }
    function B(z) {
        const N = i.get(z);
        n.deleteTexture(N.__webglTexture);
        const j = z.source
          , he = v.get(j);
        delete he[N.__cacheKey],
        o.memory.textures--
    }
    function G(z) {
        const N = z.texture
          , j = i.get(z)
          , he = i.get(N);
        if (he.__webglTexture !== void 0 && (n.deleteTexture(he.__webglTexture),
        o.memory.textures--),
        z.depthTexture && z.depthTexture.dispose(),
        z.isWebGLCubeRenderTarget)
            for (let le = 0; le < 6; le++) {
                if (Array.isArray(j.__webglFramebuffer[le]))
                    for (let me = 0; me < j.__webglFramebuffer[le].length; me++)
                        n.deleteFramebuffer(j.__webglFramebuffer[le][me]);
                else
                    n.deleteFramebuffer(j.__webglFramebuffer[le]);
                j.__webglDepthbuffer && n.deleteRenderbuffer(j.__webglDepthbuffer[le])
            }
        else {
            if (Array.isArray(j.__webglFramebuffer))
                for (let le = 0; le < j.__webglFramebuffer.length; le++)
                    n.deleteFramebuffer(j.__webglFramebuffer[le]);
            else
                n.deleteFramebuffer(j.__webglFramebuffer);
            if (j.__webglDepthbuffer && n.deleteRenderbuffer(j.__webglDepthbuffer),
            j.__webglMultisampledFramebuffer && n.deleteFramebuffer(j.__webglMultisampledFramebuffer),
            j.__webglColorRenderbuffer)
                for (let le = 0; le < j.__webglColorRenderbuffer.length; le++)
                    j.__webglColorRenderbuffer[le] && n.deleteRenderbuffer(j.__webglColorRenderbuffer[le]);
            j.__webglDepthRenderbuffer && n.deleteRenderbuffer(j.__webglDepthRenderbuffer)
        }
        if (z.isWebGLMultipleRenderTargets)
            for (let le = 0, me = N.length; le < me; le++) {
                const We = i.get(N[le]);
                We.__webglTexture && (n.deleteTexture(We.__webglTexture),
                o.memory.textures--),
                i.remove(N[le])
            }
        i.remove(N),
        i.remove(z)
    }
    let X = 0;
    function V() {
        X = 0
    }
    function ee() {
        const z = X;
        return z >= c && console.warn("THREE.WebGLTextures: Trying to use " + z + " texture units while this GPU supports only " + c),
        X += 1,
        z
    }
    function re(z) {
        const N = [];
        return N.push(z.wrapS),
        N.push(z.wrapT),
        N.push(z.wrapR || 0),
        N.push(z.magFilter),
        N.push(z.minFilter),
        N.push(z.anisotropy),
        N.push(z.internalFormat),
        N.push(z.format),
        N.push(z.type),
        N.push(z.generateMipmaps),
        N.push(z.premultiplyAlpha),
        N.push(z.flipY),
        N.push(z.unpackAlignment),
        N.push(z.colorSpace),
        N.join()
    }
    function k(z, N) {
        const j = i.get(z);
        if (z.isVideoTexture && pt(z),
        z.isRenderTargetTexture === !1 && z.version > 0 && j.__version !== z.version) {
            const he = z.image;
            if (he === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (he.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                qe(j, z, N);
                return
            }
        }
        t.bindTexture(n.TEXTURE_2D, j.__webglTexture, n.TEXTURE0 + N)
    }
    function oe(z, N) {
        const j = i.get(z);
        if (z.version > 0 && j.__version !== z.version) {
            qe(j, z, N);
            return
        }
        t.bindTexture(n.TEXTURE_2D_ARRAY, j.__webglTexture, n.TEXTURE0 + N)
    }
    function ae(z, N) {
        const j = i.get(z);
        if (z.version > 0 && j.__version !== z.version) {
            qe(j, z, N);
            return
        }
        t.bindTexture(n.TEXTURE_3D, j.__webglTexture, n.TEXTURE0 + N)
    }
    function ne(z, N) {
        const j = i.get(z);
        if (z.version > 0 && j.__version !== z.version) {
            Xe(j, z, N);
            return
        }
        t.bindTexture(n.TEXTURE_CUBE_MAP, j.__webglTexture, n.TEXTURE0 + N)
    }
    const fe = {
        [lv]: n.REPEAT,
        [Os]: n.CLAMP_TO_EDGE,
        [cv]: n.MIRRORED_REPEAT
    }
      , xe = {
        [sr]: n.NEAREST,
        [Pw]: n.NEAREST_MIPMAP_NEAREST,
        [qg]: n.NEAREST_MIPMAP_LINEAR,
        [Er]: n.LINEAR,
        [jk]: n.LINEAR_MIPMAP_NEAREST,
        [Hf]: n.LINEAR_MIPMAP_LINEAR
    }
      , Re = {
        [a4]: n.NEVER,
        [d4]: n.ALWAYS,
        [l4]: n.LESS,
        [iR]: n.LEQUAL,
        [c4]: n.EQUAL,
        [h4]: n.GEQUAL,
        [u4]: n.GREATER,
        [f4]: n.NOTEQUAL
    };
    function Ue(z, N, j) {
        if (j ? (n.texParameteri(z, n.TEXTURE_WRAP_S, fe[N.wrapS]),
        n.texParameteri(z, n.TEXTURE_WRAP_T, fe[N.wrapT]),
        (z === n.TEXTURE_3D || z === n.TEXTURE_2D_ARRAY) && n.texParameteri(z, n.TEXTURE_WRAP_R, fe[N.wrapR]),
        n.texParameteri(z, n.TEXTURE_MAG_FILTER, xe[N.magFilter]),
        n.texParameteri(z, n.TEXTURE_MIN_FILTER, xe[N.minFilter])) : (n.texParameteri(z, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE),
        n.texParameteri(z, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE),
        (z === n.TEXTURE_3D || z === n.TEXTURE_2D_ARRAY) && n.texParameteri(z, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE),
        (N.wrapS !== Os || N.wrapT !== Os) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
        n.texParameteri(z, n.TEXTURE_MAG_FILTER, R(N.magFilter)),
        n.texParameteri(z, n.TEXTURE_MIN_FILTER, R(N.minFilter)),
        N.minFilter !== sr && N.minFilter !== Er && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
        N.compareFunction && (n.texParameteri(z, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(z, n.TEXTURE_COMPARE_FUNC, Re[N.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            const he = e.get("EXT_texture_filter_anisotropic");
            if (N.magFilter === sr || N.minFilter !== qg && N.minFilter !== Hf || N.type === pa && e.has("OES_texture_float_linear") === !1 || a === !1 && N.type === Gf && e.has("OES_texture_half_float_linear") === !1)
                return;
            (N.anisotropy > 1 || i.get(N).__currentAnisotropy) && (n.texParameterf(z, he.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(N.anisotropy, r.getMaxAnisotropy())),
            i.get(N).__currentAnisotropy = N.anisotropy)
        }
    }
    function He(z, N) {
        let j = !1;
        z.__webglInit === void 0 && (z.__webglInit = !0,
        N.addEventListener("dispose", I));
        const he = N.source;
        let le = v.get(he);
        le === void 0 && (le = {},
        v.set(he, le));
        const me = re(N);
        if (me !== z.__cacheKey) {
            le[me] === void 0 && (le[me] = {
                texture: n.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            j = !0),
            le[me].usedTimes++;
            const We = le[z.__cacheKey];
            We !== void 0 && (le[z.__cacheKey].usedTimes--,
            We.usedTimes === 0 && B(N)),
            z.__cacheKey = me,
            z.__webglTexture = le[me].texture
        }
        return j
    }
    function qe(z, N, j) {
        let he = n.TEXTURE_2D;
        (N.isDataArrayTexture || N.isCompressedArrayTexture) && (he = n.TEXTURE_2D_ARRAY),
        N.isData3DTexture && (he = n.TEXTURE_3D);
        const le = He(z, N)
          , me = N.source;
        t.bindTexture(he, z.__webglTexture, n.TEXTURE0 + j);
        const We = i.get(me);
        if (me.version !== We.__version || le === !0) {
            t.activeTexture(n.TEXTURE0 + j);
            const Te = pn.getPrimaries(pn.workingColorSpace)
              , Ee = N.colorSpace === ms ? null : pn.getPrimaries(N.colorSpace)
              , Ae = N.colorSpace === ms || Te === Ee ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, N.flipY),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N.premultiplyAlpha),
            n.pixelStorei(n.UNPACK_ALIGNMENT, N.unpackAlignment),
            n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ae);
            const _t = b(N) && E(N.image) === !1;
            let Pe = S(N.image, _t, !1, h);
            Pe = Ct(N, Pe);
            const Bt = E(Pe) || a
              , vt = s.convert(N.format, N.colorSpace);
            let ht = s.convert(N.type)
              , at = P(N.internalFormat, vt, ht, N.colorSpace, N.isVideoTexture);
            Ue(he, N, Bt);
            let Le;
            const Lt = N.mipmaps
              , Y = a && N.isVideoTexture !== !0 && at !== tR
              , ze = We.__version === void 0 || le === !0
              , De = A(N, Pe, Bt);
            if (N.isDepthTexture)
                at = n.DEPTH_COMPONENT,
                a ? N.type === pa ? at = n.DEPTH_COMPONENT32F : N.type === da ? at = n.DEPTH_COMPONENT24 : N.type === bl ? at = n.DEPTH24_STENCIL8 : at = n.DEPTH_COMPONENT16 : N.type === pa && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                N.format === Sl && at === n.DEPTH_COMPONENT && N.type !== Iy && N.type !== da && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                N.type = da,
                ht = s.convert(N.type)),
                N.format === Yc && at === n.DEPTH_COMPONENT && (at = n.DEPTH_STENCIL,
                N.type !== bl && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                N.type = bl,
                ht = s.convert(N.type))),
                ze && (Y ? t.texStorage2D(n.TEXTURE_2D, 1, at, Pe.width, Pe.height) : t.texImage2D(n.TEXTURE_2D, 0, at, Pe.width, Pe.height, 0, vt, ht, null));
            else if (N.isDataTexture)
                if (Lt.length > 0 && Bt) {
                    Y && ze && t.texStorage2D(n.TEXTURE_2D, De, at, Lt[0].width, Lt[0].height);
                    for (let ge = 0, Fe = Lt.length; ge < Fe; ge++)
                        Le = Lt[ge],
                        Y ? t.texSubImage2D(n.TEXTURE_2D, ge, 0, 0, Le.width, Le.height, vt, ht, Le.data) : t.texImage2D(n.TEXTURE_2D, ge, at, Le.width, Le.height, 0, vt, ht, Le.data);
                    N.generateMipmaps = !1
                } else
                    Y ? (ze && t.texStorage2D(n.TEXTURE_2D, De, at, Pe.width, Pe.height),
                    t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Pe.width, Pe.height, vt, ht, Pe.data)) : t.texImage2D(n.TEXTURE_2D, 0, at, Pe.width, Pe.height, 0, vt, ht, Pe.data);
            else if (N.isCompressedTexture)
                if (N.isCompressedArrayTexture) {
                    Y && ze && t.texStorage3D(n.TEXTURE_2D_ARRAY, De, at, Lt[0].width, Lt[0].height, Pe.depth);
                    for (let ge = 0, Fe = Lt.length; ge < Fe; ge++)
                        Le = Lt[ge],
                        N.format !== Ns ? vt !== null ? Y ? t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, ge, 0, 0, 0, Le.width, Le.height, Pe.depth, vt, Le.data, 0, 0) : t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, ge, at, Le.width, Le.height, Pe.depth, 0, Le.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Y ? t.texSubImage3D(n.TEXTURE_2D_ARRAY, ge, 0, 0, 0, Le.width, Le.height, Pe.depth, vt, ht, Le.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, ge, at, Le.width, Le.height, Pe.depth, 0, vt, ht, Le.data)
                } else {
                    Y && ze && t.texStorage2D(n.TEXTURE_2D, De, at, Lt[0].width, Lt[0].height);
                    for (let ge = 0, Fe = Lt.length; ge < Fe; ge++)
                        Le = Lt[ge],
                        N.format !== Ns ? vt !== null ? Y ? t.compressedTexSubImage2D(n.TEXTURE_2D, ge, 0, 0, Le.width, Le.height, vt, Le.data) : t.compressedTexImage2D(n.TEXTURE_2D, ge, at, Le.width, Le.height, 0, Le.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Y ? t.texSubImage2D(n.TEXTURE_2D, ge, 0, 0, Le.width, Le.height, vt, ht, Le.data) : t.texImage2D(n.TEXTURE_2D, ge, at, Le.width, Le.height, 0, vt, ht, Le.data)
                }
            else if (N.isDataArrayTexture)
                Y ? (ze && t.texStorage3D(n.TEXTURE_2D_ARRAY, De, at, Pe.width, Pe.height, Pe.depth),
                t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Pe.width, Pe.height, Pe.depth, vt, ht, Pe.data)) : t.texImage3D(n.TEXTURE_2D_ARRAY, 0, at, Pe.width, Pe.height, Pe.depth, 0, vt, ht, Pe.data);
            else if (N.isData3DTexture)
                Y ? (ze && t.texStorage3D(n.TEXTURE_3D, De, at, Pe.width, Pe.height, Pe.depth),
                t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, Pe.width, Pe.height, Pe.depth, vt, ht, Pe.data)) : t.texImage3D(n.TEXTURE_3D, 0, at, Pe.width, Pe.height, Pe.depth, 0, vt, ht, Pe.data);
            else if (N.isFramebufferTexture) {
                if (ze)
                    if (Y)
                        t.texStorage2D(n.TEXTURE_2D, De, at, Pe.width, Pe.height);
                    else {
                        let ge = Pe.width
                          , Fe = Pe.height;
                        for (let ut = 0; ut < De; ut++)
                            t.texImage2D(n.TEXTURE_2D, ut, at, ge, Fe, 0, vt, ht, null),
                            ge >>= 1,
                            Fe >>= 1
                    }
            } else if (Lt.length > 0 && Bt) {
                Y && ze && t.texStorage2D(n.TEXTURE_2D, De, at, Lt[0].width, Lt[0].height);
                for (let ge = 0, Fe = Lt.length; ge < Fe; ge++)
                    Le = Lt[ge],
                    Y ? t.texSubImage2D(n.TEXTURE_2D, ge, 0, 0, vt, ht, Le) : t.texImage2D(n.TEXTURE_2D, ge, at, vt, ht, Le);
                N.generateMipmaps = !1
            } else
                Y ? (ze && t.texStorage2D(n.TEXTURE_2D, De, at, Pe.width, Pe.height),
                t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, vt, ht, Pe)) : t.texImage2D(n.TEXTURE_2D, 0, at, vt, ht, Pe);
            T(N, Bt) && C(he),
            We.__version = me.version,
            N.onUpdate && N.onUpdate(N)
        }
        z.__version = N.version
    }
    function Xe(z, N, j) {
        if (N.image.length !== 6)
            return;
        const he = He(z, N)
          , le = N.source;
        t.bindTexture(n.TEXTURE_CUBE_MAP, z.__webglTexture, n.TEXTURE0 + j);
        const me = i.get(le);
        if (le.version !== me.__version || he === !0) {
            t.activeTexture(n.TEXTURE0 + j);
            const We = pn.getPrimaries(pn.workingColorSpace)
              , Te = N.colorSpace === ms ? null : pn.getPrimaries(N.colorSpace)
              , Ee = N.colorSpace === ms || We === Te ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, N.flipY),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N.premultiplyAlpha),
            n.pixelStorei(n.UNPACK_ALIGNMENT, N.unpackAlignment),
            n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ee);
            const Ae = N.isCompressedTexture || N.image[0].isCompressedTexture
              , _t = N.image[0] && N.image[0].isDataTexture
              , Pe = [];
            for (let ge = 0; ge < 6; ge++)
                !Ae && !_t ? Pe[ge] = S(N.image[ge], !1, !0, u) : Pe[ge] = _t ? N.image[ge].image : N.image[ge],
                Pe[ge] = Ct(N, Pe[ge]);
            const Bt = Pe[0]
              , vt = E(Bt) || a
              , ht = s.convert(N.format, N.colorSpace)
              , at = s.convert(N.type)
              , Le = P(N.internalFormat, ht, at, N.colorSpace)
              , Lt = a && N.isVideoTexture !== !0
              , Y = me.__version === void 0 || he === !0;
            let ze = A(N, Bt, vt);
            Ue(n.TEXTURE_CUBE_MAP, N, vt);
            let De;
            if (Ae) {
                Lt && Y && t.texStorage2D(n.TEXTURE_CUBE_MAP, ze, Le, Bt.width, Bt.height);
                for (let ge = 0; ge < 6; ge++) {
                    De = Pe[ge].mipmaps;
                    for (let Fe = 0; Fe < De.length; Fe++) {
                        const ut = De[Fe];
                        N.format !== Ns ? ht !== null ? Lt ? t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ge, Fe, 0, 0, ut.width, ut.height, ht, ut.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ge, Fe, Le, ut.width, ut.height, 0, ut.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Lt ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ge, Fe, 0, 0, ut.width, ut.height, ht, at, ut.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ge, Fe, Le, ut.width, ut.height, 0, ht, at, ut.data)
                    }
                }
            } else {
                De = N.mipmaps,
                Lt && Y && (De.length > 0 && ze++,
                t.texStorage2D(n.TEXTURE_CUBE_MAP, ze, Le, Pe[0].width, Pe[0].height));
                for (let ge = 0; ge < 6; ge++)
                    if (_t) {
                        Lt ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ge, 0, 0, 0, Pe[ge].width, Pe[ge].height, ht, at, Pe[ge].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ge, 0, Le, Pe[ge].width, Pe[ge].height, 0, ht, at, Pe[ge].data);
                        for (let Fe = 0; Fe < De.length; Fe++) {
                            const Ge = De[Fe].image[ge].image;
                            Lt ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ge, Fe + 1, 0, 0, Ge.width, Ge.height, ht, at, Ge.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ge, Fe + 1, Le, Ge.width, Ge.height, 0, ht, at, Ge.data)
                        }
                    } else {
                        Lt ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ge, 0, 0, 0, ht, at, Pe[ge]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ge, 0, Le, ht, at, Pe[ge]);
                        for (let Fe = 0; Fe < De.length; Fe++) {
                            const ut = De[Fe];
                            Lt ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ge, Fe + 1, 0, 0, ht, at, ut.image[ge]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ge, Fe + 1, Le, ht, at, ut.image[ge])
                        }
                    }
            }
            T(N, vt) && C(n.TEXTURE_CUBE_MAP),
            me.__version = le.version,
            N.onUpdate && N.onUpdate(N)
        }
        z.__version = N.version
    }
    function st(z, N, j, he, le, me) {
        const We = s.convert(j.format, j.colorSpace)
          , Te = s.convert(j.type)
          , Ee = P(j.internalFormat, We, Te, j.colorSpace);
        if (!i.get(N).__hasExternalTextures) {
            const _t = Math.max(1, N.width >> me)
              , Pe = Math.max(1, N.height >> me);
            le === n.TEXTURE_3D || le === n.TEXTURE_2D_ARRAY ? t.texImage3D(le, me, Ee, _t, Pe, N.depth, 0, We, Te, null) : t.texImage2D(le, me, Ee, _t, Pe, 0, We, Te, null)
        }
        t.bindFramebuffer(n.FRAMEBUFFER, z),
        Tt(N) ? d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, he, le, i.get(j).__webglTexture, 0, ft(N)) : (le === n.TEXTURE_2D || le >= n.TEXTURE_CUBE_MAP_POSITIVE_X && le <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, he, le, i.get(j).__webglTexture, me),
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }
    function ie(z, N, j) {
        if (n.bindRenderbuffer(n.RENDERBUFFER, z),
        N.depthBuffer && !N.stencilBuffer) {
            let he = a === !0 ? n.DEPTH_COMPONENT24 : n.DEPTH_COMPONENT16;
            if (j || Tt(N)) {
                const le = N.depthTexture;
                le && le.isDepthTexture && (le.type === pa ? he = n.DEPTH_COMPONENT32F : le.type === da && (he = n.DEPTH_COMPONENT24));
                const me = ft(N);
                Tt(N) ? d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, me, he, N.width, N.height) : n.renderbufferStorageMultisample(n.RENDERBUFFER, me, he, N.width, N.height)
            } else
                n.renderbufferStorage(n.RENDERBUFFER, he, N.width, N.height);
            n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, z)
        } else if (N.depthBuffer && N.stencilBuffer) {
            const he = ft(N);
            j && Tt(N) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, he, n.DEPTH24_STENCIL8, N.width, N.height) : Tt(N) ? d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, he, n.DEPTH24_STENCIL8, N.width, N.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, N.width, N.height),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, z)
        } else {
            const he = N.isWebGLMultipleRenderTargets === !0 ? N.texture : [N.texture];
            for (let le = 0; le < he.length; le++) {
                const me = he[le]
                  , We = s.convert(me.format, me.colorSpace)
                  , Te = s.convert(me.type)
                  , Ee = P(me.internalFormat, We, Te, me.colorSpace)
                  , Ae = ft(N);
                j && Tt(N) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, Ae, Ee, N.width, N.height) : Tt(N) ? d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Ae, Ee, N.width, N.height) : n.renderbufferStorage(n.RENDERBUFFER, Ee, N.width, N.height)
            }
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null)
    }
    function dt(z, N) {
        if (N && N.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(n.FRAMEBUFFER, z),
        !(N.depthTexture && N.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!i.get(N.depthTexture).__webglTexture || N.depthTexture.image.width !== N.width || N.depthTexture.image.height !== N.height) && (N.depthTexture.image.width = N.width,
        N.depthTexture.image.height = N.height,
        N.depthTexture.needsUpdate = !0),
        k(N.depthTexture, 0);
        const he = i.get(N.depthTexture).__webglTexture
          , le = ft(N);
        if (N.depthTexture.format === Sl)
            Tt(N) ? d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, he, 0, le) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, he, 0);
        else if (N.depthTexture.format === Yc)
            Tt(N) ? d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, he, 0, le) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, he, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function Ne(z) {
        const N = i.get(z)
          , j = z.isWebGLCubeRenderTarget === !0;
        if (z.depthTexture && !N.__autoAllocateDepthBuffer) {
            if (j)
                throw new Error("target.depthTexture not supported in Cube render targets");
            dt(N.__webglFramebuffer, z)
        } else if (j) {
            N.__webglDepthbuffer = [];
            for (let he = 0; he < 6; he++)
                t.bindFramebuffer(n.FRAMEBUFFER, N.__webglFramebuffer[he]),
                N.__webglDepthbuffer[he] = n.createRenderbuffer(),
                ie(N.__webglDepthbuffer[he], z, !1)
        } else
            t.bindFramebuffer(n.FRAMEBUFFER, N.__webglFramebuffer),
            N.__webglDepthbuffer = n.createRenderbuffer(),
            ie(N.__webglDepthbuffer, z, !1);
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }
    function Ye(z, N, j) {
        const he = i.get(z);
        N !== void 0 && st(he.__webglFramebuffer, z, z.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0),
        j !== void 0 && Ne(z)
    }
    function Qe(z) {
        const N = z.texture
          , j = i.get(z)
          , he = i.get(N);
        z.addEventListener("dispose", D),
        z.isWebGLMultipleRenderTargets !== !0 && (he.__webglTexture === void 0 && (he.__webglTexture = n.createTexture()),
        he.__version = N.version,
        o.memory.textures++);
        const le = z.isWebGLCubeRenderTarget === !0
          , me = z.isWebGLMultipleRenderTargets === !0
          , We = E(z) || a;
        if (le) {
            j.__webglFramebuffer = [];
            for (let Te = 0; Te < 6; Te++)
                if (a && N.mipmaps && N.mipmaps.length > 0) {
                    j.__webglFramebuffer[Te] = [];
                    for (let Ee = 0; Ee < N.mipmaps.length; Ee++)
                        j.__webglFramebuffer[Te][Ee] = n.createFramebuffer()
                } else
                    j.__webglFramebuffer[Te] = n.createFramebuffer()
        } else {
            if (a && N.mipmaps && N.mipmaps.length > 0) {
                j.__webglFramebuffer = [];
                for (let Te = 0; Te < N.mipmaps.length; Te++)
                    j.__webglFramebuffer[Te] = n.createFramebuffer()
            } else
                j.__webglFramebuffer = n.createFramebuffer();
            if (me)
                if (r.drawBuffers) {
                    const Te = z.texture;
                    for (let Ee = 0, Ae = Te.length; Ee < Ae; Ee++) {
                        const _t = i.get(Te[Ee]);
                        _t.__webglTexture === void 0 && (_t.__webglTexture = n.createTexture(),
                        o.memory.textures++)
                    }
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (a && z.samples > 0 && Tt(z) === !1) {
                const Te = me ? N : [N];
                j.__webglMultisampledFramebuffer = n.createFramebuffer(),
                j.__webglColorRenderbuffer = [],
                t.bindFramebuffer(n.FRAMEBUFFER, j.__webglMultisampledFramebuffer);
                for (let Ee = 0; Ee < Te.length; Ee++) {
                    const Ae = Te[Ee];
                    j.__webglColorRenderbuffer[Ee] = n.createRenderbuffer(),
                    n.bindRenderbuffer(n.RENDERBUFFER, j.__webglColorRenderbuffer[Ee]);
                    const _t = s.convert(Ae.format, Ae.colorSpace)
                      , Pe = s.convert(Ae.type)
                      , Bt = P(Ae.internalFormat, _t, Pe, Ae.colorSpace, z.isXRRenderTarget === !0)
                      , vt = ft(z);
                    n.renderbufferStorageMultisample(n.RENDERBUFFER, vt, Bt, z.width, z.height),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ee, n.RENDERBUFFER, j.__webglColorRenderbuffer[Ee])
                }
                n.bindRenderbuffer(n.RENDERBUFFER, null),
                z.depthBuffer && (j.__webglDepthRenderbuffer = n.createRenderbuffer(),
                ie(j.__webglDepthRenderbuffer, z, !0)),
                t.bindFramebuffer(n.FRAMEBUFFER, null)
            }
        }
        if (le) {
            t.bindTexture(n.TEXTURE_CUBE_MAP, he.__webglTexture),
            Ue(n.TEXTURE_CUBE_MAP, N, We);
            for (let Te = 0; Te < 6; Te++)
                if (a && N.mipmaps && N.mipmaps.length > 0)
                    for (let Ee = 0; Ee < N.mipmaps.length; Ee++)
                        st(j.__webglFramebuffer[Te][Ee], z, N, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + Te, Ee);
                else
                    st(j.__webglFramebuffer[Te], z, N, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + Te, 0);
            T(N, We) && C(n.TEXTURE_CUBE_MAP),
            t.unbindTexture()
        } else if (me) {
            const Te = z.texture;
            for (let Ee = 0, Ae = Te.length; Ee < Ae; Ee++) {
                const _t = Te[Ee]
                  , Pe = i.get(_t);
                t.bindTexture(n.TEXTURE_2D, Pe.__webglTexture),
                Ue(n.TEXTURE_2D, _t, We),
                st(j.__webglFramebuffer, z, _t, n.COLOR_ATTACHMENT0 + Ee, n.TEXTURE_2D, 0),
                T(_t, We) && C(n.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let Te = n.TEXTURE_2D;
            if ((z.isWebGL3DRenderTarget || z.isWebGLArrayRenderTarget) && (a ? Te = z.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
            t.bindTexture(Te, he.__webglTexture),
            Ue(Te, N, We),
            a && N.mipmaps && N.mipmaps.length > 0)
                for (let Ee = 0; Ee < N.mipmaps.length; Ee++)
                    st(j.__webglFramebuffer[Ee], z, N, n.COLOR_ATTACHMENT0, Te, Ee);
            else
                st(j.__webglFramebuffer, z, N, n.COLOR_ATTACHMENT0, Te, 0);
            T(N, We) && C(Te),
            t.unbindTexture()
        }
        z.depthBuffer && Ne(z)
    }
    function te(z) {
        const N = E(z) || a
          , j = z.isWebGLMultipleRenderTargets === !0 ? z.texture : [z.texture];
        for (let he = 0, le = j.length; he < le; he++) {
            const me = j[he];
            if (T(me, N)) {
                const We = z.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D
                  , Te = i.get(me).__webglTexture;
                t.bindTexture(We, Te),
                C(We),
                t.unbindTexture()
            }
        }
    }
    function ot(z) {
        if (a && z.samples > 0 && Tt(z) === !1) {
            const N = z.isWebGLMultipleRenderTargets ? z.texture : [z.texture]
              , j = z.width
              , he = z.height;
            let le = n.COLOR_BUFFER_BIT;
            const me = []
              , We = z.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
              , Te = i.get(z)
              , Ee = z.isWebGLMultipleRenderTargets === !0;
            if (Ee)
                for (let Ae = 0; Ae < N.length; Ae++)
                    t.bindFramebuffer(n.FRAMEBUFFER, Te.__webglMultisampledFramebuffer),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ae, n.RENDERBUFFER, null),
                    t.bindFramebuffer(n.FRAMEBUFFER, Te.__webglFramebuffer),
                    n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ae, n.TEXTURE_2D, null, 0);
            t.bindFramebuffer(n.READ_FRAMEBUFFER, Te.__webglMultisampledFramebuffer),
            t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Te.__webglFramebuffer);
            for (let Ae = 0; Ae < N.length; Ae++) {
                me.push(n.COLOR_ATTACHMENT0 + Ae),
                z.depthBuffer && me.push(We);
                const _t = Te.__ignoreDepthValues !== void 0 ? Te.__ignoreDepthValues : !1;
                if (_t === !1 && (z.depthBuffer && (le |= n.DEPTH_BUFFER_BIT),
                z.stencilBuffer && (le |= n.STENCIL_BUFFER_BIT)),
                Ee && n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, Te.__webglColorRenderbuffer[Ae]),
                _t === !0 && (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [We]),
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [We])),
                Ee) {
                    const Pe = i.get(N[Ae]).__webglTexture;
                    n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, Pe, 0)
                }
                n.blitFramebuffer(0, 0, j, he, 0, 0, j, he, le, n.NEAREST),
                f && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, me)
            }
            if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
            t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
            Ee)
                for (let Ae = 0; Ae < N.length; Ae++) {
                    t.bindFramebuffer(n.FRAMEBUFFER, Te.__webglMultisampledFramebuffer),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ae, n.RENDERBUFFER, Te.__webglColorRenderbuffer[Ae]);
                    const _t = i.get(N[Ae]).__webglTexture;
                    t.bindFramebuffer(n.FRAMEBUFFER, Te.__webglFramebuffer),
                    n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ae, n.TEXTURE_2D, _t, 0)
                }
            t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Te.__webglMultisampledFramebuffer)
        }
    }
    function ft(z) {
        return Math.min(m, z.samples)
    }
    function Tt(z) {
        const N = i.get(z);
        return a && z.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && N.__useRenderToTexture !== !1
    }
    function pt(z) {
        const N = o.render.frame;
        _.get(z) !== N && (_.set(z, N),
        z.update())
    }
    function Ct(z, N) {
        const j = z.colorSpace
          , he = z.format
          , le = z.type;
        return z.isCompressedTexture === !0 || z.isVideoTexture === !0 || z.format === uv || j !== No && j !== ms && (pn.getTransfer(j) === Rn ? a === !1 ? e.has("EXT_sRGB") === !0 && he === Ns ? (z.format = uv,
        z.minFilter = Er,
        z.generateMipmaps = !1) : N = sR.sRGBToLinear(N) : (he !== Ns || le !== ba) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", j)),
        N
    }
    this.allocateTextureUnit = ee,
    this.resetTextureUnits = V,
    this.setTexture2D = k,
    this.setTexture2DArray = oe,
    this.setTexture3D = ae,
    this.setTextureCube = ne,
    this.rebindTextures = Ye,
    this.setupRenderTarget = Qe,
    this.updateRenderTargetMipmap = te,
    this.updateMultisampleRenderTarget = ot,
    this.setupDepthRenderbuffer = Ne,
    this.setupFrameBufferTexture = st,
    this.useMultisampledRTT = Tt
}
function mG(n, e, t) {
    const i = t.isWebGL2;
    function r(s, o=ms) {
        let a;
        const c = pn.getTransfer(o);
        if (s === ba)
            return n.UNSIGNED_BYTE;
        if (s === KC)
            return n.UNSIGNED_SHORT_4_4_4_4;
        if (s === ZC)
            return n.UNSIGNED_SHORT_5_5_5_1;
        if (s === Yk)
            return n.BYTE;
        if (s === Kk)
            return n.SHORT;
        if (s === Iy)
            return n.UNSIGNED_SHORT;
        if (s === YC)
            return n.INT;
        if (s === da)
            return n.UNSIGNED_INT;
        if (s === pa)
            return n.FLOAT;
        if (s === Gf)
            return i ? n.HALF_FLOAT : (a = e.get("OES_texture_half_float"),
            a !== null ? a.HALF_FLOAT_OES : null);
        if (s === Zk)
            return n.ALPHA;
        if (s === Ns)
            return n.RGBA;
        if (s === Jk)
            return n.LUMINANCE;
        if (s === Qk)
            return n.LUMINANCE_ALPHA;
        if (s === Sl)
            return n.DEPTH_COMPONENT;
        if (s === Yc)
            return n.DEPTH_STENCIL;
        if (s === uv)
            return a = e.get("EXT_sRGB"),
            a !== null ? a.SRGB_ALPHA_EXT : null;
        if (s === e4)
            return n.RED;
        if (s === JC)
            return n.RED_INTEGER;
        if (s === t4)
            return n.RG;
        if (s === QC)
            return n.RG_INTEGER;
        if (s === eR)
            return n.RGBA_INTEGER;
        if (s === jg || s === Yg || s === Kg || s === Zg)
            if (c === Rn)
                if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                a !== null) {
                    if (s === jg)
                        return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (s === Yg)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (s === Kg)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (s === Zg)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (a = e.get("WEBGL_compressed_texture_s3tc"),
            a !== null) {
                if (s === jg)
                    return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (s === Yg)
                    return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (s === Kg)
                    return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (s === Zg)
                    return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (s === Lw || s === Dw || s === Iw || s === Ow)
            if (a = e.get("WEBGL_compressed_texture_pvrtc"),
            a !== null) {
                if (s === Lw)
                    return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (s === Dw)
                    return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (s === Iw)
                    return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (s === Ow)
                    return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (s === tR)
            return a = e.get("WEBGL_compressed_texture_etc1"),
            a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (s === Nw || s === Uw)
            if (a = e.get("WEBGL_compressed_texture_etc"),
            a !== null) {
                if (s === Nw)
                    return c === Rn ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (s === Uw)
                    return c === Rn ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (s === Fw || s === Bw || s === kw || s === zw || s === Hw || s === Gw || s === Vw || s === Ww || s === $w || s === Xw || s === qw || s === jw || s === Yw || s === Kw)
            if (a = e.get("WEBGL_compressed_texture_astc"),
            a !== null) {
                if (s === Fw)
                    return c === Rn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (s === Bw)
                    return c === Rn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (s === kw)
                    return c === Rn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (s === zw)
                    return c === Rn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (s === Hw)
                    return c === Rn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (s === Gw)
                    return c === Rn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (s === Vw)
                    return c === Rn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (s === Ww)
                    return c === Rn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (s === $w)
                    return c === Rn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (s === Xw)
                    return c === Rn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (s === qw)
                    return c === Rn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (s === jw)
                    return c === Rn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (s === Yw)
                    return c === Rn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (s === Kw)
                    return c === Rn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (s === Jg || s === Zw || s === Jw)
            if (a = e.get("EXT_texture_compression_bptc"),
            a !== null) {
                if (s === Jg)
                    return c === Rn ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (s === Zw)
                    return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (s === Jw)
                    return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (s === n4 || s === Qw || s === e1 || s === t1)
            if (a = e.get("EXT_texture_compression_rgtc"),
            a !== null) {
                if (s === Jg)
                    return a.COMPRESSED_RED_RGTC1_EXT;
                if (s === Qw)
                    return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (s === e1)
                    return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (s === t1)
                    return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return s === bl ? i ? n.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"),
        a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null
    }
    return {
        convert: r
    }
}
class gG extends ps {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class pf extends Zr {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const _G = {
    type: "move"
};
class w0 {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new pf,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new pf,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new pe,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new pe),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new pf,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new pe,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new pe),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const i of e.hand.values())
                    this._getHandJoint(t, i)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, i) {
        let r = null
          , s = null
          , o = null;
        const a = this._targetRay
          , c = this._grip
          , u = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (u && e.hand) {
                o = !0;
                for (const g of e.hand.values()) {
                    const v = t.getJointPose(g, i)
                      , y = this._getHandJoint(u, g);
                    v !== null && (y.matrix.fromArray(v.transform.matrix),
                    y.matrix.decompose(y.position, y.rotation, y.scale),
                    y.matrixWorldNeedsUpdate = !0,
                    y.jointRadius = v.radius),
                    y.visible = v !== null
                }
                const h = u.joints["index-finger-tip"]
                  , m = u.joints["thumb-tip"]
                  , d = h.position.distanceTo(m.position)
                  , f = .02
                  , _ = .005;
                u.inputState.pinching && d > f + _ ? (u.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !u.inputState.pinching && d <= f - _ && (u.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                c !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i),
                s !== null && (c.matrix.fromArray(s.transform.matrix),
                c.matrix.decompose(c.position, c.rotation, c.scale),
                c.matrixWorldNeedsUpdate = !0,
                s.linearVelocity ? (c.hasLinearVelocity = !0,
                c.linearVelocity.copy(s.linearVelocity)) : c.hasLinearVelocity = !1,
                s.angularVelocity ? (c.hasAngularVelocity = !0,
                c.angularVelocity.copy(s.angularVelocity)) : c.hasAngularVelocity = !1));
            a !== null && (r = t.getPose(e.targetRaySpace, i),
            r === null && s !== null && (r = s),
            r !== null && (a.matrix.fromArray(r.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            a.matrixWorldNeedsUpdate = !0,
            r.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1,
            r.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(_G)))
        }
        return a !== null && (a.visible = r !== null),
        c !== null && (c.visible = s !== null),
        u !== null && (u.visible = o !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const i = new pf;
            i.matrixAutoUpdate = !1,
            i.visible = !1,
            e.joints[t.jointName] = i,
            e.add(i)
        }
        return e.joints[t.jointName]
    }
}
class vG extends Qc {
    constructor(e, t) {
        super();
        const i = this;
        let r = null
          , s = 1
          , o = null
          , a = "local-floor"
          , c = 1
          , u = null
          , h = null
          , m = null
          , d = null
          , f = null
          , _ = null;
        const g = t.getContextAttributes();
        let v = null
          , y = null;
        const w = []
          , S = []
          , E = new on;
        let b = null;
        const T = new ps;
        T.layers.enable(1),
        T.viewport = new Pi;
        const C = new ps;
        C.layers.enable(2),
        C.viewport = new Pi;
        const P = [T, C]
          , A = new gG;
        A.layers.enable(1),
        A.layers.enable(2);
        let R = null
          , I = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(ne) {
            let fe = w[ne];
            return fe === void 0 && (fe = new w0,
            w[ne] = fe),
            fe.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(ne) {
            let fe = w[ne];
            return fe === void 0 && (fe = new w0,
            w[ne] = fe),
            fe.getGripSpace()
        }
        ,
        this.getHand = function(ne) {
            let fe = w[ne];
            return fe === void 0 && (fe = new w0,
            w[ne] = fe),
            fe.getHandSpace()
        }
        ;
        function D(ne) {
            const fe = S.indexOf(ne.inputSource);
            if (fe === -1)
                return;
            const xe = w[fe];
            xe !== void 0 && (xe.update(ne.inputSource, ne.frame, u || o),
            xe.dispatchEvent({
                type: ne.type,
                data: ne.inputSource
            }))
        }
        function H() {
            r.removeEventListener("select", D),
            r.removeEventListener("selectstart", D),
            r.removeEventListener("selectend", D),
            r.removeEventListener("squeeze", D),
            r.removeEventListener("squeezestart", D),
            r.removeEventListener("squeezeend", D),
            r.removeEventListener("end", H),
            r.removeEventListener("inputsourceschange", B);
            for (let ne = 0; ne < w.length; ne++) {
                const fe = S[ne];
                fe !== null && (S[ne] = null,
                w[ne].disconnect(fe))
            }
            R = null,
            I = null,
            e.setRenderTarget(v),
            f = null,
            d = null,
            m = null,
            r = null,
            y = null,
            ae.stop(),
            i.isPresenting = !1,
            e.setPixelRatio(b),
            e.setSize(E.width, E.height, !1),
            i.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(ne) {
            s = ne,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(ne) {
            a = ne,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return u || o
        }
        ,
        this.setReferenceSpace = function(ne) {
            u = ne
        }
        ,
        this.getBaseLayer = function() {
            return d !== null ? d : f
        }
        ,
        this.getBinding = function() {
            return m
        }
        ,
        this.getFrame = function() {
            return _
        }
        ,
        this.getSession = function() {
            return r
        }
        ,
        this.setSession = async function(ne) {
            if (r = ne,
            r !== null) {
                if (v = e.getRenderTarget(),
                r.addEventListener("select", D),
                r.addEventListener("selectstart", D),
                r.addEventListener("selectend", D),
                r.addEventListener("squeeze", D),
                r.addEventListener("squeezestart", D),
                r.addEventListener("squeezeend", D),
                r.addEventListener("end", H),
                r.addEventListener("inputsourceschange", B),
                g.xrCompatible !== !0 && await t.makeXRCompatible(),
                b = e.getPixelRatio(),
                e.getSize(E),
                r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                    const fe = {
                        antialias: r.renderState.layers === void 0 ? g.antialias : !0,
                        alpha: !0,
                        depth: g.depth,
                        stencil: g.stencil,
                        framebufferScaleFactor: s
                    };
                    f = new XRWebGLLayer(r,t,fe),
                    r.updateRenderState({
                        baseLayer: f
                    }),
                    e.setPixelRatio(1),
                    e.setSize(f.framebufferWidth, f.framebufferHeight, !1),
                    y = new Ll(f.framebufferWidth,f.framebufferHeight,{
                        format: Ns,
                        type: ba,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: g.stencil
                    })
                } else {
                    let fe = null
                      , xe = null
                      , Re = null;
                    g.depth && (Re = g.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                    fe = g.stencil ? Yc : Sl,
                    xe = g.stencil ? bl : da);
                    const Ue = {
                        colorFormat: t.RGBA8,
                        depthFormat: Re,
                        scaleFactor: s
                    };
                    m = new XRWebGLBinding(r,t),
                    d = m.createProjectionLayer(Ue),
                    r.updateRenderState({
                        layers: [d]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(d.textureWidth, d.textureHeight, !1),
                    y = new Ll(d.textureWidth,d.textureHeight,{
                        format: Ns,
                        type: ba,
                        depthTexture: new vR(d.textureWidth,d.textureHeight,xe,void 0,void 0,void 0,void 0,void 0,void 0,fe),
                        stencilBuffer: g.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: g.antialias ? 4 : 0
                    });
                    const He = e.properties.get(y);
                    He.__ignoreDepthValues = d.ignoreDepthValues
                }
                y.isXRRenderTarget = !0,
                this.setFoveation(c),
                u = null,
                o = await r.requestReferenceSpace(a),
                ae.setContext(r),
                ae.start(),
                i.isPresenting = !0,
                i.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (r !== null)
                return r.environmentBlendMode
        }
        ;
        function B(ne) {
            for (let fe = 0; fe < ne.removed.length; fe++) {
                const xe = ne.removed[fe]
                  , Re = S.indexOf(xe);
                Re >= 0 && (S[Re] = null,
                w[Re].disconnect(xe))
            }
            for (let fe = 0; fe < ne.added.length; fe++) {
                const xe = ne.added[fe];
                let Re = S.indexOf(xe);
                if (Re === -1) {
                    for (let He = 0; He < w.length; He++)
                        if (He >= S.length) {
                            S.push(xe),
                            Re = He;
                            break
                        } else if (S[He] === null) {
                            S[He] = xe,
                            Re = He;
                            break
                        }
                    if (Re === -1)
                        break
                }
                const Ue = w[Re];
                Ue && Ue.connect(xe)
            }
        }
        const G = new pe
          , X = new pe;
        function V(ne, fe, xe) {
            G.setFromMatrixPosition(fe.matrixWorld),
            X.setFromMatrixPosition(xe.matrixWorld);
            const Re = G.distanceTo(X)
              , Ue = fe.projectionMatrix.elements
              , He = xe.projectionMatrix.elements
              , qe = Ue[14] / (Ue[10] - 1)
              , Xe = Ue[14] / (Ue[10] + 1)
              , st = (Ue[9] + 1) / Ue[5]
              , ie = (Ue[9] - 1) / Ue[5]
              , dt = (Ue[8] - 1) / Ue[0]
              , Ne = (He[8] + 1) / He[0]
              , Ye = qe * dt
              , Qe = qe * Ne
              , te = Re / (-dt + Ne)
              , ot = te * -dt;
            fe.matrixWorld.decompose(ne.position, ne.quaternion, ne.scale),
            ne.translateX(ot),
            ne.translateZ(te),
            ne.matrixWorld.compose(ne.position, ne.quaternion, ne.scale),
            ne.matrixWorldInverse.copy(ne.matrixWorld).invert();
            const ft = qe + te
              , Tt = Xe + te
              , pt = Ye - ot
              , Ct = Qe + (Re - ot)
              , z = st * Xe / Tt * ft
              , N = ie * Xe / Tt * ft;
            ne.projectionMatrix.makePerspective(pt, Ct, z, N, ft, Tt),
            ne.projectionMatrixInverse.copy(ne.projectionMatrix).invert()
        }
        function ee(ne, fe) {
            fe === null ? ne.matrixWorld.copy(ne.matrix) : ne.matrixWorld.multiplyMatrices(fe.matrixWorld, ne.matrix),
            ne.matrixWorldInverse.copy(ne.matrixWorld).invert()
        }
        this.updateCamera = function(ne) {
            if (r === null)
                return;
            A.near = C.near = T.near = ne.near,
            A.far = C.far = T.far = ne.far,
            (R !== A.near || I !== A.far) && (r.updateRenderState({
                depthNear: A.near,
                depthFar: A.far
            }),
            R = A.near,
            I = A.far);
            const fe = ne.parent
              , xe = A.cameras;
            ee(A, fe);
            for (let Re = 0; Re < xe.length; Re++)
                ee(xe[Re], fe);
            xe.length === 2 ? V(A, T, C) : A.projectionMatrix.copy(T.projectionMatrix),
            re(ne, A, fe)
        }
        ;
        function re(ne, fe, xe) {
            xe === null ? ne.matrix.copy(fe.matrixWorld) : (ne.matrix.copy(xe.matrixWorld),
            ne.matrix.invert(),
            ne.matrix.multiply(fe.matrixWorld)),
            ne.matrix.decompose(ne.position, ne.quaternion, ne.scale),
            ne.updateMatrixWorld(!0),
            ne.projectionMatrix.copy(fe.projectionMatrix),
            ne.projectionMatrixInverse.copy(fe.projectionMatrixInverse),
            ne.isPerspectiveCamera && (ne.fov = fv * 2 * Math.atan(1 / ne.projectionMatrix.elements[5]),
            ne.zoom = 1)
        }
        this.getCamera = function() {
            return A
        }
        ,
        this.getFoveation = function() {
            if (!(d === null && f === null))
                return c
        }
        ,
        this.setFoveation = function(ne) {
            c = ne,
            d !== null && (d.fixedFoveation = ne),
            f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = ne)
        }
        ;
        let k = null;
        function oe(ne, fe) {
            if (h = fe.getViewerPose(u || o),
            _ = fe,
            h !== null) {
                const xe = h.views;
                f !== null && (e.setRenderTargetFramebuffer(y, f.framebuffer),
                e.setRenderTarget(y));
                let Re = !1;
                xe.length !== A.cameras.length && (A.cameras.length = 0,
                Re = !0);
                for (let Ue = 0; Ue < xe.length; Ue++) {
                    const He = xe[Ue];
                    let qe = null;
                    if (f !== null)
                        qe = f.getViewport(He);
                    else {
                        const st = m.getViewSubImage(d, He);
                        qe = st.viewport,
                        Ue === 0 && (e.setRenderTargetTextures(y, st.colorTexture, d.ignoreDepthValues ? void 0 : st.depthStencilTexture),
                        e.setRenderTarget(y))
                    }
                    let Xe = P[Ue];
                    Xe === void 0 && (Xe = new ps,
                    Xe.layers.enable(Ue),
                    Xe.viewport = new Pi,
                    P[Ue] = Xe),
                    Xe.matrix.fromArray(He.transform.matrix),
                    Xe.matrix.decompose(Xe.position, Xe.quaternion, Xe.scale),
                    Xe.projectionMatrix.fromArray(He.projectionMatrix),
                    Xe.projectionMatrixInverse.copy(Xe.projectionMatrix).invert(),
                    Xe.viewport.set(qe.x, qe.y, qe.width, qe.height),
                    Ue === 0 && (A.matrix.copy(Xe.matrix),
                    A.matrix.decompose(A.position, A.quaternion, A.scale)),
                    Re === !0 && A.cameras.push(Xe)
                }
            }
            for (let xe = 0; xe < w.length; xe++) {
                const Re = S[xe]
                  , Ue = w[xe];
                Re !== null && Ue !== void 0 && Ue.update(Re, fe, u || o)
            }
            k && k(ne, fe),
            fe.detectedPlanes && i.dispatchEvent({
                type: "planesdetected",
                data: fe
            }),
            _ = null
        }
        const ae = new _R;
        ae.setAnimationLoop(oe),
        this.setAnimationLoop = function(ne) {
            k = ne
        }
        ,
        this.dispose = function() {}
    }
}
function yG(n, e) {
    function t(v, y) {
        v.matrixAutoUpdate === !0 && v.updateMatrix(),
        y.value.copy(v.matrix)
    }
    function i(v, y) {
        y.color.getRGB(v.fogColor.value, dR(n)),
        y.isFog ? (v.fogNear.value = y.near,
        v.fogFar.value = y.far) : y.isFogExp2 && (v.fogDensity.value = y.density)
    }
    function r(v, y, w, S, E) {
        y.isMeshBasicMaterial || y.isMeshLambertMaterial ? s(v, y) : y.isMeshToonMaterial ? (s(v, y),
        m(v, y)) : y.isMeshPhongMaterial ? (s(v, y),
        h(v, y)) : y.isMeshStandardMaterial ? (s(v, y),
        d(v, y),
        y.isMeshPhysicalMaterial && f(v, y, E)) : y.isMeshMatcapMaterial ? (s(v, y),
        _(v, y)) : y.isMeshDepthMaterial ? s(v, y) : y.isMeshDistanceMaterial ? (s(v, y),
        g(v, y)) : y.isMeshNormalMaterial ? s(v, y) : y.isLineBasicMaterial ? (o(v, y),
        y.isLineDashedMaterial && a(v, y)) : y.isPointsMaterial ? c(v, y, w, S) : y.isSpriteMaterial ? u(v, y) : y.isShadowMaterial ? (v.color.value.copy(y.color),
        v.opacity.value = y.opacity) : y.isShaderMaterial && (y.uniformsNeedUpdate = !1)
    }
    function s(v, y) {
        v.opacity.value = y.opacity,
        y.color && v.diffuse.value.copy(y.color),
        y.emissive && v.emissive.value.copy(y.emissive).multiplyScalar(y.emissiveIntensity),
        y.map && (v.map.value = y.map,
        t(y.map, v.mapTransform)),
        y.alphaMap && (v.alphaMap.value = y.alphaMap,
        t(y.alphaMap, v.alphaMapTransform)),
        y.bumpMap && (v.bumpMap.value = y.bumpMap,
        t(y.bumpMap, v.bumpMapTransform),
        v.bumpScale.value = y.bumpScale,
        y.side === Lr && (v.bumpScale.value *= -1)),
        y.normalMap && (v.normalMap.value = y.normalMap,
        t(y.normalMap, v.normalMapTransform),
        v.normalScale.value.copy(y.normalScale),
        y.side === Lr && v.normalScale.value.negate()),
        y.displacementMap && (v.displacementMap.value = y.displacementMap,
        t(y.displacementMap, v.displacementMapTransform),
        v.displacementScale.value = y.displacementScale,
        v.displacementBias.value = y.displacementBias),
        y.emissiveMap && (v.emissiveMap.value = y.emissiveMap,
        t(y.emissiveMap, v.emissiveMapTransform)),
        y.specularMap && (v.specularMap.value = y.specularMap,
        t(y.specularMap, v.specularMapTransform)),
        y.alphaTest > 0 && (v.alphaTest.value = y.alphaTest);
        const w = e.get(y).envMap;
        if (w && (v.envMap.value = w,
        v.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1,
        v.reflectivity.value = y.reflectivity,
        v.ior.value = y.ior,
        v.refractionRatio.value = y.refractionRatio),
        y.lightMap) {
            v.lightMap.value = y.lightMap;
            const S = n._useLegacyLights === !0 ? Math.PI : 1;
            v.lightMapIntensity.value = y.lightMapIntensity * S,
            t(y.lightMap, v.lightMapTransform)
        }
        y.aoMap && (v.aoMap.value = y.aoMap,
        v.aoMapIntensity.value = y.aoMapIntensity,
        t(y.aoMap, v.aoMapTransform))
    }
    function o(v, y) {
        v.diffuse.value.copy(y.color),
        v.opacity.value = y.opacity,
        y.map && (v.map.value = y.map,
        t(y.map, v.mapTransform))
    }
    function a(v, y) {
        v.dashSize.value = y.dashSize,
        v.totalSize.value = y.dashSize + y.gapSize,
        v.scale.value = y.scale
    }
    function c(v, y, w, S) {
        v.diffuse.value.copy(y.color),
        v.opacity.value = y.opacity,
        v.size.value = y.size * w,
        v.scale.value = S * .5,
        y.map && (v.map.value = y.map,
        t(y.map, v.uvTransform)),
        y.alphaMap && (v.alphaMap.value = y.alphaMap,
        t(y.alphaMap, v.alphaMapTransform)),
        y.alphaTest > 0 && (v.alphaTest.value = y.alphaTest)
    }
    function u(v, y) {
        v.diffuse.value.copy(y.color),
        v.opacity.value = y.opacity,
        v.rotation.value = y.rotation,
        y.map && (v.map.value = y.map,
        t(y.map, v.mapTransform)),
        y.alphaMap && (v.alphaMap.value = y.alphaMap,
        t(y.alphaMap, v.alphaMapTransform)),
        y.alphaTest > 0 && (v.alphaTest.value = y.alphaTest)
    }
    function h(v, y) {
        v.specular.value.copy(y.specular),
        v.shininess.value = Math.max(y.shininess, 1e-4)
    }
    function m(v, y) {
        y.gradientMap && (v.gradientMap.value = y.gradientMap)
    }
    function d(v, y) {
        v.metalness.value = y.metalness,
        y.metalnessMap && (v.metalnessMap.value = y.metalnessMap,
        t(y.metalnessMap, v.metalnessMapTransform)),
        v.roughness.value = y.roughness,
        y.roughnessMap && (v.roughnessMap.value = y.roughnessMap,
        t(y.roughnessMap, v.roughnessMapTransform)),
        e.get(y).envMap && (v.envMapIntensity.value = y.envMapIntensity)
    }
    function f(v, y, w) {
        v.ior.value = y.ior,
        y.sheen > 0 && (v.sheenColor.value.copy(y.sheenColor).multiplyScalar(y.sheen),
        v.sheenRoughness.value = y.sheenRoughness,
        y.sheenColorMap && (v.sheenColorMap.value = y.sheenColorMap,
        t(y.sheenColorMap, v.sheenColorMapTransform)),
        y.sheenRoughnessMap && (v.sheenRoughnessMap.value = y.sheenRoughnessMap,
        t(y.sheenRoughnessMap, v.sheenRoughnessMapTransform))),
        y.clearcoat > 0 && (v.clearcoat.value = y.clearcoat,
        v.clearcoatRoughness.value = y.clearcoatRoughness,
        y.clearcoatMap && (v.clearcoatMap.value = y.clearcoatMap,
        t(y.clearcoatMap, v.clearcoatMapTransform)),
        y.clearcoatRoughnessMap && (v.clearcoatRoughnessMap.value = y.clearcoatRoughnessMap,
        t(y.clearcoatRoughnessMap, v.clearcoatRoughnessMapTransform)),
        y.clearcoatNormalMap && (v.clearcoatNormalMap.value = y.clearcoatNormalMap,
        t(y.clearcoatNormalMap, v.clearcoatNormalMapTransform),
        v.clearcoatNormalScale.value.copy(y.clearcoatNormalScale),
        y.side === Lr && v.clearcoatNormalScale.value.negate())),
        y.iridescence > 0 && (v.iridescence.value = y.iridescence,
        v.iridescenceIOR.value = y.iridescenceIOR,
        v.iridescenceThicknessMinimum.value = y.iridescenceThicknessRange[0],
        v.iridescenceThicknessMaximum.value = y.iridescenceThicknessRange[1],
        y.iridescenceMap && (v.iridescenceMap.value = y.iridescenceMap,
        t(y.iridescenceMap, v.iridescenceMapTransform)),
        y.iridescenceThicknessMap && (v.iridescenceThicknessMap.value = y.iridescenceThicknessMap,
        t(y.iridescenceThicknessMap, v.iridescenceThicknessMapTransform))),
        y.transmission > 0 && (v.transmission.value = y.transmission,
        v.transmissionSamplerMap.value = w.texture,
        v.transmissionSamplerSize.value.set(w.width, w.height),
        y.transmissionMap && (v.transmissionMap.value = y.transmissionMap,
        t(y.transmissionMap, v.transmissionMapTransform)),
        v.thickness.value = y.thickness,
        y.thicknessMap && (v.thicknessMap.value = y.thicknessMap,
        t(y.thicknessMap, v.thicknessMapTransform)),
        v.attenuationDistance.value = y.attenuationDistance,
        v.attenuationColor.value.copy(y.attenuationColor)),
        y.anisotropy > 0 && (v.anisotropyVector.value.set(y.anisotropy * Math.cos(y.anisotropyRotation), y.anisotropy * Math.sin(y.anisotropyRotation)),
        y.anisotropyMap && (v.anisotropyMap.value = y.anisotropyMap,
        t(y.anisotropyMap, v.anisotropyMapTransform))),
        v.specularIntensity.value = y.specularIntensity,
        v.specularColor.value.copy(y.specularColor),
        y.specularColorMap && (v.specularColorMap.value = y.specularColorMap,
        t(y.specularColorMap, v.specularColorMapTransform)),
        y.specularIntensityMap && (v.specularIntensityMap.value = y.specularIntensityMap,
        t(y.specularIntensityMap, v.specularIntensityMapTransform))
    }
    function _(v, y) {
        y.matcap && (v.matcap.value = y.matcap)
    }
    function g(v, y) {
        const w = e.get(y).light;
        v.referencePosition.value.setFromMatrixPosition(w.matrixWorld),
        v.nearDistance.value = w.shadow.camera.near,
        v.farDistance.value = w.shadow.camera.far
    }
    return {
        refreshFogUniforms: i,
        refreshMaterialUniforms: r
    }
}
function xG(n, e, t, i) {
    let r = {}
      , s = {}
      , o = [];
    const a = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
    function c(w, S) {
        const E = S.program;
        i.uniformBlockBinding(w, E)
    }
    function u(w, S) {
        let E = r[w.id];
        E === void 0 && (_(w),
        E = h(w),
        r[w.id] = E,
        w.addEventListener("dispose", v));
        const b = S.program;
        i.updateUBOMapping(w, b);
        const T = e.render.frame;
        s[w.id] !== T && (d(w),
        s[w.id] = T)
    }
    function h(w) {
        const S = m();
        w.__bindingPointIndex = S;
        const E = n.createBuffer()
          , b = w.__size
          , T = w.usage;
        return n.bindBuffer(n.UNIFORM_BUFFER, E),
        n.bufferData(n.UNIFORM_BUFFER, b, T),
        n.bindBuffer(n.UNIFORM_BUFFER, null),
        n.bindBufferBase(n.UNIFORM_BUFFER, S, E),
        E
    }
    function m() {
        for (let w = 0; w < a; w++)
            if (o.indexOf(w) === -1)
                return o.push(w),
                w;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function d(w) {
        const S = r[w.id]
          , E = w.uniforms
          , b = w.__cache;
        n.bindBuffer(n.UNIFORM_BUFFER, S);
        for (let T = 0, C = E.length; T < C; T++) {
            const P = E[T];
            if (f(P, T, b) === !0) {
                const A = P.__offset
                  , R = Array.isArray(P.value) ? P.value : [P.value];
                let I = 0;
                for (let D = 0; D < R.length; D++) {
                    const H = R[D]
                      , B = g(H);
                    typeof H == "number" ? (P.__data[0] = H,
                    n.bufferSubData(n.UNIFORM_BUFFER, A + I, P.__data)) : H.isMatrix3 ? (P.__data[0] = H.elements[0],
                    P.__data[1] = H.elements[1],
                    P.__data[2] = H.elements[2],
                    P.__data[3] = H.elements[0],
                    P.__data[4] = H.elements[3],
                    P.__data[5] = H.elements[4],
                    P.__data[6] = H.elements[5],
                    P.__data[7] = H.elements[0],
                    P.__data[8] = H.elements[6],
                    P.__data[9] = H.elements[7],
                    P.__data[10] = H.elements[8],
                    P.__data[11] = H.elements[0]) : (H.toArray(P.__data, I),
                    I += B.storage / Float32Array.BYTES_PER_ELEMENT)
                }
                n.bufferSubData(n.UNIFORM_BUFFER, A, P.__data)
            }
        }
        n.bindBuffer(n.UNIFORM_BUFFER, null)
    }
    function f(w, S, E) {
        const b = w.value;
        if (E[S] === void 0) {
            if (typeof b == "number")
                E[S] = b;
            else {
                const T = Array.isArray(b) ? b : [b]
                  , C = [];
                for (let P = 0; P < T.length; P++)
                    C.push(T[P].clone());
                E[S] = C
            }
            return !0
        } else if (typeof b == "number") {
            if (E[S] !== b)
                return E[S] = b,
                !0
        } else {
            const T = Array.isArray(E[S]) ? E[S] : [E[S]]
              , C = Array.isArray(b) ? b : [b];
            for (let P = 0; P < T.length; P++) {
                const A = T[P];
                if (A.equals(C[P]) === !1)
                    return A.copy(C[P]),
                    !0
            }
        }
        return !1
    }
    function _(w) {
        const S = w.uniforms;
        let E = 0;
        const b = 16;
        let T = 0;
        for (let C = 0, P = S.length; C < P; C++) {
            const A = S[C]
              , R = {
                boundary: 0,
                storage: 0
            }
              , I = Array.isArray(A.value) ? A.value : [A.value];
            for (let D = 0, H = I.length; D < H; D++) {
                const B = I[D]
                  , G = g(B);
                R.boundary += G.boundary,
                R.storage += G.storage
            }
            if (A.__data = new Float32Array(R.storage / Float32Array.BYTES_PER_ELEMENT),
            A.__offset = E,
            C > 0) {
                T = E % b;
                const D = b - T;
                T !== 0 && D - R.boundary < 0 && (E += b - T,
                A.__offset = E)
            }
            E += R.storage
        }
        return T = E % b,
        T > 0 && (E += b - T),
        w.__size = E,
        w.__cache = {},
        this
    }
    function g(w) {
        const S = {
            boundary: 0,
            storage: 0
        };
        return typeof w == "number" ? (S.boundary = 4,
        S.storage = 4) : w.isVector2 ? (S.boundary = 8,
        S.storage = 8) : w.isVector3 || w.isColor ? (S.boundary = 16,
        S.storage = 12) : w.isVector4 ? (S.boundary = 16,
        S.storage = 16) : w.isMatrix3 ? (S.boundary = 48,
        S.storage = 48) : w.isMatrix4 ? (S.boundary = 64,
        S.storage = 64) : w.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", w),
        S
    }
    function v(w) {
        const S = w.target;
        S.removeEventListener("dispose", v);
        const E = o.indexOf(S.__bindingPointIndex);
        o.splice(E, 1),
        n.deleteBuffer(r[S.id]),
        delete r[S.id],
        delete s[S.id]
    }
    function y() {
        for (const w in r)
            n.deleteBuffer(r[w]);
        o = [],
        r = {},
        s = {}
    }
    return {
        bind: c,
        update: u,
        dispose: y
    }
}
class ER {
    constructor(e={}) {
        const {canvas: t=m4(), context: i=null, depth: r=!0, stencil: s=!0, alpha: o=!1, antialias: a=!1, premultipliedAlpha: c=!0, preserveDrawingBuffer: u=!1, powerPreference: h="default", failIfMajorPerformanceCaveat: m=!1} = e;
        this.isWebGLRenderer = !0;
        let d;
        i !== null ? d = i.getContextAttributes().alpha : d = o;
        const f = new Uint32Array(4)
          , _ = new Int32Array(4);
        let g = null
          , v = null;
        const y = []
          , w = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this._outputColorSpace = Ci,
        this._useLegacyLights = !1,
        this.toneMapping = xa,
        this.toneMappingExposure = 1;
        const S = this;
        let E = !1
          , b = 0
          , T = 0
          , C = null
          , P = -1
          , A = null;
        const R = new Pi
          , I = new Pi;
        let D = null;
        const H = new mn(0);
        let B = 0
          , G = t.width
          , X = t.height
          , V = 1
          , ee = null
          , re = null;
        const k = new Pi(0,0,G,X)
          , oe = new Pi(0,0,G,X);
        let ae = !1;
        const ne = new gR;
        let fe = !1
          , xe = !1
          , Re = null;
        const Ue = new Li
          , He = new on
          , qe = new pe
          , Xe = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        function st() {
            return C === null ? V : 1
        }
        let ie = i;
        function dt(F, J) {
            for (let ce = 0; ce < F.length; ce++) {
                const ue = F[ce]
                  , se = t.getContext(ue, J);
                if (se !== null)
                    return se
            }
            return null
        }
        try {
            const F = {
                alpha: !0,
                depth: r,
                stencil: s,
                antialias: a,
                premultipliedAlpha: c,
                preserveDrawingBuffer: u,
                powerPreference: h,
                failIfMajorPerformanceCaveat: m
            };
            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${Dy}`),
            t.addEventListener("webglcontextlost", Lt, !1),
            t.addEventListener("webglcontextrestored", Y, !1),
            t.addEventListener("webglcontextcreationerror", ze, !1),
            ie === null) {
                const J = ["webgl2", "webgl", "experimental-webgl"];
                if (S.isWebGL1Renderer === !0 && J.shift(),
                ie = dt(J, F),
                ie === null)
                    throw dt(J) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
            typeof WebGLRenderingContext < "u" && ie instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),
            ie.getShaderPrecisionFormat === void 0 && (ie.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (F) {
            throw console.error("THREE.WebGLRenderer: " + F.message),
            F
        }
        let Ne, Ye, Qe, te, ot, ft, Tt, pt, Ct, z, N, j, he, le, me, We, Te, Ee, Ae, _t, Pe, Bt, vt, ht;
        function at() {
            Ne = new LH(ie),
            Ye = new EH(ie,Ne,e),
            Ne.init(Ye),
            Bt = new mG(ie,Ne,Ye),
            Qe = new dG(ie,Ne,Ye),
            te = new OH(ie),
            ot = new Q6,
            ft = new pG(ie,Ne,Qe,ot,Ye,Bt,te),
            Tt = new MH(S),
            pt = new PH(S),
            Ct = new H4(ie,Ye),
            vt = new SH(ie,Ne,Ct,Ye),
            z = new DH(ie,Ct,te,vt),
            N = new BH(ie,z,Ct,te),
            Ae = new FH(ie,Ye,ft),
            We = new AH(ot),
            j = new J6(S,Tt,pt,Ne,Ye,vt,We),
            he = new yG(S,ot),
            le = new tG,
            me = new aG(Ne,Ye),
            Ee = new bH(S,Tt,pt,Qe,N,d,c),
            Te = new hG(S,N,Ye),
            ht = new xG(ie,te,Ye,Qe),
            _t = new wH(ie,Ne,te,Ye),
            Pe = new IH(ie,Ne,te,Ye),
            te.programs = j.programs,
            S.capabilities = Ye,
            S.extensions = Ne,
            S.properties = ot,
            S.renderLists = le,
            S.shadowMap = Te,
            S.state = Qe,
            S.info = te
        }
        at();
        const Le = new vG(S,ie);
        this.xr = Le,
        this.getContext = function() {
            return ie
        }
        ,
        this.getContextAttributes = function() {
            return ie.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const F = Ne.get("WEBGL_lose_context");
            F && F.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const F = Ne.get("WEBGL_lose_context");
            F && F.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return V
        }
        ,
        this.setPixelRatio = function(F) {
            F !== void 0 && (V = F,
            this.setSize(G, X, !1))
        }
        ,
        this.getSize = function(F) {
            return F.set(G, X)
        }
        ,
        this.setSize = function(F, J, ce=!0) {
            if (Le.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            G = F,
            X = J,
            t.width = Math.floor(F * V),
            t.height = Math.floor(J * V),
            ce === !0 && (t.style.width = F + "px",
            t.style.height = J + "px"),
            this.setViewport(0, 0, F, J)
        }
        ,
        this.getDrawingBufferSize = function(F) {
            return F.set(G * V, X * V).floor()
        }
        ,
        this.setDrawingBufferSize = function(F, J, ce) {
            G = F,
            X = J,
            V = ce,
            t.width = Math.floor(F * ce),
            t.height = Math.floor(J * ce),
            this.setViewport(0, 0, F, J)
        }
        ,
        this.getCurrentViewport = function(F) {
            return F.copy(R)
        }
        ,
        this.getViewport = function(F) {
            return F.copy(k)
        }
        ,
        this.setViewport = function(F, J, ce, ue) {
            F.isVector4 ? k.set(F.x, F.y, F.z, F.w) : k.set(F, J, ce, ue),
            Qe.viewport(R.copy(k).multiplyScalar(V).floor())
        }
        ,
        this.getScissor = function(F) {
            return F.copy(oe)
        }
        ,
        this.setScissor = function(F, J, ce, ue) {
            F.isVector4 ? oe.set(F.x, F.y, F.z, F.w) : oe.set(F, J, ce, ue),
            Qe.scissor(I.copy(oe).multiplyScalar(V).floor())
        }
        ,
        this.getScissorTest = function() {
            return ae
        }
        ,
        this.setScissorTest = function(F) {
            Qe.setScissorTest(ae = F)
        }
        ,
        this.setOpaqueSort = function(F) {
            ee = F
        }
        ,
        this.setTransparentSort = function(F) {
            re = F
        }
        ,
        this.getClearColor = function(F) {
            return F.copy(Ee.getClearColor())
        }
        ,
        this.setClearColor = function() {
            Ee.setClearColor.apply(Ee, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return Ee.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            Ee.setClearAlpha.apply(Ee, arguments)
        }
        ,
        this.clear = function(F=!0, J=!0, ce=!0) {
            let ue = 0;
            if (F) {
                let se = !1;
                if (C !== null) {
                    const ke = C.texture.format;
                    se = ke === eR || ke === QC || ke === JC
                }
                if (se) {
                    const ke = C.texture.type
                      , et = ke === ba || ke === da || ke === Iy || ke === bl || ke === KC || ke === ZC
                      , mt = Ee.getClearColor()
                      , tt = Ee.getClearAlpha()
                      , lt = mt.r
                      , gt = mt.g
                      , Pt = mt.b;
                    et ? (f[0] = lt,
                    f[1] = gt,
                    f[2] = Pt,
                    f[3] = tt,
                    ie.clearBufferuiv(ie.COLOR, 0, f)) : (_[0] = lt,
                    _[1] = gt,
                    _[2] = Pt,
                    _[3] = tt,
                    ie.clearBufferiv(ie.COLOR, 0, _))
                } else
                    ue |= ie.COLOR_BUFFER_BIT
            }
            J && (ue |= ie.DEPTH_BUFFER_BIT),
            ce && (ue |= ie.STENCIL_BUFFER_BIT,
            this.state.buffers.stencil.setMask(4294967295)),
            ie.clear(ue)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", Lt, !1),
            t.removeEventListener("webglcontextrestored", Y, !1),
            t.removeEventListener("webglcontextcreationerror", ze, !1),
            le.dispose(),
            me.dispose(),
            ot.dispose(),
            Tt.dispose(),
            pt.dispose(),
            N.dispose(),
            vt.dispose(),
            ht.dispose(),
            j.dispose(),
            Le.dispose(),
            Le.removeEventListener("sessionstart", Et),
            Le.removeEventListener("sessionend", At),
            Re && (Re.dispose(),
            Re = null),
            Be.stop()
        }
        ;
        function Lt(F) {
            F.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            E = !0
        }
        function Y() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            E = !1;
            const F = te.autoReset
              , J = Te.enabled
              , ce = Te.autoUpdate
              , ue = Te.needsUpdate
              , se = Te.type;
            at(),
            te.autoReset = F,
            Te.enabled = J,
            Te.autoUpdate = ce,
            Te.needsUpdate = ue,
            Te.type = se
        }
        function ze(F) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", F.statusMessage)
        }
        function De(F) {
            const J = F.target;
            J.removeEventListener("dispose", De),
            ge(J)
        }
        function ge(F) {
            Fe(F),
            ot.remove(F)
        }
        function Fe(F) {
            const J = ot.get(F).programs;
            J !== void 0 && (J.forEach(function(ce) {
                j.releaseProgram(ce)
            }),
            F.isShaderMaterial && j.releaseShaderCache(F))
        }
        this.renderBufferDirect = function(F, J, ce, ue, se, ke) {
            J === null && (J = Xe);
            const et = se.isMesh && se.matrixWorld.determinant() < 0
              , mt = _n(F, J, ce, ue, se);
            Qe.setMaterial(ue, et);
            let tt = ce.index
              , lt = 1;
            if (ue.wireframe === !0) {
                if (tt = z.getWireframeAttribute(ce),
                tt === void 0)
                    return;
                lt = 2
            }
            const gt = ce.drawRange
              , Pt = ce.attributes.position;
            let vn = gt.start * lt
              , zn = (gt.start + gt.count) * lt;
            ke !== null && (vn = Math.max(vn, ke.start * lt),
            zn = Math.min(zn, (ke.start + ke.count) * lt)),
            tt !== null ? (vn = Math.max(vn, 0),
            zn = Math.min(zn, tt.count)) : Pt != null && (vn = Math.max(vn, 0),
            zn = Math.min(zn, Pt.count));
            const an = zn - vn;
            if (an < 0 || an === 1 / 0)
                return;
            vt.setup(se, ue, mt, ce, tt);
            let Ei, un = _t;
            if (tt !== null && (Ei = Ct.get(tt),
            un = Pe,
            un.setIndex(Ei)),
            se.isMesh)
                ue.wireframe === !0 ? (Qe.setLineWidth(ue.wireframeLinewidth * st()),
                un.setMode(ie.LINES)) : un.setMode(ie.TRIANGLES);
            else if (se.isLine) {
                let Dt = ue.linewidth;
                Dt === void 0 && (Dt = 1),
                Qe.setLineWidth(Dt * st()),
                se.isLineSegments ? un.setMode(ie.LINES) : se.isLineLoop ? un.setMode(ie.LINE_LOOP) : un.setMode(ie.LINE_STRIP)
            } else
                se.isPoints ? un.setMode(ie.POINTS) : se.isSprite && un.setMode(ie.TRIANGLES);
            if (se.isBatchedMesh)
                un.renderMultiDraw(se._multiDrawStarts, se._multiDrawCounts, se._multiDrawCount);
            else if (se.isInstancedMesh)
                un.renderInstances(vn, an, se.count);
            else if (ce.isInstancedBufferGeometry) {
                const Dt = ce._maxInstanceCount !== void 0 ? ce._maxInstanceCount : 1 / 0
                  , uu = Math.min(ce.instanceCount, Dt);
                un.renderInstances(vn, an, uu)
            } else
                un.render(vn, an)
        }
        ;
        function ut(F, J, ce) {
            F.transparent === !0 && F.side === Co && F.forceSinglePass === !1 ? (F.side = Lr,
            F.needsUpdate = !0,
            dn(F, J, ce),
            F.side = Ma,
            F.needsUpdate = !0,
            dn(F, J, ce),
            F.side = Co) : dn(F, J, ce)
        }
        this.compile = function(F, J, ce=null) {
            ce === null && (ce = F),
            v = me.get(ce),
            v.init(),
            w.push(v),
            ce.traverseVisible(function(se) {
                se.isLight && se.layers.test(J.layers) && (v.pushLight(se),
                se.castShadow && v.pushShadow(se))
            }),
            F !== ce && F.traverseVisible(function(se) {
                se.isLight && se.layers.test(J.layers) && (v.pushLight(se),
                se.castShadow && v.pushShadow(se))
            }),
            v.setupLights(S._useLegacyLights);
            const ue = new Set;
            return F.traverse(function(se) {
                const ke = se.material;
                if (ke)
                    if (Array.isArray(ke))
                        for (let et = 0; et < ke.length; et++) {
                            const mt = ke[et];
                            ut(mt, ce, se),
                            ue.add(mt)
                        }
                    else
                        ut(ke, ce, se),
                        ue.add(ke)
            }),
            w.pop(),
            v = null,
            ue
        }
        ,
        this.compileAsync = function(F, J, ce=null) {
            const ue = this.compile(F, J, ce);
            return new Promise(se=>{
                function ke() {
                    if (ue.forEach(function(et) {
                        ot.get(et).currentProgram.isReady() && ue.delete(et)
                    }),
                    ue.size === 0) {
                        se(F);
                        return
                    }
                    setTimeout(ke, 10)
                }
                Ne.get("KHR_parallel_shader_compile") !== null ? ke() : setTimeout(ke, 10)
            }
            )
        }
        ;
        let Ge = null;
        function je(F) {
            Ge && Ge(F)
        }
        function Et() {
            Be.stop()
        }
        function At() {
            Be.start()
        }
        const Be = new _R;
        Be.setAnimationLoop(je),
        typeof self < "u" && Be.setContext(self),
        this.setAnimationLoop = function(F) {
            Ge = F,
            Le.setAnimationLoop(F),
            F === null ? Be.stop() : Be.start()
        }
        ,
        Le.addEventListener("sessionstart", Et),
        Le.addEventListener("sessionend", At),
        this.render = function(F, J) {
            if (J !== void 0 && J.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (E === !0)
                return;
            F.matrixWorldAutoUpdate === !0 && F.updateMatrixWorld(),
            J.parent === null && J.matrixWorldAutoUpdate === !0 && J.updateMatrixWorld(),
            Le.enabled === !0 && Le.isPresenting === !0 && (Le.cameraAutoUpdate === !0 && Le.updateCamera(J),
            J = Le.getCamera()),
            F.isScene === !0 && F.onBeforeRender(S, F, J, C),
            v = me.get(F, w.length),
            v.init(),
            w.push(v),
            Ue.multiplyMatrices(J.projectionMatrix, J.matrixWorldInverse),
            ne.setFromProjectionMatrix(Ue),
            xe = this.localClippingEnabled,
            fe = We.init(this.clippingPlanes, xe),
            g = le.get(F, y.length),
            g.init(),
            y.push(g),
            bt(F, J, 0, S.sortObjects),
            g.finish(),
            S.sortObjects === !0 && g.sort(ee, re),
            this.info.render.frame++,
            fe === !0 && We.beginShadows();
            const ce = v.state.shadowsArray;
            if (Te.render(ce, F, J),
            fe === !0 && We.endShadows(),
            this.info.autoReset === !0 && this.info.reset(),
            Ee.render(g, F),
            v.setupLights(S._useLegacyLights),
            J.isArrayCamera) {
                const ue = J.cameras;
                for (let se = 0, ke = ue.length; se < ke; se++) {
                    const et = ue[se];
                    yt(g, F, et, et.viewport)
                }
            } else
                yt(g, F, J);
            C !== null && (ft.updateMultisampleRenderTarget(C),
            ft.updateRenderTargetMipmap(C)),
            F.isScene === !0 && F.onAfterRender(S, F, J),
            vt.resetDefaultState(),
            P = -1,
            A = null,
            w.pop(),
            w.length > 0 ? v = w[w.length - 1] : v = null,
            y.pop(),
            y.length > 0 ? g = y[y.length - 1] : g = null
        }
        ;
        function bt(F, J, ce, ue) {
            if (F.visible === !1)
                return;
            if (F.layers.test(J.layers)) {
                if (F.isGroup)
                    ce = F.renderOrder;
                else if (F.isLOD)
                    F.autoUpdate === !0 && F.update(J);
                else if (F.isLight)
                    v.pushLight(F),
                    F.castShadow && v.pushShadow(F);
                else if (F.isSprite) {
                    if (!F.frustumCulled || ne.intersectsSprite(F)) {
                        ue && qe.setFromMatrixPosition(F.matrixWorld).applyMatrix4(Ue);
                        const et = N.update(F)
                          , mt = F.material;
                        mt.visible && g.push(F, et, mt, ce, qe.z, null)
                    }
                } else if ((F.isMesh || F.isLine || F.isPoints) && (!F.frustumCulled || ne.intersectsObject(F))) {
                    const et = N.update(F)
                      , mt = F.material;
                    if (ue && (F.boundingSphere !== void 0 ? (F.boundingSphere === null && F.computeBoundingSphere(),
                    qe.copy(F.boundingSphere.center)) : (et.boundingSphere === null && et.computeBoundingSphere(),
                    qe.copy(et.boundingSphere.center)),
                    qe.applyMatrix4(F.matrixWorld).applyMatrix4(Ue)),
                    Array.isArray(mt)) {
                        const tt = et.groups;
                        for (let lt = 0, gt = tt.length; lt < gt; lt++) {
                            const Pt = tt[lt]
                              , vn = mt[Pt.materialIndex];
                            vn && vn.visible && g.push(F, et, vn, ce, qe.z, Pt)
                        }
                    } else
                        mt.visible && g.push(F, et, mt, ce, qe.z, null)
                }
            }
            const ke = F.children;
            for (let et = 0, mt = ke.length; et < mt; et++)
                bt(ke[et], J, ce, ue)
        }
        function yt(F, J, ce, ue) {
            const se = F.opaque
              , ke = F.transmissive
              , et = F.transparent;
            v.setupLightsView(ce),
            fe === !0 && We.setGlobalState(S.clippingPlanes, ce),
            ke.length > 0 && kt(se, ke, J, ce),
            ue && Qe.viewport(R.copy(ue)),
            se.length > 0 && Mn(se, J, ce),
            ke.length > 0 && Mn(ke, J, ce),
            et.length > 0 && Mn(et, J, ce),
            Qe.buffers.depth.setTest(!0),
            Qe.buffers.depth.setMask(!0),
            Qe.buffers.color.setMask(!0),
            Qe.setPolygonOffset(!1)
        }
        function kt(F, J, ce, ue) {
            if ((ce.isScene === !0 ? ce.overrideMaterial : null) !== null)
                return;
            const ke = Ye.isWebGL2;
            Re === null && (Re = new Ll(1,1,{
                generateMipmaps: !0,
                type: Ne.has("EXT_color_buffer_half_float") ? Gf : ba,
                minFilter: Hf,
                samples: ke ? 4 : 0
            })),
            S.getDrawingBufferSize(He),
            ke ? Re.setSize(He.x, He.y) : Re.setSize(hv(He.x), hv(He.y));
            const et = S.getRenderTarget();
            S.setRenderTarget(Re),
            S.getClearColor(H),
            B = S.getClearAlpha(),
            B < 1 && S.setClearColor(16777215, .5),
            S.clear();
            const mt = S.toneMapping;
            S.toneMapping = xa,
            Mn(F, ce, ue),
            ft.updateMultisampleRenderTarget(Re),
            ft.updateRenderTargetMipmap(Re);
            let tt = !1;
            for (let lt = 0, gt = J.length; lt < gt; lt++) {
                const Pt = J[lt]
                  , vn = Pt.object
                  , zn = Pt.geometry
                  , an = Pt.material
                  , Ei = Pt.group;
                if (an.side === Co && vn.layers.test(ue.layers)) {
                    const un = an.side;
                    an.side = Lr,
                    an.needsUpdate = !0,
                    $t(vn, ce, ue, zn, an, Ei),
                    an.side = un,
                    an.needsUpdate = !0,
                    tt = !0
                }
            }
            tt === !0 && (ft.updateMultisampleRenderTarget(Re),
            ft.updateRenderTargetMipmap(Re)),
            S.setRenderTarget(et),
            S.setClearColor(H, B),
            S.toneMapping = mt
        }
        function Mn(F, J, ce) {
            const ue = J.isScene === !0 ? J.overrideMaterial : null;
            for (let se = 0, ke = F.length; se < ke; se++) {
                const et = F[se]
                  , mt = et.object
                  , tt = et.geometry
                  , lt = ue === null ? et.material : ue
                  , gt = et.group;
                mt.layers.test(ce.layers) && $t(mt, J, ce, tt, lt, gt)
            }
        }
        function $t(F, J, ce, ue, se, ke) {
            F.onBeforeRender(S, J, ce, ue, se, ke),
            F.modelViewMatrix.multiplyMatrices(ce.matrixWorldInverse, F.matrixWorld),
            F.normalMatrix.getNormalMatrix(F.modelViewMatrix),
            se.onBeforeRender(S, J, ce, ue, F, ke),
            se.transparent === !0 && se.side === Co && se.forceSinglePass === !1 ? (se.side = Lr,
            se.needsUpdate = !0,
            S.renderBufferDirect(ce, J, ue, se, F, ke),
            se.side = Ma,
            se.needsUpdate = !0,
            S.renderBufferDirect(ce, J, ue, se, F, ke),
            se.side = Co) : S.renderBufferDirect(ce, J, ue, se, F, ke),
            F.onAfterRender(S, J, ce, ue, se, ke)
        }
        function dn(F, J, ce) {
            J.isScene !== !0 && (J = Xe);
            const ue = ot.get(F)
              , se = v.state.lights
              , ke = v.state.shadowsArray
              , et = se.state.version
              , mt = j.getParameters(F, se.state, ke, J, ce)
              , tt = j.getProgramCacheKey(mt);
            let lt = ue.programs;
            ue.environment = F.isMeshStandardMaterial ? J.environment : null,
            ue.fog = J.fog,
            ue.envMap = (F.isMeshStandardMaterial ? pt : Tt).get(F.envMap || ue.environment),
            lt === void 0 && (F.addEventListener("dispose", De),
            lt = new Map,
            ue.programs = lt);
            let gt = lt.get(tt);
            if (gt !== void 0) {
                if (ue.currentProgram === gt && ue.lightsStateVersion === et)
                    return On(F, mt),
                    gt
            } else
                mt.uniforms = j.getUniforms(F),
                F.onBuild(ce, mt, S),
                F.onBeforeCompile(mt, S),
                gt = j.acquireProgram(mt, tt),
                lt.set(tt, gt),
                ue.uniforms = mt.uniforms;
            const Pt = ue.uniforms;
            return (!F.isShaderMaterial && !F.isRawShaderMaterial || F.clipping === !0) && (Pt.clippingPlanes = We.uniform),
            On(F, mt),
            ue.needsLights = Di(F),
            ue.lightsStateVersion = et,
            ue.needsLights && (Pt.ambientLightColor.value = se.state.ambient,
            Pt.lightProbe.value = se.state.probe,
            Pt.directionalLights.value = se.state.directional,
            Pt.directionalLightShadows.value = se.state.directionalShadow,
            Pt.spotLights.value = se.state.spot,
            Pt.spotLightShadows.value = se.state.spotShadow,
            Pt.rectAreaLights.value = se.state.rectArea,
            Pt.ltc_1.value = se.state.rectAreaLTC1,
            Pt.ltc_2.value = se.state.rectAreaLTC2,
            Pt.pointLights.value = se.state.point,
            Pt.pointLightShadows.value = se.state.pointShadow,
            Pt.hemisphereLights.value = se.state.hemi,
            Pt.directionalShadowMap.value = se.state.directionalShadowMap,
            Pt.directionalShadowMatrix.value = se.state.directionalShadowMatrix,
            Pt.spotShadowMap.value = se.state.spotShadowMap,
            Pt.spotLightMatrix.value = se.state.spotLightMatrix,
            Pt.spotLightMap.value = se.state.spotLightMap,
            Pt.pointShadowMap.value = se.state.pointShadowMap,
            Pt.pointShadowMatrix.value = se.state.pointShadowMatrix),
            ue.currentProgram = gt,
            ue.uniformsList = null,
            gt
        }
        function Kn(F) {
            if (F.uniformsList === null) {
                const J = F.currentProgram.getUniforms();
                F.uniformsList = op.seqWithValue(J.seq, F.uniforms)
            }
            return F.uniformsList
        }
        function On(F, J) {
            const ce = ot.get(F);
            ce.outputColorSpace = J.outputColorSpace,
            ce.batching = J.batching,
            ce.instancing = J.instancing,
            ce.instancingColor = J.instancingColor,
            ce.skinning = J.skinning,
            ce.morphTargets = J.morphTargets,
            ce.morphNormals = J.morphNormals,
            ce.morphColors = J.morphColors,
            ce.morphTargetsCount = J.morphTargetsCount,
            ce.numClippingPlanes = J.numClippingPlanes,
            ce.numIntersection = J.numClipIntersection,
            ce.vertexAlphas = J.vertexAlphas,
            ce.vertexTangents = J.vertexTangents,
            ce.toneMapping = J.toneMapping
        }
        function _n(F, J, ce, ue, se) {
            J.isScene !== !0 && (J = Xe),
            ft.resetTextureUnits();
            const ke = J.fog
              , et = ue.isMeshStandardMaterial ? J.environment : null
              , mt = C === null ? S.outputColorSpace : C.isXRRenderTarget === !0 ? C.texture.colorSpace : No
              , tt = (ue.isMeshStandardMaterial ? pt : Tt).get(ue.envMap || et)
              , lt = ue.vertexColors === !0 && !!ce.attributes.color && ce.attributes.color.itemSize === 4
              , gt = !!ce.attributes.tangent && (!!ue.normalMap || ue.anisotropy > 0)
              , Pt = !!ce.morphAttributes.position
              , vn = !!ce.morphAttributes.normal
              , zn = !!ce.morphAttributes.color;
            let an = xa;
            ue.toneMapped && (C === null || C.isXRRenderTarget === !0) && (an = S.toneMapping);
            const Ei = ce.morphAttributes.position || ce.morphAttributes.normal || ce.morphAttributes.color
              , un = Ei !== void 0 ? Ei.length : 0
              , Dt = ot.get(ue)
              , uu = v.state.lights;
            if (fe === !0 && (xe === !0 || F !== A)) {
                const pr = F === A && ue.id === P;
                We.setState(ue, F, pr)
            }
            let Tn = !1;
            ue.version === Dt.__version ? (Dt.needsLights && Dt.lightsStateVersion !== uu.state.version || Dt.outputColorSpace !== mt || se.isBatchedMesh && Dt.batching === !1 || !se.isBatchedMesh && Dt.batching === !0 || se.isInstancedMesh && Dt.instancing === !1 || !se.isInstancedMesh && Dt.instancing === !0 || se.isSkinnedMesh && Dt.skinning === !1 || !se.isSkinnedMesh && Dt.skinning === !0 || se.isInstancedMesh && Dt.instancingColor === !0 && se.instanceColor === null || se.isInstancedMesh && Dt.instancingColor === !1 && se.instanceColor !== null || Dt.envMap !== tt || ue.fog === !0 && Dt.fog !== ke || Dt.numClippingPlanes !== void 0 && (Dt.numClippingPlanes !== We.numPlanes || Dt.numIntersection !== We.numIntersection) || Dt.vertexAlphas !== lt || Dt.vertexTangents !== gt || Dt.morphTargets !== Pt || Dt.morphNormals !== vn || Dt.morphColors !== zn || Dt.toneMapping !== an || Ye.isWebGL2 === !0 && Dt.morphTargetsCount !== un) && (Tn = !0) : (Tn = !0,
            Dt.__version = ue.version);
            let Hs = Dt.currentProgram;
            Tn === !0 && (Hs = dn(ue, J, se));
            let fu = !1
              , ao = !1
              , hu = !1;
            const si = Hs.getUniforms()
              , es = Dt.uniforms;
            if (Qe.useProgram(Hs.program) && (fu = !0,
            ao = !0,
            hu = !0),
            ue.id !== P && (P = ue.id,
            ao = !0),
            fu || A !== F) {
                si.setValue(ie, "projectionMatrix", F.projectionMatrix),
                si.setValue(ie, "viewMatrix", F.matrixWorldInverse);
                const pr = si.map.cameraPosition;
                pr !== void 0 && pr.setValue(ie, qe.setFromMatrixPosition(F.matrixWorld)),
                Ye.logarithmicDepthBuffer && si.setValue(ie, "logDepthBufFC", 2 / (Math.log(F.far + 1) / Math.LN2)),
                (ue.isMeshPhongMaterial || ue.isMeshToonMaterial || ue.isMeshLambertMaterial || ue.isMeshBasicMaterial || ue.isMeshStandardMaterial || ue.isShaderMaterial) && si.setValue(ie, "isOrthographic", F.isOrthographicCamera === !0),
                A !== F && (A = F,
                ao = !0,
                hu = !0)
            }
            if (se.isSkinnedMesh) {
                si.setOptional(ie, se, "bindMatrix"),
                si.setOptional(ie, se, "bindMatrixInverse");
                const pr = se.skeleton;
                pr && (Ye.floatVertexTextures ? (pr.boneTexture === null && pr.computeBoneTexture(),
                si.setValue(ie, "boneTexture", pr.boneTexture, ft)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
            }
            se.isBatchedMesh && (si.setOptional(ie, se, "batchingTexture"),
            si.setValue(ie, "batchingTexture", se._matricesTexture, ft));
            const Bl = ce.morphAttributes;
            if ((Bl.position !== void 0 || Bl.normal !== void 0 || Bl.color !== void 0 && Ye.isWebGL2 === !0) && Ae.update(se, ce, Hs),
            (ao || Dt.receiveShadow !== se.receiveShadow) && (Dt.receiveShadow = se.receiveShadow,
            si.setValue(ie, "receiveShadow", se.receiveShadow)),
            ue.isMeshGouraudMaterial && ue.envMap !== null && (es.envMap.value = tt,
            es.flipEnvMap.value = tt.isCubeTexture && tt.isRenderTargetTexture === !1 ? -1 : 1),
            ao && (si.setValue(ie, "toneMappingExposure", S.toneMappingExposure),
            Dt.needsLights && ln(es, hu),
            ke && ue.fog === !0 && he.refreshFogUniforms(es, ke),
            he.refreshMaterialUniforms(es, ue, V, X, Re),
            op.upload(ie, Kn(Dt), es, ft)),
            ue.isShaderMaterial && ue.uniformsNeedUpdate === !0 && (op.upload(ie, Kn(Dt), es, ft),
            ue.uniformsNeedUpdate = !1),
            ue.isSpriteMaterial && si.setValue(ie, "center", se.center),
            si.setValue(ie, "modelViewMatrix", se.modelViewMatrix),
            si.setValue(ie, "normalMatrix", se.normalMatrix),
            si.setValue(ie, "modelMatrix", se.matrixWorld),
            ue.isShaderMaterial || ue.isRawShaderMaterial) {
                const pr = ue.uniformsGroups;
                for (let kl = 0, dh = pr.length; kl < dh; kl++)
                    if (Ye.isWebGL2) {
                        const zl = pr[kl];
                        ht.update(zl, Hs),
                        ht.bind(zl, Hs)
                    } else
                        console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
            }
            return Hs
        }
        function ln(F, J) {
            F.ambientLightColor.needsUpdate = J,
            F.lightProbe.needsUpdate = J,
            F.directionalLights.needsUpdate = J,
            F.directionalLightShadows.needsUpdate = J,
            F.pointLights.needsUpdate = J,
            F.pointLightShadows.needsUpdate = J,
            F.spotLights.needsUpdate = J,
            F.spotLightShadows.needsUpdate = J,
            F.rectAreaLights.needsUpdate = J,
            F.hemisphereLights.needsUpdate = J
        }
        function Di(F) {
            return F.isMeshLambertMaterial || F.isMeshToonMaterial || F.isMeshPhongMaterial || F.isMeshStandardMaterial || F.isShadowMaterial || F.isShaderMaterial && F.lights === !0
        }
        this.getActiveCubeFace = function() {
            return b
        }
        ,
        this.getActiveMipmapLevel = function() {
            return T
        }
        ,
        this.getRenderTarget = function() {
            return C
        }
        ,
        this.setRenderTargetTextures = function(F, J, ce) {
            ot.get(F.texture).__webglTexture = J,
            ot.get(F.depthTexture).__webglTexture = ce;
            const ue = ot.get(F);
            ue.__hasExternalTextures = !0,
            ue.__hasExternalTextures && (ue.__autoAllocateDepthBuffer = ce === void 0,
            ue.__autoAllocateDepthBuffer || Ne.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
            ue.__useRenderToTexture = !1))
        }
        ,
        this.setRenderTargetFramebuffer = function(F, J) {
            const ce = ot.get(F);
            ce.__webglFramebuffer = J,
            ce.__useDefaultFramebuffer = J === void 0
        }
        ,
        this.setRenderTarget = function(F, J=0, ce=0) {
            C = F,
            b = J,
            T = ce;
            let ue = !0
              , se = null
              , ke = !1
              , et = !1;
            if (F) {
                const tt = ot.get(F);
                tt.__useDefaultFramebuffer !== void 0 ? (Qe.bindFramebuffer(ie.FRAMEBUFFER, null),
                ue = !1) : tt.__webglFramebuffer === void 0 ? ft.setupRenderTarget(F) : tt.__hasExternalTextures && ft.rebindTextures(F, ot.get(F.texture).__webglTexture, ot.get(F.depthTexture).__webglTexture);
                const lt = F.texture;
                (lt.isData3DTexture || lt.isDataArrayTexture || lt.isCompressedArrayTexture) && (et = !0);
                const gt = ot.get(F).__webglFramebuffer;
                F.isWebGLCubeRenderTarget ? (Array.isArray(gt[J]) ? se = gt[J][ce] : se = gt[J],
                ke = !0) : Ye.isWebGL2 && F.samples > 0 && ft.useMultisampledRTT(F) === !1 ? se = ot.get(F).__webglMultisampledFramebuffer : Array.isArray(gt) ? se = gt[ce] : se = gt,
                R.copy(F.viewport),
                I.copy(F.scissor),
                D = F.scissorTest
            } else
                R.copy(k).multiplyScalar(V).floor(),
                I.copy(oe).multiplyScalar(V).floor(),
                D = ae;
            if (Qe.bindFramebuffer(ie.FRAMEBUFFER, se) && Ye.drawBuffers && ue && Qe.drawBuffers(F, se),
            Qe.viewport(R),
            Qe.scissor(I),
            Qe.setScissorTest(D),
            ke) {
                const tt = ot.get(F.texture);
                ie.framebufferTexture2D(ie.FRAMEBUFFER, ie.COLOR_ATTACHMENT0, ie.TEXTURE_CUBE_MAP_POSITIVE_X + J, tt.__webglTexture, ce)
            } else if (et) {
                const tt = ot.get(F.texture)
                  , lt = J || 0;
                ie.framebufferTextureLayer(ie.FRAMEBUFFER, ie.COLOR_ATTACHMENT0, tt.__webglTexture, ce || 0, lt)
            }
            P = -1
        }
        ,
        this.readRenderTargetPixels = function(F, J, ce, ue, se, ke, et) {
            if (!(F && F.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let mt = ot.get(F).__webglFramebuffer;
            if (F.isWebGLCubeRenderTarget && et !== void 0 && (mt = mt[et]),
            mt) {
                Qe.bindFramebuffer(ie.FRAMEBUFFER, mt);
                try {
                    const tt = F.texture
                      , lt = tt.format
                      , gt = tt.type;
                    if (lt !== Ns && Bt.convert(lt) !== ie.getParameter(ie.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    const Pt = gt === Gf && (Ne.has("EXT_color_buffer_half_float") || Ye.isWebGL2 && Ne.has("EXT_color_buffer_float"));
                    if (gt !== ba && Bt.convert(gt) !== ie.getParameter(ie.IMPLEMENTATION_COLOR_READ_TYPE) && !(gt === pa && (Ye.isWebGL2 || Ne.has("OES_texture_float") || Ne.has("WEBGL_color_buffer_float"))) && !Pt) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    J >= 0 && J <= F.width - ue && ce >= 0 && ce <= F.height - se && ie.readPixels(J, ce, ue, se, Bt.convert(lt), Bt.convert(gt), ke)
                } finally {
                    const tt = C !== null ? ot.get(C).__webglFramebuffer : null;
                    Qe.bindFramebuffer(ie.FRAMEBUFFER, tt)
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(F, J, ce=0) {
            const ue = Math.pow(2, -ce)
              , se = Math.floor(J.image.width * ue)
              , ke = Math.floor(J.image.height * ue);
            ft.setTexture2D(J, 0),
            ie.copyTexSubImage2D(ie.TEXTURE_2D, ce, 0, 0, F.x, F.y, se, ke),
            Qe.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(F, J, ce, ue=0) {
            const se = J.image.width
              , ke = J.image.height
              , et = Bt.convert(ce.format)
              , mt = Bt.convert(ce.type);
            ft.setTexture2D(ce, 0),
            ie.pixelStorei(ie.UNPACK_FLIP_Y_WEBGL, ce.flipY),
            ie.pixelStorei(ie.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ce.premultiplyAlpha),
            ie.pixelStorei(ie.UNPACK_ALIGNMENT, ce.unpackAlignment),
            J.isDataTexture ? ie.texSubImage2D(ie.TEXTURE_2D, ue, F.x, F.y, se, ke, et, mt, J.image.data) : J.isCompressedTexture ? ie.compressedTexSubImage2D(ie.TEXTURE_2D, ue, F.x, F.y, J.mipmaps[0].width, J.mipmaps[0].height, et, J.mipmaps[0].data) : ie.texSubImage2D(ie.TEXTURE_2D, ue, F.x, F.y, et, mt, J.image),
            ue === 0 && ce.generateMipmaps && ie.generateMipmap(ie.TEXTURE_2D),
            Qe.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(F, J, ce, ue, se=0) {
            if (S.isWebGL1Renderer) {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                return
            }
            const ke = F.max.x - F.min.x + 1
              , et = F.max.y - F.min.y + 1
              , mt = F.max.z - F.min.z + 1
              , tt = Bt.convert(ue.format)
              , lt = Bt.convert(ue.type);
            let gt;
            if (ue.isData3DTexture)
                ft.setTexture3D(ue, 0),
                gt = ie.TEXTURE_3D;
            else if (ue.isDataArrayTexture)
                ft.setTexture2DArray(ue, 0),
                gt = ie.TEXTURE_2D_ARRAY;
            else {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                return
            }
            ie.pixelStorei(ie.UNPACK_FLIP_Y_WEBGL, ue.flipY),
            ie.pixelStorei(ie.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ue.premultiplyAlpha),
            ie.pixelStorei(ie.UNPACK_ALIGNMENT, ue.unpackAlignment);
            const Pt = ie.getParameter(ie.UNPACK_ROW_LENGTH)
              , vn = ie.getParameter(ie.UNPACK_IMAGE_HEIGHT)
              , zn = ie.getParameter(ie.UNPACK_SKIP_PIXELS)
              , an = ie.getParameter(ie.UNPACK_SKIP_ROWS)
              , Ei = ie.getParameter(ie.UNPACK_SKIP_IMAGES)
              , un = ce.isCompressedTexture ? ce.mipmaps[0] : ce.image;
            ie.pixelStorei(ie.UNPACK_ROW_LENGTH, un.width),
            ie.pixelStorei(ie.UNPACK_IMAGE_HEIGHT, un.height),
            ie.pixelStorei(ie.UNPACK_SKIP_PIXELS, F.min.x),
            ie.pixelStorei(ie.UNPACK_SKIP_ROWS, F.min.y),
            ie.pixelStorei(ie.UNPACK_SKIP_IMAGES, F.min.z),
            ce.isDataTexture || ce.isData3DTexture ? ie.texSubImage3D(gt, se, J.x, J.y, J.z, ke, et, mt, tt, lt, un.data) : ce.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
            ie.compressedTexSubImage3D(gt, se, J.x, J.y, J.z, ke, et, mt, tt, un.data)) : ie.texSubImage3D(gt, se, J.x, J.y, J.z, ke, et, mt, tt, lt, un),
            ie.pixelStorei(ie.UNPACK_ROW_LENGTH, Pt),
            ie.pixelStorei(ie.UNPACK_IMAGE_HEIGHT, vn),
            ie.pixelStorei(ie.UNPACK_SKIP_PIXELS, zn),
            ie.pixelStorei(ie.UNPACK_SKIP_ROWS, an),
            ie.pixelStorei(ie.UNPACK_SKIP_IMAGES, Ei),
            se === 0 && ue.generateMipmaps && ie.generateMipmap(gt),
            Qe.unbindTexture()
        }
        ,
        this.initTexture = function(F) {
            F.isCubeTexture ? ft.setTextureCube(F, 0) : F.isData3DTexture ? ft.setTexture3D(F, 0) : F.isDataArrayTexture || F.isCompressedArrayTexture ? ft.setTexture2DArray(F, 0) : ft.setTexture2D(F, 0),
            Qe.unbindTexture()
        }
        ,
        this.resetState = function() {
            b = 0,
            T = 0,
            C = null,
            Qe.reset(),
            vt.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return Po
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = e === Oy ? "display-p3" : "srgb",
        t.unpackColorSpace = pn.workingColorSpace === Zp ? "display-p3" : "srgb"
    }
    get physicallyCorrectLights() {
        return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
        !this.useLegacyLights
    }
    set physicallyCorrectLights(e) {
        console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
        this.useLegacyLights = !e
    }
    get outputEncoding() {
        return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
        this.outputColorSpace === Ci ? wl : nR
    }
    set outputEncoding(e) {
        console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
        this.outputColorSpace = e === wl ? Ci : No
    }
    get useLegacyLights() {
        return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
        this._useLegacyLights
    }
    set useLegacyLights(e) {
        console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
        this._useLegacyLights = e
    }
}
class bG extends ER {
}
bG.prototype.isWebGL1Renderer = !0;
class SG extends Zr {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t
    }
}
class wG extends hr {
    constructor(e, t, i, r, s, o, a, c, u) {
        super(e, t, i, r, s, o, a, c, u),
        this.isVideoTexture = !0,
        this.minFilter = o !== void 0 ? o : Er,
        this.magFilter = s !== void 0 ? s : Er,
        this.generateMipmaps = !1;
        const h = this;
        function m() {
            h.needsUpdate = !0,
            e.requestVideoFrameCallback(m)
        }
        "requestVideoFrameCallback"in e && e.requestVideoFrameCallback(m)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback"in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class EG extends Ta {
    constructor(e) {
        super(e),
        this.isRawShaderMaterial = !0,
        this.type = "RawShaderMaterial"
    }
}
const W1 = {
    enabled: !1,
    files: {},
    add: function(n, e) {
        this.enabled !== !1 && (this.files[n] = e)
    },
    get: function(n) {
        if (this.enabled !== !1)
            return this.files[n]
    },
    remove: function(n) {
        delete this.files[n]
    },
    clear: function() {
        this.files = {}
    }
};
class AG {
    constructor(e, t, i) {
        const r = this;
        let s = !1, o = 0, a = 0, c;
        const u = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = i,
        this.itemStart = function(h) {
            a++,
            s === !1 && r.onStart !== void 0 && r.onStart(h, o, a),
            s = !0
        }
        ,
        this.itemEnd = function(h) {
            o++,
            r.onProgress !== void 0 && r.onProgress(h, o, a),
            o === a && (s = !1,
            r.onLoad !== void 0 && r.onLoad())
        }
        ,
        this.itemError = function(h) {
            r.onError !== void 0 && r.onError(h)
        }
        ,
        this.resolveURL = function(h) {
            return c ? c(h) : h
        }
        ,
        this.setURLModifier = function(h) {
            return c = h,
            this
        }
        ,
        this.addHandler = function(h, m) {
            return u.push(h, m),
            this
        }
        ,
        this.removeHandler = function(h) {
            const m = u.indexOf(h);
            return m !== -1 && u.splice(m, 2),
            this
        }
        ,
        this.getHandler = function(h) {
            for (let m = 0, d = u.length; m < d; m += 2) {
                const f = u[m]
                  , _ = u[m + 1];
                if (f.global && (f.lastIndex = 0),
                f.test(h))
                    return _
            }
            return null
        }
    }
}
const MG = new AG;
class Fy {
    constructor(e) {
        this.manager = e !== void 0 ? e : MG,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const i = this;
        return new Promise(function(r, s) {
            i.load(e, r, t, s)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
Fy.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class TG extends Fy {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = W1.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = Vf("img");
        function c() {
            h(),
            W1.add(e, this),
            t && t(this),
            s.manager.itemEnd(e)
        }
        function u(m) {
            h(),
            r && r(m),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
        function h() {
            a.removeEventListener("load", c, !1),
            a.removeEventListener("error", u, !1)
        }
        return a.addEventListener("load", c, !1),
        a.addEventListener("error", u, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
        s.manager.itemStart(e),
        a.src = e,
        a
    }
}
class CG extends Fy {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new hr
          , o = new TG(this.manager);
        return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(e, function(a) {
            s.image = a,
            s.needsUpdate = !0,
            t !== void 0 && t(s)
        }, i, r),
        s
    }
}
class RG {
    constructor(e=!0) {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
        this.startTime = $1(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(),
            0;
        if (this.running) {
            const t = $1();
            e = (t - this.oldTime) / 1e3,
            this.oldTime = t,
            this.elapsedTime += e
        }
        return e
    }
}
function $1() {
    return (typeof performance > "u" ? Date : performance).now()
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: Dy
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Dy);
var AR = {
    exports: {}
};
/*!
 * matter-js 0.19.0 by @liabru
 * http://brm.io/matter-js/
 * License MIT
 * 
 * The MIT License (MIT)
 * 
 * Copyright (c) Liam Brummitt and contributors.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
(function(n, e) {
    (function(i, r) {
        n.exports = r()
    }
    )(lr, function() {
        return function(t) {
            var i = {};
            function r(s) {
                if (i[s])
                    return i[s].exports;
                var o = i[s] = {
                    i: s,
                    l: !1,
                    exports: {}
                };
                return t[s].call(o.exports, o, o.exports, r),
                o.l = !0,
                o.exports
            }
            return r.m = t,
            r.c = i,
            r.d = function(s, o, a) {
                r.o(s, o) || Object.defineProperty(s, o, {
                    enumerable: !0,
                    get: a
                })
            }
            ,
            r.r = function(s) {
                typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, {
                    value: "Module"
                }),
                Object.defineProperty(s, "__esModule", {
                    value: !0
                })
            }
            ,
            r.t = function(s, o) {
                if (o & 1 && (s = r(s)),
                o & 8 || o & 4 && typeof s == "object" && s && s.__esModule)
                    return s;
                var a = Object.create(null);
                if (r.r(a),
                Object.defineProperty(a, "default", {
                    enumerable: !0,
                    value: s
                }),
                o & 2 && typeof s != "string")
                    for (var c in s)
                        r.d(a, c, (function(u) {
                            return s[u]
                        }
                        ).bind(null, c));
                return a
            }
            ,
            r.n = function(s) {
                var o = s && s.__esModule ? function() {
                    return s.default
                }
                : function() {
                    return s
                }
                ;
                return r.d(o, "a", o),
                o
            }
            ,
            r.o = function(s, o) {
                return Object.prototype.hasOwnProperty.call(s, o)
            }
            ,
            r.p = "",
            r(r.s = 20)
        }([function(t, i) {
            var r = {};
            t.exports = r,
            function() {
                r._baseDelta = 1e3 / 60,
                r._nextId = 0,
                r._seed = 0,
                r._nowStartTime = +new Date,
                r._warnedOnce = {},
                r._decomp = null,
                r.extend = function(o, a) {
                    var c, u;
                    typeof a == "boolean" ? (c = 2,
                    u = a) : (c = 1,
                    u = !0);
                    for (var h = c; h < arguments.length; h++) {
                        var m = arguments[h];
                        if (m)
                            for (var d in m)
                                u && m[d] && m[d].constructor === Object && (!o[d] || o[d].constructor === Object) ? (o[d] = o[d] || {},
                                r.extend(o[d], u, m[d])) : o[d] = m[d]
                    }
                    return o
                }
                ,
                r.clone = function(o, a) {
                    return r.extend({}, a, o)
                }
                ,
                r.keys = function(o) {
                    if (Object.keys)
                        return Object.keys(o);
                    var a = [];
                    for (var c in o)
                        a.push(c);
                    return a
                }
                ,
                r.values = function(o) {
                    var a = [];
                    if (Object.keys) {
                        for (var c = Object.keys(o), u = 0; u < c.length; u++)
                            a.push(o[c[u]]);
                        return a
                    }
                    for (var h in o)
                        a.push(o[h]);
                    return a
                }
                ,
                r.get = function(o, a, c, u) {
                    a = a.split(".").slice(c, u);
                    for (var h = 0; h < a.length; h += 1)
                        o = o[a[h]];
                    return o
                }
                ,
                r.set = function(o, a, c, u, h) {
                    var m = a.split(".").slice(u, h);
                    return r.get(o, a, 0, -1)[m[m.length - 1]] = c,
                    c
                }
                ,
                r.shuffle = function(o) {
                    for (var a = o.length - 1; a > 0; a--) {
                        var c = Math.floor(r.random() * (a + 1))
                          , u = o[a];
                        o[a] = o[c],
                        o[c] = u
                    }
                    return o
                }
                ,
                r.choose = function(o) {
                    return o[Math.floor(r.random() * o.length)]
                }
                ,
                r.isElement = function(o) {
                    return typeof HTMLElement < "u" ? o instanceof HTMLElement : !!(o && o.nodeType && o.nodeName)
                }
                ,
                r.isArray = function(o) {
                    return Object.prototype.toString.call(o) === "[object Array]"
                }
                ,
                r.isFunction = function(o) {
                    return typeof o == "function"
                }
                ,
                r.isPlainObject = function(o) {
                    return typeof o == "object" && o.constructor === Object
                }
                ,
                r.isString = function(o) {
                    return toString.call(o) === "[object String]"
                }
                ,
                r.clamp = function(o, a, c) {
                    return o < a ? a : o > c ? c : o
                }
                ,
                r.sign = function(o) {
                    return o < 0 ? -1 : 1
                }
                ,
                r.now = function() {
                    if (typeof window < "u" && window.performance) {
                        if (window.performance.now)
                            return window.performance.now();
                        if (window.performance.webkitNow)
                            return window.performance.webkitNow()
                    }
                    return Date.now ? Date.now() : new Date - r._nowStartTime
                }
                ,
                r.random = function(o, a) {
                    return o = typeof o < "u" ? o : 0,
                    a = typeof a < "u" ? a : 1,
                    o + s() * (a - o)
                }
                ;
                var s = function() {
                    return r._seed = (r._seed * 9301 + 49297) % 233280,
                    r._seed / 233280
                };
                r.colorToNumber = function(o) {
                    return o = o.replace("#", ""),
                    o.length == 3 && (o = o.charAt(0) + o.charAt(0) + o.charAt(1) + o.charAt(1) + o.charAt(2) + o.charAt(2)),
                    parseInt(o, 16)
                }
                ,
                r.logLevel = 1,
                r.log = function() {
                    console && r.logLevel > 0 && r.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                }
                ,
                r.info = function() {
                    console && r.logLevel > 0 && r.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                }
                ,
                r.warn = function() {
                    console && r.logLevel > 0 && r.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                }
                ,
                r.warnOnce = function() {
                    var o = Array.prototype.slice.call(arguments).join(" ");
                    r._warnedOnce[o] || (r.warn(o),
                    r._warnedOnce[o] = !0)
                }
                ,
                r.deprecated = function(o, a, c) {
                    o[a] = r.chain(function() {
                        r.warnOnce(" deprecated ", c)
                    }, o[a])
                }
                ,
                r.nextId = function() {
                    return r._nextId++
                }
                ,
                r.indexOf = function(o, a) {
                    if (o.indexOf)
                        return o.indexOf(a);
                    for (var c = 0; c < o.length; c++)
                        if (o[c] === a)
                            return c;
                    return -1
                }
                ,
                r.map = function(o, a) {
                    if (o.map)
                        return o.map(a);
                    for (var c = [], u = 0; u < o.length; u += 1)
                        c.push(a(o[u]));
                    return c
                }
                ,
                r.topologicalSort = function(o) {
                    var a = []
                      , c = []
                      , u = [];
                    for (var h in o)
                        !c[h] && !u[h] && r._topologicalSort(h, c, u, o, a);
                    return a
                }
                ,
                r._topologicalSort = function(o, a, c, u, h) {
                    var m = u[o] || [];
                    c[o] = !0;
                    for (var d = 0; d < m.length; d += 1) {
                        var f = m[d];
                        c[f] || a[f] || r._topologicalSort(f, a, c, u, h)
                    }
                    c[o] = !1,
                    a[o] = !0,
                    h.push(o)
                }
                ,
                r.chain = function() {
                    for (var o = [], a = 0; a < arguments.length; a += 1) {
                        var c = arguments[a];
                        c._chained ? o.push.apply(o, c._chained) : o.push(c)
                    }
                    var u = function() {
                        for (var h, m = new Array(arguments.length), d = 0, f = arguments.length; d < f; d++)
                            m[d] = arguments[d];
                        for (d = 0; d < o.length; d += 1) {
                            var _ = o[d].apply(h, m);
                            typeof _ < "u" && (h = _)
                        }
                        return h
                    };
                    return u._chained = o,
                    u
                }
                ,
                r.chainPathBefore = function(o, a, c) {
                    return r.set(o, a, r.chain(c, r.get(o, a)))
                }
                ,
                r.chainPathAfter = function(o, a, c) {
                    return r.set(o, a, r.chain(r.get(o, a), c))
                }
                ,
                r.setDecomp = function(o) {
                    r._decomp = o
                }
                ,
                r.getDecomp = function() {
                    var o = r._decomp;
                    try {
                        !o && typeof window < "u" && (o = window.decomp),
                        !o && typeof lr < "u" && (o = lr.decomp)
                    } catch {
                        o = null
                    }
                    return o
                }
            }()
        }
        , function(t, i) {
            var r = {};
            t.exports = r,
            function() {
                r.create = function(s) {
                    var o = {
                        min: {
                            x: 0,
                            y: 0
                        },
                        max: {
                            x: 0,
                            y: 0
                        }
                    };
                    return s && r.update(o, s),
                    o
                }
                ,
                r.update = function(s, o, a) {
                    s.min.x = 1 / 0,
                    s.max.x = -1 / 0,
                    s.min.y = 1 / 0,
                    s.max.y = -1 / 0;
                    for (var c = 0; c < o.length; c++) {
                        var u = o[c];
                        u.x > s.max.x && (s.max.x = u.x),
                        u.x < s.min.x && (s.min.x = u.x),
                        u.y > s.max.y && (s.max.y = u.y),
                        u.y < s.min.y && (s.min.y = u.y)
                    }
                    a && (a.x > 0 ? s.max.x += a.x : s.min.x += a.x,
                    a.y > 0 ? s.max.y += a.y : s.min.y += a.y)
                }
                ,
                r.contains = function(s, o) {
                    return o.x >= s.min.x && o.x <= s.max.x && o.y >= s.min.y && o.y <= s.max.y
                }
                ,
                r.overlaps = function(s, o) {
                    return s.min.x <= o.max.x && s.max.x >= o.min.x && s.max.y >= o.min.y && s.min.y <= o.max.y
                }
                ,
                r.translate = function(s, o) {
                    s.min.x += o.x,
                    s.max.x += o.x,
                    s.min.y += o.y,
                    s.max.y += o.y
                }
                ,
                r.shift = function(s, o) {
                    var a = s.max.x - s.min.x
                      , c = s.max.y - s.min.y;
                    s.min.x = o.x,
                    s.max.x = o.x + a,
                    s.min.y = o.y,
                    s.max.y = o.y + c
                }
            }()
        }
        , function(t, i) {
            var r = {};
            t.exports = r,
            function() {
                r.create = function(s, o) {
                    return {
                        x: s || 0,
                        y: o || 0
                    }
                }
                ,
                r.clone = function(s) {
                    return {
                        x: s.x,
                        y: s.y
                    }
                }
                ,
                r.magnitude = function(s) {
                    return Math.sqrt(s.x * s.x + s.y * s.y)
                }
                ,
                r.magnitudeSquared = function(s) {
                    return s.x * s.x + s.y * s.y
                }
                ,
                r.rotate = function(s, o, a) {
                    var c = Math.cos(o)
                      , u = Math.sin(o);
                    a || (a = {});
                    var h = s.x * c - s.y * u;
                    return a.y = s.x * u + s.y * c,
                    a.x = h,
                    a
                }
                ,
                r.rotateAbout = function(s, o, a, c) {
                    var u = Math.cos(o)
                      , h = Math.sin(o);
                    c || (c = {});
                    var m = a.x + ((s.x - a.x) * u - (s.y - a.y) * h);
                    return c.y = a.y + ((s.x - a.x) * h + (s.y - a.y) * u),
                    c.x = m,
                    c
                }
                ,
                r.normalise = function(s) {
                    var o = r.magnitude(s);
                    return o === 0 ? {
                        x: 0,
                        y: 0
                    } : {
                        x: s.x / o,
                        y: s.y / o
                    }
                }
                ,
                r.dot = function(s, o) {
                    return s.x * o.x + s.y * o.y
                }
                ,
                r.cross = function(s, o) {
                    return s.x * o.y - s.y * o.x
                }
                ,
                r.cross3 = function(s, o, a) {
                    return (o.x - s.x) * (a.y - s.y) - (o.y - s.y) * (a.x - s.x)
                }
                ,
                r.add = function(s, o, a) {
                    return a || (a = {}),
                    a.x = s.x + o.x,
                    a.y = s.y + o.y,
                    a
                }
                ,
                r.sub = function(s, o, a) {
                    return a || (a = {}),
                    a.x = s.x - o.x,
                    a.y = s.y - o.y,
                    a
                }
                ,
                r.mult = function(s, o) {
                    return {
                        x: s.x * o,
                        y: s.y * o
                    }
                }
                ,
                r.div = function(s, o) {
                    return {
                        x: s.x / o,
                        y: s.y / o
                    }
                }
                ,
                r.perp = function(s, o) {
                    return o = o === !0 ? -1 : 1,
                    {
                        x: o * -s.y,
                        y: o * s.x
                    }
                }
                ,
                r.neg = function(s) {
                    return {
                        x: -s.x,
                        y: -s.y
                    }
                }
                ,
                r.angle = function(s, o) {
                    return Math.atan2(o.y - s.y, o.x - s.x)
                }
                ,
                r._temp = [r.create(), r.create(), r.create(), r.create(), r.create(), r.create()]
            }()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(2)
              , a = r(0);
            (function() {
                s.create = function(c, u) {
                    for (var h = [], m = 0; m < c.length; m++) {
                        var d = c[m]
                          , f = {
                            x: d.x,
                            y: d.y,
                            index: m,
                            body: u,
                            isInternal: !1
                        };
                        h.push(f)
                    }
                    return h
                }
                ,
                s.fromPath = function(c, u) {
                    var h = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig
                      , m = [];
                    return c.replace(h, function(d, f, _) {
                        m.push({
                            x: parseFloat(f),
                            y: parseFloat(_)
                        })
                    }),
                    s.create(m, u)
                }
                ,
                s.centre = function(c) {
                    for (var u = s.area(c, !0), h = {
                        x: 0,
                        y: 0
                    }, m, d, f, _ = 0; _ < c.length; _++)
                        f = (_ + 1) % c.length,
                        m = o.cross(c[_], c[f]),
                        d = o.mult(o.add(c[_], c[f]), m),
                        h = o.add(h, d);
                    return o.div(h, 6 * u)
                }
                ,
                s.mean = function(c) {
                    for (var u = {
                        x: 0,
                        y: 0
                    }, h = 0; h < c.length; h++)
                        u.x += c[h].x,
                        u.y += c[h].y;
                    return o.div(u, c.length)
                }
                ,
                s.area = function(c, u) {
                    for (var h = 0, m = c.length - 1, d = 0; d < c.length; d++)
                        h += (c[m].x - c[d].x) * (c[m].y + c[d].y),
                        m = d;
                    return u ? h / 2 : Math.abs(h) / 2
                }
                ,
                s.inertia = function(c, u) {
                    for (var h = 0, m = 0, d = c, f, _, g = 0; g < d.length; g++)
                        _ = (g + 1) % d.length,
                        f = Math.abs(o.cross(d[_], d[g])),
                        h += f * (o.dot(d[_], d[_]) + o.dot(d[_], d[g]) + o.dot(d[g], d[g])),
                        m += f;
                    return u / 6 * (h / m)
                }
                ,
                s.translate = function(c, u, h) {
                    h = typeof h < "u" ? h : 1;
                    var m = c.length, d = u.x * h, f = u.y * h, _;
                    for (_ = 0; _ < m; _++)
                        c[_].x += d,
                        c[_].y += f;
                    return c
                }
                ,
                s.rotate = function(c, u, h) {
                    if (u !== 0) {
                        var m = Math.cos(u), d = Math.sin(u), f = h.x, _ = h.y, g = c.length, v, y, w, S;
                        for (S = 0; S < g; S++)
                            v = c[S],
                            y = v.x - f,
                            w = v.y - _,
                            v.x = f + (y * m - w * d),
                            v.y = _ + (y * d + w * m);
                        return c
                    }
                }
                ,
                s.contains = function(c, u) {
                    for (var h = u.x, m = u.y, d = c.length, f = c[d - 1], _, g = 0; g < d; g++) {
                        if (_ = c[g],
                        (h - f.x) * (_.y - f.y) + (m - f.y) * (f.x - _.x) > 0)
                            return !1;
                        f = _
                    }
                    return !0
                }
                ,
                s.scale = function(c, u, h, m) {
                    if (u === 1 && h === 1)
                        return c;
                    m = m || s.centre(c);
                    for (var d, f, _ = 0; _ < c.length; _++)
                        d = c[_],
                        f = o.sub(d, m),
                        c[_].x = m.x + f.x * u,
                        c[_].y = m.y + f.y * h;
                    return c
                }
                ,
                s.chamfer = function(c, u, h, m, d) {
                    typeof u == "number" ? u = [u] : u = u || [8],
                    h = typeof h < "u" ? h : -1,
                    m = m || 2,
                    d = d || 14;
                    for (var f = [], _ = 0; _ < c.length; _++) {
                        var g = c[_ - 1 >= 0 ? _ - 1 : c.length - 1]
                          , v = c[_]
                          , y = c[(_ + 1) % c.length]
                          , w = u[_ < u.length ? _ : u.length - 1];
                        if (w === 0) {
                            f.push(v);
                            continue
                        }
                        var S = o.normalise({
                            x: v.y - g.y,
                            y: g.x - v.x
                        })
                          , E = o.normalise({
                            x: y.y - v.y,
                            y: v.x - y.x
                        })
                          , b = Math.sqrt(2 * Math.pow(w, 2))
                          , T = o.mult(a.clone(S), w)
                          , C = o.normalise(o.mult(o.add(S, E), .5))
                          , P = o.sub(v, o.mult(C, b))
                          , A = h;
                        h === -1 && (A = Math.pow(w, .32) * 1.75),
                        A = a.clamp(A, m, d),
                        A % 2 === 1 && (A += 1);
                        for (var R = Math.acos(o.dot(S, E)), I = R / A, D = 0; D < A; D++)
                            f.push(o.add(o.rotate(T, I * D), P))
                    }
                    return f
                }
                ,
                s.clockwiseSort = function(c) {
                    var u = s.mean(c);
                    return c.sort(function(h, m) {
                        return o.angle(u, h) - o.angle(u, m)
                    }),
                    c
                }
                ,
                s.isConvex = function(c) {
                    var u = 0, h = c.length, m, d, f, _;
                    if (h < 3)
                        return null;
                    for (m = 0; m < h; m++)
                        if (d = (m + 1) % h,
                        f = (m + 2) % h,
                        _ = (c[d].x - c[m].x) * (c[f].y - c[d].y),
                        _ -= (c[d].y - c[m].y) * (c[f].x - c[d].x),
                        _ < 0 ? u |= 1 : _ > 0 && (u |= 2),
                        u === 3)
                            return !1;
                    return u !== 0 ? !0 : null
                }
                ,
                s.hull = function(c) {
                    var u = [], h = [], m, d;
                    for (c = c.slice(0),
                    c.sort(function(f, _) {
                        var g = f.x - _.x;
                        return g !== 0 ? g : f.y - _.y
                    }),
                    d = 0; d < c.length; d += 1) {
                        for (m = c[d]; h.length >= 2 && o.cross3(h[h.length - 2], h[h.length - 1], m) <= 0; )
                            h.pop();
                        h.push(m)
                    }
                    for (d = c.length - 1; d >= 0; d -= 1) {
                        for (m = c[d]; u.length >= 2 && o.cross3(u[u.length - 2], u[u.length - 1], m) <= 0; )
                            u.pop();
                        u.push(m)
                    }
                    return u.pop(),
                    h.pop(),
                    u.concat(h)
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(3)
              , a = r(2)
              , c = r(7)
              , u = r(0)
              , h = r(1)
              , m = r(11);
            (function() {
                s._timeCorrection = !0,
                s._inertiaScale = 4,
                s._nextCollidingGroupId = 1,
                s._nextNonCollidingGroupId = -1,
                s._nextCategory = 1,
                s._baseDelta = 1e3 / 60,
                s.create = function(f) {
                    var _ = {
                        id: u.nextId(),
                        type: "body",
                        label: "Body",
                        parts: [],
                        plugin: {},
                        angle: 0,
                        vertices: o.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),
                        position: {
                            x: 0,
                            y: 0
                        },
                        force: {
                            x: 0,
                            y: 0
                        },
                        torque: 0,
                        positionImpulse: {
                            x: 0,
                            y: 0
                        },
                        constraintImpulse: {
                            x: 0,
                            y: 0,
                            angle: 0
                        },
                        totalContacts: 0,
                        speed: 0,
                        angularSpeed: 0,
                        velocity: {
                            x: 0,
                            y: 0
                        },
                        angularVelocity: 0,
                        isSensor: !1,
                        isStatic: !1,
                        isSleeping: !1,
                        motion: 0,
                        sleepThreshold: 60,
                        density: .001,
                        restitution: 0,
                        friction: .1,
                        frictionStatic: .5,
                        frictionAir: .01,
                        collisionFilter: {
                            category: 1,
                            mask: 4294967295,
                            group: 0
                        },
                        slop: .05,
                        timeScale: 1,
                        render: {
                            visible: !0,
                            opacity: 1,
                            strokeStyle: null,
                            fillStyle: null,
                            lineWidth: null,
                            sprite: {
                                xScale: 1,
                                yScale: 1,
                                xOffset: 0,
                                yOffset: 0
                            }
                        },
                        events: null,
                        bounds: null,
                        chamfer: null,
                        circleRadius: 0,
                        positionPrev: null,
                        anglePrev: 0,
                        parent: null,
                        axes: null,
                        area: 0,
                        mass: 0,
                        inertia: 0,
                        deltaTime: 16.666666666666668,
                        _original: null
                    }
                      , g = u.extend(_, f);
                    return d(g, f),
                    g
                }
                ,
                s.nextGroup = function(f) {
                    return f ? s._nextNonCollidingGroupId-- : s._nextCollidingGroupId++
                }
                ,
                s.nextCategory = function() {
                    return s._nextCategory = s._nextCategory << 1,
                    s._nextCategory
                }
                ;
                var d = function(f, _) {
                    _ = _ || {},
                    s.set(f, {
                        bounds: f.bounds || h.create(f.vertices),
                        positionPrev: f.positionPrev || a.clone(f.position),
                        anglePrev: f.anglePrev || f.angle,
                        vertices: f.vertices,
                        parts: f.parts || [f],
                        isStatic: f.isStatic,
                        isSleeping: f.isSleeping,
                        parent: f.parent || f
                    }),
                    o.rotate(f.vertices, f.angle, f.position),
                    m.rotate(f.axes, f.angle),
                    h.update(f.bounds, f.vertices, f.velocity),
                    s.set(f, {
                        axes: _.axes || f.axes,
                        area: _.area || f.area,
                        mass: _.mass || f.mass,
                        inertia: _.inertia || f.inertia
                    });
                    var g = f.isStatic ? "#14151f" : u.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"])
                      , v = f.isStatic ? "#555" : "#ccc"
                      , y = f.isStatic && f.render.fillStyle === null ? 1 : 0;
                    f.render.fillStyle = f.render.fillStyle || g,
                    f.render.strokeStyle = f.render.strokeStyle || v,
                    f.render.lineWidth = f.render.lineWidth || y,
                    f.render.sprite.xOffset += -(f.bounds.min.x - f.position.x) / (f.bounds.max.x - f.bounds.min.x),
                    f.render.sprite.yOffset += -(f.bounds.min.y - f.position.y) / (f.bounds.max.y - f.bounds.min.y)
                };
                s.set = function(f, _, g) {
                    var v;
                    typeof _ == "string" && (v = _,
                    _ = {},
                    _[v] = g);
                    for (v in _)
                        if (Object.prototype.hasOwnProperty.call(_, v))
                            switch (g = _[v],
                            v) {
                            case "isStatic":
                                s.setStatic(f, g);
                                break;
                            case "isSleeping":
                                c.set(f, g);
                                break;
                            case "mass":
                                s.setMass(f, g);
                                break;
                            case "density":
                                s.setDensity(f, g);
                                break;
                            case "inertia":
                                s.setInertia(f, g);
                                break;
                            case "vertices":
                                s.setVertices(f, g);
                                break;
                            case "position":
                                s.setPosition(f, g);
                                break;
                            case "angle":
                                s.setAngle(f, g);
                                break;
                            case "velocity":
                                s.setVelocity(f, g);
                                break;
                            case "angularVelocity":
                                s.setAngularVelocity(f, g);
                                break;
                            case "speed":
                                s.setSpeed(f, g);
                                break;
                            case "angularSpeed":
                                s.setAngularSpeed(f, g);
                                break;
                            case "parts":
                                s.setParts(f, g);
                                break;
                            case "centre":
                                s.setCentre(f, g);
                                break;
                            default:
                                f[v] = g
                            }
                }
                ,
                s.setStatic = function(f, _) {
                    for (var g = 0; g < f.parts.length; g++) {
                        var v = f.parts[g];
                        v.isStatic = _,
                        _ ? (v._original = {
                            restitution: v.restitution,
                            friction: v.friction,
                            mass: v.mass,
                            inertia: v.inertia,
                            density: v.density,
                            inverseMass: v.inverseMass,
                            inverseInertia: v.inverseInertia
                        },
                        v.restitution = 0,
                        v.friction = 1,
                        v.mass = v.inertia = v.density = 1 / 0,
                        v.inverseMass = v.inverseInertia = 0,
                        v.positionPrev.x = v.position.x,
                        v.positionPrev.y = v.position.y,
                        v.anglePrev = v.angle,
                        v.angularVelocity = 0,
                        v.speed = 0,
                        v.angularSpeed = 0,
                        v.motion = 0) : v._original && (v.restitution = v._original.restitution,
                        v.friction = v._original.friction,
                        v.mass = v._original.mass,
                        v.inertia = v._original.inertia,
                        v.density = v._original.density,
                        v.inverseMass = v._original.inverseMass,
                        v.inverseInertia = v._original.inverseInertia,
                        v._original = null)
                    }
                }
                ,
                s.setMass = function(f, _) {
                    var g = f.inertia / (f.mass / 6);
                    f.inertia = g * (_ / 6),
                    f.inverseInertia = 1 / f.inertia,
                    f.mass = _,
                    f.inverseMass = 1 / f.mass,
                    f.density = f.mass / f.area
                }
                ,
                s.setDensity = function(f, _) {
                    s.setMass(f, _ * f.area),
                    f.density = _
                }
                ,
                s.setInertia = function(f, _) {
                    f.inertia = _,
                    f.inverseInertia = 1 / f.inertia
                }
                ,
                s.setVertices = function(f, _) {
                    _[0].body === f ? f.vertices = _ : f.vertices = o.create(_, f),
                    f.axes = m.fromVertices(f.vertices),
                    f.area = o.area(f.vertices),
                    s.setMass(f, f.density * f.area);
                    var g = o.centre(f.vertices);
                    o.translate(f.vertices, g, -1),
                    s.setInertia(f, s._inertiaScale * o.inertia(f.vertices, f.mass)),
                    o.translate(f.vertices, f.position),
                    h.update(f.bounds, f.vertices, f.velocity)
                }
                ,
                s.setParts = function(f, _, g) {
                    var v;
                    for (_ = _.slice(0),
                    f.parts.length = 0,
                    f.parts.push(f),
                    f.parent = f,
                    v = 0; v < _.length; v++) {
                        var y = _[v];
                        y !== f && (y.parent = f,
                        f.parts.push(y))
                    }
                    if (f.parts.length !== 1) {
                        if (g = typeof g < "u" ? g : !0,
                        g) {
                            var w = [];
                            for (v = 0; v < _.length; v++)
                                w = w.concat(_[v].vertices);
                            o.clockwiseSort(w);
                            var S = o.hull(w)
                              , E = o.centre(S);
                            s.setVertices(f, S),
                            o.translate(f.vertices, E)
                        }
                        var b = s._totalProperties(f);
                        f.area = b.area,
                        f.parent = f,
                        f.position.x = b.centre.x,
                        f.position.y = b.centre.y,
                        f.positionPrev.x = b.centre.x,
                        f.positionPrev.y = b.centre.y,
                        s.setMass(f, b.mass),
                        s.setInertia(f, b.inertia),
                        s.setPosition(f, b.centre)
                    }
                }
                ,
                s.setCentre = function(f, _, g) {
                    g ? (f.positionPrev.x += _.x,
                    f.positionPrev.y += _.y,
                    f.position.x += _.x,
                    f.position.y += _.y) : (f.positionPrev.x = _.x - (f.position.x - f.positionPrev.x),
                    f.positionPrev.y = _.y - (f.position.y - f.positionPrev.y),
                    f.position.x = _.x,
                    f.position.y = _.y)
                }
                ,
                s.setPosition = function(f, _, g) {
                    var v = a.sub(_, f.position);
                    g ? (f.positionPrev.x = f.position.x,
                    f.positionPrev.y = f.position.y,
                    f.velocity.x = v.x,
                    f.velocity.y = v.y,
                    f.speed = a.magnitude(v)) : (f.positionPrev.x += v.x,
                    f.positionPrev.y += v.y);
                    for (var y = 0; y < f.parts.length; y++) {
                        var w = f.parts[y];
                        w.position.x += v.x,
                        w.position.y += v.y,
                        o.translate(w.vertices, v),
                        h.update(w.bounds, w.vertices, f.velocity)
                    }
                }
                ,
                s.setAngle = function(f, _, g) {
                    var v = _ - f.angle;
                    g ? (f.anglePrev = f.angle,
                    f.angularVelocity = v,
                    f.angularSpeed = Math.abs(v)) : f.anglePrev += v;
                    for (var y = 0; y < f.parts.length; y++) {
                        var w = f.parts[y];
                        w.angle += v,
                        o.rotate(w.vertices, v, f.position),
                        m.rotate(w.axes, v),
                        h.update(w.bounds, w.vertices, f.velocity),
                        y > 0 && a.rotateAbout(w.position, v, f.position, w.position)
                    }
                }
                ,
                s.setVelocity = function(f, _) {
                    var g = f.deltaTime / s._baseDelta;
                    f.positionPrev.x = f.position.x - _.x * g,
                    f.positionPrev.y = f.position.y - _.y * g,
                    f.velocity.x = (f.position.x - f.positionPrev.x) / g,
                    f.velocity.y = (f.position.y - f.positionPrev.y) / g,
                    f.speed = a.magnitude(f.velocity)
                }
                ,
                s.getVelocity = function(f) {
                    var _ = s._baseDelta / f.deltaTime;
                    return {
                        x: (f.position.x - f.positionPrev.x) * _,
                        y: (f.position.y - f.positionPrev.y) * _
                    }
                }
                ,
                s.getSpeed = function(f) {
                    return a.magnitude(s.getVelocity(f))
                }
                ,
                s.setSpeed = function(f, _) {
                    s.setVelocity(f, a.mult(a.normalise(s.getVelocity(f)), _))
                }
                ,
                s.setAngularVelocity = function(f, _) {
                    var g = f.deltaTime / s._baseDelta;
                    f.anglePrev = f.angle - _ * g,
                    f.angularVelocity = (f.angle - f.anglePrev) / g,
                    f.angularSpeed = Math.abs(f.angularVelocity)
                }
                ,
                s.getAngularVelocity = function(f) {
                    return (f.angle - f.anglePrev) * s._baseDelta / f.deltaTime
                }
                ,
                s.getAngularSpeed = function(f) {
                    return Math.abs(s.getAngularVelocity(f))
                }
                ,
                s.setAngularSpeed = function(f, _) {
                    s.setAngularVelocity(f, u.sign(s.getAngularVelocity(f)) * _)
                }
                ,
                s.translate = function(f, _, g) {
                    s.setPosition(f, a.add(f.position, _), g)
                }
                ,
                s.rotate = function(f, _, g, v) {
                    if (!g)
                        s.setAngle(f, f.angle + _, v);
                    else {
                        var y = Math.cos(_)
                          , w = Math.sin(_)
                          , S = f.position.x - g.x
                          , E = f.position.y - g.y;
                        s.setPosition(f, {
                            x: g.x + (S * y - E * w),
                            y: g.y + (S * w + E * y)
                        }, v),
                        s.setAngle(f, f.angle + _, v)
                    }
                }
                ,
                s.scale = function(f, _, g, v) {
                    var y = 0
                      , w = 0;
                    v = v || f.position;
                    for (var S = 0; S < f.parts.length; S++) {
                        var E = f.parts[S];
                        o.scale(E.vertices, _, g, v),
                        E.axes = m.fromVertices(E.vertices),
                        E.area = o.area(E.vertices),
                        s.setMass(E, f.density * E.area),
                        o.translate(E.vertices, {
                            x: -E.position.x,
                            y: -E.position.y
                        }),
                        s.setInertia(E, s._inertiaScale * o.inertia(E.vertices, E.mass)),
                        o.translate(E.vertices, {
                            x: E.position.x,
                            y: E.position.y
                        }),
                        S > 0 && (y += E.area,
                        w += E.inertia),
                        E.position.x = v.x + (E.position.x - v.x) * _,
                        E.position.y = v.y + (E.position.y - v.y) * g,
                        h.update(E.bounds, E.vertices, f.velocity)
                    }
                    f.parts.length > 1 && (f.area = y,
                    f.isStatic || (s.setMass(f, f.density * y),
                    s.setInertia(f, w))),
                    f.circleRadius && (_ === g ? f.circleRadius *= _ : f.circleRadius = null)
                }
                ,
                s.update = function(f, _) {
                    _ = (typeof _ < "u" ? _ : 1e3 / 60) * f.timeScale;
                    var g = _ * _
                      , v = s._timeCorrection ? _ / (f.deltaTime || _) : 1
                      , y = 1 - f.frictionAir * (_ / u._baseDelta)
                      , w = (f.position.x - f.positionPrev.x) * v
                      , S = (f.position.y - f.positionPrev.y) * v;
                    f.velocity.x = w * y + f.force.x / f.mass * g,
                    f.velocity.y = S * y + f.force.y / f.mass * g,
                    f.positionPrev.x = f.position.x,
                    f.positionPrev.y = f.position.y,
                    f.position.x += f.velocity.x,
                    f.position.y += f.velocity.y,
                    f.deltaTime = _,
                    f.angularVelocity = (f.angle - f.anglePrev) * y * v + f.torque / f.inertia * g,
                    f.anglePrev = f.angle,
                    f.angle += f.angularVelocity;
                    for (var E = 0; E < f.parts.length; E++) {
                        var b = f.parts[E];
                        o.translate(b.vertices, f.velocity),
                        E > 0 && (b.position.x += f.velocity.x,
                        b.position.y += f.velocity.y),
                        f.angularVelocity !== 0 && (o.rotate(b.vertices, f.angularVelocity, f.position),
                        m.rotate(b.axes, f.angularVelocity),
                        E > 0 && a.rotateAbout(b.position, f.angularVelocity, f.position, b.position)),
                        h.update(b.bounds, b.vertices, f.velocity)
                    }
                }
                ,
                s.updateVelocities = function(f) {
                    var _ = s._baseDelta / f.deltaTime
                      , g = f.velocity;
                    g.x = (f.position.x - f.positionPrev.x) * _,
                    g.y = (f.position.y - f.positionPrev.y) * _,
                    f.speed = Math.sqrt(g.x * g.x + g.y * g.y),
                    f.angularVelocity = (f.angle - f.anglePrev) * _,
                    f.angularSpeed = Math.abs(f.angularVelocity)
                }
                ,
                s.applyForce = function(f, _, g) {
                    var v = {
                        x: _.x - f.position.x,
                        y: _.y - f.position.y
                    };
                    f.force.x += g.x,
                    f.force.y += g.y,
                    f.torque += v.x * g.y - v.y * g.x
                }
                ,
                s._totalProperties = function(f) {
                    for (var _ = {
                        mass: 0,
                        area: 0,
                        inertia: 0,
                        centre: {
                            x: 0,
                            y: 0
                        }
                    }, g = f.parts.length === 1 ? 0 : 1; g < f.parts.length; g++) {
                        var v = f.parts[g]
                          , y = v.mass !== 1 / 0 ? v.mass : 1;
                        _.mass += y,
                        _.area += v.area,
                        _.inertia += v.inertia,
                        _.centre = a.add(_.centre, a.mult(v.position, y))
                    }
                    return _.centre = a.div(_.centre, _.mass),
                    _
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(0);
            (function() {
                s.on = function(a, c, u) {
                    for (var h = c.split(" "), m, d = 0; d < h.length; d++)
                        m = h[d],
                        a.events = a.events || {},
                        a.events[m] = a.events[m] || [],
                        a.events[m].push(u);
                    return u
                }
                ,
                s.off = function(a, c, u) {
                    if (!c) {
                        a.events = {};
                        return
                    }
                    typeof c == "function" && (u = c,
                    c = o.keys(a.events).join(" "));
                    for (var h = c.split(" "), m = 0; m < h.length; m++) {
                        var d = a.events[h[m]]
                          , f = [];
                        if (u && d)
                            for (var _ = 0; _ < d.length; _++)
                                d[_] !== u && f.push(d[_]);
                        a.events[h[m]] = f
                    }
                }
                ,
                s.trigger = function(a, c, u) {
                    var h, m, d, f, _ = a.events;
                    if (_ && o.keys(_).length > 0) {
                        u || (u = {}),
                        h = c.split(" ");
                        for (var g = 0; g < h.length; g++)
                            if (m = h[g],
                            d = _[m],
                            d) {
                                f = o.clone(u, !1),
                                f.name = m,
                                f.source = a;
                                for (var v = 0; v < d.length; v++)
                                    d[v].apply(a, [f])
                            }
                    }
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(5)
              , a = r(0)
              , c = r(1)
              , u = r(4);
            (function() {
                s.create = function(h) {
                    return a.extend({
                        id: a.nextId(),
                        type: "composite",
                        parent: null,
                        isModified: !1,
                        bodies: [],
                        constraints: [],
                        composites: [],
                        label: "Composite",
                        plugin: {},
                        cache: {
                            allBodies: null,
                            allConstraints: null,
                            allComposites: null
                        }
                    }, h)
                }
                ,
                s.setModified = function(h, m, d, f) {
                    if (h.isModified = m,
                    m && h.cache && (h.cache.allBodies = null,
                    h.cache.allConstraints = null,
                    h.cache.allComposites = null),
                    d && h.parent && s.setModified(h.parent, m, d, f),
                    f)
                        for (var _ = 0; _ < h.composites.length; _++) {
                            var g = h.composites[_];
                            s.setModified(g, m, d, f)
                        }
                }
                ,
                s.add = function(h, m) {
                    var d = [].concat(m);
                    o.trigger(h, "beforeAdd", {
                        object: m
                    });
                    for (var f = 0; f < d.length; f++) {
                        var _ = d[f];
                        switch (_.type) {
                        case "body":
                            if (_.parent !== _) {
                                a.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
                                break
                            }
                            s.addBody(h, _);
                            break;
                        case "constraint":
                            s.addConstraint(h, _);
                            break;
                        case "composite":
                            s.addComposite(h, _);
                            break;
                        case "mouseConstraint":
                            s.addConstraint(h, _.constraint);
                            break
                        }
                    }
                    return o.trigger(h, "afterAdd", {
                        object: m
                    }),
                    h
                }
                ,
                s.remove = function(h, m, d) {
                    var f = [].concat(m);
                    o.trigger(h, "beforeRemove", {
                        object: m
                    });
                    for (var _ = 0; _ < f.length; _++) {
                        var g = f[_];
                        switch (g.type) {
                        case "body":
                            s.removeBody(h, g, d);
                            break;
                        case "constraint":
                            s.removeConstraint(h, g, d);
                            break;
                        case "composite":
                            s.removeComposite(h, g, d);
                            break;
                        case "mouseConstraint":
                            s.removeConstraint(h, g.constraint);
                            break
                        }
                    }
                    return o.trigger(h, "afterRemove", {
                        object: m
                    }),
                    h
                }
                ,
                s.addComposite = function(h, m) {
                    return h.composites.push(m),
                    m.parent = h,
                    s.setModified(h, !0, !0, !1),
                    h
                }
                ,
                s.removeComposite = function(h, m, d) {
                    var f = a.indexOf(h.composites, m);
                    if (f !== -1 && s.removeCompositeAt(h, f),
                    d)
                        for (var _ = 0; _ < h.composites.length; _++)
                            s.removeComposite(h.composites[_], m, !0);
                    return h
                }
                ,
                s.removeCompositeAt = function(h, m) {
                    return h.composites.splice(m, 1),
                    s.setModified(h, !0, !0, !1),
                    h
                }
                ,
                s.addBody = function(h, m) {
                    return h.bodies.push(m),
                    s.setModified(h, !0, !0, !1),
                    h
                }
                ,
                s.removeBody = function(h, m, d) {
                    var f = a.indexOf(h.bodies, m);
                    if (f !== -1 && s.removeBodyAt(h, f),
                    d)
                        for (var _ = 0; _ < h.composites.length; _++)
                            s.removeBody(h.composites[_], m, !0);
                    return h
                }
                ,
                s.removeBodyAt = function(h, m) {
                    return h.bodies.splice(m, 1),
                    s.setModified(h, !0, !0, !1),
                    h
                }
                ,
                s.addConstraint = function(h, m) {
                    return h.constraints.push(m),
                    s.setModified(h, !0, !0, !1),
                    h
                }
                ,
                s.removeConstraint = function(h, m, d) {
                    var f = a.indexOf(h.constraints, m);
                    if (f !== -1 && s.removeConstraintAt(h, f),
                    d)
                        for (var _ = 0; _ < h.composites.length; _++)
                            s.removeConstraint(h.composites[_], m, !0);
                    return h
                }
                ,
                s.removeConstraintAt = function(h, m) {
                    return h.constraints.splice(m, 1),
                    s.setModified(h, !0, !0, !1),
                    h
                }
                ,
                s.clear = function(h, m, d) {
                    if (d)
                        for (var f = 0; f < h.composites.length; f++)
                            s.clear(h.composites[f], m, !0);
                    return m ? h.bodies = h.bodies.filter(function(_) {
                        return _.isStatic
                    }) : h.bodies.length = 0,
                    h.constraints.length = 0,
                    h.composites.length = 0,
                    s.setModified(h, !0, !0, !1),
                    h
                }
                ,
                s.allBodies = function(h) {
                    if (h.cache && h.cache.allBodies)
                        return h.cache.allBodies;
                    for (var m = [].concat(h.bodies), d = 0; d < h.composites.length; d++)
                        m = m.concat(s.allBodies(h.composites[d]));
                    return h.cache && (h.cache.allBodies = m),
                    m
                }
                ,
                s.allConstraints = function(h) {
                    if (h.cache && h.cache.allConstraints)
                        return h.cache.allConstraints;
                    for (var m = [].concat(h.constraints), d = 0; d < h.composites.length; d++)
                        m = m.concat(s.allConstraints(h.composites[d]));
                    return h.cache && (h.cache.allConstraints = m),
                    m
                }
                ,
                s.allComposites = function(h) {
                    if (h.cache && h.cache.allComposites)
                        return h.cache.allComposites;
                    for (var m = [].concat(h.composites), d = 0; d < h.composites.length; d++)
                        m = m.concat(s.allComposites(h.composites[d]));
                    return h.cache && (h.cache.allComposites = m),
                    m
                }
                ,
                s.get = function(h, m, d) {
                    var f, _;
                    switch (d) {
                    case "body":
                        f = s.allBodies(h);
                        break;
                    case "constraint":
                        f = s.allConstraints(h);
                        break;
                    case "composite":
                        f = s.allComposites(h).concat(h);
                        break
                    }
                    return f ? (_ = f.filter(function(g) {
                        return g.id.toString() === m.toString()
                    }),
                    _.length === 0 ? null : _[0]) : null
                }
                ,
                s.move = function(h, m, d) {
                    return s.remove(h, m),
                    s.add(d, m),
                    h
                }
                ,
                s.rebase = function(h) {
                    for (var m = s.allBodies(h).concat(s.allConstraints(h)).concat(s.allComposites(h)), d = 0; d < m.length; d++)
                        m[d].id = a.nextId();
                    return h
                }
                ,
                s.translate = function(h, m, d) {
                    for (var f = d ? s.allBodies(h) : h.bodies, _ = 0; _ < f.length; _++)
                        u.translate(f[_], m);
                    return h
                }
                ,
                s.rotate = function(h, m, d, f) {
                    for (var _ = Math.cos(m), g = Math.sin(m), v = f ? s.allBodies(h) : h.bodies, y = 0; y < v.length; y++) {
                        var w = v[y]
                          , S = w.position.x - d.x
                          , E = w.position.y - d.y;
                        u.setPosition(w, {
                            x: d.x + (S * _ - E * g),
                            y: d.y + (S * g + E * _)
                        }),
                        u.rotate(w, m)
                    }
                    return h
                }
                ,
                s.scale = function(h, m, d, f, _) {
                    for (var g = _ ? s.allBodies(h) : h.bodies, v = 0; v < g.length; v++) {
                        var y = g[v]
                          , w = y.position.x - f.x
                          , S = y.position.y - f.y;
                        u.setPosition(y, {
                            x: f.x + w * m,
                            y: f.y + S * d
                        }),
                        u.scale(y, m, d)
                    }
                    return h
                }
                ,
                s.bounds = function(h) {
                    for (var m = s.allBodies(h), d = [], f = 0; f < m.length; f += 1) {
                        var _ = m[f];
                        d.push(_.bounds.min, _.bounds.max)
                    }
                    return c.create(d)
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(4)
              , a = r(5)
              , c = r(0);
            (function() {
                s._motionWakeThreshold = .18,
                s._motionSleepThreshold = .08,
                s._minBias = .9,
                s.update = function(u, h) {
                    for (var m = h / c._baseDelta, d = s._motionSleepThreshold, f = 0; f < u.length; f++) {
                        var _ = u[f]
                          , g = o.getSpeed(_)
                          , v = o.getAngularSpeed(_)
                          , y = g * g + v * v;
                        if (_.force.x !== 0 || _.force.y !== 0) {
                            s.set(_, !1);
                            continue
                        }
                        var w = Math.min(_.motion, y)
                          , S = Math.max(_.motion, y);
                        _.motion = s._minBias * w + (1 - s._minBias) * S,
                        _.sleepThreshold > 0 && _.motion < d ? (_.sleepCounter += 1,
                        _.sleepCounter >= _.sleepThreshold / m && s.set(_, !0)) : _.sleepCounter > 0 && (_.sleepCounter -= 1)
                    }
                }
                ,
                s.afterCollisions = function(u) {
                    for (var h = s._motionSleepThreshold, m = 0; m < u.length; m++) {
                        var d = u[m];
                        if (d.isActive) {
                            var f = d.collision
                              , _ = f.bodyA.parent
                              , g = f.bodyB.parent;
                            if (!(_.isSleeping && g.isSleeping || _.isStatic || g.isStatic) && (_.isSleeping || g.isSleeping)) {
                                var v = _.isSleeping && !_.isStatic ? _ : g
                                  , y = v === _ ? g : _;
                                !v.isStatic && y.motion > h && s.set(v, !1)
                            }
                        }
                    }
                }
                ,
                s.set = function(u, h) {
                    var m = u.isSleeping;
                    h ? (u.isSleeping = !0,
                    u.sleepCounter = u.sleepThreshold,
                    u.positionImpulse.x = 0,
                    u.positionImpulse.y = 0,
                    u.positionPrev.x = u.position.x,
                    u.positionPrev.y = u.position.y,
                    u.anglePrev = u.angle,
                    u.speed = 0,
                    u.angularSpeed = 0,
                    u.motion = 0,
                    m || a.trigger(u, "sleepStart")) : (u.isSleeping = !1,
                    u.sleepCounter = 0,
                    m && a.trigger(u, "sleepEnd"))
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(3)
              , a = r(9);
            (function() {
                var c = []
                  , u = {
                    overlap: 0,
                    axis: null
                }
                  , h = {
                    overlap: 0,
                    axis: null
                };
                s.create = function(m, d) {
                    return {
                        pair: null,
                        collided: !1,
                        bodyA: m,
                        bodyB: d,
                        parentA: m.parent,
                        parentB: d.parent,
                        depth: 0,
                        normal: {
                            x: 0,
                            y: 0
                        },
                        tangent: {
                            x: 0,
                            y: 0
                        },
                        penetration: {
                            x: 0,
                            y: 0
                        },
                        supports: []
                    }
                }
                ,
                s.collides = function(m, d, f) {
                    if (s._overlapAxes(u, m.vertices, d.vertices, m.axes),
                    u.overlap <= 0 || (s._overlapAxes(h, d.vertices, m.vertices, d.axes),
                    h.overlap <= 0))
                        return null;
                    var _ = f && f.table[a.id(m, d)], g;
                    _ ? g = _.collision : (g = s.create(m, d),
                    g.collided = !0,
                    g.bodyA = m.id < d.id ? m : d,
                    g.bodyB = m.id < d.id ? d : m,
                    g.parentA = g.bodyA.parent,
                    g.parentB = g.bodyB.parent),
                    m = g.bodyA,
                    d = g.bodyB;
                    var v;
                    u.overlap < h.overlap ? v = u : v = h;
                    var y = g.normal
                      , w = g.supports
                      , S = v.axis
                      , E = S.x
                      , b = S.y;
                    E * (d.position.x - m.position.x) + b * (d.position.y - m.position.y) < 0 ? (y.x = E,
                    y.y = b) : (y.x = -E,
                    y.y = -b),
                    g.tangent.x = -y.y,
                    g.tangent.y = y.x,
                    g.depth = v.overlap,
                    g.penetration.x = y.x * g.depth,
                    g.penetration.y = y.y * g.depth;
                    var T = s._findSupports(m, d, y, 1)
                      , C = 0;
                    if (o.contains(m.vertices, T[0]) && (w[C++] = T[0]),
                    o.contains(m.vertices, T[1]) && (w[C++] = T[1]),
                    C < 2) {
                        var P = s._findSupports(d, m, y, -1);
                        o.contains(d.vertices, P[0]) && (w[C++] = P[0]),
                        C < 2 && o.contains(d.vertices, P[1]) && (w[C++] = P[1])
                    }
                    return C === 0 && (w[C++] = T[0]),
                    w.length = C,
                    g
                }
                ,
                s._overlapAxes = function(m, d, f, _) {
                    var g = d.length, v = f.length, y = d[0].x, w = d[0].y, S = f[0].x, E = f[0].y, b = _.length, T = Number.MAX_VALUE, C = 0, P, A, R, I, D, H;
                    for (D = 0; D < b; D++) {
                        var B = _[D]
                          , G = B.x
                          , X = B.y
                          , V = y * G + w * X
                          , ee = S * G + E * X
                          , re = V
                          , k = ee;
                        for (H = 1; H < g; H += 1)
                            I = d[H].x * G + d[H].y * X,
                            I > re ? re = I : I < V && (V = I);
                        for (H = 1; H < v; H += 1)
                            I = f[H].x * G + f[H].y * X,
                            I > k ? k = I : I < ee && (ee = I);
                        if (A = re - ee,
                        R = k - V,
                        P = A < R ? A : R,
                        P < T && (T = P,
                        C = D,
                        P <= 0))
                            break
                    }
                    m.axis = _[C],
                    m.overlap = T
                }
                ,
                s._projectToAxis = function(m, d, f) {
                    for (var _ = d[0].x * f.x + d[0].y * f.y, g = _, v = 1; v < d.length; v += 1) {
                        var y = d[v].x * f.x + d[v].y * f.y;
                        y > g ? g = y : y < _ && (_ = y)
                    }
                    m.min = _,
                    m.max = g
                }
                ,
                s._findSupports = function(m, d, f, _) {
                    var g = d.vertices, v = g.length, y = m.position.x, w = m.position.y, S = f.x * _, E = f.y * _, b = Number.MAX_VALUE, T, C, P, A, R;
                    for (R = 0; R < v; R += 1)
                        C = g[R],
                        A = S * (y - C.x) + E * (w - C.y),
                        A < b && (b = A,
                        T = C);
                    return P = g[(v + T.index - 1) % v],
                    b = S * (y - P.x) + E * (w - P.y),
                    C = g[(T.index + 1) % v],
                    S * (y - C.x) + E * (w - C.y) < b ? (c[0] = T,
                    c[1] = C,
                    c) : (c[0] = T,
                    c[1] = P,
                    c)
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(16);
            (function() {
                s.create = function(a, c) {
                    var u = a.bodyA
                      , h = a.bodyB
                      , m = {
                        id: s.id(u, h),
                        bodyA: u,
                        bodyB: h,
                        collision: a,
                        contacts: [],
                        activeContacts: [],
                        separation: 0,
                        isActive: !0,
                        confirmedActive: !0,
                        isSensor: u.isSensor || h.isSensor,
                        timeCreated: c,
                        timeUpdated: c,
                        inverseMass: 0,
                        friction: 0,
                        frictionStatic: 0,
                        restitution: 0,
                        slop: 0
                    };
                    return s.update(m, a, c),
                    m
                }
                ,
                s.update = function(a, c, u) {
                    var h = a.contacts
                      , m = c.supports
                      , d = a.activeContacts
                      , f = c.parentA
                      , _ = c.parentB
                      , g = f.vertices.length;
                    a.isActive = !0,
                    a.timeUpdated = u,
                    a.collision = c,
                    a.separation = c.depth,
                    a.inverseMass = f.inverseMass + _.inverseMass,
                    a.friction = f.friction < _.friction ? f.friction : _.friction,
                    a.frictionStatic = f.frictionStatic > _.frictionStatic ? f.frictionStatic : _.frictionStatic,
                    a.restitution = f.restitution > _.restitution ? f.restitution : _.restitution,
                    a.slop = f.slop > _.slop ? f.slop : _.slop,
                    c.pair = a,
                    d.length = 0;
                    for (var v = 0; v < m.length; v++) {
                        var y = m[v]
                          , w = y.body === f ? y.index : g + y.index
                          , S = h[w];
                        S ? d.push(S) : d.push(h[w] = o.create(y))
                    }
                }
                ,
                s.setActive = function(a, c, u) {
                    c ? (a.isActive = !0,
                    a.timeUpdated = u) : (a.isActive = !1,
                    a.activeContacts.length = 0)
                }
                ,
                s.id = function(a, c) {
                    return a.id < c.id ? "A" + a.id + "B" + c.id : "A" + c.id + "B" + a.id
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(3)
              , a = r(2)
              , c = r(7)
              , u = r(1)
              , h = r(11)
              , m = r(0);
            (function() {
                s._warming = .4,
                s._torqueDampen = 1,
                s._minLength = 1e-6,
                s.create = function(d) {
                    var f = d;
                    f.bodyA && !f.pointA && (f.pointA = {
                        x: 0,
                        y: 0
                    }),
                    f.bodyB && !f.pointB && (f.pointB = {
                        x: 0,
                        y: 0
                    });
                    var _ = f.bodyA ? a.add(f.bodyA.position, f.pointA) : f.pointA
                      , g = f.bodyB ? a.add(f.bodyB.position, f.pointB) : f.pointB
                      , v = a.magnitude(a.sub(_, g));
                    f.length = typeof f.length < "u" ? f.length : v,
                    f.id = f.id || m.nextId(),
                    f.label = f.label || "Constraint",
                    f.type = "constraint",
                    f.stiffness = f.stiffness || (f.length > 0 ? 1 : .7),
                    f.damping = f.damping || 0,
                    f.angularStiffness = f.angularStiffness || 0,
                    f.angleA = f.bodyA ? f.bodyA.angle : f.angleA,
                    f.angleB = f.bodyB ? f.bodyB.angle : f.angleB,
                    f.plugin = {};
                    var y = {
                        visible: !0,
                        lineWidth: 2,
                        strokeStyle: "#ffffff",
                        type: "line",
                        anchors: !0
                    };
                    return f.length === 0 && f.stiffness > .1 ? (y.type = "pin",
                    y.anchors = !1) : f.stiffness < .9 && (y.type = "spring"),
                    f.render = m.extend(y, f.render),
                    f
                }
                ,
                s.preSolveAll = function(d) {
                    for (var f = 0; f < d.length; f += 1) {
                        var _ = d[f]
                          , g = _.constraintImpulse;
                        _.isStatic || g.x === 0 && g.y === 0 && g.angle === 0 || (_.position.x += g.x,
                        _.position.y += g.y,
                        _.angle += g.angle)
                    }
                }
                ,
                s.solveAll = function(d, f) {
                    for (var _ = m.clamp(f / m._baseDelta, 0, 1), g = 0; g < d.length; g += 1) {
                        var v = d[g]
                          , y = !v.bodyA || v.bodyA && v.bodyA.isStatic
                          , w = !v.bodyB || v.bodyB && v.bodyB.isStatic;
                        (y || w) && s.solve(d[g], _)
                    }
                    for (g = 0; g < d.length; g += 1)
                        v = d[g],
                        y = !v.bodyA || v.bodyA && v.bodyA.isStatic,
                        w = !v.bodyB || v.bodyB && v.bodyB.isStatic,
                        !y && !w && s.solve(d[g], _)
                }
                ,
                s.solve = function(d, f) {
                    var _ = d.bodyA
                      , g = d.bodyB
                      , v = d.pointA
                      , y = d.pointB;
                    if (!(!_ && !g)) {
                        _ && !_.isStatic && (a.rotate(v, _.angle - d.angleA, v),
                        d.angleA = _.angle),
                        g && !g.isStatic && (a.rotate(y, g.angle - d.angleB, y),
                        d.angleB = g.angle);
                        var w = v
                          , S = y;
                        if (_ && (w = a.add(_.position, v)),
                        g && (S = a.add(g.position, y)),
                        !(!w || !S)) {
                            var E = a.sub(w, S)
                              , b = a.magnitude(E);
                            b < s._minLength && (b = s._minLength);
                            var T = (b - d.length) / b, C = d.stiffness >= 1 || d.length === 0, P = C ? d.stiffness * f : d.stiffness * f * f, A = d.damping * f, R = a.mult(E, T * P), I = (_ ? _.inverseMass : 0) + (g ? g.inverseMass : 0), D = (_ ? _.inverseInertia : 0) + (g ? g.inverseInertia : 0), H = I + D, B, G, X, V, ee;
                            if (A > 0) {
                                var re = a.create();
                                X = a.div(E, b),
                                ee = a.sub(g && a.sub(g.position, g.positionPrev) || re, _ && a.sub(_.position, _.positionPrev) || re),
                                V = a.dot(X, ee)
                            }
                            _ && !_.isStatic && (G = _.inverseMass / I,
                            _.constraintImpulse.x -= R.x * G,
                            _.constraintImpulse.y -= R.y * G,
                            _.position.x -= R.x * G,
                            _.position.y -= R.y * G,
                            A > 0 && (_.positionPrev.x -= A * X.x * V * G,
                            _.positionPrev.y -= A * X.y * V * G),
                            B = a.cross(v, R) / H * s._torqueDampen * _.inverseInertia * (1 - d.angularStiffness),
                            _.constraintImpulse.angle -= B,
                            _.angle -= B),
                            g && !g.isStatic && (G = g.inverseMass / I,
                            g.constraintImpulse.x += R.x * G,
                            g.constraintImpulse.y += R.y * G,
                            g.position.x += R.x * G,
                            g.position.y += R.y * G,
                            A > 0 && (g.positionPrev.x += A * X.x * V * G,
                            g.positionPrev.y += A * X.y * V * G),
                            B = a.cross(y, R) / H * s._torqueDampen * g.inverseInertia * (1 - d.angularStiffness),
                            g.constraintImpulse.angle += B,
                            g.angle += B)
                        }
                    }
                }
                ,
                s.postSolveAll = function(d) {
                    for (var f = 0; f < d.length; f++) {
                        var _ = d[f]
                          , g = _.constraintImpulse;
                        if (!(_.isStatic || g.x === 0 && g.y === 0 && g.angle === 0)) {
                            c.set(_, !1);
                            for (var v = 0; v < _.parts.length; v++) {
                                var y = _.parts[v];
                                o.translate(y.vertices, g),
                                v > 0 && (y.position.x += g.x,
                                y.position.y += g.y),
                                g.angle !== 0 && (o.rotate(y.vertices, g.angle, _.position),
                                h.rotate(y.axes, g.angle),
                                v > 0 && a.rotateAbout(y.position, g.angle, _.position, y.position)),
                                u.update(y.bounds, y.vertices, _.velocity)
                            }
                            g.angle *= s._warming,
                            g.x *= s._warming,
                            g.y *= s._warming
                        }
                    }
                }
                ,
                s.pointAWorld = function(d) {
                    return {
                        x: (d.bodyA ? d.bodyA.position.x : 0) + (d.pointA ? d.pointA.x : 0),
                        y: (d.bodyA ? d.bodyA.position.y : 0) + (d.pointA ? d.pointA.y : 0)
                    }
                }
                ,
                s.pointBWorld = function(d) {
                    return {
                        x: (d.bodyB ? d.bodyB.position.x : 0) + (d.pointB ? d.pointB.x : 0),
                        y: (d.bodyB ? d.bodyB.position.y : 0) + (d.pointB ? d.pointB.y : 0)
                    }
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(2)
              , a = r(0);
            (function() {
                s.fromVertices = function(c) {
                    for (var u = {}, h = 0; h < c.length; h++) {
                        var m = (h + 1) % c.length
                          , d = o.normalise({
                            x: c[m].y - c[h].y,
                            y: c[h].x - c[m].x
                        })
                          , f = d.y === 0 ? 1 / 0 : d.x / d.y;
                        f = f.toFixed(3).toString(),
                        u[f] = d
                    }
                    return a.values(u)
                }
                ,
                s.rotate = function(c, u) {
                    if (u !== 0)
                        for (var h = Math.cos(u), m = Math.sin(u), d = 0; d < c.length; d++) {
                            var f = c[d], _;
                            _ = f.x * h - f.y * m,
                            f.y = f.x * m + f.y * h,
                            f.x = _
                        }
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(3)
              , a = r(0)
              , c = r(4)
              , u = r(1)
              , h = r(2);
            (function() {
                s.rectangle = function(m, d, f, _, g) {
                    g = g || {};
                    var v = {
                        label: "Rectangle Body",
                        position: {
                            x: m,
                            y: d
                        },
                        vertices: o.fromPath("L 0 0 L " + f + " 0 L " + f + " " + _ + " L 0 " + _)
                    };
                    if (g.chamfer) {
                        var y = g.chamfer;
                        v.vertices = o.chamfer(v.vertices, y.radius, y.quality, y.qualityMin, y.qualityMax),
                        delete g.chamfer
                    }
                    return c.create(a.extend({}, v, g))
                }
                ,
                s.trapezoid = function(m, d, f, _, g, v) {
                    v = v || {},
                    g *= .5;
                    var y = (1 - g * 2) * f, w = f * g, S = w + y, E = S + w, b;
                    g < .5 ? b = "L 0 0 L " + w + " " + -_ + " L " + S + " " + -_ + " L " + E + " 0" : b = "L 0 0 L " + S + " " + -_ + " L " + E + " 0";
                    var T = {
                        label: "Trapezoid Body",
                        position: {
                            x: m,
                            y: d
                        },
                        vertices: o.fromPath(b)
                    };
                    if (v.chamfer) {
                        var C = v.chamfer;
                        T.vertices = o.chamfer(T.vertices, C.radius, C.quality, C.qualityMin, C.qualityMax),
                        delete v.chamfer
                    }
                    return c.create(a.extend({}, T, v))
                }
                ,
                s.circle = function(m, d, f, _, g) {
                    _ = _ || {};
                    var v = {
                        label: "Circle Body",
                        circleRadius: f
                    };
                    g = g || 25;
                    var y = Math.ceil(Math.max(10, Math.min(g, f)));
                    return y % 2 === 1 && (y += 1),
                    s.polygon(m, d, y, f, a.extend({}, v, _))
                }
                ,
                s.polygon = function(m, d, f, _, g) {
                    if (g = g || {},
                    f < 3)
                        return s.circle(m, d, _, g);
                    for (var v = 2 * Math.PI / f, y = "", w = v * .5, S = 0; S < f; S += 1) {
                        var E = w + S * v
                          , b = Math.cos(E) * _
                          , T = Math.sin(E) * _;
                        y += "L " + b.toFixed(3) + " " + T.toFixed(3) + " "
                    }
                    var C = {
                        label: "Polygon Body",
                        position: {
                            x: m,
                            y: d
                        },
                        vertices: o.fromPath(y)
                    };
                    if (g.chamfer) {
                        var P = g.chamfer;
                        C.vertices = o.chamfer(C.vertices, P.radius, P.quality, P.qualityMin, P.qualityMax),
                        delete g.chamfer
                    }
                    return c.create(a.extend({}, C, g))
                }
                ,
                s.fromVertices = function(m, d, f, _, g, v, y, w) {
                    var S = a.getDecomp(), E, b, T, C, P, A, R, I, D, H, B;
                    for (E = !!(S && S.quickDecomp),
                    _ = _ || {},
                    T = [],
                    g = typeof g < "u" ? g : !1,
                    v = typeof v < "u" ? v : .01,
                    y = typeof y < "u" ? y : 10,
                    w = typeof w < "u" ? w : .01,
                    a.isArray(f[0]) || (f = [f]),
                    H = 0; H < f.length; H += 1)
                        if (A = f[H],
                        C = o.isConvex(A),
                        P = !C,
                        P && !E && a.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."),
                        C || !E)
                            C ? A = o.clockwiseSort(A) : A = o.hull(A),
                            T.push({
                                position: {
                                    x: m,
                                    y: d
                                },
                                vertices: A
                            });
                        else {
                            var G = A.map(function(Re) {
                                return [Re.x, Re.y]
                            });
                            S.makeCCW(G),
                            v !== !1 && S.removeCollinearPoints(G, v),
                            w !== !1 && S.removeDuplicatePoints && S.removeDuplicatePoints(G, w);
                            var X = S.quickDecomp(G);
                            for (R = 0; R < X.length; R++) {
                                var V = X[R]
                                  , ee = V.map(function(Re) {
                                    return {
                                        x: Re[0],
                                        y: Re[1]
                                    }
                                });
                                y > 0 && o.area(ee) < y || T.push({
                                    position: o.centre(ee),
                                    vertices: ee
                                })
                            }
                        }
                    for (R = 0; R < T.length; R++)
                        T[R] = c.create(a.extend(T[R], _));
                    if (g) {
                        var re = 5;
                        for (R = 0; R < T.length; R++) {
                            var k = T[R];
                            for (I = R + 1; I < T.length; I++) {
                                var oe = T[I];
                                if (u.overlaps(k.bounds, oe.bounds)) {
                                    var ae = k.vertices
                                      , ne = oe.vertices;
                                    for (D = 0; D < k.vertices.length; D++)
                                        for (B = 0; B < oe.vertices.length; B++) {
                                            var fe = h.magnitudeSquared(h.sub(ae[(D + 1) % ae.length], ne[B]))
                                              , xe = h.magnitudeSquared(h.sub(ae[D], ne[(B + 1) % ne.length]));
                                            fe < re && xe < re && (ae[D].isInternal = !0,
                                            ne[B].isInternal = !0)
                                        }
                                }
                            }
                        }
                    }
                    return T.length > 1 ? (b = c.create(a.extend({
                        parts: T.slice(0)
                    }, _)),
                    c.setPosition(b, {
                        x: m,
                        y: d
                    }),
                    b) : T[0]
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(0)
              , a = r(8);
            (function() {
                s.create = function(c) {
                    var u = {
                        bodies: [],
                        pairs: null
                    };
                    return o.extend(u, c)
                }
                ,
                s.setBodies = function(c, u) {
                    c.bodies = u.slice(0)
                }
                ,
                s.clear = function(c) {
                    c.bodies = []
                }
                ,
                s.collisions = function(c) {
                    var u = [], h = c.pairs, m = c.bodies, d = m.length, f = s.canCollide, _ = a.collides, g, v;
                    for (m.sort(s._compareBoundsX),
                    g = 0; g < d; g++) {
                        var y = m[g]
                          , w = y.bounds
                          , S = y.bounds.max.x
                          , E = y.bounds.max.y
                          , b = y.bounds.min.y
                          , T = y.isStatic || y.isSleeping
                          , C = y.parts.length
                          , P = C === 1;
                        for (v = g + 1; v < d; v++) {
                            var A = m[v]
                              , R = A.bounds;
                            if (R.min.x > S)
                                break;
                            if (!(E < R.min.y || b > R.max.y) && !(T && (A.isStatic || A.isSleeping)) && f(y.collisionFilter, A.collisionFilter)) {
                                var I = A.parts.length;
                                if (P && I === 1) {
                                    var D = _(y, A, h);
                                    D && u.push(D)
                                } else
                                    for (var H = C > 1 ? 1 : 0, B = I > 1 ? 1 : 0, G = H; G < C; G++)
                                        for (var X = y.parts[G], w = X.bounds, V = B; V < I; V++) {
                                            var ee = A.parts[V]
                                              , R = ee.bounds;
                                            if (!(w.min.x > R.max.x || w.max.x < R.min.x || w.max.y < R.min.y || w.min.y > R.max.y)) {
                                                var D = _(X, ee, h);
                                                D && u.push(D)
                                            }
                                        }
                            }
                        }
                    }
                    return u
                }
                ,
                s.canCollide = function(c, u) {
                    return c.group === u.group && c.group !== 0 ? c.group > 0 : (c.mask & u.category) !== 0 && (u.mask & c.category) !== 0
                }
                ,
                s._compareBoundsX = function(c, u) {
                    return c.bounds.min.x - u.bounds.min.x
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(0);
            (function() {
                s.create = function(a) {
                    var c = {};
                    return a || o.log("Mouse.create: element was undefined, defaulting to document.body", "warn"),
                    c.element = a || document.body,
                    c.absolute = {
                        x: 0,
                        y: 0
                    },
                    c.position = {
                        x: 0,
                        y: 0
                    },
                    c.mousedownPosition = {
                        x: 0,
                        y: 0
                    },
                    c.mouseupPosition = {
                        x: 0,
                        y: 0
                    },
                    c.offset = {
                        x: 0,
                        y: 0
                    },
                    c.scale = {
                        x: 1,
                        y: 1
                    },
                    c.wheelDelta = 0,
                    c.button = -1,
                    c.pixelRatio = parseInt(c.element.getAttribute("data-pixel-ratio"), 10) || 1,
                    c.sourceEvents = {
                        mousemove: null,
                        mousedown: null,
                        mouseup: null,
                        mousewheel: null
                    },
                    c.mousemove = function(u) {
                        var h = s._getRelativeMousePosition(u, c.element, c.pixelRatio)
                          , m = u.changedTouches;
                        m && (c.button = 0,
                        u.preventDefault()),
                        c.absolute.x = h.x,
                        c.absolute.y = h.y,
                        c.position.x = c.absolute.x * c.scale.x + c.offset.x,
                        c.position.y = c.absolute.y * c.scale.y + c.offset.y,
                        c.sourceEvents.mousemove = u
                    }
                    ,
                    c.mousedown = function(u) {
                        var h = s._getRelativeMousePosition(u, c.element, c.pixelRatio)
                          , m = u.changedTouches;
                        m ? (c.button = 0,
                        u.preventDefault()) : c.button = u.button,
                        c.absolute.x = h.x,
                        c.absolute.y = h.y,
                        c.position.x = c.absolute.x * c.scale.x + c.offset.x,
                        c.position.y = c.absolute.y * c.scale.y + c.offset.y,
                        c.mousedownPosition.x = c.position.x,
                        c.mousedownPosition.y = c.position.y,
                        c.sourceEvents.mousedown = u
                    }
                    ,
                    c.mouseup = function(u) {
                        var h = s._getRelativeMousePosition(u, c.element, c.pixelRatio)
                          , m = u.changedTouches;
                        m && u.preventDefault(),
                        c.button = -1,
                        c.absolute.x = h.x,
                        c.absolute.y = h.y,
                        c.position.x = c.absolute.x * c.scale.x + c.offset.x,
                        c.position.y = c.absolute.y * c.scale.y + c.offset.y,
                        c.mouseupPosition.x = c.position.x,
                        c.mouseupPosition.y = c.position.y,
                        c.sourceEvents.mouseup = u
                    }
                    ,
                    c.mousewheel = function(u) {
                        c.wheelDelta = Math.max(-1, Math.min(1, u.wheelDelta || -u.detail)),
                        u.preventDefault()
                    }
                    ,
                    s.setElement(c, c.element),
                    c
                }
                ,
                s.setElement = function(a, c) {
                    a.element = c,
                    c.addEventListener("mousemove", a.mousemove),
                    c.addEventListener("mousedown", a.mousedown),
                    c.addEventListener("mouseup", a.mouseup),
                    c.addEventListener("mousewheel", a.mousewheel),
                    c.addEventListener("DOMMouseScroll", a.mousewheel),
                    c.addEventListener("touchmove", a.mousemove),
                    c.addEventListener("touchstart", a.mousedown),
                    c.addEventListener("touchend", a.mouseup)
                }
                ,
                s.clearSourceEvents = function(a) {
                    a.sourceEvents.mousemove = null,
                    a.sourceEvents.mousedown = null,
                    a.sourceEvents.mouseup = null,
                    a.sourceEvents.mousewheel = null,
                    a.wheelDelta = 0
                }
                ,
                s.setOffset = function(a, c) {
                    a.offset.x = c.x,
                    a.offset.y = c.y,
                    a.position.x = a.absolute.x * a.scale.x + a.offset.x,
                    a.position.y = a.absolute.y * a.scale.y + a.offset.y
                }
                ,
                s.setScale = function(a, c) {
                    a.scale.x = c.x,
                    a.scale.y = c.y,
                    a.position.x = a.absolute.x * a.scale.x + a.offset.x,
                    a.position.y = a.absolute.y * a.scale.y + a.offset.y
                }
                ,
                s._getRelativeMousePosition = function(a, c, u) {
                    var h = c.getBoundingClientRect(), m = document.documentElement || document.body.parentNode || document.body, d = window.pageXOffset !== void 0 ? window.pageXOffset : m.scrollLeft, f = window.pageYOffset !== void 0 ? window.pageYOffset : m.scrollTop, _ = a.changedTouches, g, v;
                    return _ ? (g = _[0].pageX - h.left - d,
                    v = _[0].pageY - h.top - f) : (g = a.pageX - h.left - d,
                    v = a.pageY - h.top - f),
                    {
                        x: g / (c.clientWidth / (c.width || c.clientWidth) * u),
                        y: v / (c.clientHeight / (c.height || c.clientHeight) * u)
                    }
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(0);
            (function() {
                s._registry = {},
                s.register = function(a) {
                    if (s.isPlugin(a) || o.warn("Plugin.register:", s.toString(a), "does not implement all required fields."),
                    a.name in s._registry) {
                        var c = s._registry[a.name]
                          , u = s.versionParse(a.version).number
                          , h = s.versionParse(c.version).number;
                        u > h ? (o.warn("Plugin.register:", s.toString(c), "was upgraded to", s.toString(a)),
                        s._registry[a.name] = a) : u < h ? o.warn("Plugin.register:", s.toString(c), "can not be downgraded to", s.toString(a)) : a !== c && o.warn("Plugin.register:", s.toString(a), "is already registered to different plugin object")
                    } else
                        s._registry[a.name] = a;
                    return a
                }
                ,
                s.resolve = function(a) {
                    return s._registry[s.dependencyParse(a).name]
                }
                ,
                s.toString = function(a) {
                    return typeof a == "string" ? a : (a.name || "anonymous") + "@" + (a.version || a.range || "0.0.0")
                }
                ,
                s.isPlugin = function(a) {
                    return a && a.name && a.version && a.install
                }
                ,
                s.isUsed = function(a, c) {
                    return a.used.indexOf(c) > -1
                }
                ,
                s.isFor = function(a, c) {
                    var u = a.for && s.dependencyParse(a.for);
                    return !a.for || c.name === u.name && s.versionSatisfies(c.version, u.range)
                }
                ,
                s.use = function(a, c) {
                    if (a.uses = (a.uses || []).concat(c || []),
                    a.uses.length === 0) {
                        o.warn("Plugin.use:", s.toString(a), "does not specify any dependencies to install.");
                        return
                    }
                    for (var u = s.dependencies(a), h = o.topologicalSort(u), m = [], d = 0; d < h.length; d += 1)
                        if (h[d] !== a.name) {
                            var f = s.resolve(h[d]);
                            if (!f) {
                                m.push(" " + h[d]);
                                continue
                            }
                            s.isUsed(a, f.name) || (s.isFor(f, a) || (o.warn("Plugin.use:", s.toString(f), "is for", f.for, "but installed on", s.toString(a) + "."),
                            f._warned = !0),
                            f.install ? f.install(a) : (o.warn("Plugin.use:", s.toString(f), "does not specify an install function."),
                            f._warned = !0),
                            f._warned ? (m.push(" " + s.toString(f)),
                            delete f._warned) : m.push(" " + s.toString(f)),
                            a.used.push(f.name))
                        }
                    m.length > 0 && o.info(m.join("  "))
                }
                ,
                s.dependencies = function(a, c) {
                    var u = s.dependencyParse(a)
                      , h = u.name;
                    if (c = c || {},
                    !(h in c)) {
                        a = s.resolve(a) || a,
                        c[h] = o.map(a.uses || [], function(d) {
                            s.isPlugin(d) && s.register(d);
                            var f = s.dependencyParse(d)
                              , _ = s.resolve(d);
                            return _ && !s.versionSatisfies(_.version, f.range) ? (o.warn("Plugin.dependencies:", s.toString(_), "does not satisfy", s.toString(f), "used by", s.toString(u) + "."),
                            _._warned = !0,
                            a._warned = !0) : _ || (o.warn("Plugin.dependencies:", s.toString(d), "used by", s.toString(u), "could not be resolved."),
                            a._warned = !0),
                            f.name
                        });
                        for (var m = 0; m < c[h].length; m += 1)
                            s.dependencies(c[h][m], c);
                        return c
                    }
                }
                ,
                s.dependencyParse = function(a) {
                    if (o.isString(a)) {
                        var c = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/;
                        return c.test(a) || o.warn("Plugin.dependencyParse:", a, "is not a valid dependency string."),
                        {
                            name: a.split("@")[0],
                            range: a.split("@")[1] || "*"
                        }
                    }
                    return {
                        name: a.name,
                        range: a.range || a.version
                    }
                }
                ,
                s.versionParse = function(a) {
                    var c = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/;
                    c.test(a) || o.warn("Plugin.versionParse:", a, "is not a valid version or range.");
                    var u = c.exec(a)
                      , h = Number(u[4])
                      , m = Number(u[5])
                      , d = Number(u[6]);
                    return {
                        isRange: !!(u[1] || u[2]),
                        version: u[3],
                        range: a,
                        operator: u[1] || u[2] || "",
                        major: h,
                        minor: m,
                        patch: d,
                        parts: [h, m, d],
                        prerelease: u[7],
                        number: h * 1e8 + m * 1e4 + d
                    }
                }
                ,
                s.versionSatisfies = function(a, c) {
                    c = c || "*";
                    var u = s.versionParse(c)
                      , h = s.versionParse(a);
                    if (u.isRange) {
                        if (u.operator === "*" || a === "*")
                            return !0;
                        if (u.operator === ">")
                            return h.number > u.number;
                        if (u.operator === ">=")
                            return h.number >= u.number;
                        if (u.operator === "~")
                            return h.major === u.major && h.minor === u.minor && h.patch >= u.patch;
                        if (u.operator === "^")
                            return u.major > 0 ? h.major === u.major && h.number >= u.number : u.minor > 0 ? h.minor === u.minor && h.patch >= u.patch : h.patch === u.patch
                    }
                    return a === c || a === "*"
                }
            }
            )()
        }
        , function(t, i) {
            var r = {};
            t.exports = r,
            function() {
                r.create = function(s) {
                    return {
                        vertex: s,
                        normalImpulse: 0,
                        tangentImpulse: 0
                    }
                }
            }()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(7)
              , a = r(18)
              , c = r(13)
              , u = r(19)
              , h = r(5)
              , m = r(6)
              , d = r(10)
              , f = r(0)
              , _ = r(4);
            (function() {
                s.create = function(g) {
                    g = g || {};
                    var v = {
                        positionIterations: 6,
                        velocityIterations: 4,
                        constraintIterations: 2,
                        enableSleeping: !1,
                        events: [],
                        plugin: {},
                        gravity: {
                            x: 0,
                            y: 1,
                            scale: .001
                        },
                        timing: {
                            timestamp: 0,
                            timeScale: 1,
                            lastDelta: 0,
                            lastElapsed: 0
                        }
                    }
                      , y = f.extend(v, g);
                    return y.world = g.world || m.create({
                        label: "World"
                    }),
                    y.pairs = g.pairs || u.create(),
                    y.detector = g.detector || c.create(),
                    y.grid = {
                        buckets: []
                    },
                    y.world.gravity = y.gravity,
                    y.broadphase = y.grid,
                    y.metrics = {},
                    y
                }
                ,
                s.update = function(g, v) {
                    var y = f.now(), w = g.world, S = g.detector, E = g.pairs, b = g.timing, T = b.timestamp, C;
                    v = typeof v < "u" ? v : f._baseDelta,
                    v *= b.timeScale,
                    b.timestamp += v,
                    b.lastDelta = v;
                    var P = {
                        timestamp: b.timestamp,
                        delta: v
                    };
                    h.trigger(g, "beforeUpdate", P);
                    var A = m.allBodies(w)
                      , R = m.allConstraints(w);
                    for (w.isModified && (c.setBodies(S, A),
                    m.setModified(w, !1, !1, !0)),
                    g.enableSleeping && o.update(A, v),
                    s._bodiesApplyGravity(A, g.gravity),
                    v > 0 && s._bodiesUpdate(A, v),
                    d.preSolveAll(A),
                    C = 0; C < g.constraintIterations; C++)
                        d.solveAll(R, v);
                    d.postSolveAll(A),
                    S.pairs = g.pairs;
                    var I = c.collisions(S);
                    u.update(E, I, T),
                    g.enableSleeping && o.afterCollisions(E.list),
                    E.collisionStart.length > 0 && h.trigger(g, "collisionStart", {
                        pairs: E.collisionStart
                    });
                    var D = f.clamp(20 / g.positionIterations, 0, 1);
                    for (a.preSolvePosition(E.list),
                    C = 0; C < g.positionIterations; C++)
                        a.solvePosition(E.list, v, D);
                    for (a.postSolvePosition(A),
                    d.preSolveAll(A),
                    C = 0; C < g.constraintIterations; C++)
                        d.solveAll(R, v);
                    for (d.postSolveAll(A),
                    a.preSolveVelocity(E.list),
                    C = 0; C < g.velocityIterations; C++)
                        a.solveVelocity(E.list, v);
                    return s._bodiesUpdateVelocities(A),
                    E.collisionActive.length > 0 && h.trigger(g, "collisionActive", {
                        pairs: E.collisionActive
                    }),
                    E.collisionEnd.length > 0 && h.trigger(g, "collisionEnd", {
                        pairs: E.collisionEnd
                    }),
                    s._bodiesClearForces(A),
                    h.trigger(g, "afterUpdate", P),
                    g.timing.lastElapsed = f.now() - y,
                    g
                }
                ,
                s.merge = function(g, v) {
                    if (f.extend(g, v),
                    v.world) {
                        g.world = v.world,
                        s.clear(g);
                        for (var y = m.allBodies(g.world), w = 0; w < y.length; w++) {
                            var S = y[w];
                            o.set(S, !1),
                            S.id = f.nextId()
                        }
                    }
                }
                ,
                s.clear = function(g) {
                    u.clear(g.pairs),
                    c.clear(g.detector)
                }
                ,
                s._bodiesClearForces = function(g) {
                    for (var v = g.length, y = 0; y < v; y++) {
                        var w = g[y];
                        w.force.x = 0,
                        w.force.y = 0,
                        w.torque = 0
                    }
                }
                ,
                s._bodiesApplyGravity = function(g, v) {
                    var y = typeof v.scale < "u" ? v.scale : .001
                      , w = g.length;
                    if (!(v.x === 0 && v.y === 0 || y === 0))
                        for (var S = 0; S < w; S++) {
                            var E = g[S];
                            E.isStatic || E.isSleeping || (E.force.y += E.mass * v.y * y,
                            E.force.x += E.mass * v.x * y)
                        }
                }
                ,
                s._bodiesUpdate = function(g, v) {
                    for (var y = g.length, w = 0; w < y; w++) {
                        var S = g[w];
                        S.isStatic || S.isSleeping || _.update(S, v)
                    }
                }
                ,
                s._bodiesUpdateVelocities = function(g) {
                    for (var v = g.length, y = 0; y < v; y++)
                        _.updateVelocities(g[y])
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(3)
              , a = r(0)
              , c = r(1);
            (function() {
                s._restingThresh = 2,
                s._restingThreshTangent = Math.sqrt(6),
                s._positionDampen = .9,
                s._positionWarming = .8,
                s._frictionNormalMultiplier = 5,
                s._frictionMaxStatic = Number.MAX_VALUE,
                s.preSolvePosition = function(u) {
                    var h, m, d, f = u.length;
                    for (h = 0; h < f; h++)
                        m = u[h],
                        m.isActive && (d = m.activeContacts.length,
                        m.collision.parentA.totalContacts += d,
                        m.collision.parentB.totalContacts += d)
                }
                ,
                s.solvePosition = function(u, h, m) {
                    var d, f, _, g, v, y, w, S, E = s._positionDampen * (m || 1), b = a.clamp(h / a._baseDelta, 0, 1), T = u.length;
                    for (d = 0; d < T; d++)
                        f = u[d],
                        !(!f.isActive || f.isSensor) && (_ = f.collision,
                        g = _.parentA,
                        v = _.parentB,
                        y = _.normal,
                        f.separation = y.x * (v.positionImpulse.x + _.penetration.x - g.positionImpulse.x) + y.y * (v.positionImpulse.y + _.penetration.y - g.positionImpulse.y));
                    for (d = 0; d < T; d++)
                        f = u[d],
                        !(!f.isActive || f.isSensor) && (_ = f.collision,
                        g = _.parentA,
                        v = _.parentB,
                        y = _.normal,
                        S = f.separation - f.slop * b,
                        (g.isStatic || v.isStatic) && (S *= 2),
                        g.isStatic || g.isSleeping || (w = E / g.totalContacts,
                        g.positionImpulse.x += y.x * S * w,
                        g.positionImpulse.y += y.y * S * w),
                        v.isStatic || v.isSleeping || (w = E / v.totalContacts,
                        v.positionImpulse.x -= y.x * S * w,
                        v.positionImpulse.y -= y.y * S * w))
                }
                ,
                s.postSolvePosition = function(u) {
                    for (var h = s._positionWarming, m = u.length, d = o.translate, f = c.update, _ = 0; _ < m; _++) {
                        var g = u[_]
                          , v = g.positionImpulse
                          , y = v.x
                          , w = v.y
                          , S = g.velocity;
                        if (g.totalContacts = 0,
                        y !== 0 || w !== 0) {
                            for (var E = 0; E < g.parts.length; E++) {
                                var b = g.parts[E];
                                d(b.vertices, v),
                                f(b.bounds, b.vertices, S),
                                b.position.x += y,
                                b.position.y += w
                            }
                            g.positionPrev.x += y,
                            g.positionPrev.y += w,
                            y * S.x + w * S.y < 0 ? (v.x = 0,
                            v.y = 0) : (v.x *= h,
                            v.y *= h)
                        }
                    }
                }
                ,
                s.preSolveVelocity = function(u) {
                    var h = u.length, m, d;
                    for (m = 0; m < h; m++) {
                        var f = u[m];
                        if (!(!f.isActive || f.isSensor)) {
                            var _ = f.activeContacts
                              , g = _.length
                              , v = f.collision
                              , y = v.parentA
                              , w = v.parentB
                              , S = v.normal
                              , E = v.tangent;
                            for (d = 0; d < g; d++) {
                                var b = _[d]
                                  , T = b.vertex
                                  , C = b.normalImpulse
                                  , P = b.tangentImpulse;
                                if (C !== 0 || P !== 0) {
                                    var A = S.x * C + E.x * P
                                      , R = S.y * C + E.y * P;
                                    y.isStatic || y.isSleeping || (y.positionPrev.x += A * y.inverseMass,
                                    y.positionPrev.y += R * y.inverseMass,
                                    y.anglePrev += y.inverseInertia * ((T.x - y.position.x) * R - (T.y - y.position.y) * A)),
                                    w.isStatic || w.isSleeping || (w.positionPrev.x -= A * w.inverseMass,
                                    w.positionPrev.y -= R * w.inverseMass,
                                    w.anglePrev -= w.inverseInertia * ((T.x - w.position.x) * R - (T.y - w.position.y) * A))
                                }
                            }
                        }
                    }
                }
                ,
                s.solveVelocity = function(u, h) {
                    var m = h / a._baseDelta, d = m * m, f = d * m, _ = -s._restingThresh * m, g = s._restingThreshTangent, v = s._frictionNormalMultiplier * m, y = s._frictionMaxStatic, w = u.length, S, E, b, T;
                    for (b = 0; b < w; b++) {
                        var C = u[b];
                        if (!(!C.isActive || C.isSensor)) {
                            var P = C.collision
                              , A = P.parentA
                              , R = P.parentB
                              , I = A.velocity
                              , D = R.velocity
                              , H = P.normal.x
                              , B = P.normal.y
                              , G = P.tangent.x
                              , X = P.tangent.y
                              , V = C.activeContacts
                              , ee = V.length
                              , re = 1 / ee
                              , k = A.inverseMass + R.inverseMass
                              , oe = C.friction * C.frictionStatic * v;
                            for (I.x = A.position.x - A.positionPrev.x,
                            I.y = A.position.y - A.positionPrev.y,
                            D.x = R.position.x - R.positionPrev.x,
                            D.y = R.position.y - R.positionPrev.y,
                            A.angularVelocity = A.angle - A.anglePrev,
                            R.angularVelocity = R.angle - R.anglePrev,
                            T = 0; T < ee; T++) {
                                var ae = V[T]
                                  , ne = ae.vertex
                                  , fe = ne.x - A.position.x
                                  , xe = ne.y - A.position.y
                                  , Re = ne.x - R.position.x
                                  , Ue = ne.y - R.position.y
                                  , He = I.x - xe * A.angularVelocity
                                  , qe = I.y + fe * A.angularVelocity
                                  , Xe = D.x - Ue * R.angularVelocity
                                  , st = D.y + Re * R.angularVelocity
                                  , ie = He - Xe
                                  , dt = qe - st
                                  , Ne = H * ie + B * dt
                                  , Ye = G * ie + X * dt
                                  , Qe = C.separation + Ne
                                  , te = Math.min(Qe, 1);
                                te = Qe < 0 ? 0 : te;
                                var ot = te * oe;
                                Ye < -ot || Ye > ot ? (E = Ye > 0 ? Ye : -Ye,
                                S = C.friction * (Ye > 0 ? 1 : -1) * f,
                                S < -E ? S = -E : S > E && (S = E)) : (S = Ye,
                                E = y);
                                var ft = fe * B - xe * H
                                  , Tt = Re * B - Ue * H
                                  , pt = re / (k + A.inverseInertia * ft * ft + R.inverseInertia * Tt * Tt)
                                  , Ct = (1 + C.restitution) * Ne * pt;
                                if (S *= pt,
                                Ne < _)
                                    ae.normalImpulse = 0;
                                else {
                                    var z = ae.normalImpulse;
                                    ae.normalImpulse += Ct,
                                    ae.normalImpulse > 0 && (ae.normalImpulse = 0),
                                    Ct = ae.normalImpulse - z
                                }
                                if (Ye < -g || Ye > g)
                                    ae.tangentImpulse = 0;
                                else {
                                    var N = ae.tangentImpulse;
                                    ae.tangentImpulse += S,
                                    ae.tangentImpulse < -E && (ae.tangentImpulse = -E),
                                    ae.tangentImpulse > E && (ae.tangentImpulse = E),
                                    S = ae.tangentImpulse - N
                                }
                                var j = H * Ct + G * S
                                  , he = B * Ct + X * S;
                                A.isStatic || A.isSleeping || (A.positionPrev.x += j * A.inverseMass,
                                A.positionPrev.y += he * A.inverseMass,
                                A.anglePrev += (fe * he - xe * j) * A.inverseInertia),
                                R.isStatic || R.isSleeping || (R.positionPrev.x -= j * R.inverseMass,
                                R.positionPrev.y -= he * R.inverseMass,
                                R.anglePrev -= (Re * he - Ue * j) * R.inverseInertia)
                            }
                        }
                    }
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(9)
              , a = r(0);
            (function() {
                s.create = function(c) {
                    return a.extend({
                        table: {},
                        list: [],
                        collisionStart: [],
                        collisionActive: [],
                        collisionEnd: []
                    }, c)
                }
                ,
                s.update = function(c, u, h) {
                    var m = c.list, d = m.length, f = c.table, _ = u.length, g = c.collisionStart, v = c.collisionEnd, y = c.collisionActive, w, S, E, b;
                    for (g.length = 0,
                    v.length = 0,
                    y.length = 0,
                    b = 0; b < d; b++)
                        m[b].confirmedActive = !1;
                    for (b = 0; b < _; b++)
                        w = u[b],
                        E = w.pair,
                        E ? (E.isActive ? y.push(E) : g.push(E),
                        o.update(E, w, h),
                        E.confirmedActive = !0) : (E = o.create(w, h),
                        f[E.id] = E,
                        g.push(E),
                        m.push(E));
                    var T = [];
                    for (d = m.length,
                    b = 0; b < d; b++)
                        E = m[b],
                        E.confirmedActive || (o.setActive(E, !1, h),
                        v.push(E),
                        !E.collision.bodyA.isSleeping && !E.collision.bodyB.isSleeping && T.push(b));
                    for (b = 0; b < T.length; b++)
                        S = T[b] - b,
                        E = m[S],
                        m.splice(S, 1),
                        delete f[E.id]
                }
                ,
                s.clear = function(c) {
                    return c.table = {},
                    c.list.length = 0,
                    c.collisionStart.length = 0,
                    c.collisionActive.length = 0,
                    c.collisionEnd.length = 0,
                    c
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = t.exports = r(21);
            s.Axes = r(11),
            s.Bodies = r(12),
            s.Body = r(4),
            s.Bounds = r(1),
            s.Collision = r(8),
            s.Common = r(0),
            s.Composite = r(6),
            s.Composites = r(22),
            s.Constraint = r(10),
            s.Contact = r(16),
            s.Detector = r(13),
            s.Engine = r(17),
            s.Events = r(5),
            s.Grid = r(23),
            s.Mouse = r(14),
            s.MouseConstraint = r(24),
            s.Pair = r(9),
            s.Pairs = r(19),
            s.Plugin = r(15),
            s.Query = r(25),
            s.Render = r(26),
            s.Resolver = r(18),
            s.Runner = r(27),
            s.SAT = r(28),
            s.Sleeping = r(7),
            s.Svg = r(29),
            s.Vector = r(2),
            s.Vertices = r(3),
            s.World = r(30),
            s.Engine.run = s.Runner.run,
            s.Common.deprecated(s.Engine, "run", "Engine.run  use Matter.Runner.run(engine) instead")
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(15)
              , a = r(0);
            (function() {
                s.name = "matter-js",
                s.version = "0.19.0",
                s.uses = [],
                s.used = [],
                s.use = function() {
                    o.use(s, Array.prototype.slice.call(arguments))
                }
                ,
                s.before = function(c, u) {
                    return c = c.replace(/^Matter./, ""),
                    a.chainPathBefore(s, c, u)
                }
                ,
                s.after = function(c, u) {
                    return c = c.replace(/^Matter./, ""),
                    a.chainPathAfter(s, c, u)
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(6)
              , a = r(10)
              , c = r(0)
              , u = r(4)
              , h = r(12)
              , m = c.deprecated;
            (function() {
                s.stack = function(d, f, _, g, v, y, w) {
                    for (var S = o.create({
                        label: "Stack"
                    }), E = d, b = f, T, C = 0, P = 0; P < g; P++) {
                        for (var A = 0, R = 0; R < _; R++) {
                            var I = w(E, b, R, P, T, C);
                            if (I) {
                                var D = I.bounds.max.y - I.bounds.min.y
                                  , H = I.bounds.max.x - I.bounds.min.x;
                                D > A && (A = D),
                                u.translate(I, {
                                    x: H * .5,
                                    y: D * .5
                                }),
                                E = I.bounds.max.x + v,
                                o.addBody(S, I),
                                T = I,
                                C += 1
                            } else
                                E += v
                        }
                        b += A + y,
                        E = d
                    }
                    return S
                }
                ,
                s.chain = function(d, f, _, g, v, y) {
                    for (var w = d.bodies, S = 1; S < w.length; S++) {
                        var E = w[S - 1]
                          , b = w[S]
                          , T = E.bounds.max.y - E.bounds.min.y
                          , C = E.bounds.max.x - E.bounds.min.x
                          , P = b.bounds.max.y - b.bounds.min.y
                          , A = b.bounds.max.x - b.bounds.min.x
                          , R = {
                            bodyA: E,
                            pointA: {
                                x: C * f,
                                y: T * _
                            },
                            bodyB: b,
                            pointB: {
                                x: A * g,
                                y: P * v
                            }
                        }
                          , I = c.extend(R, y);
                        o.addConstraint(d, a.create(I))
                    }
                    return d.label += " Chain",
                    d
                }
                ,
                s.mesh = function(d, f, _, g, v) {
                    var y = d.bodies, w, S, E, b, T;
                    for (w = 0; w < _; w++) {
                        for (S = 1; S < f; S++)
                            E = y[S - 1 + w * f],
                            b = y[S + w * f],
                            o.addConstraint(d, a.create(c.extend({
                                bodyA: E,
                                bodyB: b
                            }, v)));
                        if (w > 0)
                            for (S = 0; S < f; S++)
                                E = y[S + (w - 1) * f],
                                b = y[S + w * f],
                                o.addConstraint(d, a.create(c.extend({
                                    bodyA: E,
                                    bodyB: b
                                }, v))),
                                g && S > 0 && (T = y[S - 1 + (w - 1) * f],
                                o.addConstraint(d, a.create(c.extend({
                                    bodyA: T,
                                    bodyB: b
                                }, v)))),
                                g && S < f - 1 && (T = y[S + 1 + (w - 1) * f],
                                o.addConstraint(d, a.create(c.extend({
                                    bodyA: T,
                                    bodyB: b
                                }, v))))
                    }
                    return d.label += " Mesh",
                    d
                }
                ,
                s.pyramid = function(d, f, _, g, v, y, w) {
                    return s.stack(d, f, _, g, v, y, function(S, E, b, T, C, P) {
                        var A = Math.min(g, Math.ceil(_ / 2))
                          , R = C ? C.bounds.max.x - C.bounds.min.x : 0;
                        if (!(T > A)) {
                            T = A - T;
                            var I = T
                              , D = _ - 1 - T;
                            if (!(b < I || b > D)) {
                                P === 1 && u.translate(C, {
                                    x: (b + (_ % 2 === 1 ? 1 : -1)) * R,
                                    y: 0
                                });
                                var H = C ? b * R : 0;
                                return w(d + H + b * v, E, b, T, C, P)
                            }
                        }
                    })
                }
                ,
                s.newtonsCradle = function(d, f, _, g, v) {
                    for (var y = o.create({
                        label: "Newtons Cradle"
                    }), w = 0; w < _; w++) {
                        var S = 1.9
                          , E = h.circle(d + w * (g * S), f + v, g, {
                            inertia: 1 / 0,
                            restitution: 1,
                            friction: 0,
                            frictionAir: 1e-4,
                            slop: 1
                        })
                          , b = a.create({
                            pointA: {
                                x: d + w * (g * S),
                                y: f
                            },
                            bodyB: E
                        });
                        o.addBody(y, E),
                        o.addConstraint(y, b)
                    }
                    return y
                }
                ,
                m(s, "newtonsCradle", "Composites.newtonsCradle  moved to newtonsCradle example"),
                s.car = function(d, f, _, g, v) {
                    var y = u.nextGroup(!0)
                      , w = 20
                      , S = -_ * .5 + w
                      , E = _ * .5 - w
                      , b = 0
                      , T = o.create({
                        label: "Car"
                    })
                      , C = h.rectangle(d, f, _, g, {
                        collisionFilter: {
                            group: y
                        },
                        chamfer: {
                            radius: g * .5
                        },
                        density: 2e-4
                    })
                      , P = h.circle(d + S, f + b, v, {
                        collisionFilter: {
                            group: y
                        },
                        friction: .8
                    })
                      , A = h.circle(d + E, f + b, v, {
                        collisionFilter: {
                            group: y
                        },
                        friction: .8
                    })
                      , R = a.create({
                        bodyB: C,
                        pointB: {
                            x: S,
                            y: b
                        },
                        bodyA: P,
                        stiffness: 1,
                        length: 0
                    })
                      , I = a.create({
                        bodyB: C,
                        pointB: {
                            x: E,
                            y: b
                        },
                        bodyA: A,
                        stiffness: 1,
                        length: 0
                    });
                    return o.addBody(T, C),
                    o.addBody(T, P),
                    o.addBody(T, A),
                    o.addConstraint(T, R),
                    o.addConstraint(T, I),
                    T
                }
                ,
                m(s, "car", "Composites.car  moved to car example"),
                s.softBody = function(d, f, _, g, v, y, w, S, E, b) {
                    E = c.extend({
                        inertia: 1 / 0
                    }, E),
                    b = c.extend({
                        stiffness: .2,
                        render: {
                            type: "line",
                            anchors: !1
                        }
                    }, b);
                    var T = s.stack(d, f, _, g, v, y, function(C, P) {
                        return h.circle(C, P, S, E)
                    });
                    return s.mesh(T, _, g, w, b),
                    T.label = "Soft Body",
                    T
                }
                ,
                m(s, "softBody", "Composites.softBody  moved to softBody and cloth examples")
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(9)
              , a = r(0)
              , c = a.deprecated;
            (function() {
                s.create = function(u) {
                    var h = {
                        buckets: {},
                        pairs: {},
                        pairsList: [],
                        bucketWidth: 48,
                        bucketHeight: 48
                    };
                    return a.extend(h, u)
                }
                ,
                s.update = function(u, h, m, d) {
                    var f, _, g, v = m.world, y = u.buckets, w, S, E = !1;
                    for (f = 0; f < h.length; f++) {
                        var b = h[f];
                        if (!(b.isSleeping && !d) && !(v.bounds && (b.bounds.max.x < v.bounds.min.x || b.bounds.min.x > v.bounds.max.x || b.bounds.max.y < v.bounds.min.y || b.bounds.min.y > v.bounds.max.y))) {
                            var T = s._getRegion(u, b);
                            if (!b.region || T.id !== b.region.id || d) {
                                (!b.region || d) && (b.region = T);
                                var C = s._regionUnion(T, b.region);
                                for (_ = C.startCol; _ <= C.endCol; _++)
                                    for (g = C.startRow; g <= C.endRow; g++) {
                                        S = s._getBucketId(_, g),
                                        w = y[S];
                                        var P = _ >= T.startCol && _ <= T.endCol && g >= T.startRow && g <= T.endRow
                                          , A = _ >= b.region.startCol && _ <= b.region.endCol && g >= b.region.startRow && g <= b.region.endRow;
                                        !P && A && A && w && s._bucketRemoveBody(u, w, b),
                                        (b.region === T || P && !A || d) && (w || (w = s._createBucket(y, S)),
                                        s._bucketAddBody(u, w, b))
                                    }
                                b.region = T,
                                E = !0
                            }
                        }
                    }
                    E && (u.pairsList = s._createActivePairsList(u))
                }
                ,
                c(s, "update", "Grid.update  replaced by Matter.Detector"),
                s.clear = function(u) {
                    u.buckets = {},
                    u.pairs = {},
                    u.pairsList = []
                }
                ,
                c(s, "clear", "Grid.clear  replaced by Matter.Detector"),
                s._regionUnion = function(u, h) {
                    var m = Math.min(u.startCol, h.startCol)
                      , d = Math.max(u.endCol, h.endCol)
                      , f = Math.min(u.startRow, h.startRow)
                      , _ = Math.max(u.endRow, h.endRow);
                    return s._createRegion(m, d, f, _)
                }
                ,
                s._getRegion = function(u, h) {
                    var m = h.bounds
                      , d = Math.floor(m.min.x / u.bucketWidth)
                      , f = Math.floor(m.max.x / u.bucketWidth)
                      , _ = Math.floor(m.min.y / u.bucketHeight)
                      , g = Math.floor(m.max.y / u.bucketHeight);
                    return s._createRegion(d, f, _, g)
                }
                ,
                s._createRegion = function(u, h, m, d) {
                    return {
                        id: u + "," + h + "," + m + "," + d,
                        startCol: u,
                        endCol: h,
                        startRow: m,
                        endRow: d
                    }
                }
                ,
                s._getBucketId = function(u, h) {
                    return "C" + u + "R" + h
                }
                ,
                s._createBucket = function(u, h) {
                    var m = u[h] = [];
                    return m
                }
                ,
                s._bucketAddBody = function(u, h, m) {
                    var d = u.pairs, f = o.id, _ = h.length, g;
                    for (g = 0; g < _; g++) {
                        var v = h[g];
                        if (!(m.id === v.id || m.isStatic && v.isStatic)) {
                            var y = f(m, v)
                              , w = d[y];
                            w ? w[2] += 1 : d[y] = [m, v, 1]
                        }
                    }
                    h.push(m)
                }
                ,
                s._bucketRemoveBody = function(u, h, m) {
                    var d = u.pairs, f = o.id, _;
                    h.splice(a.indexOf(h, m), 1);
                    var g = h.length;
                    for (_ = 0; _ < g; _++) {
                        var v = d[f(m, h[_])];
                        v && (v[2] -= 1)
                    }
                }
                ,
                s._createActivePairsList = function(u) {
                    var h, m = u.pairs, d = a.keys(m), f = d.length, _ = [], g;
                    for (g = 0; g < f; g++)
                        h = m[d[g]],
                        h[2] > 0 ? _.push(h) : delete m[d[g]];
                    return _
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(3)
              , a = r(7)
              , c = r(14)
              , u = r(5)
              , h = r(13)
              , m = r(10)
              , d = r(6)
              , f = r(0)
              , _ = r(1);
            (function() {
                s.create = function(g, v) {
                    var y = (g ? g.mouse : null) || (v ? v.mouse : null);
                    y || (g && g.render && g.render.canvas ? y = c.create(g.render.canvas) : v && v.element ? y = c.create(v.element) : (y = c.create(),
                    f.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected")));
                    var w = m.create({
                        label: "Mouse Constraint",
                        pointA: y.position,
                        pointB: {
                            x: 0,
                            y: 0
                        },
                        length: .01,
                        stiffness: .1,
                        angularStiffness: 1,
                        render: {
                            strokeStyle: "#90EE90",
                            lineWidth: 3
                        }
                    })
                      , S = {
                        type: "mouseConstraint",
                        mouse: y,
                        element: null,
                        body: null,
                        constraint: w,
                        collisionFilter: {
                            category: 1,
                            mask: 4294967295,
                            group: 0
                        }
                    }
                      , E = f.extend(S, v);
                    return u.on(g, "beforeUpdate", function() {
                        var b = d.allBodies(g.world);
                        s.update(E, b),
                        s._triggerEvents(E)
                    }),
                    E
                }
                ,
                s.update = function(g, v) {
                    var y = g.mouse
                      , w = g.constraint
                      , S = g.body;
                    if (y.button === 0) {
                        if (w.bodyB)
                            a.set(w.bodyB, !1),
                            w.pointA = y.position;
                        else
                            for (var E = 0; E < v.length; E++)
                                if (S = v[E],
                                _.contains(S.bounds, y.position) && h.canCollide(S.collisionFilter, g.collisionFilter))
                                    for (var b = S.parts.length > 1 ? 1 : 0; b < S.parts.length; b++) {
                                        var T = S.parts[b];
                                        if (o.contains(T.vertices, y.position)) {
                                            w.pointA = y.position,
                                            w.bodyB = g.body = S,
                                            w.pointB = {
                                                x: y.position.x - S.position.x,
                                                y: y.position.y - S.position.y
                                            },
                                            w.angleB = S.angle,
                                            a.set(S, !1),
                                            u.trigger(g, "startdrag", {
                                                mouse: y,
                                                body: S
                                            });
                                            break
                                        }
                                    }
                    } else
                        w.bodyB = g.body = null,
                        w.pointB = null,
                        S && u.trigger(g, "enddrag", {
                            mouse: y,
                            body: S
                        })
                }
                ,
                s._triggerEvents = function(g) {
                    var v = g.mouse
                      , y = v.sourceEvents;
                    y.mousemove && u.trigger(g, "mousemove", {
                        mouse: v
                    }),
                    y.mousedown && u.trigger(g, "mousedown", {
                        mouse: v
                    }),
                    y.mouseup && u.trigger(g, "mouseup", {
                        mouse: v
                    }),
                    c.clearSourceEvents(v)
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(2)
              , a = r(8)
              , c = r(1)
              , u = r(12)
              , h = r(3);
            (function() {
                s.collides = function(m, d) {
                    for (var f = [], _ = d.length, g = m.bounds, v = a.collides, y = c.overlaps, w = 0; w < _; w++) {
                        var S = d[w]
                          , E = S.parts.length
                          , b = E === 1 ? 0 : 1;
                        if (y(S.bounds, g))
                            for (var T = b; T < E; T++) {
                                var C = S.parts[T];
                                if (y(C.bounds, g)) {
                                    var P = v(C, m);
                                    if (P) {
                                        f.push(P);
                                        break
                                    }
                                }
                            }
                    }
                    return f
                }
                ,
                s.ray = function(m, d, f, _) {
                    _ = _ || 1e-100;
                    for (var g = o.angle(d, f), v = o.magnitude(o.sub(d, f)), y = (f.x + d.x) * .5, w = (f.y + d.y) * .5, S = u.rectangle(y, w, v, _, {
                        angle: g
                    }), E = s.collides(S, m), b = 0; b < E.length; b += 1) {
                        var T = E[b];
                        T.body = T.bodyB = T.bodyA
                    }
                    return E
                }
                ,
                s.region = function(m, d, f) {
                    for (var _ = [], g = 0; g < m.length; g++) {
                        var v = m[g]
                          , y = c.overlaps(v.bounds, d);
                        (y && !f || !y && f) && _.push(v)
                    }
                    return _
                }
                ,
                s.point = function(m, d) {
                    for (var f = [], _ = 0; _ < m.length; _++) {
                        var g = m[_];
                        if (c.contains(g.bounds, d))
                            for (var v = g.parts.length === 1 ? 0 : 1; v < g.parts.length; v++) {
                                var y = g.parts[v];
                                if (c.contains(y.bounds, d) && h.contains(y.vertices, d)) {
                                    f.push(g);
                                    break
                                }
                            }
                    }
                    return f
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(4)
              , a = r(0)
              , c = r(6)
              , u = r(1)
              , h = r(5)
              , m = r(2)
              , d = r(14);
            (function() {
                var f, _;
                typeof window < "u" && (f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(b) {
                    window.setTimeout(function() {
                        b(a.now())
                    }, 1e3 / 60)
                }
                ,
                _ = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame),
                s._goodFps = 30,
                s._goodDelta = 1e3 / 60,
                s.create = function(b) {
                    var T = {
                        engine: null,
                        element: null,
                        canvas: null,
                        mouse: null,
                        frameRequestId: null,
                        timing: {
                            historySize: 60,
                            delta: 0,
                            deltaHistory: [],
                            lastTime: 0,
                            lastTimestamp: 0,
                            lastElapsed: 0,
                            timestampElapsed: 0,
                            timestampElapsedHistory: [],
                            engineDeltaHistory: [],
                            engineElapsedHistory: [],
                            elapsedHistory: []
                        },
                        options: {
                            width: 800,
                            height: 600,
                            pixelRatio: 1,
                            background: "#14151f",
                            wireframeBackground: "#14151f",
                            hasBounds: !!b.bounds,
                            enabled: !0,
                            wireframes: !0,
                            showSleeping: !0,
                            showDebug: !1,
                            showStats: !1,
                            showPerformance: !1,
                            showBounds: !1,
                            showVelocity: !1,
                            showCollisions: !1,
                            showSeparations: !1,
                            showAxes: !1,
                            showPositions: !1,
                            showAngleIndicator: !1,
                            showIds: !1,
                            showVertexNumbers: !1,
                            showConvexHulls: !1,
                            showInternalEdges: !1,
                            showMousePosition: !1
                        }
                    }
                      , C = a.extend(T, b);
                    return C.canvas && (C.canvas.width = C.options.width || C.canvas.width,
                    C.canvas.height = C.options.height || C.canvas.height),
                    C.mouse = b.mouse,
                    C.engine = b.engine,
                    C.canvas = C.canvas || y(C.options.width, C.options.height),
                    C.context = C.canvas.getContext("2d"),
                    C.textures = {},
                    C.bounds = C.bounds || {
                        min: {
                            x: 0,
                            y: 0
                        },
                        max: {
                            x: C.canvas.width,
                            y: C.canvas.height
                        }
                    },
                    C.controller = s,
                    C.options.showBroadphase = !1,
                    C.options.pixelRatio !== 1 && s.setPixelRatio(C, C.options.pixelRatio),
                    a.isElement(C.element) && C.element.appendChild(C.canvas),
                    C
                }
                ,
                s.run = function(b) {
                    (function T(C) {
                        b.frameRequestId = f(T),
                        g(b, C),
                        s.world(b, C),
                        (b.options.showStats || b.options.showDebug) && s.stats(b, b.context, C),
                        (b.options.showPerformance || b.options.showDebug) && s.performance(b, b.context, C)
                    }
                    )()
                }
                ,
                s.stop = function(b) {
                    _(b.frameRequestId)
                }
                ,
                s.setPixelRatio = function(b, T) {
                    var C = b.options
                      , P = b.canvas;
                    T === "auto" && (T = w(P)),
                    C.pixelRatio = T,
                    P.setAttribute("data-pixel-ratio", T),
                    P.width = C.width * T,
                    P.height = C.height * T,
                    P.style.width = C.width + "px",
                    P.style.height = C.height + "px"
                }
                ,
                s.lookAt = function(b, T, C, P) {
                    P = typeof P < "u" ? P : !0,
                    T = a.isArray(T) ? T : [T],
                    C = C || {
                        x: 0,
                        y: 0
                    };
                    for (var A = {
                        min: {
                            x: 1 / 0,
                            y: 1 / 0
                        },
                        max: {
                            x: -1 / 0,
                            y: -1 / 0
                        }
                    }, R = 0; R < T.length; R += 1) {
                        var I = T[R]
                          , D = I.bounds ? I.bounds.min : I.min || I.position || I
                          , H = I.bounds ? I.bounds.max : I.max || I.position || I;
                        D && H && (D.x < A.min.x && (A.min.x = D.x),
                        H.x > A.max.x && (A.max.x = H.x),
                        D.y < A.min.y && (A.min.y = D.y),
                        H.y > A.max.y && (A.max.y = H.y))
                    }
                    var B = A.max.x - A.min.x + 2 * C.x
                      , G = A.max.y - A.min.y + 2 * C.y
                      , X = b.canvas.height
                      , V = b.canvas.width
                      , ee = V / X
                      , re = B / G
                      , k = 1
                      , oe = 1;
                    re > ee ? oe = re / ee : k = ee / re,
                    b.options.hasBounds = !0,
                    b.bounds.min.x = A.min.x,
                    b.bounds.max.x = A.min.x + B * k,
                    b.bounds.min.y = A.min.y,
                    b.bounds.max.y = A.min.y + G * oe,
                    P && (b.bounds.min.x += B * .5 - B * k * .5,
                    b.bounds.max.x += B * .5 - B * k * .5,
                    b.bounds.min.y += G * .5 - G * oe * .5,
                    b.bounds.max.y += G * .5 - G * oe * .5),
                    b.bounds.min.x -= C.x,
                    b.bounds.max.x -= C.x,
                    b.bounds.min.y -= C.y,
                    b.bounds.max.y -= C.y,
                    b.mouse && (d.setScale(b.mouse, {
                        x: (b.bounds.max.x - b.bounds.min.x) / b.canvas.width,
                        y: (b.bounds.max.y - b.bounds.min.y) / b.canvas.height
                    }),
                    d.setOffset(b.mouse, b.bounds.min))
                }
                ,
                s.startViewTransform = function(b) {
                    var T = b.bounds.max.x - b.bounds.min.x
                      , C = b.bounds.max.y - b.bounds.min.y
                      , P = T / b.options.width
                      , A = C / b.options.height;
                    b.context.setTransform(b.options.pixelRatio / P, 0, 0, b.options.pixelRatio / A, 0, 0),
                    b.context.translate(-b.bounds.min.x, -b.bounds.min.y)
                }
                ,
                s.endViewTransform = function(b) {
                    b.context.setTransform(b.options.pixelRatio, 0, 0, b.options.pixelRatio, 0, 0)
                }
                ,
                s.world = function(b, T) {
                    var C = a.now(), P = b.engine, A = P.world, R = b.canvas, I = b.context, D = b.options, H = b.timing, B = c.allBodies(A), G = c.allConstraints(A), X = D.wireframes ? D.wireframeBackground : D.background, V = [], ee = [], re, k = {
                        timestamp: P.timing.timestamp
                    };
                    if (h.trigger(b, "beforeRender", k),
                    b.currentBackground !== X && E(b, X),
                    I.globalCompositeOperation = "source-in",
                    I.fillStyle = "transparent",
                    I.fillRect(0, 0, R.width, R.height),
                    I.globalCompositeOperation = "source-over",
                    D.hasBounds) {
                        for (re = 0; re < B.length; re++) {
                            var oe = B[re];
                            u.overlaps(oe.bounds, b.bounds) && V.push(oe)
                        }
                        for (re = 0; re < G.length; re++) {
                            var ae = G[re]
                              , ne = ae.bodyA
                              , fe = ae.bodyB
                              , xe = ae.pointA
                              , Re = ae.pointB;
                            ne && (xe = m.add(ne.position, ae.pointA)),
                            fe && (Re = m.add(fe.position, ae.pointB)),
                            !(!xe || !Re) && (u.contains(b.bounds, xe) || u.contains(b.bounds, Re)) && ee.push(ae)
                        }
                        s.startViewTransform(b),
                        b.mouse && (d.setScale(b.mouse, {
                            x: (b.bounds.max.x - b.bounds.min.x) / b.options.width,
                            y: (b.bounds.max.y - b.bounds.min.y) / b.options.height
                        }),
                        d.setOffset(b.mouse, b.bounds.min))
                    } else
                        ee = G,
                        V = B,
                        b.options.pixelRatio !== 1 && b.context.setTransform(b.options.pixelRatio, 0, 0, b.options.pixelRatio, 0, 0);
                    !D.wireframes || P.enableSleeping && D.showSleeping ? s.bodies(b, V, I) : (D.showConvexHulls && s.bodyConvexHulls(b, V, I),
                    s.bodyWireframes(b, V, I)),
                    D.showBounds && s.bodyBounds(b, V, I),
                    (D.showAxes || D.showAngleIndicator) && s.bodyAxes(b, V, I),
                    D.showPositions && s.bodyPositions(b, V, I),
                    D.showVelocity && s.bodyVelocity(b, V, I),
                    D.showIds && s.bodyIds(b, V, I),
                    D.showSeparations && s.separations(b, P.pairs.list, I),
                    D.showCollisions && s.collisions(b, P.pairs.list, I),
                    D.showVertexNumbers && s.vertexNumbers(b, V, I),
                    D.showMousePosition && s.mousePosition(b, b.mouse, I),
                    s.constraints(ee, I),
                    D.hasBounds && s.endViewTransform(b),
                    h.trigger(b, "afterRender", k),
                    H.lastElapsed = a.now() - C
                }
                ,
                s.stats = function(b, T, C) {
                    for (var P = b.engine, A = P.world, R = c.allBodies(A), I = 0, D = 55, H = 44, B = 0, G = 0, X = 0; X < R.length; X += 1)
                        I += R[X].parts.length;
                    var V = {
                        Part: I,
                        Body: R.length,
                        Cons: c.allConstraints(A).length,
                        Comp: c.allComposites(A).length,
                        Pair: P.pairs.list.length
                    };
                    T.fillStyle = "#0e0f19",
                    T.fillRect(B, G, D * 5.5, H),
                    T.font = "12px Arial",
                    T.textBaseline = "top",
                    T.textAlign = "right";
                    for (var ee in V) {
                        var re = V[ee];
                        T.fillStyle = "#aaa",
                        T.fillText(ee, B + D, G + 8),
                        T.fillStyle = "#eee",
                        T.fillText(re, B + D, G + 26),
                        B += D
                    }
                }
                ,
                s.performance = function(b, T) {
                    var C = b.engine
                      , P = b.timing
                      , A = P.deltaHistory
                      , R = P.elapsedHistory
                      , I = P.timestampElapsedHistory
                      , D = P.engineDeltaHistory
                      , H = P.engineElapsedHistory
                      , B = C.timing.lastDelta
                      , G = v(A)
                      , X = v(R)
                      , V = v(D)
                      , ee = v(H)
                      , re = v(I)
                      , k = re / G || 0
                      , oe = 1e3 / G || 0
                      , ae = 4
                      , ne = 12
                      , fe = 60
                      , xe = 34
                      , Re = 10
                      , Ue = 69;
                    T.fillStyle = "#0e0f19",
                    T.fillRect(0, 50, ne * 4 + fe * 5 + 22, xe),
                    s.status(T, Re, Ue, fe, ae, A.length, Math.round(oe) + " fps", oe / s._goodFps, function(He) {
                        return A[He] / G - 1
                    }),
                    s.status(T, Re + ne + fe, Ue, fe, ae, D.length, B.toFixed(2) + " dt", s._goodDelta / B, function(He) {
                        return D[He] / V - 1
                    }),
                    s.status(T, Re + (ne + fe) * 2, Ue, fe, ae, H.length, ee.toFixed(2) + " ut", 1 - ee / s._goodFps, function(He) {
                        return H[He] / ee - 1
                    }),
                    s.status(T, Re + (ne + fe) * 3, Ue, fe, ae, R.length, X.toFixed(2) + " rt", 1 - X / s._goodFps, function(He) {
                        return R[He] / X - 1
                    }),
                    s.status(T, Re + (ne + fe) * 4, Ue, fe, ae, I.length, k.toFixed(2) + " x", k * k * k, function(He) {
                        return (I[He] / A[He] / k || 0) - 1
                    })
                }
                ,
                s.status = function(b, T, C, P, A, R, I, D, H) {
                    b.strokeStyle = "#888",
                    b.fillStyle = "#444",
                    b.lineWidth = 1,
                    b.fillRect(T, C + 7, P, 1),
                    b.beginPath(),
                    b.moveTo(T, C + 7 - A * a.clamp(.4 * H(0), -2, 2));
                    for (var B = 0; B < P; B += 1)
                        b.lineTo(T + B, C + 7 - (B < R ? A * a.clamp(.4 * H(B), -2, 2) : 0));
                    b.stroke(),
                    b.fillStyle = "hsl(" + a.clamp(25 + 95 * D, 0, 120) + ",100%,60%)",
                    b.fillRect(T, C - 7, 4, 4),
                    b.font = "12px Arial",
                    b.textBaseline = "middle",
                    b.textAlign = "right",
                    b.fillStyle = "#eee",
                    b.fillText(I, T + P, C - 5)
                }
                ,
                s.constraints = function(b, T) {
                    for (var C = T, P = 0; P < b.length; P++) {
                        var A = b[P];
                        if (!(!A.render.visible || !A.pointA || !A.pointB)) {
                            var R = A.bodyA, I = A.bodyB, D, H;
                            if (R ? D = m.add(R.position, A.pointA) : D = A.pointA,
                            A.render.type === "pin")
                                C.beginPath(),
                                C.arc(D.x, D.y, 3, 0, 2 * Math.PI),
                                C.closePath();
                            else {
                                if (I ? H = m.add(I.position, A.pointB) : H = A.pointB,
                                C.beginPath(),
                                C.moveTo(D.x, D.y),
                                A.render.type === "spring")
                                    for (var B = m.sub(H, D), G = m.perp(m.normalise(B)), X = Math.ceil(a.clamp(A.length / 5, 12, 20)), V, ee = 1; ee < X; ee += 1)
                                        V = ee % 2 === 0 ? 1 : -1,
                                        C.lineTo(D.x + B.x * (ee / X) + G.x * V * 4, D.y + B.y * (ee / X) + G.y * V * 4);
                                C.lineTo(H.x, H.y)
                            }
                            A.render.lineWidth && (C.lineWidth = A.render.lineWidth,
                            C.strokeStyle = A.render.strokeStyle,
                            C.stroke()),
                            A.render.anchors && (C.fillStyle = A.render.strokeStyle,
                            C.beginPath(),
                            C.arc(D.x, D.y, 3, 0, 2 * Math.PI),
                            C.arc(H.x, H.y, 3, 0, 2 * Math.PI),
                            C.closePath(),
                            C.fill())
                        }
                    }
                }
                ,
                s.bodies = function(b, T, C) {
                    var P = C;
                    b.engine;
                    var A = b.options, R = A.showInternalEdges || !A.wireframes, I, D, H, B;
                    for (H = 0; H < T.length; H++)
                        if (I = T[H],
                        !!I.render.visible) {
                            for (B = I.parts.length > 1 ? 1 : 0; B < I.parts.length; B++)
                                if (D = I.parts[B],
                                !!D.render.visible) {
                                    if (A.showSleeping && I.isSleeping ? P.globalAlpha = .5 * D.render.opacity : D.render.opacity !== 1 && (P.globalAlpha = D.render.opacity),
                                    D.render.sprite && D.render.sprite.texture && !A.wireframes) {
                                        var G = D.render.sprite
                                          , X = S(b, G.texture);
                                        P.translate(D.position.x, D.position.y),
                                        P.rotate(D.angle),
                                        P.drawImage(X, X.width * -G.xOffset * G.xScale, X.height * -G.yOffset * G.yScale, X.width * G.xScale, X.height * G.yScale),
                                        P.rotate(-D.angle),
                                        P.translate(-D.position.x, -D.position.y)
                                    } else {
                                        if (D.circleRadius)
                                            P.beginPath(),
                                            P.arc(D.position.x, D.position.y, D.circleRadius, 0, 2 * Math.PI);
                                        else {
                                            P.beginPath(),
                                            P.moveTo(D.vertices[0].x, D.vertices[0].y);
                                            for (var V = 1; V < D.vertices.length; V++)
                                                !D.vertices[V - 1].isInternal || R ? P.lineTo(D.vertices[V].x, D.vertices[V].y) : P.moveTo(D.vertices[V].x, D.vertices[V].y),
                                                D.vertices[V].isInternal && !R && P.moveTo(D.vertices[(V + 1) % D.vertices.length].x, D.vertices[(V + 1) % D.vertices.length].y);
                                            P.lineTo(D.vertices[0].x, D.vertices[0].y),
                                            P.closePath()
                                        }
                                        A.wireframes ? (P.lineWidth = 1,
                                        P.strokeStyle = "#bbb",
                                        P.stroke()) : (P.fillStyle = D.render.fillStyle,
                                        D.render.lineWidth && (P.lineWidth = D.render.lineWidth,
                                        P.strokeStyle = D.render.strokeStyle,
                                        P.stroke()),
                                        P.fill())
                                    }
                                    P.globalAlpha = 1
                                }
                        }
                }
                ,
                s.bodyWireframes = function(b, T, C) {
                    var P = C, A = b.options.showInternalEdges, R, I, D, H, B;
                    for (P.beginPath(),
                    D = 0; D < T.length; D++)
                        if (R = T[D],
                        !!R.render.visible)
                            for (B = R.parts.length > 1 ? 1 : 0; B < R.parts.length; B++) {
                                for (I = R.parts[B],
                                P.moveTo(I.vertices[0].x, I.vertices[0].y),
                                H = 1; H < I.vertices.length; H++)
                                    !I.vertices[H - 1].isInternal || A ? P.lineTo(I.vertices[H].x, I.vertices[H].y) : P.moveTo(I.vertices[H].x, I.vertices[H].y),
                                    I.vertices[H].isInternal && !A && P.moveTo(I.vertices[(H + 1) % I.vertices.length].x, I.vertices[(H + 1) % I.vertices.length].y);
                                P.lineTo(I.vertices[0].x, I.vertices[0].y)
                            }
                    P.lineWidth = 1,
                    P.strokeStyle = "#bbb",
                    P.stroke()
                }
                ,
                s.bodyConvexHulls = function(b, T, C) {
                    var P = C, A, R, I;
                    for (P.beginPath(),
                    R = 0; R < T.length; R++)
                        if (A = T[R],
                        !(!A.render.visible || A.parts.length === 1)) {
                            for (P.moveTo(A.vertices[0].x, A.vertices[0].y),
                            I = 1; I < A.vertices.length; I++)
                                P.lineTo(A.vertices[I].x, A.vertices[I].y);
                            P.lineTo(A.vertices[0].x, A.vertices[0].y)
                        }
                    P.lineWidth = 1,
                    P.strokeStyle = "rgba(255,255,255,0.2)",
                    P.stroke()
                }
                ,
                s.vertexNumbers = function(b, T, C) {
                    var P = C, A, R, I;
                    for (A = 0; A < T.length; A++) {
                        var D = T[A].parts;
                        for (I = D.length > 1 ? 1 : 0; I < D.length; I++) {
                            var H = D[I];
                            for (R = 0; R < H.vertices.length; R++)
                                P.fillStyle = "rgba(255,255,255,0.2)",
                                P.fillText(A + "_" + R, H.position.x + (H.vertices[R].x - H.position.x) * .8, H.position.y + (H.vertices[R].y - H.position.y) * .8)
                        }
                    }
                }
                ,
                s.mousePosition = function(b, T, C) {
                    var P = C;
                    P.fillStyle = "rgba(255,255,255,0.8)",
                    P.fillText(T.position.x + "  " + T.position.y, T.position.x + 5, T.position.y - 5)
                }
                ,
                s.bodyBounds = function(b, T, C) {
                    var P = C;
                    b.engine;
                    var A = b.options;
                    P.beginPath();
                    for (var R = 0; R < T.length; R++) {
                        var I = T[R];
                        if (I.render.visible)
                            for (var D = T[R].parts, H = D.length > 1 ? 1 : 0; H < D.length; H++) {
                                var B = D[H];
                                P.rect(B.bounds.min.x, B.bounds.min.y, B.bounds.max.x - B.bounds.min.x, B.bounds.max.y - B.bounds.min.y)
                            }
                    }
                    A.wireframes ? P.strokeStyle = "rgba(255,255,255,0.08)" : P.strokeStyle = "rgba(0,0,0,0.1)",
                    P.lineWidth = 1,
                    P.stroke()
                }
                ,
                s.bodyAxes = function(b, T, C) {
                    var P = C;
                    b.engine;
                    var A = b.options, R, I, D, H;
                    for (P.beginPath(),
                    I = 0; I < T.length; I++) {
                        var B = T[I]
                          , G = B.parts;
                        if (B.render.visible)
                            if (A.showAxes)
                                for (D = G.length > 1 ? 1 : 0; D < G.length; D++)
                                    for (R = G[D],
                                    H = 0; H < R.axes.length; H++) {
                                        var X = R.axes[H];
                                        P.moveTo(R.position.x, R.position.y),
                                        P.lineTo(R.position.x + X.x * 20, R.position.y + X.y * 20)
                                    }
                            else
                                for (D = G.length > 1 ? 1 : 0; D < G.length; D++)
                                    for (R = G[D],
                                    H = 0; H < R.axes.length; H++)
                                        P.moveTo(R.position.x, R.position.y),
                                        P.lineTo((R.vertices[0].x + R.vertices[R.vertices.length - 1].x) / 2, (R.vertices[0].y + R.vertices[R.vertices.length - 1].y) / 2)
                    }
                    A.wireframes ? (P.strokeStyle = "indianred",
                    P.lineWidth = 1) : (P.strokeStyle = "rgba(255, 255, 255, 0.4)",
                    P.globalCompositeOperation = "overlay",
                    P.lineWidth = 2),
                    P.stroke(),
                    P.globalCompositeOperation = "source-over"
                }
                ,
                s.bodyPositions = function(b, T, C) {
                    var P = C;
                    b.engine;
                    var A = b.options, R, I, D, H;
                    for (P.beginPath(),
                    D = 0; D < T.length; D++)
                        if (R = T[D],
                        !!R.render.visible)
                            for (H = 0; H < R.parts.length; H++)
                                I = R.parts[H],
                                P.arc(I.position.x, I.position.y, 3, 0, 2 * Math.PI, !1),
                                P.closePath();
                    for (A.wireframes ? P.fillStyle = "indianred" : P.fillStyle = "rgba(0,0,0,0.5)",
                    P.fill(),
                    P.beginPath(),
                    D = 0; D < T.length; D++)
                        R = T[D],
                        R.render.visible && (P.arc(R.positionPrev.x, R.positionPrev.y, 2, 0, 2 * Math.PI, !1),
                        P.closePath());
                    P.fillStyle = "rgba(255,165,0,0.8)",
                    P.fill()
                }
                ,
                s.bodyVelocity = function(b, T, C) {
                    var P = C;
                    P.beginPath();
                    for (var A = 0; A < T.length; A++) {
                        var R = T[A];
                        if (R.render.visible) {
                            var I = o.getVelocity(R);
                            P.moveTo(R.position.x, R.position.y),
                            P.lineTo(R.position.x + I.x, R.position.y + I.y)
                        }
                    }
                    P.lineWidth = 3,
                    P.strokeStyle = "cornflowerblue",
                    P.stroke()
                }
                ,
                s.bodyIds = function(b, T, C) {
                    var P = C, A, R;
                    for (A = 0; A < T.length; A++)
                        if (T[A].render.visible) {
                            var I = T[A].parts;
                            for (R = I.length > 1 ? 1 : 0; R < I.length; R++) {
                                var D = I[R];
                                P.font = "12px Arial",
                                P.fillStyle = "rgba(255,255,255,0.5)",
                                P.fillText(D.id, D.position.x + 10, D.position.y - 10)
                            }
                        }
                }
                ,
                s.collisions = function(b, T, C) {
                    var P = C, A = b.options, R, I, D, H;
                    for (P.beginPath(),
                    D = 0; D < T.length; D++)
                        if (R = T[D],
                        !!R.isActive)
                            for (I = R.collision,
                            H = 0; H < R.activeContacts.length; H++) {
                                var B = R.activeContacts[H]
                                  , G = B.vertex;
                                P.rect(G.x - 1.5, G.y - 1.5, 3.5, 3.5)
                            }
                    for (A.wireframes ? P.fillStyle = "rgba(255,255,255,0.7)" : P.fillStyle = "orange",
                    P.fill(),
                    P.beginPath(),
                    D = 0; D < T.length; D++)
                        if (R = T[D],
                        !!R.isActive && (I = R.collision,
                        R.activeContacts.length > 0)) {
                            var X = R.activeContacts[0].vertex.x
                              , V = R.activeContacts[0].vertex.y;
                            R.activeContacts.length === 2 && (X = (R.activeContacts[0].vertex.x + R.activeContacts[1].vertex.x) / 2,
                            V = (R.activeContacts[0].vertex.y + R.activeContacts[1].vertex.y) / 2),
                            I.bodyB === I.supports[0].body || I.bodyA.isStatic === !0 ? P.moveTo(X - I.normal.x * 8, V - I.normal.y * 8) : P.moveTo(X + I.normal.x * 8, V + I.normal.y * 8),
                            P.lineTo(X, V)
                        }
                    A.wireframes ? P.strokeStyle = "rgba(255,165,0,0.7)" : P.strokeStyle = "orange",
                    P.lineWidth = 1,
                    P.stroke()
                }
                ,
                s.separations = function(b, T, C) {
                    var P = C, A = b.options, R, I, D, H, B;
                    for (P.beginPath(),
                    B = 0; B < T.length; B++)
                        if (R = T[B],
                        !!R.isActive) {
                            I = R.collision,
                            D = I.bodyA,
                            H = I.bodyB;
                            var G = 1;
                            !H.isStatic && !D.isStatic && (G = .5),
                            H.isStatic && (G = 0),
                            P.moveTo(H.position.x, H.position.y),
                            P.lineTo(H.position.x - I.penetration.x * G, H.position.y - I.penetration.y * G),
                            G = 1,
                            !H.isStatic && !D.isStatic && (G = .5),
                            D.isStatic && (G = 0),
                            P.moveTo(D.position.x, D.position.y),
                            P.lineTo(D.position.x + I.penetration.x * G, D.position.y + I.penetration.y * G)
                        }
                    A.wireframes ? P.strokeStyle = "rgba(255,165,0,0.5)" : P.strokeStyle = "orange",
                    P.stroke()
                }
                ,
                s.inspector = function(b, T) {
                    b.engine;
                    var C = b.selected, P = b.render, A = P.options, R;
                    if (A.hasBounds) {
                        var I = P.bounds.max.x - P.bounds.min.x
                          , D = P.bounds.max.y - P.bounds.min.y
                          , H = I / P.options.width
                          , B = D / P.options.height;
                        T.scale(1 / H, 1 / B),
                        T.translate(-P.bounds.min.x, -P.bounds.min.y)
                    }
                    for (var G = 0; G < C.length; G++) {
                        var X = C[G].data;
                        switch (T.translate(.5, .5),
                        T.lineWidth = 1,
                        T.strokeStyle = "rgba(255,165,0,0.9)",
                        T.setLineDash([1, 2]),
                        X.type) {
                        case "body":
                            R = X.bounds,
                            T.beginPath(),
                            T.rect(Math.floor(R.min.x - 3), Math.floor(R.min.y - 3), Math.floor(R.max.x - R.min.x + 6), Math.floor(R.max.y - R.min.y + 6)),
                            T.closePath(),
                            T.stroke();
                            break;
                        case "constraint":
                            var V = X.pointA;
                            X.bodyA && (V = X.pointB),
                            T.beginPath(),
                            T.arc(V.x, V.y, 10, 0, 2 * Math.PI),
                            T.closePath(),
                            T.stroke();
                            break
                        }
                        T.setLineDash([]),
                        T.translate(-.5, -.5)
                    }
                    b.selectStart !== null && (T.translate(.5, .5),
                    T.lineWidth = 1,
                    T.strokeStyle = "rgba(255,165,0,0.6)",
                    T.fillStyle = "rgba(255,165,0,0.1)",
                    R = b.selectBounds,
                    T.beginPath(),
                    T.rect(Math.floor(R.min.x), Math.floor(R.min.y), Math.floor(R.max.x - R.min.x), Math.floor(R.max.y - R.min.y)),
                    T.closePath(),
                    T.stroke(),
                    T.fill(),
                    T.translate(-.5, -.5)),
                    A.hasBounds && T.setTransform(1, 0, 0, 1, 0, 0)
                }
                ;
                var g = function(b, T) {
                    var C = b.engine
                      , P = b.timing
                      , A = P.historySize
                      , R = C.timing.timestamp;
                    P.delta = T - P.lastTime || s._goodDelta,
                    P.lastTime = T,
                    P.timestampElapsed = R - P.lastTimestamp || 0,
                    P.lastTimestamp = R,
                    P.deltaHistory.unshift(P.delta),
                    P.deltaHistory.length = Math.min(P.deltaHistory.length, A),
                    P.engineDeltaHistory.unshift(C.timing.lastDelta),
                    P.engineDeltaHistory.length = Math.min(P.engineDeltaHistory.length, A),
                    P.timestampElapsedHistory.unshift(P.timestampElapsed),
                    P.timestampElapsedHistory.length = Math.min(P.timestampElapsedHistory.length, A),
                    P.engineElapsedHistory.unshift(C.timing.lastElapsed),
                    P.engineElapsedHistory.length = Math.min(P.engineElapsedHistory.length, A),
                    P.elapsedHistory.unshift(P.lastElapsed),
                    P.elapsedHistory.length = Math.min(P.elapsedHistory.length, A)
                }
                  , v = function(b) {
                    for (var T = 0, C = 0; C < b.length; C += 1)
                        T += b[C];
                    return T / b.length || 0
                }
                  , y = function(b, T) {
                    var C = document.createElement("canvas");
                    return C.width = b,
                    C.height = T,
                    C.oncontextmenu = function() {
                        return !1
                    }
                    ,
                    C.onselectstart = function() {
                        return !1
                    }
                    ,
                    C
                }
                  , w = function(b) {
                    var T = b.getContext("2d")
                      , C = window.devicePixelRatio || 1
                      , P = T.webkitBackingStorePixelRatio || T.mozBackingStorePixelRatio || T.msBackingStorePixelRatio || T.oBackingStorePixelRatio || T.backingStorePixelRatio || 1;
                    return C / P
                }
                  , S = function(b, T) {
                    var C = b.textures[T];
                    return C || (C = b.textures[T] = new Image,
                    C.src = T,
                    C)
                }
                  , E = function(b, T) {
                    var C = T;
                    /(jpg|gif|png)$/.test(T) && (C = "url(" + T + ")"),
                    b.canvas.style.background = C,
                    b.canvas.style.backgroundSize = "contain",
                    b.currentBackground = T
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(5)
              , a = r(17)
              , c = r(0);
            (function() {
                var u, h;
                if (typeof window < "u" && (u = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame,
                h = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame),
                !u) {
                    var m;
                    u = function(d) {
                        m = setTimeout(function() {
                            d(c.now())
                        }, 1e3 / 60)
                    }
                    ,
                    h = function() {
                        clearTimeout(m)
                    }
                }
                s.create = function(d) {
                    var f = {
                        fps: 60,
                        deltaSampleSize: 60,
                        counterTimestamp: 0,
                        frameCounter: 0,
                        deltaHistory: [],
                        timePrev: null,
                        frameRequestId: null,
                        isFixed: !1,
                        enabled: !0
                    }
                      , _ = c.extend(f, d);
                    return _.delta = _.delta || 1e3 / _.fps,
                    _.deltaMin = _.deltaMin || 1e3 / _.fps,
                    _.deltaMax = _.deltaMax || 1e3 / (_.fps * .5),
                    _.fps = 1e3 / _.delta,
                    _
                }
                ,
                s.run = function(d, f) {
                    return typeof d.positionIterations < "u" && (f = d,
                    d = s.create()),
                    function _(g) {
                        d.frameRequestId = u(_),
                        g && d.enabled && s.tick(d, f, g)
                    }(),
                    d
                }
                ,
                s.tick = function(d, f, _) {
                    var g = f.timing, v;
                    d.isFixed ? v = d.delta : (v = _ - d.timePrev || d.delta,
                    d.timePrev = _,
                    d.deltaHistory.push(v),
                    d.deltaHistory = d.deltaHistory.slice(-d.deltaSampleSize),
                    v = Math.min.apply(null, d.deltaHistory),
                    v = v < d.deltaMin ? d.deltaMin : v,
                    v = v > d.deltaMax ? d.deltaMax : v,
                    d.delta = v);
                    var y = {
                        timestamp: g.timestamp
                    };
                    o.trigger(d, "beforeTick", y),
                    d.frameCounter += 1,
                    _ - d.counterTimestamp >= 1e3 && (d.fps = d.frameCounter * ((_ - d.counterTimestamp) / 1e3),
                    d.counterTimestamp = _,
                    d.frameCounter = 0),
                    o.trigger(d, "tick", y),
                    o.trigger(d, "beforeUpdate", y),
                    a.update(f, v),
                    o.trigger(d, "afterUpdate", y),
                    o.trigger(d, "afterTick", y)
                }
                ,
                s.stop = function(d) {
                    h(d.frameRequestId)
                }
                ,
                s.start = function(d, f) {
                    s.run(d, f)
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(8)
              , a = r(0)
              , c = a.deprecated;
            (function() {
                s.collides = function(u, h) {
                    return o.collides(u, h)
                }
                ,
                c(s, "collides", "SAT.collides  replaced by Collision.collides")
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s,
            r(1);
            var o = r(0);
            (function() {
                s.pathToVertices = function(a, c) {
                    typeof window < "u" && !("SVGPathSeg"in window) && o.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
                    var u, h, m, d, f, _, g, v, y, w, S = [], E, b, T = 0, C = 0, P = 0;
                    c = c || 15;
                    var A = function(I, D, H) {
                        var B = H % 2 === 1 && H > 1;
                        if (!y || I != y.x || D != y.y) {
                            y && B ? (E = y.x,
                            b = y.y) : (E = 0,
                            b = 0);
                            var G = {
                                x: E + I,
                                y: b + D
                            };
                            (B || !y) && (y = G),
                            S.push(G),
                            C = E + I,
                            P = b + D
                        }
                    }
                      , R = function(I) {
                        var D = I.pathSegTypeAsLetter.toUpperCase();
                        if (D !== "Z") {
                            switch (D) {
                            case "M":
                            case "L":
                            case "T":
                            case "C":
                            case "S":
                            case "Q":
                                C = I.x,
                                P = I.y;
                                break;
                            case "H":
                                C = I.x;
                                break;
                            case "V":
                                P = I.y;
                                break
                            }
                            A(C, P, I.pathSegType)
                        }
                    };
                    for (s._svgPathToAbsolute(a),
                    m = a.getTotalLength(),
                    _ = [],
                    u = 0; u < a.pathSegList.numberOfItems; u += 1)
                        _.push(a.pathSegList.getItem(u));
                    for (g = _.concat(); T < m; ) {
                        if (w = a.getPathSegAtLength(T),
                        f = _[w],
                        f != v) {
                            for (; g.length && g[0] != f; )
                                R(g.shift());
                            v = f
                        }
                        switch (f.pathSegTypeAsLetter.toUpperCase()) {
                        case "C":
                        case "T":
                        case "S":
                        case "Q":
                        case "A":
                            d = a.getPointAtLength(T),
                            A(d.x, d.y, 0);
                            break
                        }
                        T += c
                    }
                    for (u = 0,
                    h = g.length; u < h; ++u)
                        R(g[u]);
                    return S
                }
                ,
                s._svgPathToAbsolute = function(a) {
                    for (var c, u, h, m, d, f, _ = a.pathSegList, g = 0, v = 0, y = _.numberOfItems, w = 0; w < y; ++w) {
                        var S = _.getItem(w)
                          , E = S.pathSegTypeAsLetter;
                        if (/[MLHVCSQTA]/.test(E))
                            "x"in S && (g = S.x),
                            "y"in S && (v = S.y);
                        else
                            switch ("x1"in S && (h = g + S.x1),
                            "x2"in S && (d = g + S.x2),
                            "y1"in S && (m = v + S.y1),
                            "y2"in S && (f = v + S.y2),
                            "x"in S && (g += S.x),
                            "y"in S && (v += S.y),
                            E) {
                            case "m":
                                _.replaceItem(a.createSVGPathSegMovetoAbs(g, v), w);
                                break;
                            case "l":
                                _.replaceItem(a.createSVGPathSegLinetoAbs(g, v), w);
                                break;
                            case "h":
                                _.replaceItem(a.createSVGPathSegLinetoHorizontalAbs(g), w);
                                break;
                            case "v":
                                _.replaceItem(a.createSVGPathSegLinetoVerticalAbs(v), w);
                                break;
                            case "c":
                                _.replaceItem(a.createSVGPathSegCurvetoCubicAbs(g, v, h, m, d, f), w);
                                break;
                            case "s":
                                _.replaceItem(a.createSVGPathSegCurvetoCubicSmoothAbs(g, v, d, f), w);
                                break;
                            case "q":
                                _.replaceItem(a.createSVGPathSegCurvetoQuadraticAbs(g, v, h, m), w);
                                break;
                            case "t":
                                _.replaceItem(a.createSVGPathSegCurvetoQuadraticSmoothAbs(g, v), w);
                                break;
                            case "a":
                                _.replaceItem(a.createSVGPathSegArcAbs(g, v, S.r1, S.r2, S.angle, S.largeArcFlag, S.sweepFlag), w);
                                break;
                            case "z":
                            case "Z":
                                g = c,
                                v = u;
                                break
                            }
                        (E == "M" || E == "m") && (c = g,
                        u = v)
                    }
                }
            }
            )()
        }
        , function(t, i, r) {
            var s = {};
            t.exports = s;
            var o = r(6);
            r(0),
            function() {
                s.create = o.create,
                s.add = o.add,
                s.remove = o.remove,
                s.clear = o.clear,
                s.addComposite = o.addComposite,
                s.addBody = o.addBody,
                s.addConstraint = o.addConstraint
            }()
        }
        ])
    })
}
)(AR);
var qt = AR.exports
  , By = {
    exports: {}
}
  , X1 = typeof document < "u" ? document.createElement("p").style : {}
  , q1 = ["O", "ms", "Moz", "Webkit"]
  , E0 = /([A-Z])/g
  , A0 = {};
function MR(n) {
    if (n = n.replace(/-([a-z])/g, function(r, s) {
        return s.toUpperCase()
    }),
    X1[n] !== void 0)
        return n;
    for (var e = n.charAt(0).toUpperCase() + n.slice(1), t = q1.length; t--; ) {
        var i = q1[t] + e;
        if (X1[i] !== void 0)
            return i
    }
    return n
}
function PG(n) {
    return n in A0 ? A0[n] : A0[n] = MR(n)
}
function LG(n) {
    return n = MR(n),
    E0.test(n) && (n = "-" + n.replace(E0, "-$1"),
    E0.lastIndex = 0),
    n.toLowerCase()
}
By.exports = PG;
By.exports.dash = LG;
var DG = By.exports;
const La = Uo(DG);
function IG(n, e) {
    for (var t = -1, i = n == null ? 0 : n.length, r = Array(i); ++t < i; )
        r[t] = e(n[t], t, n);
    return r
}
var TR = IG;
function OG() {
    this.__data__ = [],
    this.size = 0
}
var NG = OG;
function UG(n, e) {
    return n === e || n !== n && e !== e
}
var CR = UG
  , FG = CR;
function BG(n, e) {
    for (var t = n.length; t--; )
        if (FG(n[t][0], e))
            return t;
    return -1
}
var nm = BG
  , kG = nm
  , zG = Array.prototype
  , HG = zG.splice;
function GG(n) {
    var e = this.__data__
      , t = kG(e, n);
    if (t < 0)
        return !1;
    var i = e.length - 1;
    return t == i ? e.pop() : HG.call(e, t, 1),
    --this.size,
    !0
}
var VG = GG
  , WG = nm;
function $G(n) {
    var e = this.__data__
      , t = WG(e, n);
    return t < 0 ? void 0 : e[t][1]
}
var XG = $G
  , qG = nm;
function jG(n) {
    return qG(this.__data__, n) > -1
}
var YG = jG
  , KG = nm;
function ZG(n, e) {
    var t = this.__data__
      , i = KG(t, n);
    return i < 0 ? (++this.size,
    t.push([n, e])) : t[i][1] = e,
    this
}
var JG = ZG
  , QG = NG
  , eV = VG
  , tV = XG
  , nV = YG
  , iV = JG;
function tu(n) {
    var e = -1
      , t = n == null ? 0 : n.length;
    for (this.clear(); ++e < t; ) {
        var i = n[e];
        this.set(i[0], i[1])
    }
}
tu.prototype.clear = QG;
tu.prototype.delete = eV;
tu.prototype.get = tV;
tu.prototype.has = nV;
tu.prototype.set = iV;
var im = tu
  , rV = im;
function sV() {
    this.__data__ = new rV,
    this.size = 0
}
var oV = sV;
function aV(n) {
    var e = this.__data__
      , t = e.delete(n);
    return this.size = e.size,
    t
}
var lV = aV;
function cV(n) {
    return this.__data__.get(n)
}
var uV = cV;
function fV(n) {
    return this.__data__.has(n)
}
var hV = fV
  , dV = typeof lr == "object" && lr && lr.Object === Object && lr
  , RR = dV
  , pV = RR
  , mV = typeof self == "object" && self && self.Object === Object && self
  , gV = pV || mV || Function("return this")()
  , ko = gV
  , _V = ko
  , vV = _V.Symbol
  , rm = vV
  , j1 = rm
  , PR = Object.prototype
  , yV = PR.hasOwnProperty
  , xV = PR.toString
  , Fu = j1 ? j1.toStringTag : void 0;
function bV(n) {
    var e = yV.call(n, Fu)
      , t = n[Fu];
    try {
        n[Fu] = void 0;
        var i = !0
    } catch {}
    var r = xV.call(n);
    return i && (e ? n[Fu] = t : delete n[Fu]),
    r
}
var SV = bV
  , wV = Object.prototype
  , EV = wV.toString;
function AV(n) {
    return EV.call(n)
}
var MV = AV
  , Y1 = rm
  , TV = SV
  , CV = MV
  , RV = "[object Null]"
  , PV = "[object Undefined]"
  , K1 = Y1 ? Y1.toStringTag : void 0;
function LV(n) {
    return n == null ? n === void 0 ? PV : RV : K1 && K1 in Object(n) ? TV(n) : CV(n)
}
var oh = LV;
function DV(n) {
    var e = typeof n;
    return n != null && (e == "object" || e == "function")
}
var sm = DV
  , IV = oh
  , OV = sm
  , NV = "[object AsyncFunction]"
  , UV = "[object Function]"
  , FV = "[object GeneratorFunction]"
  , BV = "[object Proxy]";
function kV(n) {
    if (!OV(n))
        return !1;
    var e = IV(n);
    return e == UV || e == FV || e == NV || e == BV
}
var LR = kV
  , zV = ko
  , HV = zV["__core-js_shared__"]
  , GV = HV
  , M0 = GV
  , Z1 = function() {
    var n = /[^.]+$/.exec(M0 && M0.keys && M0.keys.IE_PROTO || "");
    return n ? "Symbol(src)_1." + n : ""
}();
function VV(n) {
    return !!Z1 && Z1 in n
}
var WV = VV
  , $V = Function.prototype
  , XV = $V.toString;
function qV(n) {
    if (n != null) {
        try {
            return XV.call(n)
        } catch {}
        try {
            return n + ""
        } catch {}
    }
    return ""
}
var DR = qV
  , jV = LR
  , YV = WV
  , KV = sm
  , ZV = DR
  , JV = /[\\^$.*+?()[\]{}|]/g
  , QV = /^\[object .+?Constructor\]$/
  , e8 = Function.prototype
  , t8 = Object.prototype
  , n8 = e8.toString
  , i8 = t8.hasOwnProperty
  , r8 = RegExp("^" + n8.call(i8).replace(JV, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function s8(n) {
    if (!KV(n) || YV(n))
        return !1;
    var e = jV(n) ? r8 : QV;
    return e.test(ZV(n))
}
var o8 = s8;
function a8(n, e) {
    return n == null ? void 0 : n[e]
}
var l8 = a8
  , c8 = o8
  , u8 = l8;
function f8(n, e) {
    var t = u8(n, e);
    return c8(t) ? t : void 0
}
var nu = f8
  , h8 = nu
  , d8 = ko
  , p8 = h8(d8, "Map")
  , ky = p8
  , m8 = nu
  , g8 = m8(Object, "create")
  , om = g8
  , J1 = om;
function _8() {
    this.__data__ = J1 ? J1(null) : {},
    this.size = 0
}
var v8 = _8;
function y8(n) {
    var e = this.has(n) && delete this.__data__[n];
    return this.size -= e ? 1 : 0,
    e
}
var x8 = y8
  , b8 = om
  , S8 = "__lodash_hash_undefined__"
  , w8 = Object.prototype
  , E8 = w8.hasOwnProperty;
function A8(n) {
    var e = this.__data__;
    if (b8) {
        var t = e[n];
        return t === S8 ? void 0 : t
    }
    return E8.call(e, n) ? e[n] : void 0
}
var M8 = A8
  , T8 = om
  , C8 = Object.prototype
  , R8 = C8.hasOwnProperty;
function P8(n) {
    var e = this.__data__;
    return T8 ? e[n] !== void 0 : R8.call(e, n)
}
var L8 = P8
  , D8 = om
  , I8 = "__lodash_hash_undefined__";
function O8(n, e) {
    var t = this.__data__;
    return this.size += this.has(n) ? 0 : 1,
    t[n] = D8 && e === void 0 ? I8 : e,
    this
}
var N8 = O8
  , U8 = v8
  , F8 = x8
  , B8 = M8
  , k8 = L8
  , z8 = N8;
function iu(n) {
    var e = -1
      , t = n == null ? 0 : n.length;
    for (this.clear(); ++e < t; ) {
        var i = n[e];
        this.set(i[0], i[1])
    }
}
iu.prototype.clear = U8;
iu.prototype.delete = F8;
iu.prototype.get = B8;
iu.prototype.has = k8;
iu.prototype.set = z8;
var H8 = iu
  , Q1 = H8
  , G8 = im
  , V8 = ky;
function W8() {
    this.size = 0,
    this.__data__ = {
        hash: new Q1,
        map: new (V8 || G8),
        string: new Q1
    }
}
var $8 = W8;
function X8(n) {
    var e = typeof n;
    return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? n !== "__proto__" : n === null
}
var q8 = X8
  , j8 = q8;
function Y8(n, e) {
    var t = n.__data__;
    return j8(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map
}
var am = Y8
  , K8 = am;
function Z8(n) {
    var e = K8(this, n).delete(n);
    return this.size -= e ? 1 : 0,
    e
}
var J8 = Z8
  , Q8 = am;
function eW(n) {
    return Q8(this, n).get(n)
}
var tW = eW
  , nW = am;
function iW(n) {
    return nW(this, n).has(n)
}
var rW = iW
  , sW = am;
function oW(n, e) {
    var t = sW(this, n)
      , i = t.size;
    return t.set(n, e),
    this.size += t.size == i ? 0 : 1,
    this
}
var aW = oW
  , lW = $8
  , cW = J8
  , uW = tW
  , fW = rW
  , hW = aW;
function ru(n) {
    var e = -1
      , t = n == null ? 0 : n.length;
    for (this.clear(); ++e < t; ) {
        var i = n[e];
        this.set(i[0], i[1])
    }
}
ru.prototype.clear = lW;
ru.prototype.delete = cW;
ru.prototype.get = uW;
ru.prototype.has = fW;
ru.prototype.set = hW;
var zy = ru
  , dW = im
  , pW = ky
  , mW = zy
  , gW = 200;
function _W(n, e) {
    var t = this.__data__;
    if (t instanceof dW) {
        var i = t.__data__;
        if (!pW || i.length < gW - 1)
            return i.push([n, e]),
            this.size = ++t.size,
            this;
        t = this.__data__ = new mW(i)
    }
    return t.set(n, e),
    this.size = t.size,
    this
}
var vW = _W
  , yW = im
  , xW = oV
  , bW = lV
  , SW = uV
  , wW = hV
  , EW = vW;
function su(n) {
    var e = this.__data__ = new yW(n);
    this.size = e.size
}
su.prototype.clear = xW;
su.prototype.delete = bW;
su.prototype.get = SW;
su.prototype.has = wW;
su.prototype.set = EW;
var IR = su
  , AW = "__lodash_hash_undefined__";
function MW(n) {
    return this.__data__.set(n, AW),
    this
}
var TW = MW;
function CW(n) {
    return this.__data__.has(n)
}
var RW = CW
  , PW = zy
  , LW = TW
  , DW = RW;
function Rp(n) {
    var e = -1
      , t = n == null ? 0 : n.length;
    for (this.__data__ = new PW; ++e < t; )
        this.add(n[e])
}
Rp.prototype.add = Rp.prototype.push = LW;
Rp.prototype.has = DW;
var IW = Rp;
function OW(n, e) {
    for (var t = -1, i = n == null ? 0 : n.length; ++t < i; )
        if (e(n[t], t, n))
            return !0;
    return !1
}
var NW = OW;
function UW(n, e) {
    return n.has(e)
}
var FW = UW
  , BW = IW
  , kW = NW
  , zW = FW
  , HW = 1
  , GW = 2;
function VW(n, e, t, i, r, s) {
    var o = t & HW
      , a = n.length
      , c = e.length;
    if (a != c && !(o && c > a))
        return !1;
    var u = s.get(n)
      , h = s.get(e);
    if (u && h)
        return u == e && h == n;
    var m = -1
      , d = !0
      , f = t & GW ? new BW : void 0;
    for (s.set(n, e),
    s.set(e, n); ++m < a; ) {
        var _ = n[m]
          , g = e[m];
        if (i)
            var v = o ? i(g, _, m, e, n, s) : i(_, g, m, n, e, s);
        if (v !== void 0) {
            if (v)
                continue;
            d = !1;
            break
        }
        if (f) {
            if (!kW(e, function(y, w) {
                if (!zW(f, w) && (_ === y || r(_, y, t, i, s)))
                    return f.push(w)
            })) {
                d = !1;
                break
            }
        } else if (!(_ === g || r(_, g, t, i, s))) {
            d = !1;
            break
        }
    }
    return s.delete(n),
    s.delete(e),
    d
}
var OR = VW
  , WW = ko
  , $W = WW.Uint8Array
  , XW = $W;
function qW(n) {
    var e = -1
      , t = Array(n.size);
    return n.forEach(function(i, r) {
        t[++e] = [r, i]
    }),
    t
}
var jW = qW;
function YW(n) {
    var e = -1
      , t = Array(n.size);
    return n.forEach(function(i) {
        t[++e] = i
    }),
    t
}
var KW = YW
  , eE = rm
  , tE = XW
  , ZW = CR
  , JW = OR
  , QW = jW
  , e$ = KW
  , t$ = 1
  , n$ = 2
  , i$ = "[object Boolean]"
  , r$ = "[object Date]"
  , s$ = "[object Error]"
  , o$ = "[object Map]"
  , a$ = "[object Number]"
  , l$ = "[object RegExp]"
  , c$ = "[object Set]"
  , u$ = "[object String]"
  , f$ = "[object Symbol]"
  , h$ = "[object ArrayBuffer]"
  , d$ = "[object DataView]"
  , nE = eE ? eE.prototype : void 0
  , T0 = nE ? nE.valueOf : void 0;
function p$(n, e, t, i, r, s, o) {
    switch (t) {
    case d$:
        if (n.byteLength != e.byteLength || n.byteOffset != e.byteOffset)
            return !1;
        n = n.buffer,
        e = e.buffer;
    case h$:
        return !(n.byteLength != e.byteLength || !s(new tE(n), new tE(e)));
    case i$:
    case r$:
    case a$:
        return ZW(+n, +e);
    case s$:
        return n.name == e.name && n.message == e.message;
    case l$:
    case u$:
        return n == e + "";
    case o$:
        var a = QW;
    case c$:
        var c = i & t$;
        if (a || (a = e$),
        n.size != e.size && !c)
            return !1;
        var u = o.get(n);
        if (u)
            return u == e;
        i |= n$,
        o.set(n, e);
        var h = JW(a(n), a(e), i, r, s, o);
        return o.delete(n),
        h;
    case f$:
        if (T0)
            return T0.call(n) == T0.call(e)
    }
    return !1
}
var m$ = p$;
function g$(n, e) {
    for (var t = -1, i = e.length, r = n.length; ++t < i; )
        n[r + t] = e[t];
    return n
}
var _$ = g$
  , v$ = Array.isArray
  , so = v$
  , y$ = _$
  , x$ = so;
function b$(n, e, t) {
    var i = e(n);
    return x$(n) ? i : y$(i, t(n))
}
var S$ = b$;
function w$(n, e) {
    for (var t = -1, i = n == null ? 0 : n.length, r = 0, s = []; ++t < i; ) {
        var o = n[t];
        e(o, t, n) && (s[r++] = o)
    }
    return s
}
var E$ = w$;
function A$() {
    return []
}
var M$ = A$
  , T$ = E$
  , C$ = M$
  , R$ = Object.prototype
  , P$ = R$.propertyIsEnumerable
  , iE = Object.getOwnPropertySymbols
  , L$ = iE ? function(n) {
    return n == null ? [] : (n = Object(n),
    T$(iE(n), function(e) {
        return P$.call(n, e)
    }))
}
: C$
  , D$ = L$;
function I$(n, e) {
    for (var t = -1, i = Array(n); ++t < n; )
        i[t] = e(t);
    return i
}
var O$ = I$;
function N$(n) {
    return n != null && typeof n == "object"
}
var ah = N$
  , U$ = oh
  , F$ = ah
  , B$ = "[object Arguments]";
function k$(n) {
    return F$(n) && U$(n) == B$
}
var z$ = k$
  , rE = z$
  , H$ = ah
  , NR = Object.prototype
  , G$ = NR.hasOwnProperty
  , V$ = NR.propertyIsEnumerable
  , W$ = rE(function() {
    return arguments
}()) ? rE : function(n) {
    return H$(n) && G$.call(n, "callee") && !V$.call(n, "callee")
}
  , UR = W$
  , Pp = {
    exports: {}
};
function $$() {
    return !1
}
var X$ = $$;
Pp.exports;
(function(n, e) {
    var t = ko
      , i = X$
      , r = e && !e.nodeType && e
      , s = r && !0 && n && !n.nodeType && n
      , o = s && s.exports === r
      , a = o ? t.Buffer : void 0
      , c = a ? a.isBuffer : void 0
      , u = c || i;
    n.exports = u
}
)(Pp, Pp.exports);
var FR = Pp.exports
  , q$ = 9007199254740991
  , j$ = /^(?:0|[1-9]\d*)$/;
function Y$(n, e) {
    var t = typeof n;
    return e = e ?? q$,
    !!e && (t == "number" || t != "symbol" && j$.test(n)) && n > -1 && n % 1 == 0 && n < e
}
var BR = Y$
  , K$ = 9007199254740991;
function Z$(n) {
    return typeof n == "number" && n > -1 && n % 1 == 0 && n <= K$
}
var Hy = Z$
  , J$ = oh
  , Q$ = Hy
  , e9 = ah
  , t9 = "[object Arguments]"
  , n9 = "[object Array]"
  , i9 = "[object Boolean]"
  , r9 = "[object Date]"
  , s9 = "[object Error]"
  , o9 = "[object Function]"
  , a9 = "[object Map]"
  , l9 = "[object Number]"
  , c9 = "[object Object]"
  , u9 = "[object RegExp]"
  , f9 = "[object Set]"
  , h9 = "[object String]"
  , d9 = "[object WeakMap]"
  , p9 = "[object ArrayBuffer]"
  , m9 = "[object DataView]"
  , g9 = "[object Float32Array]"
  , _9 = "[object Float64Array]"
  , v9 = "[object Int8Array]"
  , y9 = "[object Int16Array]"
  , x9 = "[object Int32Array]"
  , b9 = "[object Uint8Array]"
  , S9 = "[object Uint8ClampedArray]"
  , w9 = "[object Uint16Array]"
  , E9 = "[object Uint32Array]"
  , Pn = {};
Pn[g9] = Pn[_9] = Pn[v9] = Pn[y9] = Pn[x9] = Pn[b9] = Pn[S9] = Pn[w9] = Pn[E9] = !0;
Pn[t9] = Pn[n9] = Pn[p9] = Pn[i9] = Pn[m9] = Pn[r9] = Pn[s9] = Pn[o9] = Pn[a9] = Pn[l9] = Pn[c9] = Pn[u9] = Pn[f9] = Pn[h9] = Pn[d9] = !1;
function A9(n) {
    return e9(n) && Q$(n.length) && !!Pn[J$(n)]
}
var M9 = A9;
function T9(n) {
    return function(e) {
        return n(e)
    }
}
var C9 = T9
  , Lp = {
    exports: {}
};
Lp.exports;
(function(n, e) {
    var t = RR
      , i = e && !e.nodeType && e
      , r = i && !0 && n && !n.nodeType && n
      , s = r && r.exports === i
      , o = s && t.process
      , a = function() {
        try {
            var c = r && r.require && r.require("util").types;
            return c || o && o.binding && o.binding("util")
        } catch {}
    }();
    n.exports = a
}
)(Lp, Lp.exports);
var R9 = Lp.exports
  , P9 = M9
  , L9 = C9
  , sE = R9
  , oE = sE && sE.isTypedArray
  , D9 = oE ? L9(oE) : P9
  , kR = D9
  , I9 = O$
  , O9 = UR
  , N9 = so
  , U9 = FR
  , F9 = BR
  , B9 = kR
  , k9 = Object.prototype
  , z9 = k9.hasOwnProperty;
function H9(n, e) {
    var t = N9(n)
      , i = !t && O9(n)
      , r = !t && !i && U9(n)
      , s = !t && !i && !r && B9(n)
      , o = t || i || r || s
      , a = o ? I9(n.length, String) : []
      , c = a.length;
    for (var u in n)
        (e || z9.call(n, u)) && !(o && (u == "length" || r && (u == "offset" || u == "parent") || s && (u == "buffer" || u == "byteLength" || u == "byteOffset") || F9(u, c))) && a.push(u);
    return a
}
var G9 = H9
  , V9 = Object.prototype;
function W9(n) {
    var e = n && n.constructor
      , t = typeof e == "function" && e.prototype || V9;
    return n === t
}
var $9 = W9;
function X9(n, e) {
    return function(t) {
        return n(e(t))
    }
}
var q9 = X9
  , j9 = q9
  , Y9 = j9(Object.keys, Object)
  , K9 = Y9
  , Z9 = $9
  , J9 = K9
  , Q9 = Object.prototype
  , e7 = Q9.hasOwnProperty;
function t7(n) {
    if (!Z9(n))
        return J9(n);
    var e = [];
    for (var t in Object(n))
        e7.call(n, t) && t != "constructor" && e.push(t);
    return e
}
var n7 = t7
  , i7 = LR
  , r7 = Hy;
function s7(n) {
    return n != null && r7(n.length) && !i7(n)
}
var lm = s7
  , o7 = G9
  , a7 = n7
  , l7 = lm;
function c7(n) {
    return l7(n) ? o7(n) : a7(n)
}
var cm = c7
  , u7 = S$
  , f7 = D$
  , h7 = cm;
function d7(n) {
    return u7(n, h7, f7)
}
var p7 = d7
  , aE = p7
  , m7 = 1
  , g7 = Object.prototype
  , _7 = g7.hasOwnProperty;
function v7(n, e, t, i, r, s) {
    var o = t & m7
      , a = aE(n)
      , c = a.length
      , u = aE(e)
      , h = u.length;
    if (c != h && !o)
        return !1;
    for (var m = c; m--; ) {
        var d = a[m];
        if (!(o ? d in e : _7.call(e, d)))
            return !1
    }
    var f = s.get(n)
      , _ = s.get(e);
    if (f && _)
        return f == e && _ == n;
    var g = !0;
    s.set(n, e),
    s.set(e, n);
    for (var v = o; ++m < c; ) {
        d = a[m];
        var y = n[d]
          , w = e[d];
        if (i)
            var S = o ? i(w, y, d, e, n, s) : i(y, w, d, n, e, s);
        if (!(S === void 0 ? y === w || r(y, w, t, i, s) : S)) {
            g = !1;
            break
        }
        v || (v = d == "constructor")
    }
    if (g && !v) {
        var E = n.constructor
          , b = e.constructor;
        E != b && "constructor"in n && "constructor"in e && !(typeof E == "function" && E instanceof E && typeof b == "function" && b instanceof b) && (g = !1)
    }
    return s.delete(n),
    s.delete(e),
    g
}
var y7 = v7
  , x7 = nu
  , b7 = ko
  , S7 = x7(b7, "DataView")
  , w7 = S7
  , E7 = nu
  , A7 = ko
  , M7 = E7(A7, "Promise")
  , T7 = M7
  , C7 = nu
  , R7 = ko
  , P7 = C7(R7, "Set")
  , L7 = P7
  , D7 = nu
  , I7 = ko
  , O7 = D7(I7, "WeakMap")
  , N7 = O7
  , pv = w7
  , mv = ky
  , gv = T7
  , _v = L7
  , vv = N7
  , zR = oh
  , ou = DR
  , lE = "[object Map]"
  , U7 = "[object Object]"
  , cE = "[object Promise]"
  , uE = "[object Set]"
  , fE = "[object WeakMap]"
  , hE = "[object DataView]"
  , F7 = ou(pv)
  , B7 = ou(mv)
  , k7 = ou(gv)
  , z7 = ou(_v)
  , H7 = ou(vv)
  , il = zR;
(pv && il(new pv(new ArrayBuffer(1))) != hE || mv && il(new mv) != lE || gv && il(gv.resolve()) != cE || _v && il(new _v) != uE || vv && il(new vv) != fE) && (il = function(n) {
    var e = zR(n)
      , t = e == U7 ? n.constructor : void 0
      , i = t ? ou(t) : "";
    if (i)
        switch (i) {
        case F7:
            return hE;
        case B7:
            return lE;
        case k7:
            return cE;
        case z7:
            return uE;
        case H7:
            return fE
        }
    return e
}
);
var G7 = il
  , C0 = IR
  , V7 = OR
  , W7 = m$
  , $7 = y7
  , dE = G7
  , pE = so
  , mE = FR
  , X7 = kR
  , q7 = 1
  , gE = "[object Arguments]"
  , _E = "[object Array]"
  , Bd = "[object Object]"
  , j7 = Object.prototype
  , vE = j7.hasOwnProperty;
function Y7(n, e, t, i, r, s) {
    var o = pE(n)
      , a = pE(e)
      , c = o ? _E : dE(n)
      , u = a ? _E : dE(e);
    c = c == gE ? Bd : c,
    u = u == gE ? Bd : u;
    var h = c == Bd
      , m = u == Bd
      , d = c == u;
    if (d && mE(n)) {
        if (!mE(e))
            return !1;
        o = !0,
        h = !1
    }
    if (d && !h)
        return s || (s = new C0),
        o || X7(n) ? V7(n, e, t, i, r, s) : W7(n, e, c, t, i, r, s);
    if (!(t & q7)) {
        var f = h && vE.call(n, "__wrapped__")
          , _ = m && vE.call(e, "__wrapped__");
        if (f || _) {
            var g = f ? n.value() : n
              , v = _ ? e.value() : e;
            return s || (s = new C0),
            r(g, v, t, i, s)
        }
    }
    return d ? (s || (s = new C0),
    $7(n, e, t, i, r, s)) : !1
}
var K7 = Y7
  , Z7 = K7
  , yE = ah;
function HR(n, e, t, i, r) {
    return n === e ? !0 : n == null || e == null || !yE(n) && !yE(e) ? n !== n && e !== e : Z7(n, e, t, i, HR, r)
}
var GR = HR
  , J7 = IR
  , Q7 = GR
  , eX = 1
  , tX = 2;
function nX(n, e, t, i) {
    var r = t.length
      , s = r
      , o = !i;
    if (n == null)
        return !s;
    for (n = Object(n); r--; ) {
        var a = t[r];
        if (o && a[2] ? a[1] !== n[a[0]] : !(a[0]in n))
            return !1
    }
    for (; ++r < s; ) {
        a = t[r];
        var c = a[0]
          , u = n[c]
          , h = a[1];
        if (o && a[2]) {
            if (u === void 0 && !(c in n))
                return !1
        } else {
            var m = new J7;
            if (i)
                var d = i(u, h, c, n, e, m);
            if (!(d === void 0 ? Q7(h, u, eX | tX, i, m) : d))
                return !1
        }
    }
    return !0
}
var iX = nX
  , rX = sm;
function sX(n) {
    return n === n && !rX(n)
}
var VR = sX
  , oX = VR
  , aX = cm;
function lX(n) {
    for (var e = aX(n), t = e.length; t--; ) {
        var i = e[t]
          , r = n[i];
        e[t] = [i, r, oX(r)]
    }
    return e
}
var cX = lX;
function uX(n, e) {
    return function(t) {
        return t == null ? !1 : t[n] === e && (e !== void 0 || n in Object(t))
    }
}
var WR = uX
  , fX = iX
  , hX = cX
  , dX = WR;
function pX(n) {
    var e = hX(n);
    return e.length == 1 && e[0][2] ? dX(e[0][0], e[0][1]) : function(t) {
        return t === n || fX(t, n, e)
    }
}
var mX = pX
  , gX = oh
  , _X = ah
  , vX = "[object Symbol]";
function yX(n) {
    return typeof n == "symbol" || _X(n) && gX(n) == vX
}
var um = yX
  , xX = so
  , bX = um
  , SX = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
  , wX = /^\w*$/;
function EX(n, e) {
    if (xX(n))
        return !1;
    var t = typeof n;
    return t == "number" || t == "symbol" || t == "boolean" || n == null || bX(n) ? !0 : wX.test(n) || !SX.test(n) || e != null && n in Object(e)
}
var Gy = EX
  , $R = zy
  , AX = "Expected a function";
function Vy(n, e) {
    if (typeof n != "function" || e != null && typeof e != "function")
        throw new TypeError(AX);
    var t = function() {
        var i = arguments
          , r = e ? e.apply(this, i) : i[0]
          , s = t.cache;
        if (s.has(r))
            return s.get(r);
        var o = n.apply(this, i);
        return t.cache = s.set(r, o) || s,
        o
    };
    return t.cache = new (Vy.Cache || $R),
    t
}
Vy.Cache = $R;
var MX = Vy
  , TX = MX
  , CX = 500;
function RX(n) {
    var e = TX(n, function(i) {
        return t.size === CX && t.clear(),
        i
    })
      , t = e.cache;
    return e
}
var PX = RX
  , LX = PX
  , DX = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
  , IX = /\\(\\)?/g
  , OX = LX(function(n) {
    var e = [];
    return n.charCodeAt(0) === 46 && e.push(""),
    n.replace(DX, function(t, i, r, s) {
        e.push(r ? s.replace(IX, "$1") : i || t)
    }),
    e
})
  , NX = OX
  , xE = rm
  , UX = TR
  , FX = so
  , BX = um
  , kX = 1 / 0
  , bE = xE ? xE.prototype : void 0
  , SE = bE ? bE.toString : void 0;
function XR(n) {
    if (typeof n == "string")
        return n;
    if (FX(n))
        return UX(n, XR) + "";
    if (BX(n))
        return SE ? SE.call(n) : "";
    var e = n + "";
    return e == "0" && 1 / n == -kX ? "-0" : e
}
var zX = XR
  , HX = zX;
function GX(n) {
    return n == null ? "" : HX(n)
}
var VX = GX
  , WX = so
  , $X = Gy
  , XX = NX
  , qX = VX;
function jX(n, e) {
    return WX(n) ? n : $X(n, e) ? [n] : XX(qX(n))
}
var qR = jX
  , YX = um
  , KX = 1 / 0;
function ZX(n) {
    if (typeof n == "string" || YX(n))
        return n;
    var e = n + "";
    return e == "0" && 1 / n == -KX ? "-0" : e
}
var fm = ZX
  , JX = qR
  , QX = fm;
function eq(n, e) {
    e = JX(e, n);
    for (var t = 0, i = e.length; n != null && t < i; )
        n = n[QX(e[t++])];
    return t && t == i ? n : void 0
}
var jR = eq
  , tq = jR;
function nq(n, e, t) {
    var i = n == null ? void 0 : tq(n, e);
    return i === void 0 ? t : i
}
var iq = nq;
function rq(n, e) {
    return n != null && e in Object(n)
}
var sq = rq
  , oq = qR
  , aq = UR
  , lq = so
  , cq = BR
  , uq = Hy
  , fq = fm;
function hq(n, e, t) {
    e = oq(e, n);
    for (var i = -1, r = e.length, s = !1; ++i < r; ) {
        var o = fq(e[i]);
        if (!(s = n != null && t(n, o)))
            break;
        n = n[o]
    }
    return s || ++i != r ? s : (r = n == null ? 0 : n.length,
    !!r && uq(r) && cq(o, r) && (lq(n) || aq(n)))
}
var dq = hq
  , pq = sq
  , mq = dq;
function gq(n, e) {
    return n != null && mq(n, e, pq)
}
var _q = gq
  , vq = GR
  , yq = iq
  , xq = _q
  , bq = Gy
  , Sq = VR
  , wq = WR
  , Eq = fm
  , Aq = 1
  , Mq = 2;
function Tq(n, e) {
    return bq(n) && Sq(e) ? wq(Eq(n), e) : function(t) {
        var i = yq(t, n);
        return i === void 0 && i === e ? xq(t, n) : vq(e, i, Aq | Mq)
    }
}
var Cq = Tq;
function Rq(n) {
    return n
}
var YR = Rq;
function Pq(n) {
    return function(e) {
        return e == null ? void 0 : e[n]
    }
}
var Lq = Pq
  , Dq = jR;
function Iq(n) {
    return function(e) {
        return Dq(e, n)
    }
}
var Oq = Iq
  , Nq = Lq
  , Uq = Oq
  , Fq = Gy
  , Bq = fm;
function kq(n) {
    return Fq(n) ? Nq(Bq(n)) : Uq(n)
}
var zq = kq
  , Hq = mX
  , Gq = Cq
  , Vq = YR
  , Wq = so
  , $q = zq;
function Xq(n) {
    return typeof n == "function" ? n : n == null ? Vq : typeof n == "object" ? Wq(n) ? Gq(n[0], n[1]) : Hq(n) : $q(n)
}
var Wy = Xq;
function qq(n) {
    return function(e, t, i) {
        for (var r = -1, s = Object(e), o = i(e), a = o.length; a--; ) {
            var c = o[n ? a : ++r];
            if (t(s[c], c, s) === !1)
                break
        }
        return e
    }
}
var jq = qq
  , Yq = jq
  , Kq = Yq()
  , Zq = Kq
  , Jq = Zq
  , Qq = cm;
function ej(n, e) {
    return n && Jq(n, e, Qq)
}
var tj = ej
  , nj = lm;
function ij(n, e) {
    return function(t, i) {
        if (t == null)
            return t;
        if (!nj(t))
            return n(t, i);
        for (var r = t.length, s = e ? r : -1, o = Object(t); (e ? s-- : ++s < r) && i(o[s], s, o) !== !1; )
            ;
        return t
    }
}
var rj = ij
  , sj = tj
  , oj = rj
  , aj = oj(sj)
  , KR = aj
  , lj = KR
  , cj = lm;
function uj(n, e) {
    var t = -1
      , i = cj(n) ? Array(n.length) : [];
    return lj(n, function(r, s, o) {
        i[++t] = e(r, s, o)
    }),
    i
}
var fj = uj
  , hj = TR
  , dj = Wy
  , pj = fj
  , mj = so;
function gj(n, e) {
    var t = mj(n) ? hj : pj;
    return t(n, dj(e))
}
var _j = gj;
const vj = Uo(_j)
  , Wf = (n,e=0)=>{
    const t = n.getBoundingClientRect();
    return {
        bottom: t.bottom,
        height: t.height,
        left: t.left,
        top: t.top + e,
        width: t.width
    }
}
;
function $s(n, e) {
    return n instanceof window.HTMLElement ? [e(n)] : vj(n, e)
}
var yv = {
    exports: {}
};
(function(n, e) {
    (function(t, i) {
        var r = "1.0.37"
          , s = ""
          , o = "?"
          , a = "function"
          , c = "undefined"
          , u = "object"
          , h = "string"
          , m = "major"
          , d = "model"
          , f = "name"
          , _ = "type"
          , g = "vendor"
          , v = "version"
          , y = "architecture"
          , w = "console"
          , S = "mobile"
          , E = "tablet"
          , b = "smarttv"
          , T = "wearable"
          , C = "embedded"
          , P = 500
          , A = "Amazon"
          , R = "Apple"
          , I = "ASUS"
          , D = "BlackBerry"
          , H = "Browser"
          , B = "Chrome"
          , G = "Edge"
          , X = "Firefox"
          , V = "Google"
          , ee = "Huawei"
          , re = "LG"
          , k = "Microsoft"
          , oe = "Motorola"
          , ae = "Opera"
          , ne = "Samsung"
          , fe = "Sharp"
          , xe = "Sony"
          , Re = "Xiaomi"
          , Ue = "Zebra"
          , He = "Facebook"
          , qe = "Chromium OS"
          , Xe = "Mac OS"
          , st = function(j, he) {
            var le = {};
            for (var me in j)
                he[me] && he[me].length % 2 === 0 ? le[me] = he[me].concat(j[me]) : le[me] = j[me];
            return le
        }
          , ie = function(j) {
            for (var he = {}, le = 0; le < j.length; le++)
                he[j[le].toUpperCase()] = j[le];
            return he
        }
          , dt = function(j, he) {
            return typeof j === h ? Ne(he).indexOf(Ne(j)) !== -1 : !1
        }
          , Ne = function(j) {
            return j.toLowerCase()
        }
          , Ye = function(j) {
            return typeof j === h ? j.replace(/[^\d\.]/g, s).split(".")[0] : i
        }
          , Qe = function(j, he) {
            if (typeof j === h)
                return j = j.replace(/^\s\s*/, s),
                typeof he === c ? j : j.substring(0, P)
        }
          , te = function(j, he) {
            for (var le = 0, me, We, Te, Ee, Ae, _t; le < he.length && !Ae; ) {
                var Pe = he[le]
                  , Bt = he[le + 1];
                for (me = We = 0; me < Pe.length && !Ae && Pe[me]; )
                    if (Ae = Pe[me++].exec(j),
                    Ae)
                        for (Te = 0; Te < Bt.length; Te++)
                            _t = Ae[++We],
                            Ee = Bt[Te],
                            typeof Ee === u && Ee.length > 0 ? Ee.length === 2 ? typeof Ee[1] == a ? this[Ee[0]] = Ee[1].call(this, _t) : this[Ee[0]] = Ee[1] : Ee.length === 3 ? typeof Ee[1] === a && !(Ee[1].exec && Ee[1].test) ? this[Ee[0]] = _t ? Ee[1].call(this, _t, Ee[2]) : i : this[Ee[0]] = _t ? _t.replace(Ee[1], Ee[2]) : i : Ee.length === 4 && (this[Ee[0]] = _t ? Ee[3].call(this, _t.replace(Ee[1], Ee[2])) : i) : this[Ee] = _t || i;
                le += 2
            }
        }
          , ot = function(j, he) {
            for (var le in he)
                if (typeof he[le] === u && he[le].length > 0) {
                    for (var me = 0; me < he[le].length; me++)
                        if (dt(he[le][me], j))
                            return le === o ? i : le
                } else if (dt(he[le], j))
                    return le === o ? i : le;
            return j
        }
          , ft = {
            "1.0": "/8",
            "1.2": "/1",
            "1.3": "/3",
            "2.0": "/412",
            "2.0.2": "/416",
            "2.0.3": "/417",
            "2.0.4": "/419",
            "?": "/"
        }
          , Tt = {
            ME: "4.90",
            "NT 3.11": "NT3.51",
            "NT 4.0": "NT4.0",
            2e3: "NT 5.0",
            XP: ["NT 5.1", "NT 5.2"],
            Vista: "NT 6.0",
            7: "NT 6.1",
            8: "NT 6.2",
            "8.1": "NT 6.3",
            10: ["NT 6.4", "NT 10.0"],
            RT: "ARM"
        }
          , pt = {
            browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [v, [f, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [v, [f, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [f, v], [/opios[\/ ]+([\w\.]+)/i], [v, [f, ae + " Mini"]], [/\bopr\/([\w\.]+)/i], [v, [f, ae]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [v, [f, "Baidu"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(heytap|ovi)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [f, v], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [v, [f, "UC" + H]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [v, [f, "WeChat"]], [/konqueror\/([\w\.]+)/i], [v, [f, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [v, [f, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [v, [f, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [v, [f, "Smart Lenovo " + H]], [/(avast|avg)\/([\w\.]+)/i], [[f, /(.+)/, "$1 Secure " + H], v], [/\bfocus\/([\w\.]+)/i], [v, [f, X + " Focus"]], [/\bopt\/([\w\.]+)/i], [v, [f, ae + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [v, [f, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [v, [f, "Dolphin"]], [/coast\/([\w\.]+)/i], [v, [f, ae + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [v, [f, "MIUI " + H]], [/fxios\/([-\w\.]+)/i], [v, [f, X]], [/\bqihu|(qi?ho?o?|360)browser/i], [[f, "360 " + H]], [/(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i], [[f, /(.+)/, "$1 " + H], v], [/samsungbrowser\/([\w\.]+)/i], [v, [f, ne + " Internet"]], [/(comodo_dragon)\/([\w\.]+)/i], [[f, /_/g, " "], v], [/metasr[\/ ]?([\d\.]+)/i], [v, [f, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[f, "Sogou Mobile"], v], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i], [f, v], [/(lbbrowser)/i, /\[(linkedin)app\]/i], [f], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[f, He], v], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i], [f, v], [/\bgsa\/([\w\.]+) .*safari\//i], [v, [f, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [v, [f, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [v, [f, B + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[f, B + " WebView"], v], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [v, [f, "Android " + H]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [f, v], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [v, [f, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [v, f], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [f, [v, ot, ft]], [/(webkit|khtml)\/([\w\.]+)/i], [f, v], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[f, "Netscape"], v], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [v, [f, X + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [f, v], [/(cobalt)\/([\w\.]+)/i], [f, [v, /master.|lts./, ""]]],
            cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[y, "amd64"]], [/(ia32(?=;))/i], [[y, Ne]], [/((?:i[346]|x)86)[;\)]/i], [[y, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[y, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[y, "armhf"]], [/windows (ce|mobile); ppc;/i], [[y, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[y, /ower/, s, Ne]], [/(sun4\w)[;\)]/i], [[y, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[y, Ne]]],
            device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [d, [g, ne], [_, E]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [d, [g, ne], [_, S]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [d, [g, R], [_, S]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [d, [g, R], [_, E]], [/(macintosh);/i], [d, [g, R]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [d, [g, fe], [_, S]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [d, [g, ee], [_, E]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [d, [g, ee], [_, S]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[d, /_/g, " "], [g, Re], [_, S]], [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i, /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[d, /_/g, " "], [g, Re], [_, E]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [d, [g, "OPPO"], [_, S]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [d, [g, "Vivo"], [_, S]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [d, [g, "Realme"], [_, S]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [d, [g, oe], [_, S]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [d, [g, oe], [_, E]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [d, [g, re], [_, E]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [d, [g, re], [_, S]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [d, [g, "Lenovo"], [_, E]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[d, /_/g, " "], [g, "Nokia"], [_, S]], [/(pixel c)\b/i], [d, [g, V], [_, E]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [d, [g, V], [_, S]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [d, [g, xe], [_, S]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[d, "Xperia Tablet"], [g, xe], [_, E]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [d, [g, "OnePlus"], [_, S]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [d, [g, A], [_, E]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[d, /(.+)/g, "Fire Phone $1"], [g, A], [_, S]], [/(playbook);[-\w\),; ]+(rim)/i], [d, g, [_, E]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [d, [g, D], [_, S]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [d, [g, I], [_, E]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [d, [g, I], [_, S]], [/(nexus 9)/i], [d, [g, "HTC"], [_, E]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [g, [d, /_/g, " "], [_, S]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [d, [g, "Acer"], [_, E]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [d, [g, "Meizu"], [_, S]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [d, [g, "Ulefone"], [_, S]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [g, d, [_, S]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [g, d, [_, E]], [/(surface duo)/i], [d, [g, k], [_, E]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [d, [g, "Fairphone"], [_, S]], [/(u304aa)/i], [d, [g, "AT&T"], [_, S]], [/\bsie-(\w*)/i], [d, [g, "Siemens"], [_, S]], [/\b(rct\w+) b/i], [d, [g, "RCA"], [_, E]], [/\b(venue[\d ]{2,7}) b/i], [d, [g, "Dell"], [_, E]], [/\b(q(?:mv|ta)\w+) b/i], [d, [g, "Verizon"], [_, E]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [d, [g, "Barnes & Noble"], [_, E]], [/\b(tm\d{3}\w+) b/i], [d, [g, "NuVision"], [_, E]], [/\b(k88) b/i], [d, [g, "ZTE"], [_, E]], [/\b(nx\d{3}j) b/i], [d, [g, "ZTE"], [_, S]], [/\b(gen\d{3}) b.+49h/i], [d, [g, "Swiss"], [_, S]], [/\b(zur\d{3}) b/i], [d, [g, "Swiss"], [_, E]], [/\b((zeki)?tb.*\b) b/i], [d, [g, "Zeki"], [_, E]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[g, "Dragon Touch"], d, [_, E]], [/\b(ns-?\w{0,9}) b/i], [d, [g, "Insignia"], [_, E]], [/\b((nxa|next)-?\w{0,9}) b/i], [d, [g, "NextBook"], [_, E]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[g, "Voice"], d, [_, S]], [/\b(lvtel\-)?(v1[12]) b/i], [[g, "LvTel"], d, [_, S]], [/\b(ph-1) /i], [d, [g, "Essential"], [_, S]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [d, [g, "Envizen"], [_, E]], [/\b(trio[-\w\. ]+) b/i], [d, [g, "MachSpeed"], [_, E]], [/\btu_(1491) b/i], [d, [g, "Rotor"], [_, E]], [/(shield[\w ]+) b/i], [d, [g, "Nvidia"], [_, E]], [/(sprint) (\w+)/i], [g, d, [_, S]], [/(kin\.[onetw]{3})/i], [[d, /\./g, " "], [g, k], [_, S]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [d, [g, Ue], [_, E]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [d, [g, Ue], [_, S]], [/smart-tv.+(samsung)/i], [g, [_, b]], [/hbbtv.+maple;(\d+)/i], [[d, /^/, "SmartTV"], [g, ne], [_, b]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[g, re], [_, b]], [/(apple) ?tv/i], [g, [d, R + " TV"], [_, b]], [/crkey/i], [[d, B + "cast"], [g, V], [_, b]], [/droid.+aft(\w+)( bui|\))/i], [d, [g, A], [_, b]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [d, [g, fe], [_, b]], [/(bravia[\w ]+)( bui|\))/i], [d, [g, xe], [_, b]], [/(mitv-\w{5}) bui/i], [d, [g, Re], [_, b]], [/Hbbtv.*(technisat) (.*);/i], [g, d, [_, b]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[g, Qe], [d, Qe], [_, b]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[_, b]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [g, d, [_, w]], [/droid.+; (shield) bui/i], [d, [g, "Nvidia"], [_, w]], [/(playstation [345portablevi]+)/i], [d, [g, xe], [_, w]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [d, [g, k], [_, w]], [/((pebble))app/i], [g, d, [_, T]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [d, [g, R], [_, T]], [/droid.+; (glass) \d/i], [d, [g, V], [_, T]], [/droid.+; (wt63?0{2,3})\)/i], [d, [g, Ue], [_, T]], [/(quest( 2| pro)?)/i], [d, [g, He], [_, T]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [g, [_, C]], [/(aeobc)\b/i], [d, [g, A], [_, C]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i], [d, [_, S]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [d, [_, E]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[_, E]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[_, S]], [/(android[-\w\. ]{0,9});.+buil/i], [d, [g, "Generic"]]],
            engine: [[/windows.+ edge\/([\w\.]+)/i], [v, [f, G + "HTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [v, [f, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [f, v], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [v, f]],
            os: [[/microsoft (windows) (vista|xp)/i], [f, v], [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i], [f, [v, ot, Tt]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[v, ot, Tt], [f, "Windows"]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[v, /_/g, "."], [f, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[f, Xe], [v, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [v, f], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [f, v], [/\(bb(10);/i], [v, [f, D]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [v, [f, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [v, [f, X + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [v, [f, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [v, [f, "watchOS"]], [/crkey\/([\d\.]+)/i], [v, [f, B + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[f, qe], v], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [f, v], [/(sunos) ?([\w\.\d]*)/i], [[f, "Solaris"], v], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [f, v]]
        }
          , Ct = function(j, he) {
            if (typeof j === u && (he = j,
            j = i),
            !(this instanceof Ct))
                return new Ct(j,he).getResult();
            var le = typeof t !== c && t.navigator ? t.navigator : i
              , me = j || (le && le.userAgent ? le.userAgent : s)
              , We = le && le.userAgentData ? le.userAgentData : i
              , Te = he ? st(pt, he) : pt
              , Ee = le && le.userAgent == me;
            return this.getBrowser = function() {
                var Ae = {};
                return Ae[f] = i,
                Ae[v] = i,
                te.call(Ae, me, Te.browser),
                Ae[m] = Ye(Ae[v]),
                Ee && le && le.brave && typeof le.brave.isBrave == a && (Ae[f] = "Brave"),
                Ae
            }
            ,
            this.getCPU = function() {
                var Ae = {};
                return Ae[y] = i,
                te.call(Ae, me, Te.cpu),
                Ae
            }
            ,
            this.getDevice = function() {
                var Ae = {};
                return Ae[g] = i,
                Ae[d] = i,
                Ae[_] = i,
                te.call(Ae, me, Te.device),
                Ee && !Ae[_] && We && We.mobile && (Ae[_] = S),
                Ee && Ae[d] == "Macintosh" && le && typeof le.standalone !== c && le.maxTouchPoints && le.maxTouchPoints > 2 && (Ae[d] = "iPad",
                Ae[_] = E),
                Ae
            }
            ,
            this.getEngine = function() {
                var Ae = {};
                return Ae[f] = i,
                Ae[v] = i,
                te.call(Ae, me, Te.engine),
                Ae
            }
            ,
            this.getOS = function() {
                var Ae = {};
                return Ae[f] = i,
                Ae[v] = i,
                te.call(Ae, me, Te.os),
                Ee && !Ae[f] && We && We.platform != "Unknown" && (Ae[f] = We.platform.replace(/chrome os/i, qe).replace(/macos/i, Xe)),
                Ae
            }
            ,
            this.getResult = function() {
                return {
                    ua: this.getUA(),
                    browser: this.getBrowser(),
                    engine: this.getEngine(),
                    os: this.getOS(),
                    device: this.getDevice(),
                    cpu: this.getCPU()
                }
            }
            ,
            this.getUA = function() {
                return me
            }
            ,
            this.setUA = function(Ae) {
                return me = typeof Ae === h && Ae.length > P ? Qe(Ae, P) : Ae,
                this
            }
            ,
            this.setUA(me),
            this
        };
        Ct.VERSION = r,
        Ct.BROWSER = ie([f, v, m]),
        Ct.CPU = ie([y]),
        Ct.DEVICE = ie([d, g, _, w, S, b, E, T, C]),
        Ct.ENGINE = Ct.OS = ie([f, v]),
        n.exports && (e = n.exports = Ct),
        e.UAParser = Ct;
        var z = typeof t !== c && (t.jQuery || t.Zepto);
        if (z && !z.ua) {
            var N = new Ct;
            z.ua = N.getResult(),
            z.ua.get = function() {
                return N.getUA()
            }
            ,
            z.ua.set = function(j) {
                N.setUA(j);
                var he = N.getResult();
                for (var le in he)
                    z.ua[le] = he[le]
            }
        }
    }
    )(typeof window == "object" ? window : lr)
}
)(yv, yv.exports);
var yj = yv.exports;
const xj = Uo(yj);
class bj {
    constructor() {
        this.parser = new xj,
        this.type = this.determineDeviceType(this.parser.getDevice().type),
        this.isMobile = this.type !== "desktop",
        this.isPhone = this.type === "phone",
        this.isTablet = this.type === "tablet",
        this.isDesktop = this.type === "desktop",
        this.browser = this.determineBrowser(this.parser.getBrowser()),
        this.isMixBlendModeUnsupported = typeof window.getComputedStyle(document.body).mixBlendMode > "u",
        this.setHTMLClass()
    }
    determineDeviceType(e) {
        return e === "mobile" ? "phone" : ["desktop", "phone", "tablet"].includes(e) ? e : "desktop"
    }
    determineBrowser(e) {
        if (e.name === "Safari") {
            const t = document.querySelectorAll(".card__effects__holo--after")
              , i = document.querySelectorAll(".card__effects__holo");
            Jt.each(t, r=>r.remove()),
            Jt.each(i, r=>r.classList.add("reduced"))
        }
        return e.name
    }
    setHTMLClass() {
        document.documentElement.classList.add(this.isMobile ? "mobile" : "desktop")
    }
    isWebGLAvailable() {
        if (!this.webGLAvailable) {
            const e = document.createElement("canvas");
            this.webGLAvailable = !!window.WebGLRenderingContext && !!(e.getContext("webgl") || e.getContext("experimental-webgl"))
        }
        return this.webGLAvailable
    }
    isWebPSupported() {
        if (this.webPSupported === !1) {
            const e = document.createElement("canvas");
            e.getContext("2d") ? this.webPSupported = e.toDataURL("image/webp").startsWith("data:image/webp") : this.webPSupported = !1
        }
        return this.webPSupported
    }
    isAppBrowser() {
        const e = navigator.userAgent;
        return /FBAN|FBAV|Twitter/.test(e)
    }
    check({onErrorWebGL: e, onSuccess: t}) {
        this.isWebGLAvailable() ? t() : e()
    }
}
const tn = new bj;
let Sj = class {
    constructor({screen: e, engine: t, matterCanvas: i}) {
        this.screen = e,
        this.engine = t,
        this.matterCanvas = i,
        this.projectElements = document.querySelectorAll(".project"),
        this.elements = $s(this.projectElements, r=>({
            id: r.getAttribute("id"),
            src: r.getAttribute("data-fall-src"),
            width: r.getAttribute("data-fall-width"),
            height: r.getAttribute("data-fall-height"),
            svg: r.getAttribute("data-fall-svg"),
            vertices: null
        })),
        this.bodies = [],
        this.isVisible = !1,
        this.transformPrefix = La("transform")
    }
    show(e) {
        this.isVisible = !0,
        this.template = e;
        const t = Jt.find(this.elements, i=>e.includes(i.id));
        t.svg && t.src && (t.vertices === null ? this.loadSvg(t.svg).then(i=>{
            const r = qt.Svg.pathToVertices(i.querySelector("path"));
            ve.delayedCall(1.4, ()=>{
                this.makeSvgFall(r, t, e)
            }
            )
        }
        ) : ve.delayedCall(1.4, ()=>{
            this.makeSvgFall(t.vertices, t, e)
        }
        ))
    }
    hide() {
        ve.delayedCall(1.2, ()=>{
            Jt.each(this.bodies, e=>qt.Composite.remove(this.engine.world, e))
        }
        ),
        this.isVisible = !1
    }
    onResize({screen: e}) {
        this.screen = e;
        const t = tn.isMobile || this.screen.width < 768 ? 393 : 1440;
        this.scale = this.screen.width / t
    }
    makeSvgFall(e, t, i) {
        if (Jt.each(qt.Composite.allBodies(this.engine.world), o=>{
            o.isStatic || qt.Composite.remove(this.engine.world, o)
        }
        ),
        i !== this.template || !i.includes(t.id))
            return;
        const r = .5;
        let s = Math.floor(this.screen.width / Number(t.width / 3 * this.scale));
        this.bodies = [],
        t.id === "wwf" && (s *= 2),
        (tn.isMobile || this.screen.width < 768) && (s *= 1.5);
        for (let o = 0; o < s; o++) {
            let a = Number(t.width / 3 * this.scale) * (o + 1);
            t.id === "wwf" && (a = Number(t.width / 6) * (o + 1)),
            (tn.isMobile || this.screen.width < 768) && (a = a / 1.5);
            const c = ve.utils.random(-200, -1e3)
              , u = qt.Bodies.fromVertices(a, c, [e], {
                render: {
                    sprite: {
                        texture: t.src
                    }
                }
            });
            if (!this.isVisible)
                return;
            this.bodies.push(u),
            qt.Body.rotate(u, ve.utils.random(-90, 90)),
            qt.Body.applyForce(u, u.position, {
                x: 0,
                y: r
            }),
            qt.Body.scale(u, this.scale, this.scale),
            u.render.sprite.xScale = this.scale / 3,
            u.render.sprite.yScale = this.scale / 3,
            qt.Composite.add(this.engine.world, u)
        }
    }
    loadSvg(e) {
        return fetch(e).then(function(t) {
            return t.text()
        }).then(function(t) {
            return new window.DOMParser().parseFromString(t, "image/svg+xml")
        })
    }
    update(e) {
        this.isVisible && (this.matterCanvas.style[this.transformPrefix] = `translate3d(0, ${-Math.round(e.current)}px, 0)`)
    }
}
;
const wj = n=>{
    let e = n.httpHandler;
    return {
        setHttpHandler(t) {
            e = t
        },
        httpHandler() {
            return e
        },
        updateHttpClientConfig(t, i) {
            e.updateHttpClientConfig(t, i)
        },
        httpHandlerConfigs() {
            return e.httpHandlerConfigs()
        }
    }
}
  , Ej = n=>({
    httpHandler: n.httpHandler()
});
var wE;
(function(n) {
    n.HEADER = "header",
    n.QUERY = "query"
}
)(wE || (wE = {}));
var EE;
(function(n) {
    n.HEADER = "header",
    n.QUERY = "query"
}
)(EE || (EE = {}));
var $f;
(function(n) {
    n.HTTP = "http",
    n.HTTPS = "https"
}
)($f || ($f = {}));
var Dp;
(function(n) {
    n.MD5 = "md5",
    n.CRC32 = "crc32",
    n.CRC32C = "crc32c",
    n.SHA1 = "sha1",
    n.SHA256 = "sha256"
}
)(Dp || (Dp = {}));
var AE;
(function(n) {
    n[n.HEADER = 0] = "HEADER",
    n[n.TRAILER = 1] = "TRAILER"
}
)(AE || (AE = {}));
const Ip = "__smithy_context";
var ME;
(function(n) {
    n.PROFILE = "profile",
    n.SSO_SESSION = "sso-session",
    n.SERVICES = "services"
}
)(ME || (ME = {}));
var TE;
(function(n) {
    n.HTTP_0_9 = "http/0.9",
    n.HTTP_1_0 = "http/1.0",
    n.TDS_8_0 = "tds/8.0"
}
)(TE || (TE = {}));
class dr {
    constructor(e) {
        this.method = e.method || "GET",
        this.hostname = e.hostname || "localhost",
        this.port = e.port,
        this.query = e.query || {},
        this.headers = e.headers || {},
        this.body = e.body,
        this.protocol = e.protocol ? e.protocol.slice(-1) !== ":" ? `${e.protocol}:` : e.protocol : "https:",
        this.path = e.path ? e.path.charAt(0) !== "/" ? `/${e.path}` : e.path : "/",
        this.username = e.username,
        this.password = e.password,
        this.fragment = e.fragment
    }
    static isInstance(e) {
        if (!e)
            return !1;
        const t = e;
        return "method"in t && "protocol"in t && "hostname"in t && "path"in t && typeof t.query == "object" && typeof t.headers == "object"
    }
    clone() {
        const e = new dr({
            ...this,
            headers: {
                ...this.headers
            }
        });
        return e.query && (e.query = Aj(e.query)),
        e
    }
}
function Aj(n) {
    return Object.keys(n).reduce((e,t)=>{
        const i = n[t];
        return {
            ...e,
            [t]: Array.isArray(i) ? [...i] : i
        }
    }
    , {})
}
class Op {
    constructor(e) {
        this.statusCode = e.statusCode,
        this.reason = e.reason,
        this.headers = e.headers || {},
        this.body = e.body
    }
    static isInstance(e) {
        if (!e)
            return !1;
        const t = e;
        return typeof t.statusCode == "number" && typeof t.headers == "object"
    }
}
function Mj(n) {
    return e=>async t=>{
        const {request: i} = t;
        return dr.isInstance(i) && i.body && n.runtime === "node" && (i.headers = {
            ...i.headers,
            Expect: "100-continue"
        }),
        e({
            ...t,
            request: i
        })
    }
}
const Tj = {
    step: "build",
    tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
    name: "addExpectContinueMiddleware",
    override: !0
}
  , Cj = n=>({
    applyToStack: e=>{
        e.add(Mj(n), Tj)
    }
});
const Rj = n=>e=>async t=>{
    if (!dr.isInstance(t.request))
        return e(t);
    const {request: i} = t
      , {handlerProtocol: r=""} = n.requestHandler.metadata || {};
    if (r.indexOf("h2") >= 0 && !i.headers[":authority"])
        delete i.headers.host,
        i.headers[":authority"] = i.hostname + (i.port ? ":" + i.port : "");
    else if (!i.headers.host) {
        let s = i.hostname;
        i.port != null && (s += `:${i.port}`),
        i.headers.host = s
    }
    return e(t)
}
  , Pj = {
    name: "hostHeaderMiddleware",
    step: "build",
    priority: "low",
    tags: ["HOST"],
    override: !0
}
  , Lj = n=>({
    applyToStack: e=>{
        e.add(Rj(n), Pj)
    }
})
  , Dj = ()=>(n,e)=>async t=>{
    var i, r;
    try {
        const s = await n(t)
          , {clientName: o, commandName: a, logger: c, dynamoDbDocumentClientOptions: u={}} = e
          , {overrideInputFilterSensitiveLog: h, overrideOutputFilterSensitiveLog: m} = u
          , d = h ?? e.inputFilterSensitiveLog
          , f = m ?? e.outputFilterSensitiveLog
          , {$metadata: _, ...g} = s.output;
        return (i = c == null ? void 0 : c.info) == null || i.call(c, {
            clientName: o,
            commandName: a,
            input: d(t.input),
            output: f(g),
            metadata: _
        }),
        s
    } catch (s) {
        const {clientName: o, commandName: a, logger: c, dynamoDbDocumentClientOptions: u={}} = e
          , {overrideInputFilterSensitiveLog: h} = u
          , m = h ?? e.inputFilterSensitiveLog;
        throw (r = c == null ? void 0 : c.error) == null || r.call(c, {
            clientName: o,
            commandName: a,
            input: m(t.input),
            error: s,
            metadata: s.$metadata
        }),
        s
    }
}
  , Ij = {
    name: "loggerMiddleware",
    tags: ["LOGGER"],
    step: "initialize",
    override: !0
}
  , Oj = n=>({
    applyToStack: e=>{
        e.add(Dj(), Ij)
    }
})
  , CE = "X-Amzn-Trace-Id"
  , Nj = "AWS_LAMBDA_FUNCTION_NAME"
  , Uj = "_X_AMZN_TRACE_ID"
  , Fj = n=>e=>async t=>{
    const {request: i} = t;
    if (!dr.isInstance(i) || n.runtime !== "node" || i.headers.hasOwnProperty(CE))
        return e(t);
    const r = process.env[Nj]
      , s = process.env[Uj]
      , o = a=>typeof a == "string" && a.length > 0;
    return o(r) && o(s) && (i.headers[CE] = s),
    e({
        ...t,
        request: i
    })
}
  , Bj = {
    step: "build",
    tags: ["RECURSION_DETECTION"],
    name: "recursionDetectionMiddleware",
    override: !0,
    priority: "low"
}
  , kj = n=>({
    applyToStack: e=>{
        e.add(Fj(n), Bj)
    }
});
class ZR {
    trace() {}
    debug() {}
    info() {}
    warn() {}
    error() {}
}
const Ka = (n,e)=>{
    const t = [];
    if (n && t.push(n),
    e)
        for (const i of e)
            t.push(i);
    return t
}
  , ta = (n,e)=>`${n || "anonymous"}${e && e.length > 0 ? ` (a.k.a. ${e.join(",")})` : ""}`
  , Np = ()=>{
    let n = []
      , e = []
      , t = !1;
    const i = new Set
      , r = m=>m.sort((d,f)=>RE[f.step] - RE[d.step] || PE[f.priority || "normal"] - PE[d.priority || "normal"])
      , s = m=>{
        let d = !1;
        const f = _=>{
            const g = Ka(_.name, _.aliases);
            if (g.includes(m)) {
                d = !0;
                for (const v of g)
                    i.delete(v);
                return !1
            }
            return !0
        }
        ;
        return n = n.filter(f),
        e = e.filter(f),
        d
    }
      , o = m=>{
        let d = !1;
        const f = _=>{
            if (_.middleware === m) {
                d = !0;
                for (const g of Ka(_.name, _.aliases))
                    i.delete(g);
                return !1
            }
            return !0
        }
        ;
        return n = n.filter(f),
        e = e.filter(f),
        d
    }
      , a = m=>{
        var d;
        return n.forEach(f=>{
            m.add(f.middleware, {
                ...f
            })
        }
        ),
        e.forEach(f=>{
            m.addRelativeTo(f.middleware, {
                ...f
            })
        }
        ),
        (d = m.identifyOnResolve) == null || d.call(m, h.identifyOnResolve()),
        m
    }
      , c = m=>{
        const d = [];
        return m.before.forEach(f=>{
            f.before.length === 0 && f.after.length === 0 ? d.push(f) : d.push(...c(f))
        }
        ),
        d.push(m),
        m.after.reverse().forEach(f=>{
            f.before.length === 0 && f.after.length === 0 ? d.push(f) : d.push(...c(f))
        }
        ),
        d
    }
      , u = (m=!1)=>{
        const d = []
          , f = []
          , _ = {};
        return n.forEach(v=>{
            const y = {
                ...v,
                before: [],
                after: []
            };
            for (const w of Ka(y.name, y.aliases))
                _[w] = y;
            d.push(y)
        }
        ),
        e.forEach(v=>{
            const y = {
                ...v,
                before: [],
                after: []
            };
            for (const w of Ka(y.name, y.aliases))
                _[w] = y;
            f.push(y)
        }
        ),
        f.forEach(v=>{
            if (v.toMiddleware) {
                const y = _[v.toMiddleware];
                if (y === void 0) {
                    if (m)
                        return;
                    throw new Error(`${v.toMiddleware} is not found when adding ${ta(v.name, v.aliases)} middleware ${v.relation} ${v.toMiddleware}`)
                }
                v.relation === "after" && y.after.push(v),
                v.relation === "before" && y.before.push(v)
            }
        }
        ),
        r(d).map(c).reduce((v,y)=>(v.push(...y),
        v), [])
    }
      , h = {
        add: (m,d={})=>{
            const {name: f, override: _, aliases: g} = d
              , v = {
                step: "initialize",
                priority: "normal",
                middleware: m,
                ...d
            }
              , y = Ka(f, g);
            if (y.length > 0) {
                if (y.some(w=>i.has(w))) {
                    if (!_)
                        throw new Error(`Duplicate middleware name '${ta(f, g)}'`);
                    for (const w of y) {
                        const S = n.findIndex(b=>{
                            var T;
                            return b.name === w || ((T = b.aliases) == null ? void 0 : T.some(C=>C === w))
                        }
                        );
                        if (S === -1)
                            continue;
                        const E = n[S];
                        if (E.step !== v.step || v.priority !== E.priority)
                            throw new Error(`"${ta(E.name, E.aliases)}" middleware with ${E.priority} priority in ${E.step} step cannot be overridden by "${ta(f, g)}" middleware with ${v.priority} priority in ${v.step} step.`);
                        n.splice(S, 1)
                    }
                }
                for (const w of y)
                    i.add(w)
            }
            n.push(v)
        }
        ,
        addRelativeTo: (m,d)=>{
            const {name: f, override: _, aliases: g} = d
              , v = {
                middleware: m,
                ...d
            }
              , y = Ka(f, g);
            if (y.length > 0) {
                if (y.some(w=>i.has(w))) {
                    if (!_)
                        throw new Error(`Duplicate middleware name '${ta(f, g)}'`);
                    for (const w of y) {
                        const S = e.findIndex(b=>{
                            var T;
                            return b.name === w || ((T = b.aliases) == null ? void 0 : T.some(C=>C === w))
                        }
                        );
                        if (S === -1)
                            continue;
                        const E = e[S];
                        if (E.toMiddleware !== v.toMiddleware || E.relation !== v.relation)
                            throw new Error(`"${ta(E.name, E.aliases)}" middleware ${E.relation} "${E.toMiddleware}" middleware cannot be overridden by "${ta(f, g)}" middleware ${v.relation} "${v.toMiddleware}" middleware.`);
                        e.splice(S, 1)
                    }
                }
                for (const w of y)
                    i.add(w)
            }
            e.push(v)
        }
        ,
        clone: ()=>a(Np()),
        use: m=>{
            m.applyToStack(h)
        }
        ,
        remove: m=>typeof m == "string" ? s(m) : o(m),
        removeByTag: m=>{
            let d = !1;
            const f = _=>{
                const {tags: g, name: v, aliases: y} = _;
                if (g && g.includes(m)) {
                    const w = Ka(v, y);
                    for (const S of w)
                        i.delete(S);
                    return d = !0,
                    !1
                }
                return !0
            }
            ;
            return n = n.filter(f),
            e = e.filter(f),
            d
        }
        ,
        concat: m=>{
            var f;
            const d = a(Np());
            return d.use(m),
            d.identifyOnResolve(t || d.identifyOnResolve() || (((f = m.identifyOnResolve) == null ? void 0 : f.call(m)) ?? !1)),
            d
        }
        ,
        applyToStack: a,
        identify: ()=>u(!0).map(m=>{
            const d = m.step ?? m.relation + " " + m.toMiddleware;
            return ta(m.name, m.aliases) + " - " + d
        }
        ),
        identifyOnResolve(m) {
            return typeof m == "boolean" && (t = m),
            t
        },
        resolve: (m,d)=>{
            for (const f of u().map(_=>_.middleware).reverse())
                m = f(m, d);
            return t && console.log(h.identify()),
            m
        }
    };
    return h
}
  , RE = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1
}
  , PE = {
    high: 3,
    normal: 2,
    low: 1
};
class zj {
    constructor(e) {
        this.middlewareStack = Np(),
        this.config = e
    }
    send(e, t, i) {
        const r = typeof t != "function" ? t : void 0
          , s = typeof t == "function" ? t : i
          , o = e.resolveMiddleware(this.middlewareStack, this.config, r);
        if (s)
            o(e).then(a=>s(null, a.output), a=>s(a)).catch(()=>{}
            );
        else
            return o(e).then(a=>a.output)
    }
    destroy() {
        this.config.requestHandler.destroy && this.config.requestHandler.destroy()
    }
}
const Ca = {}
  , au = new Array(64);
for (let n = 0, e = "A".charCodeAt(0), t = "Z".charCodeAt(0); n + e <= t; n++) {
    const i = String.fromCharCode(n + e);
    Ca[i] = n,
    au[n] = i
}
for (let n = 0, e = "a".charCodeAt(0), t = "z".charCodeAt(0); n + e <= t; n++) {
    const i = String.fromCharCode(n + e)
      , r = n + 26;
    Ca[i] = r,
    au[r] = i
}
for (let n = 0; n < 10; n++) {
    Ca[n.toString(10)] = n + 52;
    const e = n.toString(10)
      , t = n + 52;
    Ca[e] = t,
    au[t] = e
}
Ca["+"] = 62;
au[62] = "+";
Ca["/"] = 63;
au[63] = "/";
const Bc = 6
  , Cf = 8
  , Hj = 63
  , $y = n=>{
    let e = n.length / 4 * 3;
    n.slice(-2) === "==" ? e -= 2 : n.slice(-1) === "=" && e--;
    const t = new ArrayBuffer(e)
      , i = new DataView(t);
    for (let r = 0; r < n.length; r += 4) {
        let s = 0
          , o = 0;
        for (let u = r, h = r + 3; u <= h; u++)
            if (n[u] !== "=") {
                if (!(n[u]in Ca))
                    throw new TypeError(`Invalid character ${n[u]} in base64 string.`);
                s |= Ca[n[u]] << (h - u) * Bc,
                o += Bc
            } else
                s >>= Bc;
        const a = r / 4 * 3;
        s >>= o % Cf;
        const c = Math.floor(o / Cf);
        for (let u = 0; u < c; u++) {
            const h = (c - u - 1) * Cf;
            i.setUint8(a + u, (s & 255 << h) >> h)
        }
    }
    return new Uint8Array(t)
}
;
function Xy(n) {
    let e = "";
    for (let t = 0; t < n.length; t += 3) {
        let i = 0
          , r = 0;
        for (let o = t, a = Math.min(t + 3, n.length); o < a; o++)
            i |= n[o] << (a - o - 1) * Cf,
            r += Cf;
        const s = Math.ceil(r / Bc);
        i <<= s * Bc - r;
        for (let o = 1; o <= s; o++) {
            const a = (s - o) * Bc;
            e += au[(i & Hj << a) >> a]
        }
        e += "==".slice(0, 4 - s)
    }
    return e
}
const lh = n=>new TextEncoder().encode(n)
  , kc = n=>typeof n == "string" ? lh(n) : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer,n.byteOffset,n.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(n)
  , hm = n=>new TextDecoder("utf-8").decode(n);
function Gj(n, e="utf-8") {
    return e === "base64" ? Xy(n) : hm(n)
}
function Vj(n, e) {
    return e === "base64" ? Al.mutate($y(n)) : Al.mutate(lh(n))
}
class Al extends Uint8Array {
    static fromString(e, t="utf-8") {
        switch (typeof e) {
        case "string":
            return Vj(e, t);
        default:
            throw new Error(`Unsupported conversion from ${typeof e} to Uint8ArrayBlobAdapter.`)
        }
    }
    static mutate(e) {
        return Object.setPrototypeOf(e, Al.prototype),
        e
    }
    transformToString(e="utf-8") {
        return Gj(this, e)
    }
}
const Wj = (n,e)=>{
    const {base64Encoder: t, bodyLengthChecker: i, checksumAlgorithmFn: r, checksumLocationName: s, streamHasher: o} = e
      , a = t !== void 0 && i !== void 0 && r !== void 0 && s !== void 0 && o !== void 0
      , c = a ? o(r, n) : void 0
      , u = n.getReader();
    return new ReadableStream({
        async pull(h) {
            const {value: m, done: d} = await u.read();
            if (d) {
                if (h.enqueue(`0\r
`),
                a) {
                    const f = t(await c);
                    h.enqueue(`${s}:${f}\r
`),
                    h.enqueue(`\r
`)
                }
                h.close()
            } else
                h.enqueue(`${(i(m) || 0).toString(16)}\r
${m}\r
`)
        }
    })
}
  , ul = n=>encodeURIComponent(n).replace(/[!'()*]/g, $j)
  , $j = n=>`%${n.charCodeAt(0).toString(16).toUpperCase()}`;
function JR(n) {
    const e = [];
    for (let t of Object.keys(n).sort()) {
        const i = n[t];
        if (t = ul(t),
        Array.isArray(i))
            for (let r = 0, s = i.length; r < s; r++)
                e.push(`${t}=${ul(i[r])}`);
        else {
            let r = t;
            (i || typeof i == "string") && (r += `=${ul(i)}`),
            e.push(r)
        }
    }
    return e.join("&")
}
function Xj(n=0) {
    return new Promise((e,t)=>{
        n && setTimeout(()=>{
            const i = new Error(`Request did not complete within ${n} ms`);
            i.name = "TimeoutError",
            t(i)
        }
        , n)
    }
    )
}
const qj = {
    supported: typeof Request < "u" && "keepalive"in new Request("https://[::1]")
};
class qy {
    static create(e) {
        return typeof (e == null ? void 0 : e.handle) == "function" ? e : new qy(e)
    }
    constructor(e) {
        typeof e == "function" ? this.configProvider = e().then(t=>t || {}) : (this.config = e ?? {},
        this.configProvider = Promise.resolve(this.config))
    }
    destroy() {}
    async handle(e, {abortSignal: t}={}) {
        this.config || (this.config = await this.configProvider);
        const i = this.config.requestTimeout
          , r = this.config.keepAlive === !0;
        if (t != null && t.aborted) {
            const g = new Error("Request aborted");
            return g.name = "AbortError",
            Promise.reject(g)
        }
        let s = e.path;
        const o = JR(e.query || {});
        o && (s += `?${o}`),
        e.fragment && (s += `#${e.fragment}`);
        let a = "";
        if (e.username != null || e.password != null) {
            const g = e.username ?? ""
              , v = e.password ?? "";
            a = `${g}:${v}@`
        }
        const {port: c, method: u} = e
          , h = `${e.protocol}//${a}${e.hostname}${c ? `:${c}` : ""}${s}`
          , d = {
            body: u === "GET" || u === "HEAD" ? void 0 : e.body,
            headers: new Headers(e.headers),
            method: u
        };
        typeof AbortController < "u" && (d.signal = t),
        qj.supported && (d.keepalive = r);
        const f = new Request(h,d)
          , _ = [fetch(f).then(g=>{
            const v = g.headers
              , y = {};
            for (const S of v.entries())
                y[S[0]] = S[1];
            return g.body != null ? {
                response: new Op({
                    headers: y,
                    reason: g.statusText,
                    statusCode: g.status,
                    body: g.body
                })
            } : g.blob().then(S=>({
                response: new Op({
                    headers: y,
                    reason: g.statusText,
                    statusCode: g.status,
                    body: S
                })
            }))
        }
        ), Xj(i)];
        return t && _.push(new Promise((g,v)=>{
            t.onabort = ()=>{
                const y = new Error("Request aborted");
                y.name = "AbortError",
                v(y)
            }
        }
        )),
        Promise.race(_)
    }
    updateHttpClientConfig(e, t) {
        this.config = void 0,
        this.configProvider = this.configProvider.then(i=>(i[e] = t,
        i))
    }
    httpHandlerConfigs() {
        return this.config ?? {}
    }
}
const QR = n=>typeof Blob == "function" && n instanceof Blob ? jj(n) : Yj(n);
async function jj(n) {
    const e = await Kj(n)
      , t = $y(e);
    return new Uint8Array(t)
}
async function Yj(n) {
    let e = new Uint8Array(0);
    const t = n.getReader();
    let i = !1;
    for (; !i; ) {
        const {done: r, value: s} = await t.read();
        if (s) {
            const o = e;
            e = new Uint8Array(o.length + s.length),
            e.set(o),
            e.set(s, o.length)
        }
        i = r
    }
    return e
}
function Kj(n) {
    return new Promise((e,t)=>{
        const i = new FileReader;
        i.onloadend = ()=>{
            if (i.readyState !== 2)
                return t(new Error("Reader aborted too early"));
            const r = i.result ?? ""
              , s = r.indexOf(",")
              , o = s > -1 ? s + 1 : r.length;
            e(r.substring(o))
        }
        ,
        i.onabort = ()=>t(new Error("Read aborted")),
        i.onerror = ()=>t(i.error),
        i.readAsDataURL(n)
    }
    )
}
const e2 = {}
  , xv = {};
for (let n = 0; n < 256; n++) {
    let e = n.toString(16).toLowerCase();
    e.length === 1 && (e = `0${e}`),
    e2[n] = e,
    xv[e] = n
}
function Zj(n) {
    if (n.length % 2 !== 0)
        throw new Error("Hex encoded strings must have an even number length");
    const e = new Uint8Array(n.length / 2);
    for (let t = 0; t < n.length; t += 2) {
        const i = n.slice(t, t + 2).toLowerCase();
        if (i in xv)
            e[t / 2] = xv[i];
        else
            throw new Error(`Cannot decode unrecognized sequence ${i} as hexadecimal`)
    }
    return e
}
function jr(n) {
    let e = "";
    for (let t = 0; t < n.byteLength; t++)
        e += e2[n[t]];
    return e
}
const LE = "The stream has already been transformed."
  , Jj = n=>{
    var r, s;
    if (!DE(n) && !IE(n)) {
        const o = ((s = (r = n == null ? void 0 : n.__proto__) == null ? void 0 : r.constructor) == null ? void 0 : s.name) || n;
        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${o}`)
    }
    let e = !1;
    const t = async()=>{
        if (e)
            throw new Error(LE);
        return e = !0,
        await QR(n)
    }
      , i = o=>{
        if (typeof o.stream != "function")
            throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`);
        return o.stream()
    }
    ;
    return Object.assign(n, {
        transformToByteArray: t,
        transformToString: async o=>{
            const a = await t();
            if (o === "base64")
                return Xy(a);
            if (o === "hex")
                return jr(a);
            if (o === void 0 || o === "utf8" || o === "utf-8")
                return hm(a);
            if (typeof TextDecoder == "function")
                return new TextDecoder(o).decode(a);
            throw new Error("TextDecoder is not available, please make sure polyfill is provided.")
        }
        ,
        transformToWebStream: ()=>{
            if (e)
                throw new Error(LE);
            if (e = !0,
            DE(n))
                return i(n);
            if (IE(n))
                return n;
            throw new Error(`Cannot transform payload to web stream, got ${n}`)
        }
    })
}
  , DE = n=>typeof Blob == "function" && n instanceof Blob
  , IE = n=>typeof ReadableStream == "function" && n instanceof ReadableStream
  , Qj = async(n=new Uint8Array,e)=>{
    if (n instanceof Uint8Array)
        return Al.mutate(n);
    if (!n)
        return Al.mutate(new Uint8Array);
    const t = e.streamCollector(n);
    return Al.mutate(await t)
}
;
class t2 {
    constructor() {
        this.middlewareStack = Np()
    }
}
const Up = "***SensitiveInformation***"
  , OE = n=>{
    switch (n) {
    case "true":
        return !0;
    case "false":
        return !1;
    default:
        throw new Error(`Unable to parse boolean value "${n}"`)
    }
}
  , eY = n=>{
    if (n != null) {
        if (typeof n == "string") {
            const e = parseFloat(n);
            if (!Number.isNaN(e))
                return String(e) !== String(n) && i2.warn(n2(`Expected number but observed string: ${n}`)),
                e
        }
        if (typeof n == "number")
            return n;
        throw new TypeError(`Expected number, got ${typeof n}: ${n}`)
    }
}
  , tY = Math.ceil(2 ** 127 * (2 - 2 ** -23))
  , NE = n=>{
    const e = eY(n);
    if (e !== void 0 && !Number.isNaN(e) && e !== 1 / 0 && e !== -1 / 0 && Math.abs(e) > tY)
        throw new TypeError(`Expected 32-bit float, got ${n}`);
    return e
}
  , bv = n=>{
    if (n != null) {
        if (Number.isInteger(n) && !Number.isNaN(n))
            return n;
        throw new TypeError(`Expected integer, got ${typeof n}: ${n}`)
    }
}
  , UE = n=>jy(n, 32)
  , FE = n=>jy(n, 16)
  , BE = n=>jy(n, 8)
  , jy = (n,e)=>{
    const t = bv(n);
    if (t !== void 0 && nY(t, e) !== t)
        throw new TypeError(`Expected ${e}-bit integer, got ${n}`);
    return t
}
  , nY = (n,e)=>{
    switch (e) {
    case 32:
        return Int32Array.of(n)[0];
    case 16:
        return Int16Array.of(n)[0];
    case 8:
        return Int8Array.of(n)[0]
    }
}
  , Rf = (n,e)=>{
    if (n == null)
        throw e ? new TypeError(`Expected a non-null value for ${e}`) : new TypeError("Expected a non-null value");
    return n
}
  , iY = n=>{
    if (n == null)
        return;
    if (typeof n == "object" && !Array.isArray(n))
        return n;
    const e = Array.isArray(n) ? "array" : typeof n;
    throw new TypeError(`Expected object, got ${e}: ${n}`)
}
  , Pf = n=>{
    if (n != null) {
        if (typeof n == "string")
            return n;
        if (["boolean", "number", "bigint"].includes(typeof n))
            return i2.warn(n2(`Expected string, got ${typeof n}: ${n}`)),
            String(n);
        throw new TypeError(`Expected string, got ${typeof n}: ${n}`)
    }
}
  , rY = n=>NE(typeof n == "string" ? ch(n) : n)
  , sY = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g
  , ch = n=>{
    const e = n.match(sY);
    if (e === null || e[0].length !== n.length)
        throw new TypeError("Expected real number, got implicit NaN");
    return parseFloat(n)
}
  , oY = n=>bv(typeof n == "string" ? ch(n) : n)
  , R0 = n=>UE(typeof n == "string" ? ch(n) : n)
  , Fp = n=>FE(typeof n == "string" ? ch(n) : n)
  , aY = n=>BE(typeof n == "string" ? ch(n) : n)
  , n2 = n=>String(new TypeError(n).stack || n).split(`
`).slice(0, 5).filter(e=>!e.includes("stackTraceWarning")).join(`
`)
  , i2 = {
    warn: console.warn
}
  , lY = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  , Yy = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function P0(n) {
    const e = n.getUTCFullYear()
      , t = n.getUTCMonth()
      , i = n.getUTCDay()
      , r = n.getUTCDate()
      , s = n.getUTCHours()
      , o = n.getUTCMinutes()
      , a = n.getUTCSeconds()
      , c = r < 10 ? `0${r}` : `${r}`
      , u = s < 10 ? `0${s}` : `${s}`
      , h = o < 10 ? `0${o}` : `${o}`
      , m = a < 10 ? `0${a}` : `${a}`;
    return `${lY[i]}, ${c} ${Yy[t]} ${e} ${u}:${h}:${m} GMT`
}
const cY = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/)
  , r2 = n=>{
    if (n == null)
        return;
    if (typeof n != "string")
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    const e = cY.exec(n);
    if (!e)
        throw new TypeError("Invalid RFC-3339 date-time value");
    const [t,i,r,s,o,a,c,u,h] = e
      , m = Fp(Xf(i))
      , d = Sa(r, "month", 1, 12)
      , f = Sa(s, "day", 1, 31)
      , _ = ap(m, d, f, {
        hours: o,
        minutes: a,
        seconds: c,
        fractionalMilliseconds: u
    });
    return h.toUpperCase() != "Z" && _.setTime(_.getTime() - xY(h)),
    _
}
  , uY = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)
  , fY = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/)
  , hY = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/)
  , kE = n=>{
    if (n == null)
        return;
    if (typeof n != "string")
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    let e = uY.exec(n);
    if (e) {
        const [t,i,r,s,o,a,c,u] = e;
        return ap(Fp(Xf(s)), L0(r), Sa(i, "day", 1, 31), {
            hours: o,
            minutes: a,
            seconds: c,
            fractionalMilliseconds: u
        })
    }
    if (e = fY.exec(n),
    e) {
        const [t,i,r,s,o,a,c,u] = e;
        return mY(ap(dY(s), L0(r), Sa(i, "day", 1, 31), {
            hours: o,
            minutes: a,
            seconds: c,
            fractionalMilliseconds: u
        }))
    }
    if (e = hY.exec(n),
    e) {
        const [t,i,r,s,o,a,c,u] = e;
        return ap(Fp(Xf(u)), L0(i), Sa(r.trimLeft(), "day", 1, 31), {
            hours: s,
            minutes: o,
            seconds: a,
            fractionalMilliseconds: c
        })
    }
    throw new TypeError("Invalid RFC-7231 date-time value")
}
  , ap = (n,e,t,i)=>{
    const r = e - 1;
    return _Y(n, r, t),
    new Date(Date.UTC(n, r, t, Sa(i.hours, "hour", 0, 23), Sa(i.minutes, "minute", 0, 59), Sa(i.seconds, "seconds", 0, 60), yY(i.fractionalMilliseconds)))
}
  , dY = n=>{
    const e = new Date().getUTCFullYear()
      , t = Math.floor(e / 100) * 100 + Fp(Xf(n));
    return t < e ? t + 100 : t
}
  , pY = 50 * 365 * 24 * 60 * 60 * 1e3
  , mY = n=>n.getTime() - new Date().getTime() > pY ? new Date(Date.UTC(n.getUTCFullYear() - 100, n.getUTCMonth(), n.getUTCDate(), n.getUTCHours(), n.getUTCMinutes(), n.getUTCSeconds(), n.getUTCMilliseconds())) : n
  , L0 = n=>{
    const e = Yy.indexOf(n);
    if (e < 0)
        throw new TypeError(`Invalid month: ${n}`);
    return e + 1
}
  , gY = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  , _Y = (n,e,t)=>{
    let i = gY[e];
    if (e === 1 && vY(n) && (i = 29),
    t > i)
        throw new TypeError(`Invalid day for ${Yy[e]} in ${n}: ${t}`)
}
  , vY = n=>n % 4 === 0 && (n % 100 !== 0 || n % 400 === 0)
  , Sa = (n,e,t,i)=>{
    const r = aY(Xf(n));
    if (r < t || r > i)
        throw new TypeError(`${e} must be between ${t} and ${i}, inclusive`);
    return r
}
  , yY = n=>n == null ? 0 : rY("0." + n) * 1e3
  , xY = n=>{
    const e = n[0];
    let t = 1;
    if (e == "+")
        t = 1;
    else if (e == "-")
        t = -1;
    else
        throw new TypeError(`Offset direction, ${e}, must be "+" or "-"`);
    const i = Number(n.substring(1, 3))
      , r = Number(n.substring(4, 6));
    return t * (i * 60 + r) * 60 * 1e3
}
  , Xf = n=>{
    let e = 0;
    for (; e < n.length - 1 && n.charAt(e) === "0"; )
        e++;
    return e === 0 ? n : n.slice(e)
}
;
class Ky extends Error {
    constructor(e) {
        super(e.message),
        Object.setPrototypeOf(this, Ky.prototype),
        this.name = e.name,
        this.$fault = e.$fault,
        this.$metadata = e.$metadata
    }
}
const dm = (n,e={})=>{
    Object.entries(e).filter(([,i])=>i !== void 0).forEach(([i,r])=>{
        (n[i] == null || n[i] === "") && (n[i] = r)
    }
    );
    const t = n.message || n.Message || "UnknownError";
    return n.message = t,
    delete n.Message,
    n
}
  , bY = ({output: n, parsedBody: e, exceptionCtor: t, errorCode: i})=>{
    const r = wY(n)
      , s = r.httpStatusCode ? r.httpStatusCode + "" : void 0
      , o = new t({
        name: (e == null ? void 0 : e.code) || (e == null ? void 0 : e.Code) || i || s || "UnknownError",
        $fault: "client",
        $metadata: r
    });
    throw dm(o, e)
}
  , SY = n=>({output: e, parsedBody: t, errorCode: i})=>{
    bY({
        output: e,
        parsedBody: t,
        exceptionCtor: n,
        errorCode: i
    })
}
  , wY = n=>({
    httpStatusCode: n.statusCode,
    requestId: n.headers["x-amzn-requestid"] ?? n.headers["x-amzn-request-id"] ?? n.headers["x-amz-request-id"],
    extendedRequestId: n.headers["x-amz-id-2"],
    cfId: n.headers["x-amz-cf-id"]
})
  , EY = n=>{
    switch (n) {
    case "standard":
        return {
            retryMode: "standard",
            connectionTimeout: 3100
        };
    case "in-region":
        return {
            retryMode: "standard",
            connectionTimeout: 1100
        };
    case "cross-region":
        return {
            retryMode: "standard",
            connectionTimeout: 3100
        };
    case "mobile":
        return {
            retryMode: "standard",
            connectionTimeout: 3e4
        };
    default:
        return {}
    }
}
  , AY = n=>{
    const e = [];
    for (const t in Dp) {
        const i = Dp[t];
        n[i] !== void 0 && e.push({
            algorithmId: ()=>i,
            checksumConstructor: ()=>n[i]
        })
    }
    return {
        _checksumAlgorithms: e,
        addChecksumAlgorithm(t) {
            this._checksumAlgorithms.push(t)
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms
        }
    }
}
  , MY = n=>{
    const e = {};
    return n.checksumAlgorithms().forEach(t=>{
        e[t.algorithmId()] = t.checksumConstructor()
    }
    ),
    e
}
  , TY = n=>{
    let e = n.retryStrategy;
    return {
        setRetryStrategy(t) {
            e = t
        },
        retryStrategy() {
            return e
        }
    }
}
  , CY = n=>{
    const e = {};
    return e.retryStrategy = n.retryStrategy(),
    e
}
  , RY = n=>({
    ...AY(n),
    ...TY(n)
})
  , PY = n=>({
    ...MY(n),
    ...CY(n)
});
function zE(n) {
    return encodeURIComponent(n).replace(/[!'()*]/g, function(e) {
        return "%" + e.charCodeAt(0).toString(16).toUpperCase()
    })
}
const s2 = n=>{
    const e = "#text";
    for (const t in n)
        n.hasOwnProperty(t) && n[t][e] !== void 0 ? n[t] = n[t][e] : typeof n[t] == "object" && n[t] !== null && (n[t] = s2(n[t]));
    return n
}
  , Sv = function() {
    const n = Object.getPrototypeOf(this).constructor
      , e = Function.bind.apply(String, [null, ...arguments])
      , t = new e;
    return Object.setPrototypeOf(t, n.prototype),
    t
};
Sv.prototype = Object.create(String.prototype, {
    constructor: {
        value: Sv,
        enumerable: !1,
        writable: !0,
        configurable: !0
    }
});
Object.setPrototypeOf(Sv, String);
function ro(n, e, t) {
    let i, r, s;
    if (typeof e > "u" && typeof t > "u")
        i = {},
        s = n;
    else {
        if (i = n,
        typeof e == "function")
            return r = e,
            s = t,
            LY(i, r, s);
        s = e
    }
    for (const o of Object.keys(s)) {
        if (!Array.isArray(s[o])) {
            i[o] = s[o];
            continue
        }
        DY(i, null, s, o)
    }
    return i
}
const LY = (n,e,t)=>ro(n, Object.entries(t).reduce((i,[r,s])=>(Array.isArray(s) ? i[r] = s : typeof s == "function" ? i[r] = [e, s()] : i[r] = [e, s],
i), {}))
  , DY = (n,e,t,i)=>{
    if (e !== null) {
        let o = t[i];
        typeof o == "function" && (o = [, o]);
        const [a=IY,c=OY,u=i] = o;
        (typeof a == "function" && a(e[u]) || typeof a != "function" && a) && (n[i] = c(e[u]));
        return
    }
    let[r,s] = t[i];
    if (typeof s == "function") {
        let o;
        const a = r === void 0 && (o = s()) != null
          , c = typeof r == "function" && !!r(void 0) || typeof r != "function" && !!r;
        a ? n[i] = o : c && (n[i] = s())
    } else {
        const o = r === void 0 && s != null
          , a = typeof r == "function" && !!r(s) || typeof r != "function" && !!r;
        (o || a) && (n[i] = s)
    }
}
  , IY = n=>n != null
  , OY = n=>n
  , wv = (n,e,t,i,r,s)=>{
    if (e != null && e[t] !== void 0) {
        const o = i();
        if (o.length <= 0)
            throw new Error("Empty value provided for input HTTP label: " + t + ".");
        n = n.replace(r, s ? o.split("/").map(a=>zE(a)).join("/") : zE(o))
    } else
        throw new Error("No value provided for input HTTP label: " + t + ".");
    return n
}
  , NY = n=>(e,t)=>async i=>{
    const r = await n.region()
      , s = n.region;
    t.__s3RegionRedirect && (n.region = async()=>(n.region = s,
    t.__s3RegionRedirect));
    const o = await e(i);
    if (t.__s3RegionRedirect) {
        const a = await n.region();
        if (r !== a)
            throw new Error("Region was not restored following S3 region redirect.")
    }
    return o
}
  , UY = {
    tags: ["REGION_REDIRECT", "S3"],
    name: "regionRedirectEndpointMiddleware",
    override: !0,
    relation: "before",
    toMiddleware: "endpointV2Middleware"
};
function FY(n) {
    return (e,t)=>async i=>{
        var r;
        try {
            return await e(i)
        } catch (s) {
            if (n.followRegionRedirects && s.$metadata.httpStatusCode === 301) {
                try {
                    const o = s.$response.headers["x-amz-bucket-region"];
                    (r = t.logger) == null || r.debug(`Redirecting from ${await n.region()} to ${o}`),
                    t.__s3RegionRedirect = o
                } catch (o) {
                    throw new Error("Region redirect failed: " + o)
                }
                return e(i)
            } else
                throw s
        }
    }
}
const BY = {
    step: "initialize",
    tags: ["REGION_REDIRECT", "S3"],
    name: "regionRedirectMiddleware",
    override: !0
}
  , kY = n=>({
    applyToStack: e=>{
        e.add(FY(n), BY),
        e.addRelativeTo(NY(n), UY)
    }
});
class pm {
    constructor(e={}) {
        this.data = e,
        this.lastPurgeTime = Date.now()
    }
    get(e) {
        const t = this.data[e];
        if (t)
            return t
    }
    set(e, t) {
        return this.data[e] = t,
        t
    }
    delete(e) {
        delete this.data[e]
    }
    async purgeExpired() {
        const e = Date.now();
        if (!(this.lastPurgeTime + pm.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > e))
            for (const t in this.data) {
                const i = this.data[t];
                if (!i.isRefreshing) {
                    const r = await i.identity;
                    r.expiration && r.expiration.getTime() < e && delete this.data[t]
                }
            }
    }
}
pm.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 3e4;
class D0 {
    constructor(e, t=!1, i=Date.now()) {
        this._identity = e,
        this.isRefreshing = t,
        this.accessed = i
    }
    get identity() {
        return this.accessed = Date.now(),
        this._identity
    }
}
class mm {
    constructor(e, t=new pm) {
        this.createSessionFn = e,
        this.cache = t
    }
    async getS3ExpressIdentity(e, t) {
        const i = t.Bucket
          , {cache: r} = this
          , s = r.get(i);
        return s ? s.identity.then(o=>{
            var u, h;
            return (((u = o.expiration) == null ? void 0 : u.getTime()) ?? 0) < Date.now() ? r.set(i, new D0(this.getIdentity(i))).identity : ((((h = o.expiration) == null ? void 0 : h.getTime()) ?? 0) < Date.now() + mm.REFRESH_WINDOW_MS && !s.isRefreshing && (s.isRefreshing = !0,
            this.getIdentity(i).then(m=>{
                r.set(i, new D0(Promise.resolve(m)))
            }
            )),
            o)
        }
        ) : r.set(i, new D0(this.getIdentity(i))).identity
    }
    async getIdentity(e) {
        var r, s;
        await this.cache.purgeExpired().catch(o=>{
            console.warn(`Error while clearing expired entries in S3ExpressIdentityCache: 
` + o)
        }
        );
        const t = await this.createSessionFn(e);
        if (!((r = t.Credentials) != null && r.AccessKeyId) || !((s = t.Credentials) != null && s.SecretAccessKey))
            throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
        return {
            accessKeyId: t.Credentials.AccessKeyId,
            secretAccessKey: t.Credentials.SecretAccessKey,
            sessionToken: t.Credentials.SessionToken,
            expiration: t.Credentials.Expiration ? new Date(t.Credentials.Expiration) : void 0
        }
    }
}
mm.REFRESH_WINDOW_MS = 6e4;
var I0 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ev = function(n, e) {
    return Ev = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(t, i) {
        t.__proto__ = i
    }
    || function(t, i) {
        for (var r in i)
            i.hasOwnProperty(r) && (t[r] = i[r])
    }
    ,
    Ev(n, e)
};
function zY(n, e) {
    Ev(n, e);
    function t() {
        this.constructor = n
    }
    n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype,
    new t)
}
var Av = function() {
    return Av = Object.assign || function(e) {
        for (var t, i = 1, r = arguments.length; i < r; i++) {
            t = arguments[i];
            for (var s in t)
                Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s])
        }
        return e
    }
    ,
    Av.apply(this, arguments)
};
function HY(n, e) {
    var t = {};
    for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
            e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
    return t
}
function GY(n, e, t, i) {
    var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        s = Reflect.decorate(n, e, t, i);
    else
        for (var a = n.length - 1; a >= 0; a--)
            (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
    return r > 3 && s && Object.defineProperty(e, t, s),
    s
}
function VY(n, e) {
    return function(t, i) {
        e(t, i, n)
    }
}
function WY(n, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(n, e)
}
function $Y(n, e, t, i) {
    function r(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(h) {
            try {
                u(i.next(h))
            } catch (m) {
                o(m)
            }
        }
        function c(h) {
            try {
                u(i.throw(h))
            } catch (m) {
                o(m)
            }
        }
        function u(h) {
            h.done ? s(h.value) : r(h.value).then(a, c)
        }
        u((i = i.apply(n, e || [])).next())
    }
    )
}
function XY(n, e) {
    var t = {
        label: 0,
        sent: function() {
            if (s[0] & 1)
                throw s[1];
            return s[1]
        },
        trys: [],
        ops: []
    }, i, r, s, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    },
    typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }
    ),
    o;
    function a(u) {
        return function(h) {
            return c([u, h])
        }
    }
    function c(u) {
        if (i)
            throw new TypeError("Generator is already executing.");
        for (; t; )
            try {
                if (i = 1,
                r && (s = u[0] & 2 ? r.return : u[0] ? r.throw || ((s = r.return) && s.call(r),
                0) : r.next) && !(s = s.call(r, u[1])).done)
                    return s;
                switch (r = 0,
                s && (u = [u[0] & 2, s.value]),
                u[0]) {
                case 0:
                case 1:
                    s = u;
                    break;
                case 4:
                    return t.label++,
                    {
                        value: u[1],
                        done: !1
                    };
                case 5:
                    t.label++,
                    r = u[1],
                    u = [0];
                    continue;
                case 7:
                    u = t.ops.pop(),
                    t.trys.pop();
                    continue;
                default:
                    if (s = t.trys,
                    !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
                        t = 0;
                        continue
                    }
                    if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
                        t.label = u[1];
                        break
                    }
                    if (u[0] === 6 && t.label < s[1]) {
                        t.label = s[1],
                        s = u;
                        break
                    }
                    if (s && t.label < s[2]) {
                        t.label = s[2],
                        t.ops.push(u);
                        break
                    }
                    s[2] && t.ops.pop(),
                    t.trys.pop();
                    continue
                }
                u = e.call(n, t)
            } catch (h) {
                u = [6, h],
                r = 0
            } finally {
                i = s = 0
            }
        if (u[0] & 5)
            throw u[1];
        return {
            value: u[0] ? u[1] : void 0,
            done: !0
        }
    }
}
function qY(n, e, t, i) {
    i === void 0 && (i = t),
    n[i] = e[t]
}
function jY(n, e) {
    for (var t in n)
        t !== "default" && !e.hasOwnProperty(t) && (e[t] = n[t])
}
function Mv(n) {
    var e = typeof Symbol == "function" && Symbol.iterator
      , t = e && n[e]
      , i = 0;
    if (t)
        return t.call(n);
    if (n && typeof n.length == "number")
        return {
            next: function() {
                return n && i >= n.length && (n = void 0),
                {
                    value: n && n[i++],
                    done: !n
                }
            }
        };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function o2(n, e) {
    var t = typeof Symbol == "function" && n[Symbol.iterator];
    if (!t)
        return n;
    var i = t.call(n), r, s = [], o;
    try {
        for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
            s.push(r.value)
    } catch (a) {
        o = {
            error: a
        }
    } finally {
        try {
            r && !r.done && (t = i.return) && t.call(i)
        } finally {
            if (o)
                throw o.error
        }
    }
    return s
}
function YY() {
    for (var n = [], e = 0; e < arguments.length; e++)
        n = n.concat(o2(arguments[e]));
    return n
}
function KY() {
    for (var n = 0, e = 0, t = arguments.length; e < t; e++)
        n += arguments[e].length;
    for (var i = Array(n), r = 0, e = 0; e < t; e++)
        for (var s = arguments[e], o = 0, a = s.length; o < a; o++,
        r++)
            i[r] = s[o];
    return i
}
function qf(n) {
    return this instanceof qf ? (this.v = n,
    this) : new qf(n)
}
function ZY(n, e, t) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var i = t.apply(n, e || []), r, s = [];
    return r = {},
    o("next"),
    o("throw"),
    o("return"),
    r[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    r;
    function o(d) {
        i[d] && (r[d] = function(f) {
            return new Promise(function(_, g) {
                s.push([d, f, _, g]) > 1 || a(d, f)
            }
            )
        }
        )
    }
    function a(d, f) {
        try {
            c(i[d](f))
        } catch (_) {
            m(s[0][3], _)
        }
    }
    function c(d) {
        d.value instanceof qf ? Promise.resolve(d.value.v).then(u, h) : m(s[0][2], d)
    }
    function u(d) {
        a("next", d)
    }
    function h(d) {
        a("throw", d)
    }
    function m(d, f) {
        d(f),
        s.shift(),
        s.length && a(s[0][0], s[0][1])
    }
}
function JY(n) {
    var e, t;
    return e = {},
    i("next"),
    i("throw", function(r) {
        throw r
    }),
    i("return"),
    e[Symbol.iterator] = function() {
        return this
    }
    ,
    e;
    function i(r, s) {
        e[r] = n[r] ? function(o) {
            return (t = !t) ? {
                value: qf(n[r](o)),
                done: r === "return"
            } : s ? s(o) : o
        }
        : s
    }
}
function QY(n) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = n[Symbol.asyncIterator], t;
    return e ? e.call(n) : (n = typeof Mv == "function" ? Mv(n) : n[Symbol.iterator](),
    t = {},
    i("next"),
    i("throw"),
    i("return"),
    t[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    t);
    function i(s) {
        t[s] = n[s] && function(o) {
            return new Promise(function(a, c) {
                o = n[s](o),
                r(a, c, o.done, o.value)
            }
            )
        }
    }
    function r(s, o, a, c) {
        Promise.resolve(c).then(function(u) {
            s({
                value: u,
                done: a
            })
        }, o)
    }
}
function eK(n, e) {
    return Object.defineProperty ? Object.defineProperty(n, "raw", {
        value: e
    }) : n.raw = e,
    n
}
function tK(n) {
    if (n && n.__esModule)
        return n;
    var e = {};
    if (n != null)
        for (var t in n)
            Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
    return e.default = n,
    e
}
function nK(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function iK(n, e) {
    if (!e.has(n))
        throw new TypeError("attempted to get private field on non-instance");
    return e.get(n)
}
function rK(n, e, t) {
    if (!e.has(n))
        throw new TypeError("attempted to set private field on non-instance");
    return e.set(n, t),
    t
}
const sK = Object.freeze(Object.defineProperty({
    __proto__: null,
    get __assign() {
        return Av
    },
    __asyncDelegator: JY,
    __asyncGenerator: ZY,
    __asyncValues: QY,
    __await: qf,
    __awaiter: $Y,
    __classPrivateFieldGet: iK,
    __classPrivateFieldSet: rK,
    __createBinding: qY,
    __decorate: GY,
    __exportStar: jY,
    __extends: zY,
    __generator: XY,
    __importDefault: nK,
    __importStar: tK,
    __makeTemplateObject: eK,
    __metadata: WY,
    __param: VY,
    __read: o2,
    __rest: HY,
    __spread: YY,
    __spreadArrays: KY,
    __values: Mv
}, Symbol.toStringTag, {
    value: "Module"
}))
  , a2 = Fo(sK);
var O0 = {}
  , Bu = {};
const oK = n=>{
    const e = [];
    for (let t = 0, i = n.length; t < i; t++) {
        const r = n.charCodeAt(t);
        if (r < 128)
            e.push(r);
        else if (r < 2048)
            e.push(r >> 6 | 192, r & 63 | 128);
        else if (t + 1 < n.length && (r & 64512) === 55296 && (n.charCodeAt(t + 1) & 64512) === 56320) {
            const s = 65536 + ((r & 1023) << 10) + (n.charCodeAt(++t) & 1023);
            e.push(s >> 18 | 240, s >> 12 & 63 | 128, s >> 6 & 63 | 128, s & 63 | 128)
        } else
            e.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128)
    }
    return Uint8Array.from(e)
}
  , aK = n=>{
    let e = "";
    for (let t = 0, i = n.length; t < i; t++) {
        const r = n[t];
        if (r < 128)
            e += String.fromCharCode(r);
        else if (192 <= r && r < 224) {
            const s = n[++t];
            e += String.fromCharCode((r & 31) << 6 | s & 63)
        } else if (240 <= r && r < 365) {
            const o = "%" + [r, n[++t], n[++t], n[++t]].map(a=>a.toString(16)).join("%");
            e += decodeURIComponent(o)
        } else
            e += String.fromCharCode((r & 15) << 12 | (n[++t] & 63) << 6 | n[++t] & 63)
    }
    return e
}
;
function lK(n) {
    return new TextEncoder().encode(n)
}
function cK(n) {
    return new TextDecoder("utf-8").decode(n)
}
const uK = n=>typeof TextEncoder == "function" ? lK(n) : oK(n)
  , fK = n=>typeof TextDecoder == "function" ? cK(n) : aK(n)
  , hK = Object.freeze(Object.defineProperty({
    __proto__: null,
    fromUtf8: uK,
    toUtf8: fK
}, Symbol.toStringTag, {
    value: "Module"
}))
  , gm = Fo(hK);
var HE;
function dK() {
    if (HE)
        return Bu;
    HE = 1,
    Object.defineProperty(Bu, "__esModule", {
        value: !0
    }),
    Bu.convertToBuffer = void 0;
    var n = gm
      , e = typeof Buffer < "u" && Buffer.from ? function(i) {
        return Buffer.from(i, "utf8")
    }
    : n.fromUtf8;
    function t(i) {
        return i instanceof Uint8Array ? i : typeof i == "string" ? e(i) : ArrayBuffer.isView(i) ? new Uint8Array(i.buffer,i.byteOffset,i.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(i)
    }
    return Bu.convertToBuffer = t,
    Bu
}
var ku = {}, GE;
function pK() {
    if (GE)
        return ku;
    GE = 1,
    Object.defineProperty(ku, "__esModule", {
        value: !0
    }),
    ku.isEmptyData = void 0;
    function n(e) {
        return typeof e == "string" ? e.length === 0 : e.byteLength === 0
    }
    return ku.isEmptyData = n,
    ku
}
var zu = {}, VE;
function mK() {
    if (VE)
        return zu;
    VE = 1,
    Object.defineProperty(zu, "__esModule", {
        value: !0
    }),
    zu.numToUint8 = void 0;
    function n(e) {
        return new Uint8Array([(e & 4278190080) >> 24, (e & 16711680) >> 16, (e & 65280) >> 8, e & 255])
    }
    return zu.numToUint8 = n,
    zu
}
var Hu = {}, WE;
function gK() {
    if (WE)
        return Hu;
    WE = 1,
    Object.defineProperty(Hu, "__esModule", {
        value: !0
    }),
    Hu.uint32ArrayFrom = void 0;
    function n(e) {
        if (!Uint32Array.from) {
            for (var t = new Uint32Array(e.length), i = 0; i < e.length; )
                t[i] = e[i],
                i += 1;
            return t
        }
        return Uint32Array.from(e)
    }
    return Hu.uint32ArrayFrom = n,
    Hu
}
var $E;
function Da() {
    return $E || ($E = 1,
    function(n) {
        Object.defineProperty(n, "__esModule", {
            value: !0
        }),
        n.uint32ArrayFrom = n.numToUint8 = n.isEmptyData = n.convertToBuffer = void 0;
        var e = dK();
        Object.defineProperty(n, "convertToBuffer", {
            enumerable: !0,
            get: function() {
                return e.convertToBuffer
            }
        });
        var t = pK();
        Object.defineProperty(n, "isEmptyData", {
            enumerable: !0,
            get: function() {
                return t.isEmptyData
            }
        });
        var i = mK();
        Object.defineProperty(n, "numToUint8", {
            enumerable: !0,
            get: function() {
                return i.numToUint8
            }
        });
        var r = gK();
        Object.defineProperty(n, "uint32ArrayFrom", {
            enumerable: !0,
            get: function() {
                return r.uint32ArrayFrom
            }
        })
    }(O0)),
    O0
}
var Gu = {}, XE;
function _K() {
    if (XE)
        return Gu;
    XE = 1,
    Object.defineProperty(Gu, "__esModule", {
        value: !0
    }),
    Gu.AwsCrc32 = void 0;
    var n = a2
      , e = Da()
      , t = l2()
      , i = function() {
        function r() {
            this.crc32 = new t.Crc32
        }
        return r.prototype.update = function(s) {
            (0,
            e.isEmptyData)(s) || this.crc32.update((0,
            e.convertToBuffer)(s))
        }
        ,
        r.prototype.digest = function() {
            return n.__awaiter(this, void 0, void 0, function() {
                return n.__generator(this, function(s) {
                    return [2, (0,
                    e.numToUint8)(this.crc32.digest())]
                })
            })
        }
        ,
        r.prototype.reset = function() {
            this.crc32 = new t.Crc32
        }
        ,
        r
    }();
    return Gu.AwsCrc32 = i,
    Gu
}
var qE;
function l2() {
    return qE || (qE = 1,
    function(n) {
        Object.defineProperty(n, "__esModule", {
            value: !0
        }),
        n.AwsCrc32 = n.Crc32 = n.crc32 = void 0;
        var e = a2
          , t = Da();
        function i(c) {
            return new r().update(c).digest()
        }
        n.crc32 = i;
        var r = function() {
            function c() {
                this.checksum = 4294967295
            }
            return c.prototype.update = function(u) {
                var h, m;
                try {
                    for (var d = e.__values(u), f = d.next(); !f.done; f = d.next()) {
                        var _ = f.value;
                        this.checksum = this.checksum >>> 8 ^ o[(this.checksum ^ _) & 255]
                    }
                } catch (g) {
                    h = {
                        error: g
                    }
                } finally {
                    try {
                        f && !f.done && (m = d.return) && m.call(d)
                    } finally {
                        if (h)
                            throw h.error
                    }
                }
                return this
            }
            ,
            c.prototype.digest = function() {
                return (this.checksum ^ 4294967295) >>> 0
            }
            ,
            c
        }();
        n.Crc32 = r;
        var s = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117]
          , o = (0,
        t.uint32ArrayFrom)(s)
          , a = _K();
        Object.defineProperty(n, "AwsCrc32", {
            enumerable: !0,
            get: function() {
                return a.AwsCrc32
            }
        })
    }(I0)),
    I0
}
var Zy = l2();
class Lf {
    constructor(e) {
        if (this.bytes = e,
        e.byteLength !== 8)
            throw new Error("Int64 buffers must be exactly 8 bytes")
    }
    static fromNumber(e) {
        if (e > 9223372036854776e3 || e < -9223372036854776e3)
            throw new Error(`${e} is too large (or, if negative, too small) to represent as an Int64`);
        const t = new Uint8Array(8);
        for (let i = 7, r = Math.abs(Math.round(e)); i > -1 && r > 0; i--,
        r /= 256)
            t[i] = r;
        return e < 0 && jE(t),
        new Lf(t)
    }
    valueOf() {
        const e = this.bytes.slice(0)
          , t = e[0] & 128;
        return t && jE(e),
        parseInt(jr(e), 16) * (t ? -1 : 1)
    }
    toString() {
        return String(this.valueOf())
    }
}
function jE(n) {
    for (let e = 0; e < 8; e++)
        n[e] ^= 255;
    for (let e = 7; e > -1 && (n[e]++,
    n[e] === 0); e--)
        ;
}
class c2 {
    constructor(e, t) {
        this.toUtf8 = e,
        this.fromUtf8 = t
    }
    format(e) {
        const t = [];
        for (const s of Object.keys(e)) {
            const o = this.fromUtf8(s);
            t.push(Uint8Array.from([o.byteLength]), o, this.formatHeaderValue(e[s]))
        }
        const i = new Uint8Array(t.reduce((s,o)=>s + o.byteLength, 0));
        let r = 0;
        for (const s of t)
            i.set(s, r),
            r += s.byteLength;
        return i
    }
    formatHeaderValue(e) {
        switch (e.type) {
        case "boolean":
            return Uint8Array.from([e.value ? 0 : 1]);
        case "byte":
            return Uint8Array.from([2, e.value]);
        case "short":
            const t = new DataView(new ArrayBuffer(3));
            return t.setUint8(0, 3),
            t.setInt16(1, e.value, !1),
            new Uint8Array(t.buffer);
        case "integer":
            const i = new DataView(new ArrayBuffer(5));
            return i.setUint8(0, 4),
            i.setInt32(1, e.value, !1),
            new Uint8Array(i.buffer);
        case "long":
            const r = new Uint8Array(9);
            return r[0] = 5,
            r.set(e.value.bytes, 1),
            r;
        case "binary":
            const s = new DataView(new ArrayBuffer(3 + e.value.byteLength));
            s.setUint8(0, 6),
            s.setUint16(1, e.value.byteLength, !1);
            const o = new Uint8Array(s.buffer);
            return o.set(e.value, 3),
            o;
        case "string":
            const a = this.fromUtf8(e.value)
              , c = new DataView(new ArrayBuffer(3 + a.byteLength));
            c.setUint8(0, 7),
            c.setUint16(1, a.byteLength, !1);
            const u = new Uint8Array(c.buffer);
            return u.set(a, 3),
            u;
        case "timestamp":
            const h = new Uint8Array(9);
            return h[0] = 8,
            h.set(Lf.fromNumber(e.value.valueOf()).bytes, 1),
            h;
        case "uuid":
            if (!MK.test(e.value))
                throw new Error(`Invalid UUID received: ${e.value}`);
            const m = new Uint8Array(17);
            return m[0] = 9,
            m.set(Zj(e.value.replace(/\-/g, "")), 1),
            m
        }
    }
    parse(e) {
        const t = {};
        let i = 0;
        for (; i < e.byteLength; ) {
            const r = e.getUint8(i++)
              , s = this.toUtf8(new Uint8Array(e.buffer,e.byteOffset + i,r));
            switch (i += r,
            e.getUint8(i++)) {
            case 0:
                t[s] = {
                    type: KE,
                    value: !0
                };
                break;
            case 1:
                t[s] = {
                    type: KE,
                    value: !1
                };
                break;
            case 2:
                t[s] = {
                    type: vK,
                    value: e.getInt8(i++)
                };
                break;
            case 3:
                t[s] = {
                    type: yK,
                    value: e.getInt16(i, !1)
                },
                i += 2;
                break;
            case 4:
                t[s] = {
                    type: xK,
                    value: e.getInt32(i, !1)
                },
                i += 4;
                break;
            case 5:
                t[s] = {
                    type: bK,
                    value: new Lf(new Uint8Array(e.buffer,e.byteOffset + i,8))
                },
                i += 8;
                break;
            case 6:
                const o = e.getUint16(i, !1);
                i += 2,
                t[s] = {
                    type: SK,
                    value: new Uint8Array(e.buffer,e.byteOffset + i,o)
                },
                i += o;
                break;
            case 7:
                const a = e.getUint16(i, !1);
                i += 2,
                t[s] = {
                    type: wK,
                    value: this.toUtf8(new Uint8Array(e.buffer,e.byteOffset + i,a))
                },
                i += a;
                break;
            case 8:
                t[s] = {
                    type: EK,
                    value: new Date(new Lf(new Uint8Array(e.buffer,e.byteOffset + i,8)).valueOf())
                },
                i += 8;
                break;
            case 9:
                const c = new Uint8Array(e.buffer,e.byteOffset + i,16);
                i += 16,
                t[s] = {
                    type: AK,
                    value: `${jr(c.subarray(0, 4))}-${jr(c.subarray(4, 6))}-${jr(c.subarray(6, 8))}-${jr(c.subarray(8, 10))}-${jr(c.subarray(10))}`
                };
                break;
            default:
                throw new Error("Unrecognized header type tag")
            }
        }
        return t
    }
}
var YE;
(function(n) {
    n[n.boolTrue = 0] = "boolTrue",
    n[n.boolFalse = 1] = "boolFalse",
    n[n.byte = 2] = "byte",
    n[n.short = 3] = "short",
    n[n.integer = 4] = "integer",
    n[n.long = 5] = "long",
    n[n.byteArray = 6] = "byteArray",
    n[n.string = 7] = "string",
    n[n.timestamp = 8] = "timestamp",
    n[n.uuid = 9] = "uuid"
}
)(YE || (YE = {}));
const KE = "boolean"
  , vK = "byte"
  , yK = "short"
  , xK = "integer"
  , bK = "long"
  , SK = "binary"
  , wK = "string"
  , EK = "timestamp"
  , AK = "uuid"
  , MK = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/
  , u2 = 4
  , oa = u2 * 2
  , rl = 4
  , TK = oa + rl * 2;
function CK({byteLength: n, byteOffset: e, buffer: t}) {
    if (n < TK)
        throw new Error("Provided message too short to accommodate event stream message overhead");
    const i = new DataView(t,e,n)
      , r = i.getUint32(0, !1);
    if (n !== r)
        throw new Error("Reported message length does not match received message length");
    const s = i.getUint32(u2, !1)
      , o = i.getUint32(oa, !1)
      , a = i.getUint32(n - rl, !1)
      , c = new Zy.Crc32().update(new Uint8Array(t,e,oa));
    if (o !== c.digest())
        throw new Error(`The prelude checksum specified in the message (${o}) does not match the calculated CRC32 checksum (${c.digest()})`);
    if (c.update(new Uint8Array(t,e + oa,n - (oa + rl))),
    a !== c.digest())
        throw new Error(`The message checksum (${c.digest()}) did not match the expected value of ${a}`);
    return {
        headers: new DataView(t,e + oa + rl,s),
        body: new Uint8Array(t,e + oa + rl + s,r - s - (oa + rl + rl))
    }
}
class RK {
    constructor(e, t) {
        this.headerMarshaller = new c2(e,t),
        this.messageBuffer = [],
        this.isEndOfStream = !1
    }
    feed(e) {
        this.messageBuffer.push(this.decode(e))
    }
    endOfStream() {
        this.isEndOfStream = !0
    }
    getMessage() {
        const e = this.messageBuffer.pop()
          , t = this.isEndOfStream;
        return {
            getMessage() {
                return e
            },
            isEndOfStream() {
                return t
            }
        }
    }
    getAvailableMessages() {
        const e = this.messageBuffer;
        this.messageBuffer = [];
        const t = this.isEndOfStream;
        return {
            getMessages() {
                return e
            },
            isEndOfStream() {
                return t
            }
        }
    }
    encode({headers: e, body: t}) {
        const i = this.headerMarshaller.format(e)
          , r = i.byteLength + t.byteLength + 16
          , s = new Uint8Array(r)
          , o = new DataView(s.buffer,s.byteOffset,s.byteLength)
          , a = new Zy.Crc32;
        return o.setUint32(0, r, !1),
        o.setUint32(4, i.byteLength, !1),
        o.setUint32(8, a.update(s.subarray(0, 8)).digest(), !1),
        s.set(i, 12),
        s.set(t, i.byteLength + 12),
        o.setUint32(r - 4, a.update(s.subarray(8, r - 4)).digest(), !1),
        s
    }
    decode(e) {
        const {headers: t, body: i} = CK(e);
        return {
            headers: this.headerMarshaller.parse(t),
            body: i
        }
    }
    formatHeaders(e) {
        return this.headerMarshaller.format(e)
    }
}
class PK {
    constructor(e) {
        this.options = e
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator()
    }
    async*asyncIterator() {
        for await(const e of this.options.inputStream)
            yield this.options.decoder.decode(e)
    }
}
class LK {
    constructor(e) {
        this.options = e
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator()
    }
    async*asyncIterator() {
        for await(const e of this.options.messageStream)
            yield this.options.encoder.encode(e);
        this.options.includeEndFrame && (yield new Uint8Array(0))
    }
}
class DK {
    constructor(e) {
        this.options = e
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator()
    }
    async*asyncIterator() {
        for await(const e of this.options.messageStream) {
            const t = await this.options.deserializer(e);
            t !== void 0 && (yield t)
        }
    }
}
class IK {
    constructor(e) {
        this.options = e
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator()
    }
    async*asyncIterator() {
        for await(const e of this.options.inputStream)
            yield this.options.serializer(e)
    }
}
const OK = n=>n[Ip] || (n[Ip] = {})
  , Us = n=>{
    if (typeof n == "function")
        return n;
    const e = Promise.resolve(n);
    return ()=>e
}
  , NK = "X-Amz-Algorithm"
  , UK = "X-Amz-Credential"
  , f2 = "X-Amz-Date"
  , FK = "X-Amz-SignedHeaders"
  , BK = "X-Amz-Expires"
  , h2 = "X-Amz-Signature"
  , d2 = "X-Amz-Security-Token"
  , p2 = "authorization"
  , m2 = f2.toLowerCase()
  , kK = "date"
  , zK = [p2, m2, kK]
  , HK = h2.toLowerCase()
  , Tv = "x-amz-content-sha256"
  , GK = d2.toLowerCase()
  , VK = {
    authorization: !0,
    "cache-control": !0,
    connection: !0,
    expect: !0,
    from: !0,
    "keep-alive": !0,
    "max-forwards": !0,
    pragma: !0,
    referer: !0,
    te: !0,
    trailer: !0,
    "transfer-encoding": !0,
    upgrade: !0,
    "user-agent": !0,
    "x-amzn-trace-id": !0
}
  , WK = /^proxy-/
  , $K = /^sec-/
  , N0 = "AWS4-HMAC-SHA256"
  , XK = "AWS4-HMAC-SHA256-PAYLOAD"
  , qK = "UNSIGNED-PAYLOAD"
  , jK = 50
  , g2 = "aws4_request"
  , YK = 60 * 60 * 24 * 7
  , kd = {}
  , U0 = []
  , F0 = (n,e,t)=>`${n}/${e}/${t}/${g2}`
  , KK = async(n,e,t,i,r)=>{
    const s = await ZE(n, e.secretAccessKey, e.accessKeyId)
      , o = `${t}:${i}:${r}:${jr(s)}:${e.sessionToken}`;
    if (o in kd)
        return kd[o];
    for (U0.push(o); U0.length > jK; )
        delete kd[U0.shift()];
    let a = `AWS4${e.secretAccessKey}`;
    for (const c of [t, i, r, g2])
        a = await ZE(n, a, c);
    return kd[o] = a
}
  , ZE = (n,e,t)=>{
    const i = new n(e);
    return i.update(kc(t)),
    i.digest()
}
  , JE = ({headers: n},e,t)=>{
    const i = {};
    for (const r of Object.keys(n).sort()) {
        if (n[r] == null)
            continue;
        const s = r.toLowerCase();
        (s in VK || e != null && e.has(s) || WK.test(s) || $K.test(s)) && (!t || t && !t.has(s)) || (i[s] = n[r].trim().replace(/\s+/g, " "))
    }
    return i
}
  , ZK = ({query: n={}})=>{
    const e = []
      , t = {};
    for (const i of Object.keys(n).sort()) {
        if (i.toLowerCase() === HK)
            continue;
        e.push(i);
        const r = n[i];
        typeof r == "string" ? t[i] = `${ul(i)}=${ul(r)}` : Array.isArray(r) && (t[i] = r.slice(0).reduce((s,o)=>s.concat([`${ul(i)}=${ul(o)}`]), []).sort().join("&"))
    }
    return e.map(i=>t[i]).filter(i=>i).join("&")
}
  , _2 = n=>typeof ArrayBuffer == "function" && n instanceof ArrayBuffer || Object.prototype.toString.call(n) === "[object ArrayBuffer]"
  , B0 = async({headers: n, body: e},t)=>{
    for (const i of Object.keys(n))
        if (i.toLowerCase() === Tv)
            return n[i];
    if (e == null)
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    if (typeof e == "string" || ArrayBuffer.isView(e) || _2(e)) {
        const i = new t;
        return i.update(kc(e)),
        jr(await i.digest())
    }
    return qK
}
  , JK = (n,e)=>{
    n = n.toLowerCase();
    for (const t of Object.keys(e))
        if (n === t.toLowerCase())
            return !0;
    return !1
}
  , v2 = ({headers: n, query: e, ...t})=>({
    ...t,
    headers: {
        ...n
    },
    query: e ? QK(e) : void 0
})
  , QK = n=>Object.keys(n).reduce((e,t)=>{
    const i = n[t];
    return {
        ...e,
        [t]: Array.isArray(i) ? [...i] : i
    }
}
, {})
  , eZ = (n,e={})=>{
    var r;
    const {headers: t, query: i={}} = typeof n.clone == "function" ? n.clone() : v2(n);
    for (const s of Object.keys(t)) {
        const o = s.toLowerCase();
        o.slice(0, 6) === "x-amz-" && !((r = e.unhoistableHeaders) != null && r.has(o)) && (i[s] = t[s],
        delete t[s])
    }
    return {
        ...n,
        headers: t,
        query: i
    }
}
  , QE = n=>{
    n = typeof n.clone == "function" ? n.clone() : v2(n);
    for (const e of Object.keys(n.headers))
        zK.indexOf(e.toLowerCase()) > -1 && delete n.headers[e];
    return n
}
  , tZ = n=>nZ(n).toISOString().replace(/\.\d{3}Z$/, "Z")
  , nZ = n=>typeof n == "number" ? new Date(n * 1e3) : typeof n == "string" ? Number(n) ? new Date(Number(n) * 1e3) : new Date(n) : n;
class Cv {
    constructor({applyChecksum: e, credentials: t, region: i, service: r, sha256: s, uriEscapePath: o=!0}) {
        this.headerMarshaller = new c2(hm,lh),
        this.service = r,
        this.sha256 = s,
        this.uriEscapePath = o,
        this.applyChecksum = typeof e == "boolean" ? e : !0,
        this.regionProvider = Us(i),
        this.credentialProvider = Us(t)
    }
    async presign(e, t={}) {
        const {signingDate: i=new Date, expiresIn: r=3600, unsignableHeaders: s, unhoistableHeaders: o, signableHeaders: a, signingRegion: c, signingService: u} = t
          , h = await this.credentialProvider();
        this.validateResolvedCredentials(h);
        const m = c ?? await this.regionProvider()
          , {longDate: d, shortDate: f} = zd(i);
        if (r > YK)
            return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
        const _ = F0(f, m, u ?? this.service)
          , g = eZ(QE(e), {
            unhoistableHeaders: o
        });
        h.sessionToken && (g.query[d2] = h.sessionToken),
        g.query[NK] = N0,
        g.query[UK] = `${h.accessKeyId}/${_}`,
        g.query[f2] = d,
        g.query[BK] = r.toString(10);
        const v = JE(g, s, a);
        return g.query[FK] = eA(v),
        g.query[h2] = await this.getSignature(d, _, this.getSigningKey(h, m, f, u), this.createCanonicalRequest(g, v, await B0(e, this.sha256))),
        g
    }
    async sign(e, t) {
        return typeof e == "string" ? this.signString(e, t) : e.headers && e.payload ? this.signEvent(e, t) : e.message ? this.signMessage(e, t) : this.signRequest(e, t)
    }
    async signEvent({headers: e, payload: t}, {signingDate: i=new Date, priorSignature: r, signingRegion: s, signingService: o}) {
        const a = s ?? await this.regionProvider()
          , {shortDate: c, longDate: u} = zd(i)
          , h = F0(c, a, o ?? this.service)
          , m = await B0({
            headers: {},
            body: t
        }, this.sha256)
          , d = new this.sha256;
        d.update(e);
        const f = jr(await d.digest())
          , _ = [XK, u, h, r, f, m].join(`
`);
        return this.signString(_, {
            signingDate: i,
            signingRegion: a,
            signingService: o
        })
    }
    async signMessage(e, {signingDate: t=new Date, signingRegion: i, signingService: r}) {
        return this.signEvent({
            headers: this.headerMarshaller.format(e.message.headers),
            payload: e.message.body
        }, {
            signingDate: t,
            signingRegion: i,
            signingService: r,
            priorSignature: e.priorSignature
        }).then(o=>({
            message: e.message,
            signature: o
        }))
    }
    async signString(e, {signingDate: t=new Date, signingRegion: i, signingService: r}={}) {
        const s = await this.credentialProvider();
        this.validateResolvedCredentials(s);
        const o = i ?? await this.regionProvider()
          , {shortDate: a} = zd(t)
          , c = new this.sha256(await this.getSigningKey(s, o, a, r));
        return c.update(kc(e)),
        jr(await c.digest())
    }
    async signRequest(e, {signingDate: t=new Date, signableHeaders: i, unsignableHeaders: r, signingRegion: s, signingService: o}={}) {
        const a = await this.credentialProvider();
        this.validateResolvedCredentials(a);
        const c = s ?? await this.regionProvider()
          , u = QE(e)
          , {longDate: h, shortDate: m} = zd(t)
          , d = F0(m, c, o ?? this.service);
        u.headers[m2] = h,
        a.sessionToken && (u.headers[GK] = a.sessionToken);
        const f = await B0(u, this.sha256);
        !JK(Tv, u.headers) && this.applyChecksum && (u.headers[Tv] = f);
        const _ = JE(u, r, i)
          , g = await this.getSignature(h, d, this.getSigningKey(a, c, m, o), this.createCanonicalRequest(u, _, f));
        return u.headers[p2] = `${N0} Credential=${a.accessKeyId}/${d}, SignedHeaders=${eA(_)}, Signature=${g}`,
        u
    }
    createCanonicalRequest(e, t, i) {
        const r = Object.keys(t).sort();
        return `${e.method}
${this.getCanonicalPath(e)}
${ZK(e)}
${r.map(s=>`${s}:${t[s]}`).join(`
`)}

${r.join(";")}
${i}`
    }
    async createStringToSign(e, t, i) {
        const r = new this.sha256;
        r.update(kc(i));
        const s = await r.digest();
        return `${N0}
${e}
${t}
${jr(s)}`
    }
    getCanonicalPath({path: e}) {
        if (this.uriEscapePath) {
            const t = [];
            for (const s of e.split("/"))
                (s == null ? void 0 : s.length) !== 0 && s !== "." && (s === ".." ? t.pop() : t.push(s));
            const i = `${e != null && e.startsWith("/") ? "/" : ""}${t.join("/")}${t.length > 0 && (e != null && e.endsWith("/")) ? "/" : ""}`;
            return encodeURIComponent(i).replace(/%2F/g, "/")
        }
        return e
    }
    async getSignature(e, t, i, r) {
        const s = await this.createStringToSign(e, t, r)
          , o = new this.sha256(await i);
        return o.update(kc(s)),
        jr(await o.digest())
    }
    getSigningKey(e, t, i, r) {
        return KK(this.sha256, e, i, t, r || this.service)
    }
    validateResolvedCredentials(e) {
        if (typeof e != "object" || typeof e.accessKeyId != "string" || typeof e.secretAccessKey != "string")
            throw new Error("Resolved credential object is not valid")
    }
}
const zd = n=>{
    const e = tZ(n).replace(/[\-:]/g, "");
    return {
        longDate: e,
        shortDate: e.slice(0, 8)
    }
}
  , eA = n=>Object.keys(n).sort().join(";");
var tA;
(function(n) {
    n.ENV = "env",
    n.CONFIG = "shared config entry"
}
)(tA || (tA = {}));
const iZ = "Directory"
  , rZ = "S3Express"
  , sZ = "sigv4-s3express"
  , Rv = "X-Amz-S3session-Token"
  , Pv = Rv.toLowerCase();
class oZ extends Cv {
    async signWithCredentials(e, t, i) {
        const r = nA(t);
        e.headers[Pv] = t.sessionToken;
        const s = this;
        return iA(s, r),
        s.signRequest(e, i ?? {})
    }
    async presignWithCredentials(e, t, i) {
        const r = nA(t);
        return delete e.headers[Pv],
        e.headers[Rv] = t.sessionToken,
        e.query = e.query ?? {},
        e.query[Rv] = t.sessionToken,
        iA(this, r),
        this.presign(e, i)
    }
}
function nA(n) {
    return {
        accessKeyId: n.accessKeyId,
        secretAccessKey: n.secretAccessKey,
        expiration: n.expiration
    }
}
function iA(n, e) {
    const t = setTimeout(()=>{
        throw new Error("SignatureV4S3Express credential override was created but not called.")
    }
    , 10)
      , i = n.credentialProvider
      , r = ()=>(clearTimeout(t),
    n.credentialProvider = i,
    Promise.resolve(e));
    n.credentialProvider = r
}
const aZ = n=>(e,t)=>async i=>{
    var r, s, o, a, c;
    if (t.endpointV2) {
        const u = t.endpointV2
          , h = ((o = (s = (r = u.properties) == null ? void 0 : r.authSchemes) == null ? void 0 : s[0]) == null ? void 0 : o.name) === sZ;
        if ((((a = u.properties) == null ? void 0 : a.backend) === rZ || ((c = u.properties) == null ? void 0 : c.bucketType) === iZ) && (t.isS3ExpressBucket = !0),
        h) {
            const d = i.input.Bucket;
            if (d) {
                const f = await n.s3ExpressIdentityProvider.getS3ExpressIdentity(await n.credentials(), {
                    Bucket: d
                });
                t.s3ExpressIdentity = f,
                dr.isInstance(i.request) && f.sessionToken && (i.request.headers[Pv] = f.sessionToken)
            }
        }
    }
    return e(i)
}
  , lZ = {
    name: "s3ExpressMiddleware",
    step: "build",
    tags: ["S3", "S3_EXPRESS"],
    override: !0
}
  , cZ = n=>({
    applyToStack: e=>{
        e.add(aZ(n), lZ)
    }
})
  , uZ = (n,{session: e})=>{
    const [t,i] = e;
    return {
        ...n,
        forcePathStyle: n.forcePathStyle ?? !1,
        useAccelerateEndpoint: n.useAccelerateEndpoint ?? !1,
        disableMultiregionAccessPoints: n.disableMultiregionAccessPoints ?? !1,
        followRegionRedirects: n.followRegionRedirects ?? !1,
        s3ExpressIdentityProvider: n.s3ExpressIdentityProvider ?? new mm(async r=>t().send(new i({
            Bucket: r,
            SessionMode: "ReadWrite"
        })))
    }
}
  , fZ = n=>typeof n == "string" && n.indexOf("arn:") === 0 && n.split(":").length >= 6;
function hZ() {
    return n=>async e=>{
        const {input: {Bucket: t}} = e;
        if (typeof t == "string" && !fZ(t) && t.indexOf("/") >= 0) {
            const i = new Error(`Bucket name shouldn't contain '/', received '${t}'`);
            throw i.name = "InvalidBucketName",
            i
        }
        return n({
            ...e
        })
    }
}
const dZ = {
    step: "initialize",
    tags: ["VALIDATE_BUCKET_NAME"],
    name: "validateBucketNameMiddleware",
    override: !0
}
  , pZ = n=>({
    applyToStack: e=>{
        e.add(hZ(), dZ)
    }
})
  , y2 = (n,e,t)=>{
    let i, r, s, o = !1;
    const a = async()=>{
        r || (r = n());
        try {
            i = await r,
            s = !0,
            o = !1
        } finally {
            r = void 0
        }
        return i
    }
    ;
    return e === void 0 ? async c=>((!s || c != null && c.forceRefresh) && (i = await a()),
    i) : async c=>((!s || c != null && c.forceRefresh) && (i = await a()),
    o ? i : t && !t(i) ? (o = !0,
    i) : (e(i) && await a(),
    i))
}
  , mZ = 3e5
  , gZ = n=>{
    const e = n.credentials ? _Z(n.credentials) : n.credentialDefaultProvider(n)
      , {signingEscapePath: t=!0, systemClockOffset: i=n.systemClockOffset || 0, sha256: r} = n;
    let s;
    return n.signer ? s = Us(n.signer) : n.regionInfoProvider ? s = ()=>Us(n.region)().then(async o=>[await n.regionInfoProvider(o, {
        useFipsEndpoint: await n.useFipsEndpoint(),
        useDualstackEndpoint: await n.useDualstackEndpoint()
    }) || {}, o]).then(([o,a])=>{
        const {signingRegion: c, signingService: u} = o;
        n.signingRegion = n.signingRegion || c || a,
        n.signingName = n.signingName || u || n.serviceId;
        const h = {
            ...n,
            credentials: e,
            region: n.signingRegion,
            service: n.signingName,
            sha256: r,
            uriEscapePath: t
        }
          , m = n.signerConstructor || Cv;
        return new m(h)
    }
    ) : s = async o=>{
        o = Object.assign({}, {
            name: "sigv4",
            signingName: n.signingName || n.defaultSigningName,
            signingRegion: await Us(n.region)(),
            properties: {}
        }, o);
        const a = o.signingRegion
          , c = o.signingName;
        n.signingRegion = n.signingRegion || a,
        n.signingName = n.signingName || c || n.serviceId;
        const u = {
            ...n,
            credentials: e,
            region: n.signingRegion,
            service: n.signingName,
            sha256: r,
            uriEscapePath: t
        }
          , h = n.signerConstructor || Cv;
        return new h(u)
    }
    ,
    {
        ...n,
        systemClockOffset: i,
        signingEscapePath: t,
        credentials: e,
        signer: s
    }
}
  , _Z = n=>typeof n == "function" ? y2(n, e=>e.expiration !== void 0 && e.expiration.getTime() - Date.now() < mZ, e=>e.expiration !== void 0) : Us(n)
  , x2 = n=>new Date(Date.now() + n)
  , vZ = (n,e)=>Math.abs(x2(e).getTime() - n) >= 3e5
  , rA = (n,e)=>{
    const t = Date.parse(n);
    return vZ(t, e) ? t - Date.now() : e
}
  , yZ = n=>(e,t)=>async function(i) {
    var m, d, f, _;
    if (!dr.isInstance(i.request))
        return e(i);
    const r = (f = (d = (m = t.endpointV2) == null ? void 0 : m.properties) == null ? void 0 : d.authSchemes) == null ? void 0 : f[0]
      , s = (r == null ? void 0 : r.name) === "sigv4a" ? (_ = r == null ? void 0 : r.signingRegionSet) == null ? void 0 : _.join(",") : void 0
      , o = await n.signer(r);
    let a;
    const c = {
        signingDate: x2(n.systemClockOffset),
        signingRegion: s || t.signing_region,
        signingService: t.signing_service
    };
    if (t.s3ExpressIdentity) {
        if (a = await o.signWithCredentials(i.request, t.s3ExpressIdentity, c),
        a.headers["X-Amz-Security-Token"] || a.headers["x-amz-security-token"])
            throw new Error("X-Amz-Security-Token must not be set for s3-express requests.")
    } else
        a = await o.sign(i.request, c);
    const u = await e({
        ...i,
        request: a
    }).catch(g=>{
        const v = g.ServerTime ?? sA(g.$response);
        throw v && (n.systemClockOffset = rA(v, n.systemClockOffset)),
        g
    }
    )
      , h = sA(u.response);
    return h && (n.systemClockOffset = rA(h, n.systemClockOffset)),
    u
}
  , sA = n=>{
    var e, t;
    return Op.isInstance(n) ? ((e = n.headers) == null ? void 0 : e.date) ?? ((t = n.headers) == null ? void 0 : t.Date) : void 0
}
  , xZ = {
    name: "awsAuthMiddleware",
    tags: ["SIGNATURE", "AWSAUTH"],
    relation: "after",
    toMiddleware: "retryMiddleware",
    override: !0
}
  , bZ = n=>({
    applyToStack: e=>{
        e.addRelativeTo(yZ(n), xZ)
    }
});
function SZ(n) {
    return {
        ...n,
        customUserAgent: typeof n.customUserAgent == "string" ? [[n.customUserAgent]] : n.customUserAgent
    }
}
const wZ = new RegExp("^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$")
  , b2 = n=>wZ.test(n) || n.startsWith("[") && n.endsWith("]")
  , EZ = new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$")
  , Jy = (n,e=!1)=>{
    if (!e)
        return EZ.test(n);
    const t = n.split(".");
    for (const i of t)
        if (!Jy(i))
            return !1;
    return !0
}
  , Lv = {}
  , jf = "endpoints";
function Ra(n) {
    return typeof n != "object" || n == null ? n : "ref"in n ? `$${Ra(n.ref)}` : "fn"in n ? `${n.fn}(${(n.argv || []).map(Ra).join(", ")})` : JSON.stringify(n, null, 2)
}
class Qr extends Error {
    constructor(e) {
        super(e),
        this.name = "EndpointError"
    }
}
const AZ = (n,e)=>n === e
  , MZ = n=>{
    const e = n.split(".")
      , t = [];
    for (const i of e) {
        const r = i.indexOf("[");
        if (r !== -1) {
            if (i.indexOf("]") !== i.length - 1)
                throw new Qr(`Path: '${n}' does not end with ']'`);
            const s = i.slice(r + 1, -1);
            if (Number.isNaN(parseInt(s)))
                throw new Qr(`Invalid array index: '${s}' in path: '${n}'`);
            r !== 0 && t.push(i.slice(0, r)),
            t.push(s)
        } else
            t.push(i)
    }
    return t
}
  , S2 = (n,e)=>MZ(e).reduce((t,i)=>{
    if (typeof t != "object")
        throw new Qr(`Index '${i}' in '${e}' not found in '${JSON.stringify(n)}'`);
    return Array.isArray(t) ? t[parseInt(i)] : t[i]
}
, n)
  , TZ = n=>n != null
  , CZ = n=>!n
  , k0 = {
    [$f.HTTP]: 80,
    [$f.HTTPS]: 443
}
  , RZ = n=>{
    const e = (()=>{
        try {
            if (n instanceof URL)
                return n;
            if (typeof n == "object" && "hostname"in n) {
                const {hostname: d, port: f, protocol: _="", path: g="", query: v={}} = n
                  , y = new URL(`${_}//${d}${f ? `:${f}` : ""}${g}`);
                return y.search = Object.entries(v).map(([w,S])=>`${w}=${S}`).join("&"),
                y
            }
            return new URL(n)
        } catch {
            return null
        }
    }
    )();
    if (!e)
        return console.error(`Unable to parse ${JSON.stringify(n)} as a whatwg URL.`),
        null;
    const t = e.href
      , {host: i, hostname: r, pathname: s, protocol: o, search: a} = e;
    if (a)
        return null;
    const c = o.slice(0, -1);
    if (!Object.values($f).includes(c))
        return null;
    const u = b2(r)
      , h = t.includes(`${i}:${k0[c]}`) || typeof n == "string" && n.includes(`${i}:${k0[c]}`)
      , m = `${i}${h ? `:${k0[c]}` : ""}`;
    return {
        scheme: c,
        authority: m,
        path: s,
        normalizedPath: s.endsWith("/") ? s : `${s}/`,
        isIp: u
    }
}
  , PZ = (n,e)=>n === e
  , LZ = (n,e,t,i)=>e >= t || n.length < t ? null : i ? n.substring(n.length - t, n.length - e) : n.substring(e, t)
  , DZ = n=>encodeURIComponent(n).replace(/[!*'()]/g, e=>`%${e.charCodeAt(0).toString(16).toUpperCase()}`)
  , IZ = {
    booleanEquals: AZ,
    getAttr: S2,
    isSet: TZ,
    isValidHostLabel: Jy,
    not: CZ,
    parseURL: RZ,
    stringEquals: PZ,
    substring: LZ,
    uriEncode: DZ
}
  , w2 = (n,e)=>{
    const t = []
      , i = {
        ...e.endpointParams,
        ...e.referenceRecord
    };
    let r = 0;
    for (; r < n.length; ) {
        const s = n.indexOf("{", r);
        if (s === -1) {
            t.push(n.slice(r));
            break
        }
        t.push(n.slice(r, s));
        const o = n.indexOf("}", s);
        if (o === -1) {
            t.push(n.slice(s));
            break
        }
        n[s + 1] === "{" && n[o + 1] === "}" && (t.push(n.slice(s + 1, o)),
        r = o + 2);
        const a = n.substring(s + 1, o);
        if (a.includes("#")) {
            const [c,u] = a.split("#");
            t.push(S2(i[c], u))
        } else
            t.push(i[a]);
        r = o + 1
    }
    return t.join("")
}
  , OZ = ({ref: n},e)=>({
    ...e.endpointParams,
    ...e.referenceRecord
})[n]
  , _m = (n,e,t)=>{
    if (typeof n == "string")
        return w2(n, t);
    if (n.fn)
        return E2(n, t);
    if (n.ref)
        return OZ(n, t);
    throw new Qr(`'${e}': ${String(n)} is not a string, function or reference.`)
}
  , E2 = ({fn: n, argv: e},t)=>{
    const i = e.map(s=>["boolean", "number"].includes(typeof s) ? s : _m(s, "arg", t))
      , r = n.split(".");
    return r[0]in Lv && r[1] != null ? Lv[r[0]][r[1]](...i) : IZ[n](...i)
}
  , NZ = ({assign: n, ...e},t)=>{
    var r, s;
    if (n && n in t.referenceRecord)
        throw new Qr(`'${n}' is already defined in Reference Record.`);
    const i = E2(e, t);
    return (s = (r = t.logger) == null ? void 0 : r.debug) == null || s.call(r, jf, `evaluateCondition: ${Ra(e)} = ${Ra(i)}`),
    {
        result: i === "" ? !0 : !!i,
        ...n != null && {
            toAssign: {
                name: n,
                value: i
            }
        }
    }
}
  , Qy = (n=[],e)=>{
    var i, r;
    const t = {};
    for (const s of n) {
        const {result: o, toAssign: a} = NZ(s, {
            ...e,
            referenceRecord: {
                ...e.referenceRecord,
                ...t
            }
        });
        if (!o)
            return {
                result: o
            };
        a && (t[a.name] = a.value,
        (r = (i = e.logger) == null ? void 0 : i.debug) == null || r.call(i, jf, `assign: ${a.name} := ${Ra(a.value)}`))
    }
    return {
        result: !0,
        referenceRecord: t
    }
}
  , UZ = (n,e)=>Object.entries(n).reduce((t,[i,r])=>({
    ...t,
    [i]: r.map(s=>{
        const o = _m(s, "Header value entry", e);
        if (typeof o != "string")
            throw new Qr(`Header '${i}' value '${o}' is not a string`);
        return o
    }
    )
}), {})
  , A2 = (n,e)=>{
    if (Array.isArray(n))
        return n.map(t=>A2(t, e));
    switch (typeof n) {
    case "string":
        return w2(n, e);
    case "object":
        if (n === null)
            throw new Qr(`Unexpected endpoint property: ${n}`);
        return M2(n, e);
    case "boolean":
        return n;
    default:
        throw new Qr(`Unexpected endpoint property type: ${typeof n}`)
    }
}
  , M2 = (n,e)=>Object.entries(n).reduce((t,[i,r])=>({
    ...t,
    [i]: A2(r, e)
}), {})
  , FZ = (n,e)=>{
    const t = _m(n, "Endpoint URL", e);
    if (typeof t == "string")
        try {
            return new URL(t)
        } catch (i) {
            throw console.error(`Failed to construct URL with ${t}`, i),
            i
        }
    throw new Qr(`Endpoint URL must be a string, got ${typeof t}`)
}
  , BZ = (n,e)=>{
    var h, m;
    const {conditions: t, endpoint: i} = n
      , {result: r, referenceRecord: s} = Qy(t, e);
    if (!r)
        return;
    const o = {
        ...e,
        referenceRecord: {
            ...e.referenceRecord,
            ...s
        }
    }
      , {url: a, properties: c, headers: u} = i;
    return (m = (h = e.logger) == null ? void 0 : h.debug) == null || m.call(h, jf, `Resolving endpoint from template: ${Ra(i)}`),
    {
        ...u != null && {
            headers: UZ(u, o)
        },
        ...c != null && {
            properties: M2(c, o)
        },
        url: FZ(a, o)
    }
}
  , kZ = (n,e)=>{
    const {conditions: t, error: i} = n
      , {result: r, referenceRecord: s} = Qy(t, e);
    if (r)
        throw new Qr(_m(i, "Error", {
            ...e,
            referenceRecord: {
                ...e.referenceRecord,
                ...s
            }
        }))
}
  , zZ = (n,e)=>{
    const {conditions: t, rules: i} = n
      , {result: r, referenceRecord: s} = Qy(t, e);
    if (r)
        return T2(i, {
            ...e,
            referenceRecord: {
                ...e.referenceRecord,
                ...s
            }
        })
}
  , T2 = (n,e)=>{
    for (const t of n)
        if (t.type === "endpoint") {
            const i = BZ(t, e);
            if (i)
                return i
        } else if (t.type === "error")
            kZ(t, e);
        else if (t.type === "tree") {
            const i = zZ(t, e);
            if (i)
                return i
        } else
            throw new Qr(`Unknown endpoint rule: ${t}`);
    throw new Qr("Rules evaluation failed")
}
  , HZ = (n,e)=>{
    var u, h, m, d, f;
    const {endpointParams: t, logger: i} = e
      , {parameters: r, rules: s} = n;
    (h = (u = e.logger) == null ? void 0 : u.debug) == null || h.call(u, `${jf} Initial EndpointParams: ${Ra(t)}`);
    const o = Object.entries(r).filter(([,_])=>_.default != null).map(([_,g])=>[_, g.default]);
    if (o.length > 0)
        for (const [_,g] of o)
            t[_] = t[_] ?? g;
    const a = Object.entries(r).filter(([,_])=>_.required).map(([_])=>_);
    for (const _ of a)
        if (t[_] == null)
            throw new Qr(`Missing required parameter: '${_}'`);
    const c = T2(s, {
        endpointParams: t,
        logger: i,
        referenceRecord: {}
    });
    if ((m = e.endpointParams) != null && m.Endpoint)
        try {
            const _ = new URL(e.endpointParams.Endpoint)
              , {protocol: g, port: v} = _;
            c.url.protocol = g,
            c.url.port = v
        } catch {}
    return (f = (d = e.logger) == null ? void 0 : d.debug) == null || f.call(d, `${jf} Resolved endpoint: ${Ra(c)}`),
    c
}
  , C2 = (n,e=!1)=>{
    if (e) {
        for (const t of n.split("."))
            if (!C2(t))
                return !1;
        return !0
    }
    return !(!Jy(n) || n.length < 3 || n.length > 63 || n !== n.toLowerCase() || b2(n))
}
  , GZ = n=>{
    const e = n.split(":");
    if (e.length < 6)
        return null;
    const [t,i,r,s,o,...a] = e;
    return t !== "arn" || i === "" || r === "" || a[0] === "" ? null : {
        partition: i,
        service: r,
        region: s,
        accountId: o,
        resourceId: a[0].includes("/") ? a[0].split("/") : a
    }
}
  , VZ = [{
    id: "aws",
    outputs: {
        dnsSuffix: "amazonaws.com",
        dualStackDnsSuffix: "api.aws",
        implicitGlobalRegion: "us-east-1",
        name: "aws",
        supportsDualStack: !0,
        supportsFIPS: !0
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",
    regions: {
        "af-south-1": {
            description: "Africa (Cape Town)"
        },
        "ap-east-1": {
            description: "Asia Pacific (Hong Kong)"
        },
        "ap-northeast-1": {
            description: "Asia Pacific (Tokyo)"
        },
        "ap-northeast-2": {
            description: "Asia Pacific (Seoul)"
        },
        "ap-northeast-3": {
            description: "Asia Pacific (Osaka)"
        },
        "ap-south-1": {
            description: "Asia Pacific (Mumbai)"
        },
        "ap-south-2": {
            description: "Asia Pacific (Hyderabad)"
        },
        "ap-southeast-1": {
            description: "Asia Pacific (Singapore)"
        },
        "ap-southeast-2": {
            description: "Asia Pacific (Sydney)"
        },
        "ap-southeast-3": {
            description: "Asia Pacific (Jakarta)"
        },
        "ap-southeast-4": {
            description: "Asia Pacific (Melbourne)"
        },
        "aws-global": {
            description: "AWS Standard global region"
        },
        "ca-central-1": {
            description: "Canada (Central)"
        },
        "eu-central-1": {
            description: "Europe (Frankfurt)"
        },
        "eu-central-2": {
            description: "Europe (Zurich)"
        },
        "eu-north-1": {
            description: "Europe (Stockholm)"
        },
        "eu-south-1": {
            description: "Europe (Milan)"
        },
        "eu-south-2": {
            description: "Europe (Spain)"
        },
        "eu-west-1": {
            description: "Europe (Ireland)"
        },
        "eu-west-2": {
            description: "Europe (London)"
        },
        "eu-west-3": {
            description: "Europe (Paris)"
        },
        "il-central-1": {
            description: "Israel (Tel Aviv)"
        },
        "me-central-1": {
            description: "Middle East (UAE)"
        },
        "me-south-1": {
            description: "Middle East (Bahrain)"
        },
        "sa-east-1": {
            description: "South America (Sao Paulo)"
        },
        "us-east-1": {
            description: "US East (N. Virginia)"
        },
        "us-east-2": {
            description: "US East (Ohio)"
        },
        "us-west-1": {
            description: "US West (N. California)"
        },
        "us-west-2": {
            description: "US West (Oregon)"
        }
    }
}, {
    id: "aws-cn",
    outputs: {
        dnsSuffix: "amazonaws.com.cn",
        dualStackDnsSuffix: "api.amazonwebservices.com.cn",
        implicitGlobalRegion: "cn-northwest-1",
        name: "aws-cn",
        supportsDualStack: !0,
        supportsFIPS: !0
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
        "aws-cn-global": {
            description: "AWS China global region"
        },
        "cn-north-1": {
            description: "China (Beijing)"
        },
        "cn-northwest-1": {
            description: "China (Ningxia)"
        }
    }
}, {
    id: "aws-us-gov",
    outputs: {
        dnsSuffix: "amazonaws.com",
        dualStackDnsSuffix: "api.aws",
        implicitGlobalRegion: "us-gov-west-1",
        name: "aws-us-gov",
        supportsDualStack: !0,
        supportsFIPS: !0
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
        "aws-us-gov-global": {
            description: "AWS GovCloud (US) global region"
        },
        "us-gov-east-1": {
            description: "AWS GovCloud (US-East)"
        },
        "us-gov-west-1": {
            description: "AWS GovCloud (US-West)"
        }
    }
}, {
    id: "aws-iso",
    outputs: {
        dnsSuffix: "c2s.ic.gov",
        dualStackDnsSuffix: "c2s.ic.gov",
        implicitGlobalRegion: "us-iso-east-1",
        name: "aws-iso",
        supportsDualStack: !1,
        supportsFIPS: !0
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
        "aws-iso-global": {
            description: "AWS ISO (US) global region"
        },
        "us-iso-east-1": {
            description: "US ISO East"
        },
        "us-iso-west-1": {
            description: "US ISO WEST"
        }
    }
}, {
    id: "aws-iso-b",
    outputs: {
        dnsSuffix: "sc2s.sgov.gov",
        dualStackDnsSuffix: "sc2s.sgov.gov",
        implicitGlobalRegion: "us-isob-east-1",
        name: "aws-iso-b",
        supportsDualStack: !1,
        supportsFIPS: !0
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
        "aws-iso-b-global": {
            description: "AWS ISOB (US) global region"
        },
        "us-isob-east-1": {
            description: "US ISOB East (Ohio)"
        }
    }
}, {
    id: "aws-iso-e",
    outputs: {
        dnsSuffix: "cloud.adc-e.uk",
        dualStackDnsSuffix: "cloud.adc-e.uk",
        implicitGlobalRegion: "eu-isoe-west-1",
        name: "aws-iso-e",
        supportsDualStack: !1,
        supportsFIPS: !0
    },
    regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
    regions: {}
}, {
    id: "aws-iso-f",
    outputs: {
        dnsSuffix: "csp.hci.ic.gov",
        dualStackDnsSuffix: "csp.hci.ic.gov",
        implicitGlobalRegion: "us-isof-south-1",
        name: "aws-iso-f",
        supportsDualStack: !1,
        supportsFIPS: !0
    },
    regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
    regions: {}
}]
  , WZ = "1.1"
  , $Z = {
    partitions: VZ,
    version: WZ
};
let XZ = $Z;
const qZ = n=>{
    const {partitions: e} = XZ;
    for (const i of e) {
        const {regions: r, outputs: s} = i;
        for (const [o,a] of Object.entries(r))
            if (o === n)
                return {
                    ...s,
                    ...a
                }
    }
    for (const i of e) {
        const {regionRegex: r, outputs: s} = i;
        if (new RegExp(r).test(n))
            return {
                ...s
            }
    }
    const t = e.find(i=>i.id === "aws");
    if (!t)
        throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
    return {
        ...t.outputs
    }
}
  , jZ = {
    isVirtualHostableS3Bucket: C2,
    parseArn: GZ,
    partition: qZ
};
Lv.aws = jZ;
const oA = "user-agent"
  , z0 = "x-amz-user-agent"
  , aA = " "
  , H0 = "/"
  , YZ = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g
  , KZ = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g
  , lA = "-"
  , ZZ = n=>(e,t)=>async i=>{
    var m, d;
    const {request: r} = i;
    if (!dr.isInstance(r))
        return e(i);
    const {headers: s} = r
      , o = ((m = t == null ? void 0 : t.userAgent) == null ? void 0 : m.map(G0)) || []
      , a = (await n.defaultUserAgentProvider()).map(G0)
      , c = ((d = n == null ? void 0 : n.customUserAgent) == null ? void 0 : d.map(G0)) || []
      , u = [].concat([...a, ...o, ...c]).join(aA)
      , h = [...a.filter(f=>f.startsWith("aws-sdk-")), ...c].join(aA);
    return n.runtime !== "browser" ? (h && (s[z0] = s[z0] ? `${s[oA]} ${h}` : h),
    s[oA] = u) : s[z0] = u,
    e({
        ...i,
        request: r
    })
}
  , G0 = n=>{
    var o;
    const e = n[0].split(H0).map(a=>a.replace(YZ, lA)).join(H0)
      , t = (o = n[1]) == null ? void 0 : o.replace(KZ, lA)
      , i = e.indexOf(H0)
      , r = e.substring(0, i);
    let s = e.substring(i + 1);
    return r === "api" && (s = s.toLowerCase()),
    [r, s, t].filter(a=>a && a.length > 0).reduce((a,c,u)=>{
        switch (u) {
        case 0:
            return c;
        case 1:
            return `${a}/${c}`;
        default:
            return `${a}#${c}`
        }
    }
    , "")
}
  , JZ = {
    name: "getUserAgentMiddleware",
    step: "build",
    priority: "low",
    tags: ["SET_USER_AGENT", "USER_AGENT"],
    override: !0
}
  , QZ = n=>({
    applyToStack: e=>{
        e.add(ZZ(n), JZ)
    }
})
  , eJ = !1
  , tJ = !1
  , R2 = n=>typeof n == "string" && (n.startsWith("fips-") || n.endsWith("-fips"))
  , cA = n=>R2(n) ? ["fips-aws-global", "aws-fips"].includes(n) ? "us-east-1" : n.replace(/fips-(dkr-|prod-)?|-fips/, "") : n
  , nJ = n=>{
    const {region: e, useFipsEndpoint: t} = n;
    if (!e)
        throw new Error("Region is missing");
    return {
        ...n,
        region: async()=>{
            if (typeof e == "string")
                return cA(e);
            const i = await e();
            return cA(i)
        }
        ,
        useFipsEndpoint: async()=>{
            const i = typeof e == "string" ? e : await e();
            return R2(i) ? !0 : typeof t != "function" ? Promise.resolve(!!t) : t()
        }
    }
}
  , iJ = n=>({
    ...n,
    eventStreamMarshaller: n.eventStreamSerdeProvider(n)
})
  , uA = "content-length";
function rJ(n) {
    return e=>async t=>{
        const i = t.request;
        if (dr.isInstance(i)) {
            const {body: r, headers: s} = i;
            if (r && Object.keys(s).map(o=>o.toLowerCase()).indexOf(uA) === -1)
                try {
                    const o = n(r);
                    i.headers = {
                        ...i.headers,
                        [uA]: String(o)
                    }
                } catch {}
        }
        return e({
            ...t,
            request: i
        })
    }
}
const sJ = {
    step: "build",
    tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
    name: "contentLengthMiddleware",
    override: !0
}
  , oJ = n=>({
    applyToStack: e=>{
        e.add(rJ(n.bodyLengthChecker), sJ)
    }
})
  , aJ = async n=>{
    const e = (n == null ? void 0 : n.Bucket) || "";
    if (typeof n.Bucket == "string" && (n.Bucket = e.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"))),
    hJ(e)) {
        if (n.ForcePathStyle === !0)
            throw new Error("Path-style addressing cannot be used with ARN buckets")
    } else
        (!fJ(e) || e.indexOf(".") !== -1 && !String(n.Endpoint).startsWith("http:") || e.toLowerCase() !== e || e.length < 3) && (n.ForcePathStyle = !0);
    return n.DisableMultiRegionAccessPoints && (n.disableMultiRegionAccessPoints = !0,
    n.DisableMRAP = !0),
    n
}
  , lJ = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/
  , cJ = /(\d+\.){3}\d+/
  , uJ = /\.\./
  , fJ = n=>lJ.test(n) && !cJ.test(n) && !uJ.test(n)
  , hJ = n=>{
    const [e,t,i,r,s,o] = n.split(":")
      , a = e === "arn" && n.split(":").length >= 6
      , c = [e, t, i, s, o].filter(Boolean).length === 5;
    if (a && !c)
        throw new Error(`Invalid ARN: ${n} was an invalid ARN.`);
    return e === "arn" && !!t && !!i && !!s && !!o
}
  , dJ = (n,e,t)=>{
    const i = async()=>{
        const r = t[n] ?? t[e];
        return typeof r == "function" ? r() : r
    }
    ;
    return n === "endpoint" || e === "endpoint" ? async()=>{
        const r = await i();
        if (r && typeof r == "object") {
            if ("url"in r)
                return r.url.href;
            if ("hostname"in r) {
                const {protocol: s, hostname: o, port: a, path: c} = r;
                return `${s}//${o}${a ? ":" + a : ""}${c}`
            }
        }
        return r
    }
    : i
}
  , pJ = async n=>{}
;
function mJ(n) {
    const e = {};
    if (n = n.replace(/^\?/, ""),
    n)
        for (const t of n.split("&")) {
            let[i,r=null] = t.split("=");
            i = decodeURIComponent(i),
            r && (r = decodeURIComponent(r)),
            i in e ? Array.isArray(e[i]) ? e[i].push(r) : e[i] = [e[i], r] : e[i] = r
        }
    return e
}
const Bp = n=>{
    if (typeof n == "string")
        return Bp(new URL(n));
    const {hostname: e, pathname: t, port: i, protocol: r, search: s} = n;
    let o;
    return s && (o = mJ(s)),
    {
        hostname: e,
        port: i ? parseInt(i) : void 0,
        protocol: r,
        path: t,
        query: o
    }
}
  , P2 = n=>typeof n == "object" ? "url"in n ? Bp(n.url) : n : Bp(n)
  , L2 = async(n,e,t,i)=>{
    if (!t.endpoint) {
        const o = await pJ(t.serviceId || "");
        o && (t.endpoint = ()=>Promise.resolve(P2(o)))
    }
    const r = await gJ(n, e, t);
    if (typeof t.endpointProvider != "function")
        throw new Error("config.endpointProvider is not set.");
    return t.endpointProvider(r, i)
}
  , gJ = async(n,e,t)=>{
    var s;
    const i = {}
      , r = ((s = e == null ? void 0 : e.getEndpointParameterInstructions) == null ? void 0 : s.call(e)) || {};
    for (const [o,a] of Object.entries(r))
        switch (a.type) {
        case "staticContextParams":
            i[o] = a.value;
            break;
        case "contextParams":
            i[o] = n[a.name];
            break;
        case "clientContextParams":
        case "builtInParams":
            i[o] = await dJ(a.name, o, t)();
            break;
        default:
            throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(a))
        }
    return Object.keys(r).length === 0 && Object.assign(i, t),
    String(t.serviceId).toLowerCase() === "s3" && await aJ(i),
    i
}
  , _J = ({config: n, instructions: e})=>(t,i)=>async r=>{
    var a, c, u;
    const s = await L2(r.input, {
        getEndpointParameterInstructions() {
            return e
        }
    }, {
        ...n
    }, i);
    i.endpointV2 = s,
    i.authSchemes = (a = s.properties) == null ? void 0 : a.authSchemes;
    const o = (c = i.authSchemes) == null ? void 0 : c[0];
    if (o) {
        i.signing_region = o.signingRegion,
        i.signing_service = o.signingName;
        const h = OK(i)
          , m = (u = h == null ? void 0 : h.selectedHttpAuthScheme) == null ? void 0 : u.httpAuthOption;
        m && (m.signingProperties = Object.assign(m.signingProperties || {}, {
            signing_region: o.signingRegion,
            signingRegion: o.signingRegion,
            signing_service: o.signingName,
            signingName: o.signingName,
            signingRegionSet: o.signingRegionSet
        }, o.properties))
    }
    return t({
        ...r
    })
}
  , vJ = (n,e)=>(t,i)=>async r=>{
    const {response: s} = await t(r);
    try {
        const o = await e(s, n);
        return {
            response: s,
            output: o
        }
    } catch (o) {
        if (Object.defineProperty(o, "$response", {
            value: s
        }),
        !("$metadata"in o)) {
            const a = "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";
            o.message += `
  ` + a
        }
        throw o
    }
}
  , yJ = (n,e)=>(t,i)=>async r=>{
    var a;
    const s = (a = i.endpointV2) != null && a.url && n.urlParser ? async()=>n.urlParser(i.endpointV2.url) : n.endpoint;
    if (!s)
        throw new Error("No valid endpoint provider available.");
    const o = await e(r.input, {
        ...n,
        endpoint: s
    });
    return t({
        ...r,
        request: o
    })
}
  , xJ = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: !0
}
  , D2 = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: !0
};
function I2(n, e, t) {
    return {
        applyToStack: i=>{
            i.add(vJ(n, t), xJ),
            i.add(yJ(n, e), D2)
        }
    }
}
const bJ = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: !0,
    relation: "before",
    toMiddleware: D2.name
}
  , O2 = (n,e)=>({
    applyToStack: t=>{
        t.addRelativeTo(_J({
            config: n,
            instructions: e
        }), bJ)
    }
})
  , SJ = n=>{
    const e = n.tls ?? !0
      , {endpoint: t} = n
      , i = t != null ? async()=>P2(await Us(t)()) : void 0;
    return {
        ...n,
        endpoint: i,
        tls: e,
        isCustomEndpoint: !!t,
        useDualstackEndpoint: Us(n.useDualstackEndpoint ?? !1),
        useFipsEndpoint: Us(n.useFipsEndpoint ?? !1)
    }
}
;
var Zc;
(function(n) {
    n.STANDARD = "standard",
    n.ADAPTIVE = "adaptive"
}
)(Zc || (Zc = {}));
const kp = 3
  , wJ = Zc.STANDARD
  , EJ = ["BandwidthLimitExceeded", "EC2ThrottledException", "LimitExceededException", "PriorRequestNotComplete", "ProvisionedThroughputExceededException", "RequestLimitExceeded", "RequestThrottled", "RequestThrottledException", "SlowDown", "ThrottledException", "Throttling", "ThrottlingException", "TooManyRequestsException", "TransactionInProgressException"]
  , AJ = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"]
  , MJ = [500, 502, 503, 504]
  , TJ = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"]
  , N2 = n=>{
    var e, t;
    return ((e = n.$metadata) == null ? void 0 : e.httpStatusCode) === 429 || EJ.includes(n.name) || ((t = n.$retryable) == null ? void 0 : t.throttling) == !0
}
  , U2 = n=>{
    var e;
    return AJ.includes(n.name) || TJ.includes((n == null ? void 0 : n.code) || "") || MJ.includes(((e = n.$metadata) == null ? void 0 : e.httpStatusCode) || 0)
}
  , CJ = n=>{
    var e;
    if (((e = n.$metadata) == null ? void 0 : e.httpStatusCode) !== void 0) {
        const t = n.$metadata.httpStatusCode;
        return 500 <= t && t <= 599 && !U2(n)
    }
    return !1
}
;
class RJ {
    constructor(e) {
        this.currentCapacity = 0,
        this.enabled = !1,
        this.lastMaxRate = 0,
        this.measuredTxRate = 0,
        this.requestCount = 0,
        this.lastTimestamp = 0,
        this.timeWindow = 0,
        this.beta = (e == null ? void 0 : e.beta) ?? .7,
        this.minCapacity = (e == null ? void 0 : e.minCapacity) ?? 1,
        this.minFillRate = (e == null ? void 0 : e.minFillRate) ?? .5,
        this.scaleConstant = (e == null ? void 0 : e.scaleConstant) ?? .4,
        this.smooth = (e == null ? void 0 : e.smooth) ?? .8;
        const t = this.getCurrentTimeInSeconds();
        this.lastThrottleTime = t,
        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds()),
        this.fillRate = this.minFillRate,
        this.maxCapacity = this.minCapacity
    }
    getCurrentTimeInSeconds() {
        return Date.now() / 1e3
    }
    async getSendToken() {
        return this.acquireTokenBucket(1)
    }
    async acquireTokenBucket(e) {
        if (this.enabled) {
            if (this.refillTokenBucket(),
            e > this.currentCapacity) {
                const t = (e - this.currentCapacity) / this.fillRate * 1e3;
                await new Promise(i=>setTimeout(i, t))
            }
            this.currentCapacity = this.currentCapacity - e
        }
    }
    refillTokenBucket() {
        const e = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
            this.lastTimestamp = e;
            return
        }
        const t = (e - this.lastTimestamp) * this.fillRate;
        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + t),
        this.lastTimestamp = e
    }
    updateClientSendingRate(e) {
        let t;
        if (this.updateMeasuredRate(),
        N2(e)) {
            const r = this.enabled ? Math.min(this.measuredTxRate, this.fillRate) : this.measuredTxRate;
            this.lastMaxRate = r,
            this.calculateTimeWindow(),
            this.lastThrottleTime = this.getCurrentTimeInSeconds(),
            t = this.cubicThrottle(r),
            this.enableTokenBucket()
        } else
            this.calculateTimeWindow(),
            t = this.cubicSuccess(this.getCurrentTimeInSeconds());
        const i = Math.min(t, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(i)
    }
    calculateTimeWindow() {
        this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3))
    }
    cubicThrottle(e) {
        return this.getPrecise(e * this.beta)
    }
    cubicSuccess(e) {
        return this.getPrecise(this.scaleConstant * Math.pow(e - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate)
    }
    enableTokenBucket() {
        this.enabled = !0
    }
    updateTokenBucketRate(e) {
        this.refillTokenBucket(),
        this.fillRate = Math.max(e, this.minFillRate),
        this.maxCapacity = Math.max(e, this.minCapacity),
        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity)
    }
    updateMeasuredRate() {
        const e = this.getCurrentTimeInSeconds()
          , t = Math.floor(e * 2) / 2;
        if (this.requestCount++,
        t > this.lastTxRateBucket) {
            const i = this.requestCount / (t - this.lastTxRateBucket);
            this.measuredTxRate = this.getPrecise(i * this.smooth + this.measuredTxRate * (1 - this.smooth)),
            this.requestCount = 0,
            this.lastTxRateBucket = t
        }
    }
    getPrecise(e) {
        return parseFloat(e.toFixed(8))
    }
}
const Dv = 100
  , F2 = 20 * 1e3
  , PJ = 500
  , fA = 500
  , LJ = 5
  , DJ = 10
  , IJ = 1
  , OJ = "amz-sdk-invocation-id"
  , NJ = "amz-sdk-request"
  , UJ = ()=>{
    let n = Dv;
    return {
        computeNextBackoffDelay: i=>Math.floor(Math.min(F2, Math.random() * 2 ** i * n)),
        setDelayBase: i=>{
            n = i
        }
    }
}
  , hA = ({retryDelay: n, retryCount: e, retryCost: t})=>({
    getRetryCount: ()=>e,
    getRetryDelay: ()=>Math.min(F2, n),
    getRetryCost: ()=>t
});
class B2 {
    constructor(e) {
        this.maxAttempts = e,
        this.mode = Zc.STANDARD,
        this.capacity = fA,
        this.retryBackoffStrategy = UJ(),
        this.maxAttemptsProvider = typeof e == "function" ? e : async()=>e
    }
    async acquireInitialRetryToken(e) {
        return hA({
            retryDelay: Dv,
            retryCount: 0
        })
    }
    async refreshRetryTokenForRetry(e, t) {
        const i = await this.getMaxAttempts();
        if (this.shouldRetry(e, t, i)) {
            const r = t.errorType;
            this.retryBackoffStrategy.setDelayBase(r === "THROTTLING" ? PJ : Dv);
            const s = this.retryBackoffStrategy.computeNextBackoffDelay(e.getRetryCount())
              , o = t.retryAfterHint ? Math.max(t.retryAfterHint.getTime() - Date.now() || 0, s) : s
              , a = this.getCapacityCost(r);
            return this.capacity -= a,
            hA({
                retryDelay: o,
                retryCount: e.getRetryCount() + 1,
                retryCost: a
            })
        }
        throw new Error("No retry token available")
    }
    recordSuccess(e) {
        this.capacity = Math.max(fA, this.capacity + (e.getRetryCost() ?? IJ))
    }
    getCapacity() {
        return this.capacity
    }
    async getMaxAttempts() {
        try {
            return await this.maxAttemptsProvider()
        } catch {
            return console.warn(`Max attempts provider could not resolve. Using default of ${kp}`),
            kp
        }
    }
    shouldRetry(e, t, i) {
        return e.getRetryCount() + 1 < i && this.capacity >= this.getCapacityCost(t.errorType) && this.isRetryableError(t.errorType)
    }
    getCapacityCost(e) {
        return e === "TRANSIENT" ? DJ : LJ
    }
    isRetryableError(e) {
        return e === "THROTTLING" || e === "TRANSIENT"
    }
}
class FJ {
    constructor(e, t) {
        this.maxAttemptsProvider = e,
        this.mode = Zc.ADAPTIVE;
        const {rateLimiter: i} = t ?? {};
        this.rateLimiter = i ?? new RJ,
        this.standardRetryStrategy = new B2(e)
    }
    async acquireInitialRetryToken(e) {
        return await this.rateLimiter.getSendToken(),
        this.standardRetryStrategy.acquireInitialRetryToken(e)
    }
    async refreshRetryTokenForRetry(e, t) {
        return this.rateLimiter.updateClientSendingRate(t),
        this.standardRetryStrategy.refreshRetryTokenForRetry(e, t)
    }
    recordSuccess(e) {
        this.rateLimiter.updateClientSendingRate({}),
        this.standardRetryStrategy.recordSuccess(e)
    }
}
var Hd, BJ = new Uint8Array(16);
function kJ() {
    if (!Hd && (Hd = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto),
    !Hd))
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return Hd(BJ)
}
const zJ = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function HJ(n) {
    return typeof n == "string" && zJ.test(n)
}
var Ti = [];
for (var V0 = 0; V0 < 256; ++V0)
    Ti.push((V0 + 256).toString(16).substr(1));
function GJ(n) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
      , t = (Ti[n[e + 0]] + Ti[n[e + 1]] + Ti[n[e + 2]] + Ti[n[e + 3]] + "-" + Ti[n[e + 4]] + Ti[n[e + 5]] + "-" + Ti[n[e + 6]] + Ti[n[e + 7]] + "-" + Ti[n[e + 8]] + Ti[n[e + 9]] + "-" + Ti[n[e + 10]] + Ti[n[e + 11]] + Ti[n[e + 12]] + Ti[n[e + 13]] + Ti[n[e + 14]] + Ti[n[e + 15]]).toLowerCase();
    if (!HJ(t))
        throw TypeError("Stringified UUID is invalid");
    return t
}
function VJ(n, e, t) {
    n = n || {};
    var i = n.random || (n.rng || kJ)();
    if (i[6] = i[6] & 15 | 64,
    i[8] = i[8] & 63 | 128,
    e) {
        t = t || 0;
        for (var r = 0; r < 16; ++r)
            e[t + r] = i[r];
        return e
    }
    return GJ(i)
}
const WJ = n=>n instanceof Error ? n : n instanceof Object ? Object.assign(new Error, n) : typeof n == "string" ? new Error(n) : new Error(`AWS SDK error wrapper for ${n}`)
  , $J = n=>{
    const {retryStrategy: e} = n
      , t = Us(n.maxAttempts ?? kp);
    return {
        ...n,
        maxAttempts: t,
        retryStrategy: async()=>e || (await Us(n.retryMode)() === Zc.ADAPTIVE ? new FJ(t) : new B2(t))
    }
}
  , XJ = n=>(n == null ? void 0 : n.body)instanceof ReadableStream
  , qJ = n=>(e,t)=>async i=>{
    var o;
    let r = await n.retryStrategy();
    const s = await n.maxAttempts();
    if (jJ(r)) {
        r = r;
        let a = await r.acquireInitialRetryToken(t.partition_id)
          , c = new Error
          , u = 0
          , h = 0;
        const {request: m} = i
          , d = dr.isInstance(m);
        for (d && (m.headers[OJ] = VJ()); ; )
            try {
                d && (m.headers[NJ] = `attempt=${u + 1}; max=${s}`);
                const {response: f, output: _} = await e(i);
                return r.recordSuccess(a),
                _.$metadata.attempts = u + 1,
                _.$metadata.totalRetryDelay = h,
                {
                    response: f,
                    output: _
                }
            } catch (f) {
                const _ = YJ(f);
                if (c = WJ(f),
                d && XJ(m))
                    throw (o = t.logger instanceof ZR ? console : t.logger) == null || o.warn("An error was encountered in a non-retryable streaming request."),
                    c;
                try {
                    a = await r.refreshRetryTokenForRetry(a, _)
                } catch {
                    throw c.$metadata || (c.$metadata = {}),
                    c.$metadata.attempts = u + 1,
                    c.$metadata.totalRetryDelay = h,
                    c
                }
                u = a.getRetryCount();
                const g = a.getRetryDelay();
                h += g,
                await new Promise(v=>setTimeout(v, g))
            }
    } else
        return r = r,
        r != null && r.mode && (t.userAgent = [...t.userAgent || [], ["cfg/retry-mode", r.mode]]),
        r.retry(e, i)
}
  , jJ = n=>typeof n.acquireInitialRetryToken < "u" && typeof n.refreshRetryTokenForRetry < "u" && typeof n.recordSuccess < "u"
  , YJ = n=>{
    const e = {
        errorType: KJ(n)
    }
      , t = QJ(n.$response);
    return t && (e.retryAfterHint = t),
    e
}
  , KJ = n=>N2(n) ? "THROTTLING" : U2(n) ? "TRANSIENT" : CJ(n) ? "SERVER_ERROR" : "CLIENT_ERROR"
  , ZJ = {
    name: "retryMiddleware",
    tags: ["RETRY"],
    step: "finalizeRequest",
    priority: "high",
    override: !0
}
  , JJ = n=>({
    applyToStack: e=>{
        e.add(qJ(n), ZJ)
    }
})
  , QJ = n=>{
    if (!Op.isInstance(n))
        return;
    const e = Object.keys(n.headers).find(s=>s.toLowerCase() === "retry-after");
    if (!e)
        return;
    const t = n.headers[e]
      , i = Number(t);
    return Number.isNaN(i) ? new Date(t) : new Date(i * 1e3)
}
;
class lu extends Ky {
    constructor(e) {
        super(e),
        Object.setPrototypeOf(this, lu.prototype)
    }
}
class ex extends lu {
    constructor(e) {
        super({
            name: "NoSuchBucket",
            $fault: "client",
            ...e
        }),
        this.name = "NoSuchBucket",
        this.$fault = "client",
        Object.setPrototypeOf(this, ex.prototype)
    }
}
var dA;
(function(n) {
    n.visit = (e,t)=>e.Prefix !== void 0 ? t.Prefix(e.Prefix) : e.Tag !== void 0 ? t.Tag(e.Tag) : e.And !== void 0 ? t.And(e.And) : t._(e.$unknown[0], e.$unknown[1])
}
)(dA || (dA = {}));
var pA;
(function(n) {
    n.visit = (e,t)=>e.Prefix !== void 0 ? t.Prefix(e.Prefix) : e.Tag !== void 0 ? t.Tag(e.Tag) : e.ObjectSizeGreaterThan !== void 0 ? t.ObjectSizeGreaterThan(e.ObjectSizeGreaterThan) : e.ObjectSizeLessThan !== void 0 ? t.ObjectSizeLessThan(e.ObjectSizeLessThan) : e.And !== void 0 ? t.And(e.And) : t._(e.$unknown[0], e.$unknown[1])
}
)(pA || (pA = {}));
var mA;
(function(n) {
    n.visit = (e,t)=>e.Prefix !== void 0 ? t.Prefix(e.Prefix) : e.Tag !== void 0 ? t.Tag(e.Tag) : e.AccessPointArn !== void 0 ? t.AccessPointArn(e.AccessPointArn) : e.And !== void 0 ? t.And(e.And) : t._(e.$unknown[0], e.$unknown[1])
}
)(mA || (mA = {}));
var gA;
(function(n) {
    n.visit = (e,t)=>e.Prefix !== void 0 ? t.Prefix(e.Prefix) : e.Tag !== void 0 ? t.Tag(e.Tag) : e.And !== void 0 ? t.And(e.And) : t._(e.$unknown[0], e.$unknown[1])
}
)(gA || (gA = {}));
class tx extends lu {
    constructor(e) {
        super({
            name: "InvalidObjectState",
            $fault: "client",
            ...e
        }),
        this.name = "InvalidObjectState",
        this.$fault = "client",
        Object.setPrototypeOf(this, tx.prototype),
        this.StorageClass = e.StorageClass,
        this.AccessTier = e.AccessTier
    }
}
class nx extends lu {
    constructor(e) {
        super({
            name: "NoSuchKey",
            $fault: "client",
            ...e
        }),
        this.name = "NoSuchKey",
        this.$fault = "client",
        Object.setPrototypeOf(this, nx.prototype)
    }
}
const eQ = n=>({
    ...n,
    ...n.SecretAccessKey && {
        SecretAccessKey: Up
    },
    ...n.SessionToken && {
        SessionToken: Up
    }
})
  , tQ = n=>({
    ...n,
    ...n.Credentials && {
        Credentials: eQ(n.Credentials)
    }
})
  , nQ = n=>({
    ...n,
    ...n.SSEKMSKeyId && {
        SSEKMSKeyId: Up
    }
})
  , iQ = n=>({
    ...n,
    ...n.SSECustomerKey && {
        SSECustomerKey: Up
    }
});
var ix = {}
  , vm = {};
(function(n) {
    const e = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD"
      , t = e + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040"
      , i = "[" + e + "][" + t + "]*"
      , r = new RegExp("^" + i + "$")
      , s = function(a, c) {
        const u = [];
        let h = c.exec(a);
        for (; h; ) {
            const m = [];
            m.startIndex = c.lastIndex - h[0].length;
            const d = h.length;
            for (let f = 0; f < d; f++)
                m.push(h[f]);
            u.push(m),
            h = c.exec(a)
        }
        return u
    }
      , o = function(a) {
        const c = r.exec(a);
        return !(c === null || typeof c > "u")
    };
    n.isExist = function(a) {
        return typeof a < "u"
    }
    ,
    n.isEmptyObject = function(a) {
        return Object.keys(a).length === 0
    }
    ,
    n.merge = function(a, c, u) {
        if (c) {
            const h = Object.keys(c)
              , m = h.length;
            for (let d = 0; d < m; d++)
                u === "strict" ? a[h[d]] = [c[h[d]]] : a[h[d]] = c[h[d]]
        }
    }
    ,
    n.getValue = function(a) {
        return n.isExist(a) ? a : ""
    }
    ,
    n.isName = o,
    n.getAllMatches = s,
    n.nameRegexp = i
}
)(vm);
const rx = vm
  , rQ = {
    allowBooleanAttributes: !1,
    unpairedTags: []
};
ix.validate = function(n, e) {
    e = Object.assign({}, rQ, e);
    const t = [];
    let i = !1
      , r = !1;
    n[0] === "\uFEFF" && (n = n.substr(1));
    for (let s = 0; s < n.length; s++)
        if (n[s] === "<" && n[s + 1] === "?") {
            if (s += 2,
            s = vA(n, s),
            s.err)
                return s
        } else if (n[s] === "<") {
            let o = s;
            if (s++,
            n[s] === "!") {
                s = yA(n, s);
                continue
            } else {
                let a = !1;
                n[s] === "/" && (a = !0,
                s++);
                let c = "";
                for (; s < n.length && n[s] !== ">" && n[s] !== " " && n[s] !== "	" && n[s] !== `
` && n[s] !== "\r"; s++)
                    c += n[s];
                if (c = c.trim(),
                c[c.length - 1] === "/" && (c = c.substring(0, c.length - 1),
                s--),
                !hQ(c)) {
                    let m;
                    return c.trim().length === 0 ? m = "Invalid space after '<'." : m = "Tag '" + c + "' is an invalid name.",
                    ei("InvalidTag", m, br(n, s))
                }
                const u = aQ(n, s);
                if (u === !1)
                    return ei("InvalidAttr", "Attributes for '" + c + "' have open quote.", br(n, s));
                let h = u.value;
                if (s = u.index,
                h[h.length - 1] === "/") {
                    const m = s - h.length;
                    h = h.substring(0, h.length - 1);
                    const d = xA(h, e);
                    if (d === !0)
                        i = !0;
                    else
                        return ei(d.err.code, d.err.msg, br(n, m + d.err.line))
                } else if (a)
                    if (u.tagClosed) {
                        if (h.trim().length > 0)
                            return ei("InvalidTag", "Closing tag '" + c + "' can't have attributes or invalid starting.", br(n, o));
                        {
                            const m = t.pop();
                            if (c !== m.tagName) {
                                let d = br(n, m.tagStartPos);
                                return ei("InvalidTag", "Expected closing tag '" + m.tagName + "' (opened in line " + d.line + ", col " + d.col + ") instead of closing tag '" + c + "'.", br(n, o))
                            }
                            t.length == 0 && (r = !0)
                        }
                    } else
                        return ei("InvalidTag", "Closing tag '" + c + "' doesn't have proper closing.", br(n, s));
                else {
                    const m = xA(h, e);
                    if (m !== !0)
                        return ei(m.err.code, m.err.msg, br(n, s - h.length + m.err.line));
                    if (r === !0)
                        return ei("InvalidXml", "Multiple possible root nodes found.", br(n, s));
                    e.unpairedTags.indexOf(c) !== -1 || t.push({
                        tagName: c,
                        tagStartPos: o
                    }),
                    i = !0
                }
                for (s++; s < n.length; s++)
                    if (n[s] === "<")
                        if (n[s + 1] === "!") {
                            s++,
                            s = yA(n, s);
                            continue
                        } else if (n[s + 1] === "?") {
                            if (s = vA(n, ++s),
                            s.err)
                                return s
                        } else
                            break;
                    else if (n[s] === "&") {
                        const m = uQ(n, s);
                        if (m == -1)
                            return ei("InvalidChar", "char '&' is not expected.", br(n, s));
                        s = m
                    } else if (r === !0 && !_A(n[s]))
                        return ei("InvalidXml", "Extra text at the end", br(n, s));
                n[s] === "<" && s--
            }
        } else {
            if (_A(n[s]))
                continue;
            return ei("InvalidChar", "char '" + n[s] + "' is not expected.", br(n, s))
        }
    if (i) {
        if (t.length == 1)
            return ei("InvalidTag", "Unclosed tag '" + t[0].tagName + "'.", br(n, t[0].tagStartPos));
        if (t.length > 0)
            return ei("InvalidXml", "Invalid '" + JSON.stringify(t.map(s=>s.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", {
                line: 1,
                col: 1
            })
    } else
        return ei("InvalidXml", "Start tag expected.", 1);
    return !0
}
;
function _A(n) {
    return n === " " || n === "	" || n === `
` || n === "\r"
}
function vA(n, e) {
    const t = e;
    for (; e < n.length; e++)
        if (n[e] == "?" || n[e] == " ") {
            const i = n.substr(t, e - t);
            if (e > 5 && i === "xml")
                return ei("InvalidXml", "XML declaration allowed only at the start of the document.", br(n, e));
            if (n[e] == "?" && n[e + 1] == ">") {
                e++;
                break
            } else
                continue
        }
    return e
}
function yA(n, e) {
    if (n.length > e + 5 && n[e + 1] === "-" && n[e + 2] === "-") {
        for (e += 3; e < n.length; e++)
            if (n[e] === "-" && n[e + 1] === "-" && n[e + 2] === ">") {
                e += 2;
                break
            }
    } else if (n.length > e + 8 && n[e + 1] === "D" && n[e + 2] === "O" && n[e + 3] === "C" && n[e + 4] === "T" && n[e + 5] === "Y" && n[e + 6] === "P" && n[e + 7] === "E") {
        let t = 1;
        for (e += 8; e < n.length; e++)
            if (n[e] === "<")
                t++;
            else if (n[e] === ">" && (t--,
            t === 0))
                break
    } else if (n.length > e + 9 && n[e + 1] === "[" && n[e + 2] === "C" && n[e + 3] === "D" && n[e + 4] === "A" && n[e + 5] === "T" && n[e + 6] === "A" && n[e + 7] === "[") {
        for (e += 8; e < n.length; e++)
            if (n[e] === "]" && n[e + 1] === "]" && n[e + 2] === ">") {
                e += 2;
                break
            }
    }
    return e
}
const sQ = '"'
  , oQ = "'";
function aQ(n, e) {
    let t = ""
      , i = ""
      , r = !1;
    for (; e < n.length; e++) {
        if (n[e] === sQ || n[e] === oQ)
            i === "" ? i = n[e] : i !== n[e] || (i = "");
        else if (n[e] === ">" && i === "") {
            r = !0;
            break
        }
        t += n[e]
    }
    return i !== "" ? !1 : {
        value: t,
        index: e,
        tagClosed: r
    }
}
const lQ = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`,"g");
function xA(n, e) {
    const t = rx.getAllMatches(n, lQ)
      , i = {};
    for (let r = 0; r < t.length; r++) {
        if (t[r][1].length === 0)
            return ei("InvalidAttr", "Attribute '" + t[r][2] + "' has no space in starting.", Vu(t[r]));
        if (t[r][3] !== void 0 && t[r][4] === void 0)
            return ei("InvalidAttr", "Attribute '" + t[r][2] + "' is without value.", Vu(t[r]));
        if (t[r][3] === void 0 && !e.allowBooleanAttributes)
            return ei("InvalidAttr", "boolean attribute '" + t[r][2] + "' is not allowed.", Vu(t[r]));
        const s = t[r][2];
        if (!fQ(s))
            return ei("InvalidAttr", "Attribute '" + s + "' is an invalid name.", Vu(t[r]));
        if (!i.hasOwnProperty(s))
            i[s] = 1;
        else
            return ei("InvalidAttr", "Attribute '" + s + "' is repeated.", Vu(t[r]))
    }
    return !0
}
function cQ(n, e) {
    let t = /\d/;
    for (n[e] === "x" && (e++,
    t = /[\da-fA-F]/); e < n.length; e++) {
        if (n[e] === ";")
            return e;
        if (!n[e].match(t))
            break
    }
    return -1
}
function uQ(n, e) {
    if (e++,
    n[e] === ";")
        return -1;
    if (n[e] === "#")
        return e++,
        cQ(n, e);
    let t = 0;
    for (; e < n.length; e++,
    t++)
        if (!(n[e].match(/\w/) && t < 20)) {
            if (n[e] === ";")
                break;
            return -1
        }
    return e
}
function ei(n, e, t) {
    return {
        err: {
            code: n,
            msg: e,
            line: t.line || t,
            col: t.col
        }
    }
}
function fQ(n) {
    return rx.isName(n)
}
function hQ(n) {
    return rx.isName(n)
}
function br(n, e) {
    const t = n.substring(0, e).split(/\r?\n/);
    return {
        line: t.length,
        col: t[t.length - 1].length + 1
    }
}
function Vu(n) {
    return n.startIndex + n[1].length
}
var sx = {};
const k2 = {
    preserveOrder: !1,
    attributeNamePrefix: "@_",
    attributesGroupName: !1,
    textNodeName: "#text",
    ignoreAttributes: !0,
    removeNSPrefix: !1,
    allowBooleanAttributes: !1,
    parseTagValue: !0,
    parseAttributeValue: !1,
    trimValues: !0,
    cdataPropName: !1,
    numberParseOptions: {
        hex: !0,
        leadingZeros: !0,
        eNotation: !0
    },
    tagValueProcessor: function(n, e) {
        return e
    },
    attributeValueProcessor: function(n, e) {
        return e
    },
    stopNodes: [],
    alwaysCreateTextNode: !1,
    isArray: ()=>!1,
    commentPropName: !1,
    unpairedTags: [],
    processEntities: !0,
    htmlEntities: !1,
    ignoreDeclaration: !1,
    ignorePiTags: !1,
    transformTagName: !1,
    transformAttributeName: !1,
    updateTag: function(n, e, t) {
        return n
    }
}
  , dQ = function(n) {
    return Object.assign({}, k2, n)
};
sx.buildOptions = dQ;
sx.defaultOptions = k2;
class pQ {
    constructor(e) {
        this.tagname = e,
        this.child = [],
        this[":@"] = {}
    }
    add(e, t) {
        e === "__proto__" && (e = "#__proto__"),
        this.child.push({
            [e]: t
        })
    }
    addChild(e) {
        e.tagname === "__proto__" && (e.tagname = "#__proto__"),
        e[":@"] && Object.keys(e[":@"]).length > 0 ? this.child.push({
            [e.tagname]: e.child,
            ":@": e[":@"]
        }) : this.child.push({
            [e.tagname]: e.child
        })
    }
}
var mQ = pQ;
const gQ = vm;
function _Q(n, e) {
    const t = {};
    if (n[e + 3] === "O" && n[e + 4] === "C" && n[e + 5] === "T" && n[e + 6] === "Y" && n[e + 7] === "P" && n[e + 8] === "E") {
        e = e + 9;
        let i = 1
          , r = !1
          , s = !1
          , o = "";
        for (; e < n.length; e++)
            if (n[e] === "<" && !s) {
                if (r && xQ(n, e))
                    e += 7,
                    [entityName,val,e] = vQ(n, e + 1),
                    val.indexOf("&") === -1 && (t[EQ(entityName)] = {
                        regx: RegExp(`&${entityName};`, "g"),
                        val
                    });
                else if (r && bQ(n, e))
                    e += 8;
                else if (r && SQ(n, e))
                    e += 8;
                else if (r && wQ(n, e))
                    e += 9;
                else if (yQ)
                    s = !0;
                else
                    throw new Error("Invalid DOCTYPE");
                i++,
                o = ""
            } else if (n[e] === ">") {
                if (s ? n[e - 1] === "-" && n[e - 2] === "-" && (s = !1,
                i--) : i--,
                i === 0)
                    break
            } else
                n[e] === "[" ? r = !0 : o += n[e];
        if (i !== 0)
            throw new Error("Unclosed DOCTYPE")
    } else
        throw new Error("Invalid Tag instead of DOCTYPE");
    return {
        entities: t,
        i: e
    }
}
function vQ(n, e) {
    let t = "";
    for (; e < n.length && n[e] !== "'" && n[e] !== '"'; e++)
        t += n[e];
    if (t = t.trim(),
    t.indexOf(" ") !== -1)
        throw new Error("External entites are not supported");
    const i = n[e++];
    let r = "";
    for (; e < n.length && n[e] !== i; e++)
        r += n[e];
    return [t, r, e]
}
function yQ(n, e) {
    return n[e + 1] === "!" && n[e + 2] === "-" && n[e + 3] === "-"
}
function xQ(n, e) {
    return n[e + 1] === "!" && n[e + 2] === "E" && n[e + 3] === "N" && n[e + 4] === "T" && n[e + 5] === "I" && n[e + 6] === "T" && n[e + 7] === "Y"
}
function bQ(n, e) {
    return n[e + 1] === "!" && n[e + 2] === "E" && n[e + 3] === "L" && n[e + 4] === "E" && n[e + 5] === "M" && n[e + 6] === "E" && n[e + 7] === "N" && n[e + 8] === "T"
}
function SQ(n, e) {
    return n[e + 1] === "!" && n[e + 2] === "A" && n[e + 3] === "T" && n[e + 4] === "T" && n[e + 5] === "L" && n[e + 6] === "I" && n[e + 7] === "S" && n[e + 8] === "T"
}
function wQ(n, e) {
    return n[e + 1] === "!" && n[e + 2] === "N" && n[e + 3] === "O" && n[e + 4] === "T" && n[e + 5] === "A" && n[e + 6] === "T" && n[e + 7] === "I" && n[e + 8] === "O" && n[e + 9] === "N"
}
function EQ(n) {
    if (gQ.isName(n))
        return n;
    throw new Error(`Invalid entity name ${n}`)
}
var AQ = _Q;
const MQ = /^[-+]?0x[a-fA-F0-9]+$/
  , TQ = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
!Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt);
!Number.parseFloat && window.parseFloat && (Number.parseFloat = window.parseFloat);
const CQ = {
    hex: !0,
    leadingZeros: !0,
    decimalPoint: ".",
    eNotation: !0
};
function RQ(n, e={}) {
    if (e = Object.assign({}, CQ, e),
    !n || typeof n != "string")
        return n;
    let t = n.trim();
    if (e.skipLike !== void 0 && e.skipLike.test(t))
        return n;
    if (e.hex && MQ.test(t))
        return Number.parseInt(t, 16);
    {
        const i = TQ.exec(t);
        if (i) {
            const r = i[1]
              , s = i[2];
            let o = PQ(i[3]);
            const a = i[4] || i[6];
            if (!e.leadingZeros && s.length > 0 && r && t[2] !== ".")
                return n;
            if (!e.leadingZeros && s.length > 0 && !r && t[1] !== ".")
                return n;
            {
                const c = Number(t)
                  , u = "" + c;
                return u.search(/[eE]/) !== -1 || a ? e.eNotation ? c : n : t.indexOf(".") !== -1 ? u === "0" && o === "" || u === o || r && u === "-" + o ? c : n : s ? o === u || r + o === u ? c : n : t === u || t === r + u ? c : n
            }
        } else
            return n
    }
}
function PQ(n) {
    return n && n.indexOf(".") !== -1 && (n = n.replace(/0+$/, ""),
    n === "." ? n = "0" : n[0] === "." ? n = "0" + n : n[n.length - 1] === "." && (n = n.substr(0, n.length - 1))),
    n
}
var LQ = RQ;
const ox = vm
  , Wu = mQ
  , DQ = AQ
  , IQ = LQ;
"<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, ox.nameRegexp);
let OQ = class {
    constructor(e) {
        this.options = e,
        this.currentNode = null,
        this.tagsNodeStack = [],
        this.docTypeEntities = {},
        this.lastEntities = {
            apos: {
                regex: /&(apos|#39|#x27);/g,
                val: "'"
            },
            gt: {
                regex: /&(gt|#62|#x3E);/g,
                val: ">"
            },
            lt: {
                regex: /&(lt|#60|#x3C);/g,
                val: "<"
            },
            quot: {
                regex: /&(quot|#34|#x22);/g,
                val: '"'
            }
        },
        this.ampEntity = {
            regex: /&(amp|#38|#x26);/g,
            val: "&"
        },
        this.htmlEntities = {
            space: {
                regex: /&(nbsp|#160);/g,
                val: " "
            },
            cent: {
                regex: /&(cent|#162);/g,
                val: ""
            },
            pound: {
                regex: /&(pound|#163);/g,
                val: ""
            },
            yen: {
                regex: /&(yen|#165);/g,
                val: ""
            },
            euro: {
                regex: /&(euro|#8364);/g,
                val: ""
            },
            copyright: {
                regex: /&(copy|#169);/g,
                val: ""
            },
            reg: {
                regex: /&(reg|#174);/g,
                val: ""
            },
            inr: {
                regex: /&(inr|#8377);/g,
                val: ""
            }
        },
        this.addExternalEntities = NQ,
        this.parseXml = zQ,
        this.parseTextData = UQ,
        this.resolveNameSpace = FQ,
        this.buildAttributesMap = kQ,
        this.isItStopNode = WQ,
        this.replaceEntitiesValue = GQ,
        this.readStopNodeData = XQ,
        this.saveTextToParentTag = VQ,
        this.addChild = HQ
    }
}
;
function NQ(n) {
    const e = Object.keys(n);
    for (let t = 0; t < e.length; t++) {
        const i = e[t];
        this.lastEntities[i] = {
            regex: new RegExp("&" + i + ";","g"),
            val: n[i]
        }
    }
}
function UQ(n, e, t, i, r, s, o) {
    if (n !== void 0 && (this.options.trimValues && !i && (n = n.trim()),
    n.length > 0)) {
        o || (n = this.replaceEntitiesValue(n));
        const a = this.options.tagValueProcessor(e, n, t, r, s);
        return a == null ? n : typeof a != typeof n || a !== n ? a : this.options.trimValues ? Ov(n, this.options.parseTagValue, this.options.numberParseOptions) : n.trim() === n ? Ov(n, this.options.parseTagValue, this.options.numberParseOptions) : n
    }
}
function FQ(n) {
    if (this.options.removeNSPrefix) {
        const e = n.split(":")
          , t = n.charAt(0) === "/" ? "/" : "";
        if (e[0] === "xmlns")
            return "";
        e.length === 2 && (n = t + e[1])
    }
    return n
}
const BQ = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`,"gm");
function kQ(n, e, t) {
    if (!this.options.ignoreAttributes && typeof n == "string") {
        const i = ox.getAllMatches(n, BQ)
          , r = i.length
          , s = {};
        for (let o = 0; o < r; o++) {
            const a = this.resolveNameSpace(i[o][1]);
            let c = i[o][4]
              , u = this.options.attributeNamePrefix + a;
            if (a.length)
                if (this.options.transformAttributeName && (u = this.options.transformAttributeName(u)),
                u === "__proto__" && (u = "#__proto__"),
                c !== void 0) {
                    this.options.trimValues && (c = c.trim()),
                    c = this.replaceEntitiesValue(c);
                    const h = this.options.attributeValueProcessor(a, c, e);
                    h == null ? s[u] = c : typeof h != typeof c || h !== c ? s[u] = h : s[u] = Ov(c, this.options.parseAttributeValue, this.options.numberParseOptions)
                } else
                    this.options.allowBooleanAttributes && (s[u] = !0)
        }
        if (!Object.keys(s).length)
            return;
        if (this.options.attributesGroupName) {
            const o = {};
            return o[this.options.attributesGroupName] = s,
            o
        }
        return s
    }
}
const zQ = function(n) {
    n = n.replace(/\r\n?/g, `
`);
    const e = new Wu("!xml");
    let t = e
      , i = ""
      , r = "";
    for (let s = 0; s < n.length; s++)
        if (n[s] === "<")
            if (n[s + 1] === "/") {
                const a = fl(n, ">", s, "Closing Tag is not closed.");
                let c = n.substring(s + 2, a).trim();
                if (this.options.removeNSPrefix) {
                    const m = c.indexOf(":");
                    m !== -1 && (c = c.substr(m + 1))
                }
                this.options.transformTagName && (c = this.options.transformTagName(c)),
                t && (i = this.saveTextToParentTag(i, t, r));
                const u = r.substring(r.lastIndexOf(".") + 1);
                if (c && this.options.unpairedTags.indexOf(c) !== -1)
                    throw new Error(`Unpaired tag can not be used as closing tag: </${c}>`);
                let h = 0;
                u && this.options.unpairedTags.indexOf(u) !== -1 ? (h = r.lastIndexOf(".", r.lastIndexOf(".") - 1),
                this.tagsNodeStack.pop()) : h = r.lastIndexOf("."),
                r = r.substring(0, h),
                t = this.tagsNodeStack.pop(),
                i = "",
                s = a
            } else if (n[s + 1] === "?") {
                let a = Iv(n, s, !1, "?>");
                if (!a)
                    throw new Error("Pi Tag is not closed.");
                if (i = this.saveTextToParentTag(i, t, r),
                !(this.options.ignoreDeclaration && a.tagName === "?xml" || this.options.ignorePiTags)) {
                    const c = new Wu(a.tagName);
                    c.add(this.options.textNodeName, ""),
                    a.tagName !== a.tagExp && a.attrExpPresent && (c[":@"] = this.buildAttributesMap(a.tagExp, r, a.tagName)),
                    this.addChild(t, c, r)
                }
                s = a.closeIndex + 1
            } else if (n.substr(s + 1, 3) === "!--") {
                const a = fl(n, "-->", s + 4, "Comment is not closed.");
                if (this.options.commentPropName) {
                    const c = n.substring(s + 4, a - 2);
                    i = this.saveTextToParentTag(i, t, r),
                    t.add(this.options.commentPropName, [{
                        [this.options.textNodeName]: c
                    }])
                }
                s = a
            } else if (n.substr(s + 1, 2) === "!D") {
                const a = DQ(n, s);
                this.docTypeEntities = a.entities,
                s = a.i
            } else if (n.substr(s + 1, 2) === "![") {
                const a = fl(n, "]]>", s, "CDATA is not closed.") - 2
                  , c = n.substring(s + 9, a);
                if (i = this.saveTextToParentTag(i, t, r),
                this.options.cdataPropName)
                    t.add(this.options.cdataPropName, [{
                        [this.options.textNodeName]: c
                    }]);
                else {
                    let u = this.parseTextData(c, t.tagname, r, !0, !1, !0);
                    u == null && (u = ""),
                    t.add(this.options.textNodeName, u)
                }
                s = a + 2
            } else {
                let a = Iv(n, s, this.options.removeNSPrefix)
                  , c = a.tagName
                  , u = a.tagExp
                  , h = a.attrExpPresent
                  , m = a.closeIndex;
                this.options.transformTagName && (c = this.options.transformTagName(c)),
                t && i && t.tagname !== "!xml" && (i = this.saveTextToParentTag(i, t, r, !1));
                const d = t;
                if (d && this.options.unpairedTags.indexOf(d.tagname) !== -1 && (t = this.tagsNodeStack.pop(),
                r = r.substring(0, r.lastIndexOf("."))),
                c !== e.tagname && (r += r ? "." + c : c),
                this.isItStopNode(this.options.stopNodes, r, c)) {
                    let f = "";
                    if (u.length > 0 && u.lastIndexOf("/") === u.length - 1)
                        s = a.closeIndex;
                    else if (this.options.unpairedTags.indexOf(c) !== -1)
                        s = a.closeIndex;
                    else {
                        const g = this.readStopNodeData(n, c, m + 1);
                        if (!g)
                            throw new Error(`Unexpected end of ${c}`);
                        s = g.i,
                        f = g.tagContent
                    }
                    const _ = new Wu(c);
                    c !== u && h && (_[":@"] = this.buildAttributesMap(u, r, c)),
                    f && (f = this.parseTextData(f, c, r, !0, h, !0, !0)),
                    r = r.substr(0, r.lastIndexOf(".")),
                    _.add(this.options.textNodeName, f),
                    this.addChild(t, _, r)
                } else {
                    if (u.length > 0 && u.lastIndexOf("/") === u.length - 1) {
                        c[c.length - 1] === "/" ? (c = c.substr(0, c.length - 1),
                        u = c) : u = u.substr(0, u.length - 1),
                        this.options.transformTagName && (c = this.options.transformTagName(c));
                        const f = new Wu(c);
                        c !== u && h && (f[":@"] = this.buildAttributesMap(u, r, c)),
                        this.addChild(t, f, r),
                        r = r.substr(0, r.lastIndexOf("."))
                    } else {
                        const f = new Wu(c);
                        this.tagsNodeStack.push(t),
                        c !== u && h && (f[":@"] = this.buildAttributesMap(u, r, c)),
                        this.addChild(t, f, r),
                        t = f
                    }
                    i = "",
                    s = m
                }
            }
        else
            i += n[s];
    return e.child
};
function HQ(n, e, t) {
    const i = this.options.updateTag(e.tagname, t, e[":@"]);
    i === !1 || (typeof i == "string" && (e.tagname = i),
    n.addChild(e))
}
const GQ = function(n) {
    if (this.options.processEntities) {
        for (let e in this.docTypeEntities) {
            const t = this.docTypeEntities[e];
            n = n.replace(t.regx, t.val)
        }
        for (let e in this.lastEntities) {
            const t = this.lastEntities[e];
            n = n.replace(t.regex, t.val)
        }
        if (this.options.htmlEntities)
            for (let e in this.htmlEntities) {
                const t = this.htmlEntities[e];
                n = n.replace(t.regex, t.val)
            }
        n = n.replace(this.ampEntity.regex, this.ampEntity.val)
    }
    return n
};
function VQ(n, e, t, i) {
    return n && (i === void 0 && (i = Object.keys(e.child).length === 0),
    n = this.parseTextData(n, e.tagname, t, !1, e[":@"] ? Object.keys(e[":@"]).length !== 0 : !1, i),
    n !== void 0 && n !== "" && e.add(this.options.textNodeName, n),
    n = ""),
    n
}
function WQ(n, e, t) {
    const i = "*." + t;
    for (const r in n) {
        const s = n[r];
        if (i === s || e === s)
            return !0
    }
    return !1
}
function $Q(n, e, t=">") {
    let i, r = "";
    for (let s = e; s < n.length; s++) {
        let o = n[s];
        if (i)
            o === i && (i = "");
        else if (o === '"' || o === "'")
            i = o;
        else if (o === t[0])
            if (t[1]) {
                if (n[s + 1] === t[1])
                    return {
                        data: r,
                        index: s
                    }
            } else
                return {
                    data: r,
                    index: s
                };
        else
            o === "	" && (o = " ");
        r += o
    }
}
function fl(n, e, t, i) {
    const r = n.indexOf(e, t);
    if (r === -1)
        throw new Error(i);
    return r + e.length - 1
}
function Iv(n, e, t, i=">") {
    const r = $Q(n, e + 1, i);
    if (!r)
        return;
    let s = r.data;
    const o = r.index
      , a = s.search(/\s/);
    let c = s
      , u = !0;
    if (a !== -1 && (c = s.substr(0, a).replace(/\s\s*$/, ""),
    s = s.substr(a + 1)),
    t) {
        const h = c.indexOf(":");
        h !== -1 && (c = c.substr(h + 1),
        u = c !== r.data.substr(h + 1))
    }
    return {
        tagName: c,
        tagExp: s,
        closeIndex: o,
        attrExpPresent: u
    }
}
function XQ(n, e, t) {
    const i = t;
    let r = 1;
    for (; t < n.length; t++)
        if (n[t] === "<")
            if (n[t + 1] === "/") {
                const s = fl(n, ">", t, `${e} is not closed`);
                if (n.substring(t + 2, s).trim() === e && (r--,
                r === 0))
                    return {
                        tagContent: n.substring(i, t),
                        i: s
                    };
                t = s
            } else if (n[t + 1] === "?")
                t = fl(n, "?>", t + 1, "StopNode is not closed.");
            else if (n.substr(t + 1, 3) === "!--")
                t = fl(n, "-->", t + 3, "StopNode is not closed.");
            else if (n.substr(t + 1, 2) === "![")
                t = fl(n, "]]>", t, "StopNode is not closed.") - 2;
            else {
                const s = Iv(n, t, ">");
                s && ((s && s.tagName) === e && s.tagExp[s.tagExp.length - 1] !== "/" && r++,
                t = s.closeIndex)
            }
}
function Ov(n, e, t) {
    if (e && typeof n == "string") {
        const i = n.trim();
        return i === "true" ? !0 : i === "false" ? !1 : IQ(n, t)
    } else
        return ox.isExist(n) ? n : ""
}
var qQ = OQ
  , z2 = {};
function jQ(n, e) {
    return H2(n, e)
}
function H2(n, e, t) {
    let i;
    const r = {};
    for (let s = 0; s < n.length; s++) {
        const o = n[s]
          , a = YQ(o);
        let c = "";
        if (t === void 0 ? c = a : c = t + "." + a,
        a === e.textNodeName)
            i === void 0 ? i = o[a] : i += "" + o[a];
        else {
            if (a === void 0)
                continue;
            if (o[a]) {
                let u = H2(o[a], e, c);
                const h = ZQ(u, e);
                o[":@"] ? KQ(u, o[":@"], c, e) : Object.keys(u).length === 1 && u[e.textNodeName] !== void 0 && !e.alwaysCreateTextNode ? u = u[e.textNodeName] : Object.keys(u).length === 0 && (e.alwaysCreateTextNode ? u[e.textNodeName] = "" : u = ""),
                r[a] !== void 0 && r.hasOwnProperty(a) ? (Array.isArray(r[a]) || (r[a] = [r[a]]),
                r[a].push(u)) : e.isArray(a, c, h) ? r[a] = [u] : r[a] = u
            }
        }
    }
    return typeof i == "string" ? i.length > 0 && (r[e.textNodeName] = i) : i !== void 0 && (r[e.textNodeName] = i),
    r
}
function YQ(n) {
    const e = Object.keys(n);
    for (let t = 0; t < e.length; t++) {
        const i = e[t];
        if (i !== ":@")
            return i
    }
}
function KQ(n, e, t, i) {
    if (e) {
        const r = Object.keys(e)
          , s = r.length;
        for (let o = 0; o < s; o++) {
            const a = r[o];
            i.isArray(a, t + "." + a, !0, !0) ? n[a] = [e[a]] : n[a] = e[a]
        }
    }
}
function ZQ(n, e) {
    const {textNodeName: t} = e
      , i = Object.keys(n).length;
    return !!(i === 0 || i === 1 && (n[t] || typeof n[t] == "boolean" || n[t] === 0))
}
z2.prettify = jQ;
const {buildOptions: JQ} = sx
  , QQ = qQ
  , {prettify: eee} = z2
  , tee = ix;
let nee = class {
    constructor(e) {
        this.externalEntities = {},
        this.options = JQ(e)
    }
    parse(e, t) {
        if (typeof e != "string")
            if (e.toString)
                e = e.toString();
            else
                throw new Error("XML data is accepted in String or Bytes[] form.");
        if (t) {
            t === !0 && (t = {});
            const s = tee.validate(e, t);
            if (s !== !0)
                throw Error(`${s.err.msg}:${s.err.line}:${s.err.col}`)
        }
        const i = new QQ(this.options);
        i.addExternalEntities(this.externalEntities);
        const r = i.parseXml(e);
        return this.options.preserveOrder || r === void 0 ? r : eee(r, this.options)
    }
    addEntity(e, t) {
        if (t.indexOf("&") !== -1)
            throw new Error("Entity value can't have '&'");
        if (e.indexOf("&") !== -1 || e.indexOf(";") !== -1)
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        if (t === "&")
            throw new Error("An entity with value '&' is not permitted");
        this.externalEntities[e] = t
    }
}
;
var iee = nee;
const ree = `
`;
function see(n, e) {
    let t = "";
    return e.format && e.indentBy.length > 0 && (t = ree),
    G2(n, e, "", t)
}
function G2(n, e, t, i) {
    let r = ""
      , s = !1;
    for (let o = 0; o < n.length; o++) {
        const a = n[o]
          , c = oee(a);
        let u = "";
        if (t.length === 0 ? u = c : u = `${t}.${c}`,
        c === e.textNodeName) {
            let _ = a[c];
            aee(u, e) || (_ = e.tagValueProcessor(c, _),
            _ = V2(_, e)),
            s && (r += i),
            r += _,
            s = !1;
            continue
        } else if (c === e.cdataPropName) {
            s && (r += i),
            r += `<![CDATA[${a[c][0][e.textNodeName]}]]>`,
            s = !1;
            continue
        } else if (c === e.commentPropName) {
            r += i + `<!--${a[c][0][e.textNodeName]}-->`,
            s = !0;
            continue
        } else if (c[0] === "?") {
            const _ = bA(a[":@"], e)
              , g = c === "?xml" ? "" : i;
            let v = a[c][0][e.textNodeName];
            v = v.length !== 0 ? " " + v : "",
            r += g + `<${c}${v}${_}?>`,
            s = !0;
            continue
        }
        let h = i;
        h !== "" && (h += e.indentBy);
        const m = bA(a[":@"], e)
          , d = i + `<${c}${m}`
          , f = G2(a[c], e, u, h);
        e.unpairedTags.indexOf(c) !== -1 ? e.suppressUnpairedNode ? r += d + ">" : r += d + "/>" : (!f || f.length === 0) && e.suppressEmptyNode ? r += d + "/>" : f && f.endsWith(">") ? r += d + `>${f}${i}</${c}>` : (r += d + ">",
        f && i !== "" && (f.includes("/>") || f.includes("</")) ? r += i + e.indentBy + f + i : r += f,
        r += `</${c}>`),
        s = !0
    }
    return r
}
function oee(n) {
    const e = Object.keys(n);
    for (let t = 0; t < e.length; t++) {
        const i = e[t];
        if (i !== ":@")
            return i
    }
}
function bA(n, e) {
    let t = "";
    if (n && !e.ignoreAttributes)
        for (let i in n) {
            let r = e.attributeValueProcessor(i, n[i]);
            r = V2(r, e),
            r === !0 && e.suppressBooleanAttributes ? t += ` ${i.substr(e.attributeNamePrefix.length)}` : t += ` ${i.substr(e.attributeNamePrefix.length)}="${r}"`
        }
    return t
}
function aee(n, e) {
    n = n.substr(0, n.length - e.textNodeName.length - 1);
    let t = n.substr(n.lastIndexOf(".") + 1);
    for (let i in e.stopNodes)
        if (e.stopNodes[i] === n || e.stopNodes[i] === "*." + t)
            return !0;
    return !1
}
function V2(n, e) {
    if (n && n.length > 0 && e.processEntities)
        for (let t = 0; t < e.entities.length; t++) {
            const i = e.entities[t];
            n = n.replace(i.regex, i.val)
        }
    return n
}
var lee = see;
const cee = lee
  , uee = {
    attributeNamePrefix: "@_",
    attributesGroupName: !1,
    textNodeName: "#text",
    ignoreAttributes: !0,
    cdataPropName: !1,
    format: !1,
    indentBy: "  ",
    suppressEmptyNode: !1,
    suppressUnpairedNode: !0,
    suppressBooleanAttributes: !0,
    tagValueProcessor: function(n, e) {
        return e
    },
    attributeValueProcessor: function(n, e) {
        return e
    },
    preserveOrder: !1,
    commentPropName: !1,
    unpairedTags: [],
    entities: [{
        regex: new RegExp("&","g"),
        val: "&amp;"
    }, {
        regex: new RegExp(">","g"),
        val: "&gt;"
    }, {
        regex: new RegExp("<","g"),
        val: "&lt;"
    }, {
        regex: new RegExp("'","g"),
        val: "&apos;"
    }, {
        regex: new RegExp('"',"g"),
        val: "&quot;"
    }],
    processEntities: !0,
    stopNodes: [],
    oneListGroup: !1
};
function Ia(n) {
    this.options = Object.assign({}, uee, n),
    this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function() {
        return !1
    }
    : (this.attrPrefixLen = this.options.attributeNamePrefix.length,
    this.isAttribute = dee),
    this.processTextOrObjNode = fee,
    this.options.format ? (this.indentate = hee,
    this.tagEndChar = `>
`,
    this.newLine = `
`) : (this.indentate = function() {
        return ""
    }
    ,
    this.tagEndChar = ">",
    this.newLine = "")
}
Ia.prototype.build = function(n) {
    return this.options.preserveOrder ? cee(n, this.options) : (Array.isArray(n) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (n = {
        [this.options.arrayNodeName]: n
    }),
    this.j2x(n, 0).val)
}
;
Ia.prototype.j2x = function(n, e) {
    let t = ""
      , i = "";
    for (let r in n)
        if (!(typeof n[r] > "u"))
            if (n[r] === null)
                r[0] === "?" ? i += this.indentate(e) + "<" + r + "?" + this.tagEndChar : i += this.indentate(e) + "<" + r + "/" + this.tagEndChar;
            else if (n[r]instanceof Date)
                i += this.buildTextValNode(n[r], r, "", e);
            else if (typeof n[r] != "object") {
                const s = this.isAttribute(r);
                if (s)
                    t += this.buildAttrPairStr(s, "" + n[r]);
                else if (r === this.options.textNodeName) {
                    let o = this.options.tagValueProcessor(r, "" + n[r]);
                    i += this.replaceEntitiesValue(o)
                } else
                    i += this.buildTextValNode(n[r], r, "", e)
            } else if (Array.isArray(n[r])) {
                const s = n[r].length;
                let o = "";
                for (let a = 0; a < s; a++) {
                    const c = n[r][a];
                    typeof c > "u" || (c === null ? r[0] === "?" ? i += this.indentate(e) + "<" + r + "?" + this.tagEndChar : i += this.indentate(e) + "<" + r + "/" + this.tagEndChar : typeof c == "object" ? this.options.oneListGroup ? o += this.j2x(c, e + 1).val : o += this.processTextOrObjNode(c, r, e) : o += this.buildTextValNode(c, r, "", e))
                }
                this.options.oneListGroup && (o = this.buildObjectNode(o, r, "", e)),
                i += o
            } else if (this.options.attributesGroupName && r === this.options.attributesGroupName) {
                const s = Object.keys(n[r])
                  , o = s.length;
                for (let a = 0; a < o; a++)
                    t += this.buildAttrPairStr(s[a], "" + n[r][s[a]])
            } else
                i += this.processTextOrObjNode(n[r], r, e);
    return {
        attrStr: t,
        val: i
    }
}
;
Ia.prototype.buildAttrPairStr = function(n, e) {
    return e = this.options.attributeValueProcessor(n, "" + e),
    e = this.replaceEntitiesValue(e),
    this.options.suppressBooleanAttributes && e === "true" ? " " + n : " " + n + '="' + e + '"'
}
;
function fee(n, e, t) {
    const i = this.j2x(n, t + 1);
    return n[this.options.textNodeName] !== void 0 && Object.keys(n).length === 1 ? this.buildTextValNode(n[this.options.textNodeName], e, i.attrStr, t) : this.buildObjectNode(i.val, e, i.attrStr, t)
}
Ia.prototype.buildObjectNode = function(n, e, t, i) {
    if (n === "")
        return e[0] === "?" ? this.indentate(i) + "<" + e + t + "?" + this.tagEndChar : this.indentate(i) + "<" + e + t + this.closeTag(e) + this.tagEndChar;
    {
        let r = "</" + e + this.tagEndChar
          , s = "";
        return e[0] === "?" && (s = "?",
        r = ""),
        t && n.indexOf("<") === -1 ? this.indentate(i) + "<" + e + t + s + ">" + n + r : this.options.commentPropName !== !1 && e === this.options.commentPropName && s.length === 0 ? this.indentate(i) + `<!--${n}-->` + this.newLine : this.indentate(i) + "<" + e + t + s + this.tagEndChar + n + this.indentate(i) + r
    }
}
;
Ia.prototype.closeTag = function(n) {
    let e = "";
    return this.options.unpairedTags.indexOf(n) !== -1 ? this.options.suppressUnpairedNode || (e = "/") : this.options.suppressEmptyNode ? e = "/" : e = `></${n}`,
    e
}
;
Ia.prototype.buildTextValNode = function(n, e, t, i) {
    if (this.options.cdataPropName !== !1 && e === this.options.cdataPropName)
        return this.indentate(i) + `<![CDATA[${n}]]>` + this.newLine;
    if (this.options.commentPropName !== !1 && e === this.options.commentPropName)
        return this.indentate(i) + `<!--${n}-->` + this.newLine;
    if (e[0] === "?")
        return this.indentate(i) + "<" + e + t + "?" + this.tagEndChar;
    {
        let r = this.options.tagValueProcessor(e, n);
        return r = this.replaceEntitiesValue(r),
        r === "" ? this.indentate(i) + "<" + e + t + this.closeTag(e) + this.tagEndChar : this.indentate(i) + "<" + e + t + ">" + r + "</" + e + this.tagEndChar
    }
}
;
Ia.prototype.replaceEntitiesValue = function(n) {
    if (n && n.length > 0 && this.options.processEntities)
        for (let e = 0; e < this.options.entities.length; e++) {
            const t = this.options.entities[e];
            n = n.replace(t.regex, t.val)
        }
    return n
}
;
function hee(n) {
    return this.options.indentBy.repeat(n)
}
function dee(n) {
    return n.startsWith(this.options.attributeNamePrefix) ? n.substr(this.attrPrefixLen) : !1
}
var pee = Ia;
const mee = ix
  , gee = iee
  , _ee = pee;
var vee = {
    XMLParser: gee,
    XMLValidator: mee,
    XMLBuilder: _ee
};
const yee = async(n,e)=>{
    const {hostname: t, protocol: i="https", port: r, path: s} = await e.endpoint()
      , o = ro({}, lp, {
        "x-amz-create-session-mode": n.SessionMode
    });
    let a = `${s != null && s.endsWith("/") ? s.slice(0, -1) : s || ""}/`;
    a = wv(a, n, "Bucket", ()=>n.Bucket, "{Bucket}", !1);
    const c = ro({
        session: [, ""]
    });
    let u;
    return new dr({
        protocol: i,
        hostname: t,
        port: r,
        method: "GET",
        headers: o,
        path: a,
        query: c,
        body: u
    })
}
  , xee = async(n,e)=>{
    const {hostname: t, protocol: i="https", port: r, path: s} = await e.endpoint()
      , o = ro({}, lp, {
        "if-match": n.IfMatch,
        "if-modified-since": [()=>lp(n.IfModifiedSince), ()=>P0(n.IfModifiedSince).toString()],
        "if-none-match": n.IfNoneMatch,
        "if-unmodified-since": [()=>lp(n.IfUnmodifiedSince), ()=>P0(n.IfUnmodifiedSince).toString()],
        range: n.Range,
        "x-amz-server-side-encryption-customer-algorithm": n.SSECustomerAlgorithm,
        "x-amz-server-side-encryption-customer-key": n.SSECustomerKey,
        "x-amz-server-side-encryption-customer-key-md5": n.SSECustomerKeyMD5,
        "x-amz-request-payer": n.RequestPayer,
        "x-amz-expected-bucket-owner": n.ExpectedBucketOwner,
        "x-amz-checksum-mode": n.ChecksumMode
    });
    let a = `${s != null && s.endsWith("/") ? s.slice(0, -1) : s || ""}/{Key+}`;
    a = wv(a, n, "Bucket", ()=>n.Bucket, "{Bucket}", !1),
    a = wv(a, n, "Key", ()=>n.Key, "{Key+}", !0);
    const c = ro({
        "x-id": [, "GetObject"],
        "response-cache-control": [, n.ResponseCacheControl],
        "response-content-disposition": [, n.ResponseContentDisposition],
        "response-content-encoding": [, n.ResponseContentEncoding],
        "response-content-language": [, n.ResponseContentLanguage],
        "response-content-type": [, n.ResponseContentType],
        "response-expires": [()=>n.ResponseExpires !== void 0, ()=>P0(n.ResponseExpires).toString()],
        versionId: [, n.VersionId],
        partNumber: [()=>n.PartNumber !== void 0, ()=>n.PartNumber.toString()]
    });
    let u;
    return new dr({
        protocol: i,
        hostname: t,
        port: r,
        method: "GET",
        headers: o,
        path: a,
        query: c,
        body: u
    })
}
  , bee = async(n,e)=>{
    if (n.statusCode !== 200 && n.statusCode >= 300)
        return See(n, e);
    const t = ro({
        $metadata: uh(n)
    })
      , i = Rf(iY(await $2(n.body, e)), "body");
    return i.Credentials !== void 0 && (t.Credentials = Cee(i.Credentials)),
    t
}
  , See = async(n,e)=>{
    const t = {
        ...n,
        body: await X2(n.body, e)
    }
      , i = q2(n, t.body);
    switch (i) {
    case "NoSuchBucket":
    case "com.amazonaws.s3#NoSuchBucket":
        throw await Mee(t);
    default:
        const r = t.body;
        return W2({
            output: n,
            parsedBody: r,
            errorCode: i
        })
    }
}
  , wee = async(n,e)=>{
    if (n.statusCode !== 200 && n.statusCode >= 300)
        return Eee(n, e);
    const t = ro({
        $metadata: uh(n),
        DeleteMarker: [()=>n.headers["x-amz-delete-marker"] !== void 0, ()=>OE(n.headers["x-amz-delete-marker"])],
        AcceptRanges: [, n.headers["accept-ranges"]],
        Expiration: [, n.headers["x-amz-expiration"]],
        Restore: [, n.headers["x-amz-restore"]],
        LastModified: [()=>n.headers["last-modified"] !== void 0, ()=>Rf(kE(n.headers["last-modified"]))],
        ContentLength: [()=>n.headers["content-length"] !== void 0, ()=>oY(n.headers["content-length"])],
        ETag: [, n.headers.etag],
        ChecksumCRC32: [, n.headers["x-amz-checksum-crc32"]],
        ChecksumCRC32C: [, n.headers["x-amz-checksum-crc32c"]],
        ChecksumSHA1: [, n.headers["x-amz-checksum-sha1"]],
        ChecksumSHA256: [, n.headers["x-amz-checksum-sha256"]],
        MissingMeta: [()=>n.headers["x-amz-missing-meta"] !== void 0, ()=>R0(n.headers["x-amz-missing-meta"])],
        VersionId: [, n.headers["x-amz-version-id"]],
        CacheControl: [, n.headers["cache-control"]],
        ContentDisposition: [, n.headers["content-disposition"]],
        ContentEncoding: [, n.headers["content-encoding"]],
        ContentLanguage: [, n.headers["content-language"]],
        ContentRange: [, n.headers["content-range"]],
        ContentType: [, n.headers["content-type"]],
        Expires: [()=>n.headers.expires !== void 0, ()=>Rf(kE(n.headers.expires))],
        WebsiteRedirectLocation: [, n.headers["x-amz-website-redirect-location"]],
        ServerSideEncryption: [, n.headers["x-amz-server-side-encryption"]],
        SSECustomerAlgorithm: [, n.headers["x-amz-server-side-encryption-customer-algorithm"]],
        SSECustomerKeyMD5: [, n.headers["x-amz-server-side-encryption-customer-key-md5"]],
        SSEKMSKeyId: [, n.headers["x-amz-server-side-encryption-aws-kms-key-id"]],
        BucketKeyEnabled: [()=>n.headers["x-amz-server-side-encryption-bucket-key-enabled"] !== void 0, ()=>OE(n.headers["x-amz-server-side-encryption-bucket-key-enabled"])],
        StorageClass: [, n.headers["x-amz-storage-class"]],
        RequestCharged: [, n.headers["x-amz-request-charged"]],
        ReplicationStatus: [, n.headers["x-amz-replication-status"]],
        PartsCount: [()=>n.headers["x-amz-mp-parts-count"] !== void 0, ()=>R0(n.headers["x-amz-mp-parts-count"])],
        TagCount: [()=>n.headers["x-amz-tagging-count"] !== void 0, ()=>R0(n.headers["x-amz-tagging-count"])],
        ObjectLockMode: [, n.headers["x-amz-object-lock-mode"]],
        ObjectLockRetainUntilDate: [()=>n.headers["x-amz-object-lock-retain-until-date"] !== void 0, ()=>Rf(r2(n.headers["x-amz-object-lock-retain-until-date"]))],
        ObjectLockLegalHoldStatus: [, n.headers["x-amz-object-lock-legal-hold"]],
        Metadata: [, Object.keys(n.headers).filter(r=>r.startsWith("x-amz-meta-")).reduce((r,s)=>(r[s.substring(11)] = n.headers[s],
        r), {})]
    })
      , i = n.body;
    return e.sdkStreamMixin(i),
    t.Body = i,
    t
}
  , Eee = async(n,e)=>{
    const t = {
        ...n,
        body: await X2(n.body, e)
    }
      , i = q2(n, t.body);
    switch (i) {
    case "InvalidObjectState":
    case "com.amazonaws.s3#InvalidObjectState":
        throw await Aee(t);
    case "NoSuchKey":
    case "com.amazonaws.s3#NoSuchKey":
        throw await Tee(t);
    default:
        const r = t.body;
        return W2({
            output: n,
            parsedBody: r,
            errorCode: i
        })
    }
}
  , W2 = SY(lu)
  , Aee = async(n,e)=>{
    const t = ro({})
      , i = n.body;
    i.AccessTier !== void 0 && (t.AccessTier = Pf(i.AccessTier)),
    i.StorageClass !== void 0 && (t.StorageClass = Pf(i.StorageClass));
    const r = new tx({
        $metadata: uh(n),
        ...t
    });
    return dm(r, n.body)
}
  , Mee = async(n,e)=>{
    const t = ro({});
    n.body;
    const i = new ex({
        $metadata: uh(n),
        ...t
    });
    return dm(i, n.body)
}
  , Tee = async(n,e)=>{
    const t = ro({});
    n.body;
    const i = new nx({
        $metadata: uh(n),
        ...t
    });
    return dm(i, n.body)
}
  , Cee = (n,e)=>{
    const t = {};
    return n.AccessKeyId !== void 0 && (t.AccessKeyId = Pf(n.AccessKeyId)),
    n.SecretAccessKey !== void 0 && (t.SecretAccessKey = Pf(n.SecretAccessKey)),
    n.SessionToken !== void 0 && (t.SessionToken = Pf(n.SessionToken)),
    n.Expiration !== void 0 && (t.Expiration = Rf(r2(n.Expiration))),
    t
}
  , uh = n=>({
    httpStatusCode: n.statusCode,
    requestId: n.headers["x-amzn-requestid"] ?? n.headers["x-amzn-request-id"] ?? n.headers["x-amz-request-id"],
    extendedRequestId: n.headers["x-amz-id-2"],
    cfId: n.headers["x-amz-cf-id"]
})
  , Ree = (n,e)=>Qj(n, e).then(t=>e.utf8Encoder(t))
  , lp = n=>n != null && n !== "" && (!Object.getOwnPropertyNames(n).includes("length") || n.length != 0) && (!Object.getOwnPropertyNames(n).includes("size") || n.size != 0)
  , $2 = (n,e)=>Ree(n, e).then(t=>{
    if (t.length) {
        const i = new vee.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: !0,
            ignoreAttributes: !1,
            ignoreDeclaration: !0,
            parseTagValue: !1,
            trimValues: !1,
            tagValueProcessor: (c,u)=>u.trim() === "" && u.includes(`
`) ? "" : void 0
        });
        i.addEntity("#xD", "\r"),
        i.addEntity("#10", `
`);
        const r = i.parse(t)
          , s = "#text"
          , o = Object.keys(r)[0]
          , a = r[o];
        return a[s] && (a[o] = a[s],
        delete a[s]),
        s2(a)
    }
    return {}
}
)
  , X2 = async(n,e)=>{
    const t = await $2(n, e);
    return t.Error && (t.Error.message = t.Error.message ?? t.Error.Message),
    t
}
  , q2 = (n,e)=>{
    if ((e == null ? void 0 : e.Code) !== void 0)
        return e.Code;
    if (n.statusCode == 404)
        return "NotFound"
}
;
class ax extends t2 {
    static getEndpointParameterInstructions() {
        return {
            DisableS3ExpressSessionAuth: {
                type: "staticContextParams",
                value: !0
            },
            Bucket: {
                type: "contextParams",
                name: "Bucket"
            },
            ForcePathStyle: {
                type: "clientContextParams",
                name: "forcePathStyle"
            },
            UseArnRegion: {
                type: "clientContextParams",
                name: "useArnRegion"
            },
            DisableMultiRegionAccessPoints: {
                type: "clientContextParams",
                name: "disableMultiregionAccessPoints"
            },
            Accelerate: {
                type: "clientContextParams",
                name: "useAccelerateEndpoint"
            },
            UseGlobalEndpoint: {
                type: "builtInParams",
                name: "useGlobalEndpoint"
            },
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        }
    }
    constructor(e) {
        super(),
        this.input = e
    }
    resolveMiddleware(e, t, i) {
        this.middlewareStack.use(I2(t, this.serialize, this.deserialize)),
        this.middlewareStack.use(O2(t, ax.getEndpointParameterInstructions()));
        const r = e.concat(this.middlewareStack)
          , {logger: s} = t
          , c = {
            logger: s,
            clientName: "S3Client",
            commandName: "CreateSessionCommand",
            inputFilterSensitiveLog: h=>h,
            outputFilterSensitiveLog: tQ,
            [Ip]: {
                service: "AmazonS3",
                operation: "CreateSession"
            }
        }
          , {requestHandler: u} = t;
        return r.resolve(h=>u.handle(h.request, i || {}), c)
    }
    serialize(e, t) {
        return yee(e, t)
    }
    deserialize(e, t) {
        return bee(e, t)
    }
}
const Pee = n=>({
    ...n,
    useFipsEndpoint: n.useFipsEndpoint ?? !1,
    useDualstackEndpoint: n.useDualstackEndpoint ?? !1,
    forcePathStyle: n.forcePathStyle ?? !1,
    useAccelerateEndpoint: n.useAccelerateEndpoint ?? !1,
    useGlobalEndpoint: n.useGlobalEndpoint ?? !1,
    disableMultiregionAccessPoints: n.disableMultiregionAccessPoints ?? !1,
    defaultSigningName: "s3"
})
  , Lee = "@aws-sdk/client-s3"
  , Dee = "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native"
  , Iee = "3.468.0"
  , Oee = {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
    test: "yarn test:unit",
    "test:e2e": "yarn test:e2e:node && yarn test:e2e:browser",
    "test:e2e:browser": "ts-mocha test/**/*.browser.ispec.ts && karma start karma.conf.js",
    "test:e2e:node": "jest --c jest.config.e2e.js",
    "test:unit": "ts-mocha test/unit/**/*.spec.ts"
}
  , Nee = "./dist-cjs/index.js"
  , Uee = "./dist-types/index.d.ts"
  , Fee = "./dist-es/index.js"
  , Bee = !1
  , kee = {
    "@aws-crypto/sha1-browser": "3.0.0",
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/client-sts": "3.468.0",
    "@aws-sdk/core": "3.468.0",
    "@aws-sdk/credential-provider-node": "3.468.0",
    "@aws-sdk/middleware-bucket-endpoint": "3.468.0",
    "@aws-sdk/middleware-expect-continue": "3.468.0",
    "@aws-sdk/middleware-flexible-checksums": "3.468.0",
    "@aws-sdk/middleware-host-header": "3.468.0",
    "@aws-sdk/middleware-location-constraint": "3.468.0",
    "@aws-sdk/middleware-logger": "3.468.0",
    "@aws-sdk/middleware-recursion-detection": "3.468.0",
    "@aws-sdk/middleware-sdk-s3": "3.468.0",
    "@aws-sdk/middleware-signing": "3.468.0",
    "@aws-sdk/middleware-ssec": "3.468.0",
    "@aws-sdk/middleware-user-agent": "3.468.0",
    "@aws-sdk/region-config-resolver": "3.468.0",
    "@aws-sdk/signature-v4-multi-region": "3.468.0",
    "@aws-sdk/types": "3.468.0",
    "@aws-sdk/util-endpoints": "3.468.0",
    "@aws-sdk/util-user-agent-browser": "3.468.0",
    "@aws-sdk/util-user-agent-node": "3.468.0",
    "@aws-sdk/xml-builder": "3.465.0",
    "@smithy/config-resolver": "^2.0.20",
    "@smithy/eventstream-serde-browser": "^2.0.15",
    "@smithy/eventstream-serde-config-resolver": "^2.0.15",
    "@smithy/eventstream-serde-node": "^2.0.15",
    "@smithy/fetch-http-handler": "^2.3.1",
    "@smithy/hash-blob-browser": "^2.0.16",
    "@smithy/hash-node": "^2.0.17",
    "@smithy/hash-stream-node": "^2.0.17",
    "@smithy/invalid-dependency": "^2.0.15",
    "@smithy/md5-js": "^2.0.17",
    "@smithy/middleware-content-length": "^2.0.17",
    "@smithy/middleware-endpoint": "^2.2.2",
    "@smithy/middleware-retry": "^2.0.23",
    "@smithy/middleware-serde": "^2.0.15",
    "@smithy/middleware-stack": "^2.0.9",
    "@smithy/node-config-provider": "^2.1.7",
    "@smithy/node-http-handler": "^2.2.1",
    "@smithy/protocol-http": "^3.0.11",
    "@smithy/smithy-client": "^2.1.18",
    "@smithy/types": "^2.7.0",
    "@smithy/url-parser": "^2.0.15",
    "@smithy/util-base64": "^2.0.1",
    "@smithy/util-body-length-browser": "^2.0.1",
    "@smithy/util-body-length-node": "^2.1.0",
    "@smithy/util-defaults-mode-browser": "^2.0.22",
    "@smithy/util-defaults-mode-node": "^2.0.28",
    "@smithy/util-endpoints": "^1.0.6",
    "@smithy/util-retry": "^2.0.8",
    "@smithy/util-stream": "^2.0.23",
    "@smithy/util-utf8": "^2.0.2",
    "@smithy/util-waiter": "^2.0.15",
    "fast-xml-parser": "4.2.5",
    tslib: "^2.5.0"
}
  , zee = {
    "@smithy/service-client-documentation-generator": "^2.0.0",
    "@tsconfig/node14": "1.0.3",
    "@types/chai": "^4.2.11",
    "@types/mocha": "^8.0.4",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typescript: "~4.9.5"
}
  , Hee = {
    node: ">=14.0.0"
}
  , Gee = {
    "<4.0": {
        "dist-types/*": ["dist-types/ts3.4/*"]
    }
}
  , Vee = ["dist-*/**"]
  , Wee = {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
}
  , $ee = "Apache-2.0"
  , Xee = {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
}
  , qee = "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3"
  , jee = {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-s3"
}
  , Yee = {
    name: Lee,
    description: Dee,
    version: Iee,
    scripts: Oee,
    main: Nee,
    types: Uee,
    module: Fee,
    sideEffects: Bee,
    dependencies: kee,
    devDependencies: zee,
    engines: Hee,
    typesVersions: Gee,
    files: Vee,
    author: Wee,
    license: $ee,
    browser: Xee,
    "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: qee,
    repository: jee
};
var j2 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Nv = function(n, e) {
    return Nv = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(t, i) {
        t.__proto__ = i
    }
    || function(t, i) {
        for (var r in i)
            i.hasOwnProperty(r) && (t[r] = i[r])
    }
    ,
    Nv(n, e)
};
function Kee(n, e) {
    Nv(n, e);
    function t() {
        this.constructor = n
    }
    n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype,
    new t)
}
var Uv = function() {
    return Uv = Object.assign || function(e) {
        for (var t, i = 1, r = arguments.length; i < r; i++) {
            t = arguments[i];
            for (var s in t)
                Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s])
        }
        return e
    }
    ,
    Uv.apply(this, arguments)
};
function Zee(n, e) {
    var t = {};
    for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
            e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
    return t
}
function Jee(n, e, t, i) {
    var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        s = Reflect.decorate(n, e, t, i);
    else
        for (var a = n.length - 1; a >= 0; a--)
            (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
    return r > 3 && s && Object.defineProperty(e, t, s),
    s
}
function Qee(n, e) {
    return function(t, i) {
        e(t, i, n)
    }
}
function ete(n, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(n, e)
}
function tte(n, e, t, i) {
    function r(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(h) {
            try {
                u(i.next(h))
            } catch (m) {
                o(m)
            }
        }
        function c(h) {
            try {
                u(i.throw(h))
            } catch (m) {
                o(m)
            }
        }
        function u(h) {
            h.done ? s(h.value) : r(h.value).then(a, c)
        }
        u((i = i.apply(n, e || [])).next())
    }
    )
}
function nte(n, e) {
    var t = {
        label: 0,
        sent: function() {
            if (s[0] & 1)
                throw s[1];
            return s[1]
        },
        trys: [],
        ops: []
    }, i, r, s, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    },
    typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }
    ),
    o;
    function a(u) {
        return function(h) {
            return c([u, h])
        }
    }
    function c(u) {
        if (i)
            throw new TypeError("Generator is already executing.");
        for (; t; )
            try {
                if (i = 1,
                r && (s = u[0] & 2 ? r.return : u[0] ? r.throw || ((s = r.return) && s.call(r),
                0) : r.next) && !(s = s.call(r, u[1])).done)
                    return s;
                switch (r = 0,
                s && (u = [u[0] & 2, s.value]),
                u[0]) {
                case 0:
                case 1:
                    s = u;
                    break;
                case 4:
                    return t.label++,
                    {
                        value: u[1],
                        done: !1
                    };
                case 5:
                    t.label++,
                    r = u[1],
                    u = [0];
                    continue;
                case 7:
                    u = t.ops.pop(),
                    t.trys.pop();
                    continue;
                default:
                    if (s = t.trys,
                    !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
                        t = 0;
                        continue
                    }
                    if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
                        t.label = u[1];
                        break
                    }
                    if (u[0] === 6 && t.label < s[1]) {
                        t.label = s[1],
                        s = u;
                        break
                    }
                    if (s && t.label < s[2]) {
                        t.label = s[2],
                        t.ops.push(u);
                        break
                    }
                    s[2] && t.ops.pop(),
                    t.trys.pop();
                    continue
                }
                u = e.call(n, t)
            } catch (h) {
                u = [6, h],
                r = 0
            } finally {
                i = s = 0
            }
        if (u[0] & 5)
            throw u[1];
        return {
            value: u[0] ? u[1] : void 0,
            done: !0
        }
    }
}
function ite(n, e, t, i) {
    i === void 0 && (i = t),
    n[i] = e[t]
}
function rte(n, e) {
    for (var t in n)
        t !== "default" && !e.hasOwnProperty(t) && (e[t] = n[t])
}
function Fv(n) {
    var e = typeof Symbol == "function" && Symbol.iterator
      , t = e && n[e]
      , i = 0;
    if (t)
        return t.call(n);
    if (n && typeof n.length == "number")
        return {
            next: function() {
                return n && i >= n.length && (n = void 0),
                {
                    value: n && n[i++],
                    done: !n
                }
            }
        };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function Y2(n, e) {
    var t = typeof Symbol == "function" && n[Symbol.iterator];
    if (!t)
        return n;
    var i = t.call(n), r, s = [], o;
    try {
        for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
            s.push(r.value)
    } catch (a) {
        o = {
            error: a
        }
    } finally {
        try {
            r && !r.done && (t = i.return) && t.call(i)
        } finally {
            if (o)
                throw o.error
        }
    }
    return s
}
function ste() {
    for (var n = [], e = 0; e < arguments.length; e++)
        n = n.concat(Y2(arguments[e]));
    return n
}
function ote() {
    for (var n = 0, e = 0, t = arguments.length; e < t; e++)
        n += arguments[e].length;
    for (var i = Array(n), r = 0, e = 0; e < t; e++)
        for (var s = arguments[e], o = 0, a = s.length; o < a; o++,
        r++)
            i[r] = s[o];
    return i
}
function Yf(n) {
    return this instanceof Yf ? (this.v = n,
    this) : new Yf(n)
}
function ate(n, e, t) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var i = t.apply(n, e || []), r, s = [];
    return r = {},
    o("next"),
    o("throw"),
    o("return"),
    r[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    r;
    function o(d) {
        i[d] && (r[d] = function(f) {
            return new Promise(function(_, g) {
                s.push([d, f, _, g]) > 1 || a(d, f)
            }
            )
        }
        )
    }
    function a(d, f) {
        try {
            c(i[d](f))
        } catch (_) {
            m(s[0][3], _)
        }
    }
    function c(d) {
        d.value instanceof Yf ? Promise.resolve(d.value.v).then(u, h) : m(s[0][2], d)
    }
    function u(d) {
        a("next", d)
    }
    function h(d) {
        a("throw", d)
    }
    function m(d, f) {
        d(f),
        s.shift(),
        s.length && a(s[0][0], s[0][1])
    }
}
function lte(n) {
    var e, t;
    return e = {},
    i("next"),
    i("throw", function(r) {
        throw r
    }),
    i("return"),
    e[Symbol.iterator] = function() {
        return this
    }
    ,
    e;
    function i(r, s) {
        e[r] = n[r] ? function(o) {
            return (t = !t) ? {
                value: Yf(n[r](o)),
                done: r === "return"
            } : s ? s(o) : o
        }
        : s
    }
}
function cte(n) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = n[Symbol.asyncIterator], t;
    return e ? e.call(n) : (n = typeof Fv == "function" ? Fv(n) : n[Symbol.iterator](),
    t = {},
    i("next"),
    i("throw"),
    i("return"),
    t[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    t);
    function i(s) {
        t[s] = n[s] && function(o) {
            return new Promise(function(a, c) {
                o = n[s](o),
                r(a, c, o.done, o.value)
            }
            )
        }
    }
    function r(s, o, a, c) {
        Promise.resolve(c).then(function(u) {
            s({
                value: u,
                done: a
            })
        }, o)
    }
}
function ute(n, e) {
    return Object.defineProperty ? Object.defineProperty(n, "raw", {
        value: e
    }) : n.raw = e,
    n
}
function fte(n) {
    if (n && n.__esModule)
        return n;
    var e = {};
    if (n != null)
        for (var t in n)
            Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
    return e.default = n,
    e
}
function hte(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function dte(n, e) {
    if (!e.has(n))
        throw new TypeError("attempted to get private field on non-instance");
    return e.get(n)
}
function pte(n, e, t) {
    if (!e.has(n))
        throw new TypeError("attempted to set private field on non-instance");
    return e.set(n, t),
    t
}
const mte = Object.freeze(Object.defineProperty({
    __proto__: null,
    get __assign() {
        return Uv
    },
    __asyncDelegator: lte,
    __asyncGenerator: ate,
    __asyncValues: cte,
    __await: Yf,
    __awaiter: tte,
    __classPrivateFieldGet: dte,
    __classPrivateFieldSet: pte,
    __createBinding: ite,
    __decorate: Jee,
    __exportStar: rte,
    __extends: Kee,
    __generator: nte,
    __importDefault: hte,
    __importStar: fte,
    __makeTemplateObject: ute,
    __metadata: ete,
    __param: Qee,
    __read: Y2,
    __rest: Zee,
    __spread: ste,
    __spreadArrays: ote,
    __values: Fv
}, Symbol.toStringTag, {
    value: "Module"
}))
  , gte = Fo(mte);
var $u = {}, Xu = {}, qu = {}, SA;
function K2() {
    if (SA)
        return qu;
    SA = 1,
    Object.defineProperty(qu, "__esModule", {
        value: !0
    }),
    qu.isEmptyData = void 0;
    function n(e) {
        return typeof e == "string" ? e.length === 0 : e.byteLength === 0
    }
    return qu.isEmptyData = n,
    qu
}
var W0 = {}, wA;
function Z2() {
    return wA || (wA = 1,
    function(n) {
        Object.defineProperty(n, "__esModule", {
            value: !0
        }),
        n.EMPTY_DATA_SHA_1 = n.SHA_1_HMAC_ALGO = n.SHA_1_HASH = void 0,
        n.SHA_1_HASH = {
            name: "SHA-1"
        },
        n.SHA_1_HMAC_ALGO = {
            name: "HMAC",
            hash: n.SHA_1_HASH
        },
        n.EMPTY_DATA_SHA_1 = new Uint8Array([218, 57, 163, 238, 94, 107, 75, 13, 50, 85, 191, 239, 149, 96, 24, 144, 175, 216, 7, 9])
    }(W0)),
    W0
}
const _te = {};
function vte() {
    return typeof window < "u" ? window : typeof self < "u" ? self : _te
}
const yte = Object.freeze(Object.defineProperty({
    __proto__: null,
    locateWindow: vte
}, Symbol.toStringTag, {
    value: "Module"
}))
  , cu = Fo(yte);
var EA;
function J2() {
    if (EA)
        return Xu;
    EA = 1,
    Object.defineProperty(Xu, "__esModule", {
        value: !0
    }),
    Xu.Sha1 = void 0;
    var n = K2()
      , e = Z2()
      , t = gm
      , i = cu
      , r = function() {
        function a(c) {
            this.secret = c,
            this.reset()
        }
        return a.prototype.update = function(c) {
            var u = this;
            (0,
            n.isEmptyData)(c) || (this.operation = this.operation.then(function(h) {
                return h.onerror = function() {
                    u.operation = Promise.reject(new Error("Error encountered updating hash"))
                }
                ,
                h.process(o(c)),
                h
            }),
            this.operation.catch(function() {}))
        }
        ,
        a.prototype.digest = function() {
            return this.operation.then(function(c) {
                return new Promise(function(u, h) {
                    c.onerror = function() {
                        h(new Error("Error encountered finalizing hash"))
                    }
                    ,
                    c.oncomplete = function() {
                        c.result && u(new Uint8Array(c.result)),
                        h(new Error("Error encountered finalizing hash"))
                    }
                    ,
                    c.finish()
                }
                )
            })
        }
        ,
        a.prototype.reset = function() {
            this.secret ? (this.operation = s(this.secret).then(function(c) {
                return (0,
                i.locateWindow)().msCrypto.subtle.sign(e.SHA_1_HMAC_ALGO, c)
            }),
            this.operation.catch(function() {})) : this.operation = Promise.resolve((0,
            i.locateWindow)().msCrypto.subtle.digest("SHA-1"))
        }
        ,
        a
    }();
    Xu.Sha1 = r;
    function s(a) {
        return new Promise(function(c, u) {
            var h = (0,
            i.locateWindow)().msCrypto.subtle.importKey("raw", o(a), e.SHA_1_HMAC_ALGO, !1, ["sign"]);
            h.oncomplete = function() {
                h.result && c(h.result),
                u(new Error("ImportKey completed without importing key."))
            }
            ,
            h.onerror = function() {
                u(new Error("ImportKey failed to import key."))
            }
        }
        )
    }
    function o(a) {
        return typeof a == "string" ? (0,
        t.fromUtf8)(a) : ArrayBuffer.isView(a) ? new Uint8Array(a.buffer,a.byteOffset,a.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(a)
    }
    return Xu
}
var ju = {}, AA;
function Q2() {
    if (AA)
        return ju;
    AA = 1,
    Object.defineProperty(ju, "__esModule", {
        value: !0
    }),
    ju.Sha1 = void 0;
    var n = gm
      , e = K2()
      , t = Z2()
      , i = cu
      , r = function() {
        function o(a) {
            this.toHash = new Uint8Array(0),
            a !== void 0 && (this.key = new Promise(function(c, u) {
                (0,
                i.locateWindow)().crypto.subtle.importKey("raw", s(a), t.SHA_1_HMAC_ALGO, !1, ["sign"]).then(c, u)
            }
            ),
            this.key.catch(function() {}))
        }
        return o.prototype.update = function(a) {
            if (!(0,
            e.isEmptyData)(a)) {
                var c = s(a)
                  , u = new Uint8Array(this.toHash.byteLength + c.byteLength);
                u.set(this.toHash, 0),
                u.set(c, this.toHash.byteLength),
                this.toHash = u
            }
        }
        ,
        o.prototype.digest = function() {
            var a = this;
            return this.key ? this.key.then(function(c) {
                return (0,
                i.locateWindow)().crypto.subtle.sign(t.SHA_1_HMAC_ALGO, c, a.toHash).then(function(u) {
                    return new Uint8Array(u)
                })
            }) : (0,
            e.isEmptyData)(this.toHash) ? Promise.resolve(t.EMPTY_DATA_SHA_1) : Promise.resolve().then(function() {
                return (0,
                i.locateWindow)().crypto.subtle.digest(t.SHA_1_HASH, a.toHash)
            }).then(function(c) {
                return Promise.resolve(new Uint8Array(c))
            })
        }
        ,
        o.prototype.reset = function() {
            this.toHash = new Uint8Array(0)
        }
        ,
        o
    }();
    ju.Sha1 = r;
    function s(o) {
        return typeof o == "string" ? (0,
        n.fromUtf8)(o) : ArrayBuffer.isView(o) ? new Uint8Array(o.buffer,o.byteOffset,o.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(o)
    }
    return ju
}
var $0 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Bv = function(n, e) {
    return Bv = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(t, i) {
        t.__proto__ = i
    }
    || function(t, i) {
        for (var r in i)
            i.hasOwnProperty(r) && (t[r] = i[r])
    }
    ,
    Bv(n, e)
};
function xte(n, e) {
    Bv(n, e);
    function t() {
        this.constructor = n
    }
    n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype,
    new t)
}
var kv = function() {
    return kv = Object.assign || function(e) {
        for (var t, i = 1, r = arguments.length; i < r; i++) {
            t = arguments[i];
            for (var s in t)
                Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s])
        }
        return e
    }
    ,
    kv.apply(this, arguments)
};
function bte(n, e) {
    var t = {};
    for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
            e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
    return t
}
function Ste(n, e, t, i) {
    var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        s = Reflect.decorate(n, e, t, i);
    else
        for (var a = n.length - 1; a >= 0; a--)
            (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
    return r > 3 && s && Object.defineProperty(e, t, s),
    s
}
function wte(n, e) {
    return function(t, i) {
        e(t, i, n)
    }
}
function Ete(n, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(n, e)
}
function Ate(n, e, t, i) {
    function r(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(h) {
            try {
                u(i.next(h))
            } catch (m) {
                o(m)
            }
        }
        function c(h) {
            try {
                u(i.throw(h))
            } catch (m) {
                o(m)
            }
        }
        function u(h) {
            h.done ? s(h.value) : r(h.value).then(a, c)
        }
        u((i = i.apply(n, e || [])).next())
    }
    )
}
function Mte(n, e) {
    var t = {
        label: 0,
        sent: function() {
            if (s[0] & 1)
                throw s[1];
            return s[1]
        },
        trys: [],
        ops: []
    }, i, r, s, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    },
    typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }
    ),
    o;
    function a(u) {
        return function(h) {
            return c([u, h])
        }
    }
    function c(u) {
        if (i)
            throw new TypeError("Generator is already executing.");
        for (; t; )
            try {
                if (i = 1,
                r && (s = u[0] & 2 ? r.return : u[0] ? r.throw || ((s = r.return) && s.call(r),
                0) : r.next) && !(s = s.call(r, u[1])).done)
                    return s;
                switch (r = 0,
                s && (u = [u[0] & 2, s.value]),
                u[0]) {
                case 0:
                case 1:
                    s = u;
                    break;
                case 4:
                    return t.label++,
                    {
                        value: u[1],
                        done: !1
                    };
                case 5:
                    t.label++,
                    r = u[1],
                    u = [0];
                    continue;
                case 7:
                    u = t.ops.pop(),
                    t.trys.pop();
                    continue;
                default:
                    if (s = t.trys,
                    !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
                        t = 0;
                        continue
                    }
                    if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
                        t.label = u[1];
                        break
                    }
                    if (u[0] === 6 && t.label < s[1]) {
                        t.label = s[1],
                        s = u;
                        break
                    }
                    if (s && t.label < s[2]) {
                        t.label = s[2],
                        t.ops.push(u);
                        break
                    }
                    s[2] && t.ops.pop(),
                    t.trys.pop();
                    continue
                }
                u = e.call(n, t)
            } catch (h) {
                u = [6, h],
                r = 0
            } finally {
                i = s = 0
            }
        if (u[0] & 5)
            throw u[1];
        return {
            value: u[0] ? u[1] : void 0,
            done: !0
        }
    }
}
function Tte(n, e, t, i) {
    i === void 0 && (i = t),
    n[i] = e[t]
}
function Cte(n, e) {
    for (var t in n)
        t !== "default" && !e.hasOwnProperty(t) && (e[t] = n[t])
}
function zv(n) {
    var e = typeof Symbol == "function" && Symbol.iterator
      , t = e && n[e]
      , i = 0;
    if (t)
        return t.call(n);
    if (n && typeof n.length == "number")
        return {
            next: function() {
                return n && i >= n.length && (n = void 0),
                {
                    value: n && n[i++],
                    done: !n
                }
            }
        };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function eP(n, e) {
    var t = typeof Symbol == "function" && n[Symbol.iterator];
    if (!t)
        return n;
    var i = t.call(n), r, s = [], o;
    try {
        for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
            s.push(r.value)
    } catch (a) {
        o = {
            error: a
        }
    } finally {
        try {
            r && !r.done && (t = i.return) && t.call(i)
        } finally {
            if (o)
                throw o.error
        }
    }
    return s
}
function Rte() {
    for (var n = [], e = 0; e < arguments.length; e++)
        n = n.concat(eP(arguments[e]));
    return n
}
function Pte() {
    for (var n = 0, e = 0, t = arguments.length; e < t; e++)
        n += arguments[e].length;
    for (var i = Array(n), r = 0, e = 0; e < t; e++)
        for (var s = arguments[e], o = 0, a = s.length; o < a; o++,
        r++)
            i[r] = s[o];
    return i
}
function Kf(n) {
    return this instanceof Kf ? (this.v = n,
    this) : new Kf(n)
}
function Lte(n, e, t) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var i = t.apply(n, e || []), r, s = [];
    return r = {},
    o("next"),
    o("throw"),
    o("return"),
    r[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    r;
    function o(d) {
        i[d] && (r[d] = function(f) {
            return new Promise(function(_, g) {
                s.push([d, f, _, g]) > 1 || a(d, f)
            }
            )
        }
        )
    }
    function a(d, f) {
        try {
            c(i[d](f))
        } catch (_) {
            m(s[0][3], _)
        }
    }
    function c(d) {
        d.value instanceof Kf ? Promise.resolve(d.value.v).then(u, h) : m(s[0][2], d)
    }
    function u(d) {
        a("next", d)
    }
    function h(d) {
        a("throw", d)
    }
    function m(d, f) {
        d(f),
        s.shift(),
        s.length && a(s[0][0], s[0][1])
    }
}
function Dte(n) {
    var e, t;
    return e = {},
    i("next"),
    i("throw", function(r) {
        throw r
    }),
    i("return"),
    e[Symbol.iterator] = function() {
        return this
    }
    ,
    e;
    function i(r, s) {
        e[r] = n[r] ? function(o) {
            return (t = !t) ? {
                value: Kf(n[r](o)),
                done: r === "return"
            } : s ? s(o) : o
        }
        : s
    }
}
function Ite(n) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = n[Symbol.asyncIterator], t;
    return e ? e.call(n) : (n = typeof zv == "function" ? zv(n) : n[Symbol.iterator](),
    t = {},
    i("next"),
    i("throw"),
    i("return"),
    t[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    t);
    function i(s) {
        t[s] = n[s] && function(o) {
            return new Promise(function(a, c) {
                o = n[s](o),
                r(a, c, o.done, o.value)
            }
            )
        }
    }
    function r(s, o, a, c) {
        Promise.resolve(c).then(function(u) {
            s({
                value: u,
                done: a
            })
        }, o)
    }
}
function Ote(n, e) {
    return Object.defineProperty ? Object.defineProperty(n, "raw", {
        value: e
    }) : n.raw = e,
    n
}
function Nte(n) {
    if (n && n.__esModule)
        return n;
    var e = {};
    if (n != null)
        for (var t in n)
            Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
    return e.default = n,
    e
}
function Ute(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function Fte(n, e) {
    if (!e.has(n))
        throw new TypeError("attempted to get private field on non-instance");
    return e.get(n)
}
function Bte(n, e, t) {
    if (!e.has(n))
        throw new TypeError("attempted to set private field on non-instance");
    return e.set(n, t),
    t
}
const kte = Object.freeze(Object.defineProperty({
    __proto__: null,
    get __assign() {
        return kv
    },
    __asyncDelegator: Dte,
    __asyncGenerator: Lte,
    __asyncValues: Ite,
    __await: Kf,
    __awaiter: Ate,
    __classPrivateFieldGet: Fte,
    __classPrivateFieldSet: Bte,
    __createBinding: Tte,
    __decorate: Ste,
    __exportStar: Cte,
    __extends: xte,
    __generator: Mte,
    __importDefault: Ute,
    __importStar: Nte,
    __makeTemplateObject: Ote,
    __metadata: Ete,
    __param: wte,
    __read: eP,
    __rest: bte,
    __spread: Rte,
    __spreadArrays: Pte,
    __values: zv
}, Symbol.toStringTag, {
    value: "Module"
}))
  , tP = Fo(kte);
var Cs = {}, MA;
function zte() {
    if (MA)
        return Cs;
    MA = 1,
    Object.defineProperty(Cs, "__esModule", {
        value: !0
    }),
    Cs.supportsZeroByteGCM = Cs.supportsSubtleCrypto = Cs.supportsSecureRandom = Cs.supportsWebCrypto = void 0;
    var n = tP
      , e = ["decrypt", "digest", "encrypt", "exportKey", "generateKey", "importKey", "sign", "verify"];
    function t(o) {
        if (i(o) && typeof o.crypto.subtle == "object") {
            var a = o.crypto.subtle;
            return r(a)
        }
        return !1
    }
    Cs.supportsWebCrypto = t;
    function i(o) {
        if (typeof o == "object" && typeof o.crypto == "object") {
            var a = o.crypto.getRandomValues;
            return typeof a == "function"
        }
        return !1
    }
    Cs.supportsSecureRandom = i;
    function r(o) {
        return o && e.every(function(a) {
            return typeof o[a] == "function"
        })
    }
    Cs.supportsSubtleCrypto = r;
    function s(o) {
        return n.__awaiter(this, void 0, void 0, function() {
            var a, c;
            return n.__generator(this, function(u) {
                switch (u.label) {
                case 0:
                    if (!r(o))
                        return [2, !1];
                    u.label = 1;
                case 1:
                    return u.trys.push([1, 4, , 5]),
                    [4, o.generateKey({
                        name: "AES-GCM",
                        length: 128
                    }, !1, ["encrypt"])];
                case 2:
                    return a = u.sent(),
                    [4, o.encrypt({
                        name: "AES-GCM",
                        iv: new Uint8Array(Array(12)),
                        additionalData: new Uint8Array(Array(16)),
                        tagLength: 128
                    }, a, new Uint8Array(0))];
                case 3:
                    return c = u.sent(),
                    [2, c.byteLength === 16];
                case 4:
                    return u.sent(),
                    [2, !1];
                case 5:
                    return [2]
                }
            })
        })
    }
    return Cs.supportsZeroByteGCM = s,
    Cs
}
var TA;
function nP() {
    return TA || (TA = 1,
    function(n) {
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var e = tP;
        e.__exportStar(zte(), n)
    }($0)),
    $0
}
var X0 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Hv = function(n, e) {
    return Hv = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(t, i) {
        t.__proto__ = i
    }
    || function(t, i) {
        for (var r in i)
            i.hasOwnProperty(r) && (t[r] = i[r])
    }
    ,
    Hv(n, e)
};
function Hte(n, e) {
    Hv(n, e);
    function t() {
        this.constructor = n
    }
    n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype,
    new t)
}
var Gv = function() {
    return Gv = Object.assign || function(e) {
        for (var t, i = 1, r = arguments.length; i < r; i++) {
            t = arguments[i];
            for (var s in t)
                Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s])
        }
        return e
    }
    ,
    Gv.apply(this, arguments)
};
function Gte(n, e) {
    var t = {};
    for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
            e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
    return t
}
function Vte(n, e, t, i) {
    var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        s = Reflect.decorate(n, e, t, i);
    else
        for (var a = n.length - 1; a >= 0; a--)
            (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
    return r > 3 && s && Object.defineProperty(e, t, s),
    s
}
function Wte(n, e) {
    return function(t, i) {
        e(t, i, n)
    }
}
function $te(n, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(n, e)
}
function Xte(n, e, t, i) {
    function r(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(h) {
            try {
                u(i.next(h))
            } catch (m) {
                o(m)
            }
        }
        function c(h) {
            try {
                u(i.throw(h))
            } catch (m) {
                o(m)
            }
        }
        function u(h) {
            h.done ? s(h.value) : r(h.value).then(a, c)
        }
        u((i = i.apply(n, e || [])).next())
    }
    )
}
function qte(n, e) {
    var t = {
        label: 0,
        sent: function() {
            if (s[0] & 1)
                throw s[1];
            return s[1]
        },
        trys: [],
        ops: []
    }, i, r, s, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    },
    typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }
    ),
    o;
    function a(u) {
        return function(h) {
            return c([u, h])
        }
    }
    function c(u) {
        if (i)
            throw new TypeError("Generator is already executing.");
        for (; t; )
            try {
                if (i = 1,
                r && (s = u[0] & 2 ? r.return : u[0] ? r.throw || ((s = r.return) && s.call(r),
                0) : r.next) && !(s = s.call(r, u[1])).done)
                    return s;
                switch (r = 0,
                s && (u = [u[0] & 2, s.value]),
                u[0]) {
                case 0:
                case 1:
                    s = u;
                    break;
                case 4:
                    return t.label++,
                    {
                        value: u[1],
                        done: !1
                    };
                case 5:
                    t.label++,
                    r = u[1],
                    u = [0];
                    continue;
                case 7:
                    u = t.ops.pop(),
                    t.trys.pop();
                    continue;
                default:
                    if (s = t.trys,
                    !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
                        t = 0;
                        continue
                    }
                    if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
                        t.label = u[1];
                        break
                    }
                    if (u[0] === 6 && t.label < s[1]) {
                        t.label = s[1],
                        s = u;
                        break
                    }
                    if (s && t.label < s[2]) {
                        t.label = s[2],
                        t.ops.push(u);
                        break
                    }
                    s[2] && t.ops.pop(),
                    t.trys.pop();
                    continue
                }
                u = e.call(n, t)
            } catch (h) {
                u = [6, h],
                r = 0
            } finally {
                i = s = 0
            }
        if (u[0] & 5)
            throw u[1];
        return {
            value: u[0] ? u[1] : void 0,
            done: !0
        }
    }
}
function jte(n, e, t, i) {
    i === void 0 && (i = t),
    n[i] = e[t]
}
function Yte(n, e) {
    for (var t in n)
        t !== "default" && !e.hasOwnProperty(t) && (e[t] = n[t])
}
function Vv(n) {
    var e = typeof Symbol == "function" && Symbol.iterator
      , t = e && n[e]
      , i = 0;
    if (t)
        return t.call(n);
    if (n && typeof n.length == "number")
        return {
            next: function() {
                return n && i >= n.length && (n = void 0),
                {
                    value: n && n[i++],
                    done: !n
                }
            }
        };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function iP(n, e) {
    var t = typeof Symbol == "function" && n[Symbol.iterator];
    if (!t)
        return n;
    var i = t.call(n), r, s = [], o;
    try {
        for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
            s.push(r.value)
    } catch (a) {
        o = {
            error: a
        }
    } finally {
        try {
            r && !r.done && (t = i.return) && t.call(i)
        } finally {
            if (o)
                throw o.error
        }
    }
    return s
}
function Kte() {
    for (var n = [], e = 0; e < arguments.length; e++)
        n = n.concat(iP(arguments[e]));
    return n
}
function Zte() {
    for (var n = 0, e = 0, t = arguments.length; e < t; e++)
        n += arguments[e].length;
    for (var i = Array(n), r = 0, e = 0; e < t; e++)
        for (var s = arguments[e], o = 0, a = s.length; o < a; o++,
        r++)
            i[r] = s[o];
    return i
}
function Zf(n) {
    return this instanceof Zf ? (this.v = n,
    this) : new Zf(n)
}
function Jte(n, e, t) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var i = t.apply(n, e || []), r, s = [];
    return r = {},
    o("next"),
    o("throw"),
    o("return"),
    r[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    r;
    function o(d) {
        i[d] && (r[d] = function(f) {
            return new Promise(function(_, g) {
                s.push([d, f, _, g]) > 1 || a(d, f)
            }
            )
        }
        )
    }
    function a(d, f) {
        try {
            c(i[d](f))
        } catch (_) {
            m(s[0][3], _)
        }
    }
    function c(d) {
        d.value instanceof Zf ? Promise.resolve(d.value.v).then(u, h) : m(s[0][2], d)
    }
    function u(d) {
        a("next", d)
    }
    function h(d) {
        a("throw", d)
    }
    function m(d, f) {
        d(f),
        s.shift(),
        s.length && a(s[0][0], s[0][1])
    }
}
function Qte(n) {
    var e, t;
    return e = {},
    i("next"),
    i("throw", function(r) {
        throw r
    }),
    i("return"),
    e[Symbol.iterator] = function() {
        return this
    }
    ,
    e;
    function i(r, s) {
        e[r] = n[r] ? function(o) {
            return (t = !t) ? {
                value: Zf(n[r](o)),
                done: r === "return"
            } : s ? s(o) : o
        }
        : s
    }
}
function ene(n) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = n[Symbol.asyncIterator], t;
    return e ? e.call(n) : (n = typeof Vv == "function" ? Vv(n) : n[Symbol.iterator](),
    t = {},
    i("next"),
    i("throw"),
    i("return"),
    t[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    t);
    function i(s) {
        t[s] = n[s] && function(o) {
            return new Promise(function(a, c) {
                o = n[s](o),
                r(a, c, o.done, o.value)
            }
            )
        }
    }
    function r(s, o, a, c) {
        Promise.resolve(c).then(function(u) {
            s({
                value: u,
                done: a
            })
        }, o)
    }
}
function tne(n, e) {
    return Object.defineProperty ? Object.defineProperty(n, "raw", {
        value: e
    }) : n.raw = e,
    n
}
function nne(n) {
    if (n && n.__esModule)
        return n;
    var e = {};
    if (n != null)
        for (var t in n)
            Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
    return e.default = n,
    e
}
function ine(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function rne(n, e) {
    if (!e.has(n))
        throw new TypeError("attempted to get private field on non-instance");
    return e.get(n)
}
function sne(n, e, t) {
    if (!e.has(n))
        throw new TypeError("attempted to set private field on non-instance");
    return e.set(n, t),
    t
}
const one = Object.freeze(Object.defineProperty({
    __proto__: null,
    get __assign() {
        return Gv
    },
    __asyncDelegator: Qte,
    __asyncGenerator: Jte,
    __asyncValues: ene,
    __await: Zf,
    __awaiter: Xte,
    __classPrivateFieldGet: rne,
    __classPrivateFieldSet: sne,
    __createBinding: jte,
    __decorate: Vte,
    __exportStar: Yte,
    __extends: Hte,
    __generator: qte,
    __importDefault: ine,
    __importStar: nne,
    __makeTemplateObject: tne,
    __metadata: $te,
    __param: Wte,
    __read: iP,
    __rest: Gte,
    __spread: Kte,
    __spreadArrays: Zte,
    __values: Vv
}, Symbol.toStringTag, {
    value: "Module"
}))
  , ane = Fo(one);
var q0 = {}, CA;
function lne() {
    return CA || (CA = 1,
    Object.defineProperty(q0, "__esModule", {
        value: !0
    })),
    q0
}
var j0 = {}, RA;
function cne() {
    return RA || (RA = 1,
    Object.defineProperty(j0, "__esModule", {
        value: !0
    })),
    j0
}
var Y0 = {}, PA;
function une() {
    return PA || (PA = 1,
    Object.defineProperty(Y0, "__esModule", {
        value: !0
    })),
    Y0
}
var K0 = {}, LA;
function fne() {
    return LA || (LA = 1,
    Object.defineProperty(K0, "__esModule", {
        value: !0
    })),
    K0
}
var Yu = {}, DA;
function hne() {
    if (DA)
        return Yu;
    DA = 1,
    Object.defineProperty(Yu, "__esModule", {
        value: !0
    }),
    Yu.isMsWindow = void 0;
    var n = ["decrypt", "digest", "encrypt", "exportKey", "generateKey", "importKey", "sign", "verify"];
    function e(i) {
        return "MSInputMethodContext"in i && "msCrypto"in i
    }
    function t(i) {
        if (e(i) && i.msCrypto.subtle !== void 0) {
            var r = i.msCrypto
              , s = r.getRandomValues
              , o = r.subtle;
            return n.map(function(a) {
                return o[a]
            }).concat(s).every(function(a) {
                return typeof a == "function"
            })
        }
        return !1
    }
    return Yu.isMsWindow = t,
    Yu
}
var IA;
function rP() {
    return IA || (IA = 1,
    function(n) {
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var e = ane;
        e.__exportStar(lne(), n),
        e.__exportStar(cne(), n),
        e.__exportStar(une(), n),
        e.__exportStar(fne(), n),
        e.__exportStar(hne(), n)
    }(X0)),
    X0
}
var OA;
function dne() {
    if (OA)
        return $u;
    OA = 1,
    Object.defineProperty($u, "__esModule", {
        value: !0
    }),
    $u.Sha1 = void 0;
    var n = J2()
      , e = Q2()
      , t = nP()
      , i = rP()
      , r = cu
      , s = Da()
      , o = function() {
        function a(c) {
            if ((0,
            t.supportsWebCrypto)((0,
            r.locateWindow)()))
                this.hash = new e.Sha1(c);
            else if ((0,
            i.isMsWindow)((0,
            r.locateWindow)()))
                this.hash = new n.Sha1(c);
            else
                throw new Error("SHA1 not supported")
        }
        return a.prototype.update = function(c, u) {
            this.hash.update((0,
            s.convertToBuffer)(c))
        }
        ,
        a.prototype.digest = function() {
            return this.hash.digest()
        }
        ,
        a.prototype.reset = function() {
            this.hash.reset()
        }
        ,
        a
    }();
    return $u.Sha1 = o,
    $u
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.WebCryptoSha1 = n.Ie11Sha1 = void 0;
    var e = gte;
    e.__exportStar(dne(), n);
    var t = J2();
    Object.defineProperty(n, "Ie11Sha1", {
        enumerable: !0,
        get: function() {
            return t.Sha1
        }
    });
    var i = Q2();
    Object.defineProperty(n, "WebCryptoSha1", {
        enumerable: !0,
        get: function() {
            return i.Sha1
        }
    })
}
)(j2);
var sP = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Wv = function(n, e) {
    return Wv = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(t, i) {
        t.__proto__ = i
    }
    || function(t, i) {
        for (var r in i)
            i.hasOwnProperty(r) && (t[r] = i[r])
    }
    ,
    Wv(n, e)
};
function pne(n, e) {
    Wv(n, e);
    function t() {
        this.constructor = n
    }
    n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype,
    new t)
}
var $v = function() {
    return $v = Object.assign || function(e) {
        for (var t, i = 1, r = arguments.length; i < r; i++) {
            t = arguments[i];
            for (var s in t)
                Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s])
        }
        return e
    }
    ,
    $v.apply(this, arguments)
};
function mne(n, e) {
    var t = {};
    for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
            e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
    return t
}
function gne(n, e, t, i) {
    var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        s = Reflect.decorate(n, e, t, i);
    else
        for (var a = n.length - 1; a >= 0; a--)
            (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
    return r > 3 && s && Object.defineProperty(e, t, s),
    s
}
function _ne(n, e) {
    return function(t, i) {
        e(t, i, n)
    }
}
function vne(n, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(n, e)
}
function yne(n, e, t, i) {
    function r(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(h) {
            try {
                u(i.next(h))
            } catch (m) {
                o(m)
            }
        }
        function c(h) {
            try {
                u(i.throw(h))
            } catch (m) {
                o(m)
            }
        }
        function u(h) {
            h.done ? s(h.value) : r(h.value).then(a, c)
        }
        u((i = i.apply(n, e || [])).next())
    }
    )
}
function xne(n, e) {
    var t = {
        label: 0,
        sent: function() {
            if (s[0] & 1)
                throw s[1];
            return s[1]
        },
        trys: [],
        ops: []
    }, i, r, s, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    },
    typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }
    ),
    o;
    function a(u) {
        return function(h) {
            return c([u, h])
        }
    }
    function c(u) {
        if (i)
            throw new TypeError("Generator is already executing.");
        for (; t; )
            try {
                if (i = 1,
                r && (s = u[0] & 2 ? r.return : u[0] ? r.throw || ((s = r.return) && s.call(r),
                0) : r.next) && !(s = s.call(r, u[1])).done)
                    return s;
                switch (r = 0,
                s && (u = [u[0] & 2, s.value]),
                u[0]) {
                case 0:
                case 1:
                    s = u;
                    break;
                case 4:
                    return t.label++,
                    {
                        value: u[1],
                        done: !1
                    };
                case 5:
                    t.label++,
                    r = u[1],
                    u = [0];
                    continue;
                case 7:
                    u = t.ops.pop(),
                    t.trys.pop();
                    continue;
                default:
                    if (s = t.trys,
                    !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
                        t = 0;
                        continue
                    }
                    if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
                        t.label = u[1];
                        break
                    }
                    if (u[0] === 6 && t.label < s[1]) {
                        t.label = s[1],
                        s = u;
                        break
                    }
                    if (s && t.label < s[2]) {
                        t.label = s[2],
                        t.ops.push(u);
                        break
                    }
                    s[2] && t.ops.pop(),
                    t.trys.pop();
                    continue
                }
                u = e.call(n, t)
            } catch (h) {
                u = [6, h],
                r = 0
            } finally {
                i = s = 0
            }
        if (u[0] & 5)
            throw u[1];
        return {
            value: u[0] ? u[1] : void 0,
            done: !0
        }
    }
}
function bne(n, e, t, i) {
    i === void 0 && (i = t),
    n[i] = e[t]
}
function Sne(n, e) {
    for (var t in n)
        t !== "default" && !e.hasOwnProperty(t) && (e[t] = n[t])
}
function Xv(n) {
    var e = typeof Symbol == "function" && Symbol.iterator
      , t = e && n[e]
      , i = 0;
    if (t)
        return t.call(n);
    if (n && typeof n.length == "number")
        return {
            next: function() {
                return n && i >= n.length && (n = void 0),
                {
                    value: n && n[i++],
                    done: !n
                }
            }
        };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function oP(n, e) {
    var t = typeof Symbol == "function" && n[Symbol.iterator];
    if (!t)
        return n;
    var i = t.call(n), r, s = [], o;
    try {
        for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
            s.push(r.value)
    } catch (a) {
        o = {
            error: a
        }
    } finally {
        try {
            r && !r.done && (t = i.return) && t.call(i)
        } finally {
            if (o)
                throw o.error
        }
    }
    return s
}
function wne() {
    for (var n = [], e = 0; e < arguments.length; e++)
        n = n.concat(oP(arguments[e]));
    return n
}
function Ene() {
    for (var n = 0, e = 0, t = arguments.length; e < t; e++)
        n += arguments[e].length;
    for (var i = Array(n), r = 0, e = 0; e < t; e++)
        for (var s = arguments[e], o = 0, a = s.length; o < a; o++,
        r++)
            i[r] = s[o];
    return i
}
function Jf(n) {
    return this instanceof Jf ? (this.v = n,
    this) : new Jf(n)
}
function Ane(n, e, t) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var i = t.apply(n, e || []), r, s = [];
    return r = {},
    o("next"),
    o("throw"),
    o("return"),
    r[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    r;
    function o(d) {
        i[d] && (r[d] = function(f) {
            return new Promise(function(_, g) {
                s.push([d, f, _, g]) > 1 || a(d, f)
            }
            )
        }
        )
    }
    function a(d, f) {
        try {
            c(i[d](f))
        } catch (_) {
            m(s[0][3], _)
        }
    }
    function c(d) {
        d.value instanceof Jf ? Promise.resolve(d.value.v).then(u, h) : m(s[0][2], d)
    }
    function u(d) {
        a("next", d)
    }
    function h(d) {
        a("throw", d)
    }
    function m(d, f) {
        d(f),
        s.shift(),
        s.length && a(s[0][0], s[0][1])
    }
}
function Mne(n) {
    var e, t;
    return e = {},
    i("next"),
    i("throw", function(r) {
        throw r
    }),
    i("return"),
    e[Symbol.iterator] = function() {
        return this
    }
    ,
    e;
    function i(r, s) {
        e[r] = n[r] ? function(o) {
            return (t = !t) ? {
                value: Jf(n[r](o)),
                done: r === "return"
            } : s ? s(o) : o
        }
        : s
    }
}
function Tne(n) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = n[Symbol.asyncIterator], t;
    return e ? e.call(n) : (n = typeof Xv == "function" ? Xv(n) : n[Symbol.iterator](),
    t = {},
    i("next"),
    i("throw"),
    i("return"),
    t[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    t);
    function i(s) {
        t[s] = n[s] && function(o) {
            return new Promise(function(a, c) {
                o = n[s](o),
                r(a, c, o.done, o.value)
            }
            )
        }
    }
    function r(s, o, a, c) {
        Promise.resolve(c).then(function(u) {
            s({
                value: u,
                done: a
            })
        }, o)
    }
}
function Cne(n, e) {
    return Object.defineProperty ? Object.defineProperty(n, "raw", {
        value: e
    }) : n.raw = e,
    n
}
function Rne(n) {
    if (n && n.__esModule)
        return n;
    var e = {};
    if (n != null)
        for (var t in n)
            Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
    return e.default = n,
    e
}
function Pne(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function Lne(n, e) {
    if (!e.has(n))
        throw new TypeError("attempted to get private field on non-instance");
    return e.get(n)
}
function Dne(n, e, t) {
    if (!e.has(n))
        throw new TypeError("attempted to set private field on non-instance");
    return e.set(n, t),
    t
}
const Ine = Object.freeze(Object.defineProperty({
    __proto__: null,
    get __assign() {
        return $v
    },
    __asyncDelegator: Mne,
    __asyncGenerator: Ane,
    __asyncValues: Tne,
    __await: Jf,
    __awaiter: yne,
    __classPrivateFieldGet: Lne,
    __classPrivateFieldSet: Dne,
    __createBinding: bne,
    __decorate: gne,
    __exportStar: Sne,
    __extends: pne,
    __generator: xne,
    __importDefault: Pne,
    __importStar: Rne,
    __makeTemplateObject: Cne,
    __metadata: vne,
    __param: _ne,
    __read: oP,
    __rest: mne,
    __spread: wne,
    __spreadArrays: Ene,
    __values: Xv
}, Symbol.toStringTag, {
    value: "Module"
}))
  , One = Fo(Ine);
var Ku = {}, Zu = {}, Ju = {}, NA;
function Nne() {
    if (NA)
        return Ju;
    NA = 1,
    Object.defineProperty(Ju, "__esModule", {
        value: !0
    }),
    Ju.isEmptyData = void 0;
    function n(e) {
        return typeof e == "string" ? e.length === 0 : e.byteLength === 0
    }
    return Ju.isEmptyData = n,
    Ju
}
var Z0 = {}, UA;
function aP() {
    return UA || (UA = 1,
    function(n) {
        Object.defineProperty(n, "__esModule", {
            value: !0
        }),
        n.EMPTY_DATA_SHA_256 = n.SHA_256_HMAC_ALGO = n.SHA_256_HASH = void 0,
        n.SHA_256_HASH = {
            name: "SHA-256"
        },
        n.SHA_256_HMAC_ALGO = {
            name: "HMAC",
            hash: n.SHA_256_HASH
        },
        n.EMPTY_DATA_SHA_256 = new Uint8Array([227, 176, 196, 66, 152, 252, 28, 20, 154, 251, 244, 200, 153, 111, 185, 36, 39, 174, 65, 228, 100, 155, 147, 76, 164, 149, 153, 27, 120, 82, 184, 85])
    }(Z0)),
    Z0
}
var FA;
function lP() {
    if (FA)
        return Zu;
    FA = 1,
    Object.defineProperty(Zu, "__esModule", {
        value: !0
    }),
    Zu.Sha256 = void 0;
    var n = Nne()
      , e = aP()
      , t = gm
      , i = cu
      , r = function() {
        function a(c) {
            this.secret = c,
            this.reset()
        }
        return a.prototype.update = function(c) {
            var u = this;
            (0,
            n.isEmptyData)(c) || (this.operation = this.operation.then(function(h) {
                return h.onerror = function() {
                    u.operation = Promise.reject(new Error("Error encountered updating hash"))
                }
                ,
                h.process(o(c)),
                h
            }),
            this.operation.catch(function() {}))
        }
        ,
        a.prototype.digest = function() {
            return this.operation.then(function(c) {
                return new Promise(function(u, h) {
                    c.onerror = function() {
                        h(new Error("Error encountered finalizing hash"))
                    }
                    ,
                    c.oncomplete = function() {
                        c.result && u(new Uint8Array(c.result)),
                        h(new Error("Error encountered finalizing hash"))
                    }
                    ,
                    c.finish()
                }
                )
            })
        }
        ,
        a.prototype.reset = function() {
            this.secret ? (this.operation = s(this.secret).then(function(c) {
                return (0,
                i.locateWindow)().msCrypto.subtle.sign(e.SHA_256_HMAC_ALGO, c)
            }),
            this.operation.catch(function() {})) : this.operation = Promise.resolve((0,
            i.locateWindow)().msCrypto.subtle.digest("SHA-256"))
        }
        ,
        a
    }();
    Zu.Sha256 = r;
    function s(a) {
        return new Promise(function(c, u) {
            var h = (0,
            i.locateWindow)().msCrypto.subtle.importKey("raw", o(a), e.SHA_256_HMAC_ALGO, !1, ["sign"]);
            h.oncomplete = function() {
                h.result && c(h.result),
                u(new Error("ImportKey completed without importing key."))
            }
            ,
            h.onerror = function() {
                u(new Error("ImportKey failed to import key."))
            }
        }
        )
    }
    function o(a) {
        return typeof a == "string" ? (0,
        t.fromUtf8)(a) : ArrayBuffer.isView(a) ? new Uint8Array(a.buffer,a.byteOffset,a.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(a)
    }
    return Zu
}
var Qu = {}, BA;
function cP() {
    if (BA)
        return Qu;
    BA = 1,
    Object.defineProperty(Qu, "__esModule", {
        value: !0
    }),
    Qu.Sha256 = void 0;
    var n = Da()
      , e = aP()
      , t = cu
      , i = function() {
        function r(s) {
            this.toHash = new Uint8Array(0),
            this.secret = s,
            this.reset()
        }
        return r.prototype.update = function(s) {
            if (!(0,
            n.isEmptyData)(s)) {
                var o = (0,
                n.convertToBuffer)(s)
                  , a = new Uint8Array(this.toHash.byteLength + o.byteLength);
                a.set(this.toHash, 0),
                a.set(o, this.toHash.byteLength),
                this.toHash = a
            }
        }
        ,
        r.prototype.digest = function() {
            var s = this;
            return this.key ? this.key.then(function(o) {
                return (0,
                t.locateWindow)().crypto.subtle.sign(e.SHA_256_HMAC_ALGO, o, s.toHash).then(function(a) {
                    return new Uint8Array(a)
                })
            }) : (0,
            n.isEmptyData)(this.toHash) ? Promise.resolve(e.EMPTY_DATA_SHA_256) : Promise.resolve().then(function() {
                return (0,
                t.locateWindow)().crypto.subtle.digest(e.SHA_256_HASH, s.toHash)
            }).then(function(o) {
                return Promise.resolve(new Uint8Array(o))
            })
        }
        ,
        r.prototype.reset = function() {
            var s = this;
            this.toHash = new Uint8Array(0),
            this.secret && this.secret !== void 0 && (this.key = new Promise(function(o, a) {
                (0,
                t.locateWindow)().crypto.subtle.importKey("raw", (0,
                n.convertToBuffer)(s.secret), e.SHA_256_HMAC_ALGO, !1, ["sign"]).then(o, a)
            }
            ),
            this.key.catch(function() {}))
        }
        ,
        r
    }();
    return Qu.Sha256 = i,
    Qu
}
var J0 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var qv = function(n, e) {
    return qv = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(t, i) {
        t.__proto__ = i
    }
    || function(t, i) {
        for (var r in i)
            i.hasOwnProperty(r) && (t[r] = i[r])
    }
    ,
    qv(n, e)
};
function Une(n, e) {
    qv(n, e);
    function t() {
        this.constructor = n
    }
    n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype,
    new t)
}
var jv = function() {
    return jv = Object.assign || function(e) {
        for (var t, i = 1, r = arguments.length; i < r; i++) {
            t = arguments[i];
            for (var s in t)
                Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s])
        }
        return e
    }
    ,
    jv.apply(this, arguments)
};
function Fne(n, e) {
    var t = {};
    for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
            e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
    return t
}
function Bne(n, e, t, i) {
    var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        s = Reflect.decorate(n, e, t, i);
    else
        for (var a = n.length - 1; a >= 0; a--)
            (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
    return r > 3 && s && Object.defineProperty(e, t, s),
    s
}
function kne(n, e) {
    return function(t, i) {
        e(t, i, n)
    }
}
function zne(n, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(n, e)
}
function Hne(n, e, t, i) {
    function r(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(h) {
            try {
                u(i.next(h))
            } catch (m) {
                o(m)
            }
        }
        function c(h) {
            try {
                u(i.throw(h))
            } catch (m) {
                o(m)
            }
        }
        function u(h) {
            h.done ? s(h.value) : r(h.value).then(a, c)
        }
        u((i = i.apply(n, e || [])).next())
    }
    )
}
function Gne(n, e) {
    var t = {
        label: 0,
        sent: function() {
            if (s[0] & 1)
                throw s[1];
            return s[1]
        },
        trys: [],
        ops: []
    }, i, r, s, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    },
    typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }
    ),
    o;
    function a(u) {
        return function(h) {
            return c([u, h])
        }
    }
    function c(u) {
        if (i)
            throw new TypeError("Generator is already executing.");
        for (; t; )
            try {
                if (i = 1,
                r && (s = u[0] & 2 ? r.return : u[0] ? r.throw || ((s = r.return) && s.call(r),
                0) : r.next) && !(s = s.call(r, u[1])).done)
                    return s;
                switch (r = 0,
                s && (u = [u[0] & 2, s.value]),
                u[0]) {
                case 0:
                case 1:
                    s = u;
                    break;
                case 4:
                    return t.label++,
                    {
                        value: u[1],
                        done: !1
                    };
                case 5:
                    t.label++,
                    r = u[1],
                    u = [0];
                    continue;
                case 7:
                    u = t.ops.pop(),
                    t.trys.pop();
                    continue;
                default:
                    if (s = t.trys,
                    !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
                        t = 0;
                        continue
                    }
                    if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
                        t.label = u[1];
                        break
                    }
                    if (u[0] === 6 && t.label < s[1]) {
                        t.label = s[1],
                        s = u;
                        break
                    }
                    if (s && t.label < s[2]) {
                        t.label = s[2],
                        t.ops.push(u);
                        break
                    }
                    s[2] && t.ops.pop(),
                    t.trys.pop();
                    continue
                }
                u = e.call(n, t)
            } catch (h) {
                u = [6, h],
                r = 0
            } finally {
                i = s = 0
            }
        if (u[0] & 5)
            throw u[1];
        return {
            value: u[0] ? u[1] : void 0,
            done: !0
        }
    }
}
function Vne(n, e, t, i) {
    i === void 0 && (i = t),
    n[i] = e[t]
}
function Wne(n, e) {
    for (var t in n)
        t !== "default" && !e.hasOwnProperty(t) && (e[t] = n[t])
}
function Yv(n) {
    var e = typeof Symbol == "function" && Symbol.iterator
      , t = e && n[e]
      , i = 0;
    if (t)
        return t.call(n);
    if (n && typeof n.length == "number")
        return {
            next: function() {
                return n && i >= n.length && (n = void 0),
                {
                    value: n && n[i++],
                    done: !n
                }
            }
        };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function uP(n, e) {
    var t = typeof Symbol == "function" && n[Symbol.iterator];
    if (!t)
        return n;
    var i = t.call(n), r, s = [], o;
    try {
        for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
            s.push(r.value)
    } catch (a) {
        o = {
            error: a
        }
    } finally {
        try {
            r && !r.done && (t = i.return) && t.call(i)
        } finally {
            if (o)
                throw o.error
        }
    }
    return s
}
function $ne() {
    for (var n = [], e = 0; e < arguments.length; e++)
        n = n.concat(uP(arguments[e]));
    return n
}
function Xne() {
    for (var n = 0, e = 0, t = arguments.length; e < t; e++)
        n += arguments[e].length;
    for (var i = Array(n), r = 0, e = 0; e < t; e++)
        for (var s = arguments[e], o = 0, a = s.length; o < a; o++,
        r++)
            i[r] = s[o];
    return i
}
function Qf(n) {
    return this instanceof Qf ? (this.v = n,
    this) : new Qf(n)
}
function qne(n, e, t) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var i = t.apply(n, e || []), r, s = [];
    return r = {},
    o("next"),
    o("throw"),
    o("return"),
    r[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    r;
    function o(d) {
        i[d] && (r[d] = function(f) {
            return new Promise(function(_, g) {
                s.push([d, f, _, g]) > 1 || a(d, f)
            }
            )
        }
        )
    }
    function a(d, f) {
        try {
            c(i[d](f))
        } catch (_) {
            m(s[0][3], _)
        }
    }
    function c(d) {
        d.value instanceof Qf ? Promise.resolve(d.value.v).then(u, h) : m(s[0][2], d)
    }
    function u(d) {
        a("next", d)
    }
    function h(d) {
        a("throw", d)
    }
    function m(d, f) {
        d(f),
        s.shift(),
        s.length && a(s[0][0], s[0][1])
    }
}
function jne(n) {
    var e, t;
    return e = {},
    i("next"),
    i("throw", function(r) {
        throw r
    }),
    i("return"),
    e[Symbol.iterator] = function() {
        return this
    }
    ,
    e;
    function i(r, s) {
        e[r] = n[r] ? function(o) {
            return (t = !t) ? {
                value: Qf(n[r](o)),
                done: r === "return"
            } : s ? s(o) : o
        }
        : s
    }
}
function Yne(n) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = n[Symbol.asyncIterator], t;
    return e ? e.call(n) : (n = typeof Yv == "function" ? Yv(n) : n[Symbol.iterator](),
    t = {},
    i("next"),
    i("throw"),
    i("return"),
    t[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    t);
    function i(s) {
        t[s] = n[s] && function(o) {
            return new Promise(function(a, c) {
                o = n[s](o),
                r(a, c, o.done, o.value)
            }
            )
        }
    }
    function r(s, o, a, c) {
        Promise.resolve(c).then(function(u) {
            s({
                value: u,
                done: a
            })
        }, o)
    }
}
function Kne(n, e) {
    return Object.defineProperty ? Object.defineProperty(n, "raw", {
        value: e
    }) : n.raw = e,
    n
}
function Zne(n) {
    if (n && n.__esModule)
        return n;
    var e = {};
    if (n != null)
        for (var t in n)
            Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
    return e.default = n,
    e
}
function Jne(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function Qne(n, e) {
    if (!e.has(n))
        throw new TypeError("attempted to get private field on non-instance");
    return e.get(n)
}
function eie(n, e, t) {
    if (!e.has(n))
        throw new TypeError("attempted to set private field on non-instance");
    return e.set(n, t),
    t
}
const tie = Object.freeze(Object.defineProperty({
    __proto__: null,
    get __assign() {
        return jv
    },
    __asyncDelegator: jne,
    __asyncGenerator: qne,
    __asyncValues: Yne,
    __await: Qf,
    __awaiter: Hne,
    __classPrivateFieldGet: Qne,
    __classPrivateFieldSet: eie,
    __createBinding: Vne,
    __decorate: Bne,
    __exportStar: Wne,
    __extends: Une,
    __generator: Gne,
    __importDefault: Jne,
    __importStar: Zne,
    __makeTemplateObject: Kne,
    __metadata: zne,
    __param: kne,
    __read: uP,
    __rest: Fne,
    __spread: $ne,
    __spreadArrays: Xne,
    __values: Yv
}, Symbol.toStringTag, {
    value: "Module"
}))
  , fP = Fo(tie);
var ef = {}, Gr = {}, kA;
function hP() {
    return kA || (kA = 1,
    Object.defineProperty(Gr, "__esModule", {
        value: !0
    }),
    Gr.MAX_HASHABLE_LENGTH = Gr.INIT = Gr.KEY = Gr.DIGEST_LENGTH = Gr.BLOCK_SIZE = void 0,
    Gr.BLOCK_SIZE = 64,
    Gr.DIGEST_LENGTH = 32,
    Gr.KEY = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
    Gr.INIT = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225],
    Gr.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1),
    Gr
}
var tf = {}, zA;
function nie() {
    if (zA)
        return tf;
    zA = 1,
    Object.defineProperty(tf, "__esModule", {
        value: !0
    }),
    tf.RawSha256 = void 0;
    var n = hP()
      , e = function() {
        function t() {
            this.state = Int32Array.from(n.INIT),
            this.temp = new Int32Array(64),
            this.buffer = new Uint8Array(64),
            this.bufferLength = 0,
            this.bytesHashed = 0,
            this.finished = !1
        }
        return t.prototype.update = function(i) {
            if (this.finished)
                throw new Error("Attempted to update an already finished hash.");
            var r = 0
              , s = i.byteLength;
            if (this.bytesHashed += s,
            this.bytesHashed * 8 > n.MAX_HASHABLE_LENGTH)
                throw new Error("Cannot hash more than 2^53 - 1 bits");
            for (; s > 0; )
                this.buffer[this.bufferLength++] = i[r++],
                s--,
                this.bufferLength === n.BLOCK_SIZE && (this.hashBuffer(),
                this.bufferLength = 0)
        }
        ,
        t.prototype.digest = function() {
            if (!this.finished) {
                var i = this.bytesHashed * 8
                  , r = new DataView(this.buffer.buffer,this.buffer.byteOffset,this.buffer.byteLength)
                  , s = this.bufferLength;
                if (r.setUint8(this.bufferLength++, 128),
                s % n.BLOCK_SIZE >= n.BLOCK_SIZE - 8) {
                    for (var o = this.bufferLength; o < n.BLOCK_SIZE; o++)
                        r.setUint8(o, 0);
                    this.hashBuffer(),
                    this.bufferLength = 0
                }
                for (var o = this.bufferLength; o < n.BLOCK_SIZE - 8; o++)
                    r.setUint8(o, 0);
                r.setUint32(n.BLOCK_SIZE - 8, Math.floor(i / 4294967296), !0),
                r.setUint32(n.BLOCK_SIZE - 4, i),
                this.hashBuffer(),
                this.finished = !0
            }
            for (var a = new Uint8Array(n.DIGEST_LENGTH), o = 0; o < 8; o++)
                a[o * 4] = this.state[o] >>> 24 & 255,
                a[o * 4 + 1] = this.state[o] >>> 16 & 255,
                a[o * 4 + 2] = this.state[o] >>> 8 & 255,
                a[o * 4 + 3] = this.state[o] >>> 0 & 255;
            return a
        }
        ,
        t.prototype.hashBuffer = function() {
            for (var i = this, r = i.buffer, s = i.state, o = s[0], a = s[1], c = s[2], u = s[3], h = s[4], m = s[5], d = s[6], f = s[7], _ = 0; _ < n.BLOCK_SIZE; _++) {
                if (_ < 16)
                    this.temp[_] = (r[_ * 4] & 255) << 24 | (r[_ * 4 + 1] & 255) << 16 | (r[_ * 4 + 2] & 255) << 8 | r[_ * 4 + 3] & 255;
                else {
                    var g = this.temp[_ - 2]
                      , v = (g >>> 17 | g << 15) ^ (g >>> 19 | g << 13) ^ g >>> 10;
                    g = this.temp[_ - 15];
                    var y = (g >>> 7 | g << 25) ^ (g >>> 18 | g << 14) ^ g >>> 3;
                    this.temp[_] = (v + this.temp[_ - 7] | 0) + (y + this.temp[_ - 16] | 0)
                }
                var w = (((h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7)) + (h & m ^ ~h & d) | 0) + (f + (n.KEY[_] + this.temp[_] | 0) | 0) | 0
                  , S = ((o >>> 2 | o << 30) ^ (o >>> 13 | o << 19) ^ (o >>> 22 | o << 10)) + (o & a ^ o & c ^ a & c) | 0;
                f = d,
                d = m,
                m = h,
                h = u + w | 0,
                u = c,
                c = a,
                a = o,
                o = w + S | 0
            }
            s[0] += o,
            s[1] += a,
            s[2] += c,
            s[3] += u,
            s[4] += h,
            s[5] += m,
            s[6] += d,
            s[7] += f
        }
        ,
        t
    }();
    return tf.RawSha256 = e,
    tf
}
var HA;
function iie() {
    if (HA)
        return ef;
    HA = 1,
    Object.defineProperty(ef, "__esModule", {
        value: !0
    }),
    ef.Sha256 = void 0;
    var n = fP
      , e = hP()
      , t = nie()
      , i = Da()
      , r = function() {
        function o(a) {
            this.secret = a,
            this.hash = new t.RawSha256,
            this.reset()
        }
        return o.prototype.update = function(a) {
            if (!((0,
            i.isEmptyData)(a) || this.error))
                try {
                    this.hash.update((0,
                    i.convertToBuffer)(a))
                } catch (c) {
                    this.error = c
                }
        }
        ,
        o.prototype.digestSync = function() {
            if (this.error)
                throw this.error;
            return this.outer ? (this.outer.finished || this.outer.update(this.hash.digest()),
            this.outer.digest()) : this.hash.digest()
        }
        ,
        o.prototype.digest = function() {
            return n.__awaiter(this, void 0, void 0, function() {
                return n.__generator(this, function(a) {
                    return [2, this.digestSync()]
                })
            })
        }
        ,
        o.prototype.reset = function() {
            if (this.hash = new t.RawSha256,
            this.secret) {
                this.outer = new t.RawSha256;
                var a = s(this.secret)
                  , c = new Uint8Array(e.BLOCK_SIZE);
                c.set(a);
                for (var u = 0; u < e.BLOCK_SIZE; u++)
                    a[u] ^= 54,
                    c[u] ^= 92;
                this.hash.update(a),
                this.outer.update(c);
                for (var u = 0; u < a.byteLength; u++)
                    a[u] = 0
            }
        }
        ,
        o
    }();
    ef.Sha256 = r;
    function s(o) {
        var a = (0,
        i.convertToBuffer)(o);
        if (a.byteLength > e.BLOCK_SIZE) {
            var c = new t.RawSha256;
            c.update(a),
            a = c.digest()
        }
        var u = new Uint8Array(e.BLOCK_SIZE);
        return u.set(a),
        u
    }
    return ef
}
var GA;
function rie() {
    return GA || (GA = 1,
    function(n) {
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var e = fP;
        e.__exportStar(iie(), n)
    }(J0)),
    J0
}
var VA;
function sie() {
    if (VA)
        return Ku;
    VA = 1,
    Object.defineProperty(Ku, "__esModule", {
        value: !0
    }),
    Ku.Sha256 = void 0;
    var n = lP()
      , e = cP()
      , t = rie()
      , i = nP()
      , r = rP()
      , s = cu
      , o = Da()
      , a = function() {
        function c(u) {
            (0,
            i.supportsWebCrypto)((0,
            s.locateWindow)()) ? this.hash = new e.Sha256(u) : (0,
            r.isMsWindow)((0,
            s.locateWindow)()) ? this.hash = new n.Sha256(u) : this.hash = new t.Sha256(u)
        }
        return c.prototype.update = function(u, h) {
            this.hash.update((0,
            o.convertToBuffer)(u))
        }
        ,
        c.prototype.digest = function() {
            return this.hash.digest()
        }
        ,
        c.prototype.reset = function() {
            this.hash.reset()
        }
        ,
        c
    }();
    return Ku.Sha256 = a,
    Ku
}
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.WebCryptoSha256 = n.Ie11Sha256 = void 0;
    var e = One;
    e.__exportStar(sie(), n);
    var t = lP();
    Object.defineProperty(n, "Ie11Sha256", {
        enumerable: !0,
        get: function() {
            return t.Sha256
        }
    });
    var i = cP();
    Object.defineProperty(n, "WebCryptoSha256", {
        enumerable: !0,
        get: function() {
            return i.Sha256
        }
    })
}
)(sP);
const oie = {
    "Amazon Silk": "amazon_silk",
    "Android Browser": "android",
    Bada: "bada",
    BlackBerry: "blackberry",
    Chrome: "chrome",
    Chromium: "chromium",
    Electron: "electron",
    Epiphany: "epiphany",
    Firefox: "firefox",
    Focus: "focus",
    Generic: "generic",
    "Google Search": "google_search",
    Googlebot: "googlebot",
    "Internet Explorer": "ie",
    "K-Meleon": "k_meleon",
    Maxthon: "maxthon",
    "Microsoft Edge": "edge",
    "MZ Browser": "mz",
    "NAVER Whale Browser": "naver",
    Opera: "opera",
    "Opera Coast": "opera_coast",
    PhantomJS: "phantomjs",
    Puffin: "puffin",
    QupZilla: "qupzilla",
    QQ: "qq",
    QQLite: "qqlite",
    Safari: "safari",
    Sailfish: "sailfish",
    "Samsung Internet for Android": "samsung_internet",
    SeaMonkey: "seamonkey",
    Sleipnir: "sleipnir",
    Swing: "swing",
    Tizen: "tizen",
    "UC Browser": "uc",
    Vivaldi: "vivaldi",
    "WebOS Browser": "webos",
    WeChat: "wechat",
    "Yandex Browser": "yandex",
    Roku: "roku"
}
  , dP = {
    amazon_silk: "Amazon Silk",
    android: "Android Browser",
    bada: "Bada",
    blackberry: "BlackBerry",
    chrome: "Chrome",
    chromium: "Chromium",
    electron: "Electron",
    epiphany: "Epiphany",
    firefox: "Firefox",
    focus: "Focus",
    generic: "Generic",
    googlebot: "Googlebot",
    google_search: "Google Search",
    ie: "Internet Explorer",
    k_meleon: "K-Meleon",
    maxthon: "Maxthon",
    edge: "Microsoft Edge",
    mz: "MZ Browser",
    naver: "NAVER Whale Browser",
    opera: "Opera",
    opera_coast: "Opera Coast",
    phantomjs: "PhantomJS",
    puffin: "Puffin",
    qupzilla: "QupZilla",
    qq: "QQ Browser",
    qqlite: "QQ Browser Lite",
    safari: "Safari",
    sailfish: "Sailfish",
    samsung_internet: "Samsung Internet for Android",
    seamonkey: "SeaMonkey",
    sleipnir: "Sleipnir",
    swing: "Swing",
    tizen: "Tizen",
    uc: "UC Browser",
    vivaldi: "Vivaldi",
    webos: "WebOS Browser",
    wechat: "WeChat",
    yandex: "Yandex Browser"
}
  , qn = {
    tablet: "tablet",
    mobile: "mobile",
    desktop: "desktop",
    tv: "tv"
}
  , Ji = {
    WindowsPhone: "Windows Phone",
    Windows: "Windows",
    MacOS: "macOS",
    iOS: "iOS",
    Android: "Android",
    WebOS: "WebOS",
    BlackBerry: "BlackBerry",
    Bada: "Bada",
    Tizen: "Tizen",
    Linux: "Linux",
    ChromeOS: "Chrome OS",
    PlayStation4: "PlayStation 4",
    Roku: "Roku"
}
  , aa = {
    EdgeHTML: "EdgeHTML",
    Blink: "Blink",
    Trident: "Trident",
    Presto: "Presto",
    Gecko: "Gecko",
    WebKit: "WebKit"
};
class Me {
    static getFirstMatch(e, t) {
        const i = t.match(e);
        return i && i.length > 0 && i[1] || ""
    }
    static getSecondMatch(e, t) {
        const i = t.match(e);
        return i && i.length > 1 && i[2] || ""
    }
    static matchAndReturnConst(e, t, i) {
        if (e.test(t))
            return i
    }
    static getWindowsVersionName(e) {
        switch (e) {
        case "NT":
            return "NT";
        case "XP":
            return "XP";
        case "NT 5.0":
            return "2000";
        case "NT 5.1":
            return "XP";
        case "NT 5.2":
            return "2003";
        case "NT 6.0":
            return "Vista";
        case "NT 6.1":
            return "7";
        case "NT 6.2":
            return "8";
        case "NT 6.3":
            return "8.1";
        case "NT 10.0":
            return "10";
        default:
            return
        }
    }
    static getMacOSVersionName(e) {
        const t = e.split(".").splice(0, 2).map(i=>parseInt(i, 10) || 0);
        if (t.push(0),
        t[0] === 10)
            switch (t[1]) {
            case 5:
                return "Leopard";
            case 6:
                return "Snow Leopard";
            case 7:
                return "Lion";
            case 8:
                return "Mountain Lion";
            case 9:
                return "Mavericks";
            case 10:
                return "Yosemite";
            case 11:
                return "El Capitan";
            case 12:
                return "Sierra";
            case 13:
                return "High Sierra";
            case 14:
                return "Mojave";
            case 15:
                return "Catalina";
            default:
                return
            }
    }
    static getAndroidVersionName(e) {
        const t = e.split(".").splice(0, 2).map(i=>parseInt(i, 10) || 0);
        if (t.push(0),
        !(t[0] === 1 && t[1] < 5)) {
            if (t[0] === 1 && t[1] < 6)
                return "Cupcake";
            if (t[0] === 1 && t[1] >= 6)
                return "Donut";
            if (t[0] === 2 && t[1] < 2)
                return "Eclair";
            if (t[0] === 2 && t[1] === 2)
                return "Froyo";
            if (t[0] === 2 && t[1] > 2)
                return "Gingerbread";
            if (t[0] === 3)
                return "Honeycomb";
            if (t[0] === 4 && t[1] < 1)
                return "Ice Cream Sandwich";
            if (t[0] === 4 && t[1] < 4)
                return "Jelly Bean";
            if (t[0] === 4 && t[1] >= 4)
                return "KitKat";
            if (t[0] === 5)
                return "Lollipop";
            if (t[0] === 6)
                return "Marshmallow";
            if (t[0] === 7)
                return "Nougat";
            if (t[0] === 8)
                return "Oreo";
            if (t[0] === 9)
                return "Pie"
        }
    }
    static getVersionPrecision(e) {
        return e.split(".").length
    }
    static compareVersions(e, t, i=!1) {
        const r = Me.getVersionPrecision(e)
          , s = Me.getVersionPrecision(t);
        let o = Math.max(r, s)
          , a = 0;
        const c = Me.map([e, t], u=>{
            const h = o - Me.getVersionPrecision(u)
              , m = u + new Array(h + 1).join(".0");
            return Me.map(m.split("."), d=>new Array(20 - d.length).join("0") + d).reverse()
        }
        );
        for (i && (a = o - Math.min(r, s)),
        o -= 1; o >= a; ) {
            if (c[0][o] > c[1][o])
                return 1;
            if (c[0][o] === c[1][o]) {
                if (o === a)
                    return 0;
                o -= 1
            } else if (c[0][o] < c[1][o])
                return -1
        }
    }
    static map(e, t) {
        const i = [];
        let r;
        if (Array.prototype.map)
            return Array.prototype.map.call(e, t);
        for (r = 0; r < e.length; r += 1)
            i.push(t(e[r]));
        return i
    }
    static find(e, t) {
        let i, r;
        if (Array.prototype.find)
            return Array.prototype.find.call(e, t);
        for (i = 0,
        r = e.length; i < r; i += 1) {
            const s = e[i];
            if (t(s, i))
                return s
        }
    }
    static assign(e, ...t) {
        const i = e;
        let r, s;
        if (Object.assign)
            return Object.assign(e, ...t);
        for (r = 0,
        s = t.length; r < s; r += 1) {
            const o = t[r];
            typeof o == "object" && o !== null && Object.keys(o).forEach(c=>{
                i[c] = o[c]
            }
            )
        }
        return e
    }
    static getBrowserAlias(e) {
        return oie[e]
    }
    static getBrowserTypeByAlias(e) {
        return dP[e] || ""
    }
}
const xn = /version\/(\d+(\.?_?\d+)+)/i
  , aie = [{
    test: [/googlebot/i],
    describe(n) {
        const e = {
            name: "Googlebot"
        }
          , t = Me.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, n) || Me.getFirstMatch(xn, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/opera/i],
    describe(n) {
        const e = {
            name: "Opera"
        }
          , t = Me.getFirstMatch(xn, n) || Me.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/opr\/|opios/i],
    describe(n) {
        const e = {
            name: "Opera"
        }
          , t = Me.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, n) || Me.getFirstMatch(xn, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/SamsungBrowser/i],
    describe(n) {
        const e = {
            name: "Samsung Internet for Android"
        }
          , t = Me.getFirstMatch(xn, n) || Me.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/Whale/i],
    describe(n) {
        const e = {
            name: "NAVER Whale Browser"
        }
          , t = Me.getFirstMatch(xn, n) || Me.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/MZBrowser/i],
    describe(n) {
        const e = {
            name: "MZ Browser"
        }
          , t = Me.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, n) || Me.getFirstMatch(xn, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/focus/i],
    describe(n) {
        const e = {
            name: "Focus"
        }
          , t = Me.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, n) || Me.getFirstMatch(xn, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/swing/i],
    describe(n) {
        const e = {
            name: "Swing"
        }
          , t = Me.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, n) || Me.getFirstMatch(xn, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/coast/i],
    describe(n) {
        const e = {
            name: "Opera Coast"
        }
          , t = Me.getFirstMatch(xn, n) || Me.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(n) {
        const e = {
            name: "Opera Touch"
        }
          , t = Me.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, n) || Me.getFirstMatch(xn, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/yabrowser/i],
    describe(n) {
        const e = {
            name: "Yandex Browser"
        }
          , t = Me.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, n) || Me.getFirstMatch(xn, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/ucbrowser/i],
    describe(n) {
        const e = {
            name: "UC Browser"
        }
          , t = Me.getFirstMatch(xn, n) || Me.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/Maxthon|mxios/i],
    describe(n) {
        const e = {
            name: "Maxthon"
        }
          , t = Me.getFirstMatch(xn, n) || Me.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/epiphany/i],
    describe(n) {
        const e = {
            name: "Epiphany"
        }
          , t = Me.getFirstMatch(xn, n) || Me.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/puffin/i],
    describe(n) {
        const e = {
            name: "Puffin"
        }
          , t = Me.getFirstMatch(xn, n) || Me.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/sleipnir/i],
    describe(n) {
        const e = {
            name: "Sleipnir"
        }
          , t = Me.getFirstMatch(xn, n) || Me.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/k-meleon/i],
    describe(n) {
        const e = {
            name: "K-Meleon"
        }
          , t = Me.getFirstMatch(xn, n) || Me.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/micromessenger/i],
    describe(n) {
        const e = {
            name: "WeChat"
        }
          , t = Me.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, n) || Me.getFirstMatch(xn, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/qqbrowser/i],
    describe(n) {
        const e = {
            name: /qqbrowserlite/i.test(n) ? "QQ Browser Lite" : "QQ Browser"
        }
          , t = Me.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, n) || Me.getFirstMatch(xn, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/msie|trident/i],
    describe(n) {
        const e = {
            name: "Internet Explorer"
        }
          , t = Me.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/\sedg\//i],
    describe(n) {
        const e = {
            name: "Microsoft Edge"
        }
          , t = Me.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/edg([ea]|ios)/i],
    describe(n) {
        const e = {
            name: "Microsoft Edge"
        }
          , t = Me.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/vivaldi/i],
    describe(n) {
        const e = {
            name: "Vivaldi"
        }
          , t = Me.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/seamonkey/i],
    describe(n) {
        const e = {
            name: "SeaMonkey"
        }
          , t = Me.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/sailfish/i],
    describe(n) {
        const e = {
            name: "Sailfish"
        }
          , t = Me.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/silk/i],
    describe(n) {
        const e = {
            name: "Amazon Silk"
        }
          , t = Me.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/phantom/i],
    describe(n) {
        const e = {
            name: "PhantomJS"
        }
          , t = Me.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/slimerjs/i],
    describe(n) {
        const e = {
            name: "SlimerJS"
        }
          , t = Me.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(n) {
        const e = {
            name: "BlackBerry"
        }
          , t = Me.getFirstMatch(xn, n) || Me.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/(web|hpw)[o0]s/i],
    describe(n) {
        const e = {
            name: "WebOS Browser"
        }
          , t = Me.getFirstMatch(xn, n) || Me.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/bada/i],
    describe(n) {
        const e = {
            name: "Bada"
        }
          , t = Me.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/tizen/i],
    describe(n) {
        const e = {
            name: "Tizen"
        }
          , t = Me.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, n) || Me.getFirstMatch(xn, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/qupzilla/i],
    describe(n) {
        const e = {
            name: "QupZilla"
        }
          , t = Me.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, n) || Me.getFirstMatch(xn, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/firefox|iceweasel|fxios/i],
    describe(n) {
        const e = {
            name: "Firefox"
        }
          , t = Me.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/electron/i],
    describe(n) {
        const e = {
            name: "Electron"
        }
          , t = Me.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/MiuiBrowser/i],
    describe(n) {
        const e = {
            name: "Miui"
        }
          , t = Me.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/chromium/i],
    describe(n) {
        const e = {
            name: "Chromium"
        }
          , t = Me.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, n) || Me.getFirstMatch(xn, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/chrome|crios|crmo/i],
    describe(n) {
        const e = {
            name: "Chrome"
        }
          , t = Me.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/GSA/i],
    describe(n) {
        const e = {
            name: "Google Search"
        }
          , t = Me.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test(n) {
        const e = !n.test(/like android/i)
          , t = n.test(/android/i);
        return e && t
    },
    describe(n) {
        const e = {
            name: "Android Browser"
        }
          , t = Me.getFirstMatch(xn, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/playstation 4/i],
    describe(n) {
        const e = {
            name: "PlayStation 4"
        }
          , t = Me.getFirstMatch(xn, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/safari|applewebkit/i],
    describe(n) {
        const e = {
            name: "Safari"
        }
          , t = Me.getFirstMatch(xn, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/.*/i],
    describe(n) {
        const e = /^(.*)\/(.*) /
          , t = /^(.*)\/(.*)[ \t]\((.*)/
          , r = n.search("\\(") !== -1 ? t : e;
        return {
            name: Me.getFirstMatch(r, n),
            version: Me.getSecondMatch(r, n)
        }
    }
}]
  , lie = [{
    test: [/Roku\/DVP/],
    describe(n) {
        const e = Me.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, n);
        return {
            name: Ji.Roku,
            version: e
        }
    }
}, {
    test: [/windows phone/i],
    describe(n) {
        const e = Me.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, n);
        return {
            name: Ji.WindowsPhone,
            version: e
        }
    }
}, {
    test: [/windows /i],
    describe(n) {
        const e = Me.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, n)
          , t = Me.getWindowsVersionName(e);
        return {
            name: Ji.Windows,
            version: e,
            versionName: t
        }
    }
}, {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(n) {
        const e = {
            name: Ji.iOS
        }
          , t = Me.getSecondMatch(/(Version\/)(\d[\d.]+)/, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/macintosh/i],
    describe(n) {
        const e = Me.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, n).replace(/[_\s]/g, ".")
          , t = Me.getMacOSVersionName(e)
          , i = {
            name: Ji.MacOS,
            version: e
        };
        return t && (i.versionName = t),
        i
    }
}, {
    test: [/(ipod|iphone|ipad)/i],
    describe(n) {
        const e = Me.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, n).replace(/[_\s]/g, ".");
        return {
            name: Ji.iOS,
            version: e
        }
    }
}, {
    test(n) {
        const e = !n.test(/like android/i)
          , t = n.test(/android/i);
        return e && t
    },
    describe(n) {
        const e = Me.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, n)
          , t = Me.getAndroidVersionName(e)
          , i = {
            name: Ji.Android,
            version: e
        };
        return t && (i.versionName = t),
        i
    }
}, {
    test: [/(web|hpw)[o0]s/i],
    describe(n) {
        const e = Me.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, n)
          , t = {
            name: Ji.WebOS
        };
        return e && e.length && (t.version = e),
        t
    }
}, {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(n) {
        const e = Me.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, n) || Me.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, n) || Me.getFirstMatch(/\bbb(\d+)/i, n);
        return {
            name: Ji.BlackBerry,
            version: e
        }
    }
}, {
    test: [/bada/i],
    describe(n) {
        const e = Me.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, n);
        return {
            name: Ji.Bada,
            version: e
        }
    }
}, {
    test: [/tizen/i],
    describe(n) {
        const e = Me.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, n);
        return {
            name: Ji.Tizen,
            version: e
        }
    }
}, {
    test: [/linux/i],
    describe() {
        return {
            name: Ji.Linux
        }
    }
}, {
    test: [/CrOS/],
    describe() {
        return {
            name: Ji.ChromeOS
        }
    }
}, {
    test: [/PlayStation 4/],
    describe(n) {
        const e = Me.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, n);
        return {
            name: Ji.PlayStation4,
            version: e
        }
    }
}]
  , cie = [{
    test: [/googlebot/i],
    describe() {
        return {
            type: "bot",
            vendor: "Google"
        }
    }
}, {
    test: [/huawei/i],
    describe(n) {
        const e = Me.getFirstMatch(/(can-l01)/i, n) && "Nova"
          , t = {
            type: qn.mobile,
            vendor: "Huawei"
        };
        return e && (t.model = e),
        t
    }
}, {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
        return {
            type: qn.tablet,
            vendor: "Nexus"
        }
    }
}, {
    test: [/ipad/i],
    describe() {
        return {
            type: qn.tablet,
            vendor: "Apple",
            model: "iPad"
        }
    }
}, {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
        return {
            type: qn.tablet,
            vendor: "Apple",
            model: "iPad"
        }
    }
}, {
    test: [/kftt build/i],
    describe() {
        return {
            type: qn.tablet,
            vendor: "Amazon",
            model: "Kindle Fire HD 7"
        }
    }
}, {
    test: [/silk/i],
    describe() {
        return {
            type: qn.tablet,
            vendor: "Amazon"
        }
    }
}, {
    test: [/tablet(?! pc)/i],
    describe() {
        return {
            type: qn.tablet
        }
    }
}, {
    test(n) {
        const e = n.test(/ipod|iphone/i)
          , t = n.test(/like (ipod|iphone)/i);
        return e && !t
    },
    describe(n) {
        const e = Me.getFirstMatch(/(ipod|iphone)/i, n);
        return {
            type: qn.mobile,
            vendor: "Apple",
            model: e
        }
    }
}, {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
        return {
            type: qn.mobile,
            vendor: "Nexus"
        }
    }
}, {
    test: [/[^-]mobi/i],
    describe() {
        return {
            type: qn.mobile
        }
    }
}, {
    test(n) {
        return n.getBrowserName(!0) === "blackberry"
    },
    describe() {
        return {
            type: qn.mobile,
            vendor: "BlackBerry"
        }
    }
}, {
    test(n) {
        return n.getBrowserName(!0) === "bada"
    },
    describe() {
        return {
            type: qn.mobile
        }
    }
}, {
    test(n) {
        return n.getBrowserName() === "windows phone"
    },
    describe() {
        return {
            type: qn.mobile,
            vendor: "Microsoft"
        }
    }
}, {
    test(n) {
        const e = Number(String(n.getOSVersion()).split(".")[0]);
        return n.getOSName(!0) === "android" && e >= 3
    },
    describe() {
        return {
            type: qn.tablet
        }
    }
}, {
    test(n) {
        return n.getOSName(!0) === "android"
    },
    describe() {
        return {
            type: qn.mobile
        }
    }
}, {
    test(n) {
        return n.getOSName(!0) === "macos"
    },
    describe() {
        return {
            type: qn.desktop,
            vendor: "Apple"
        }
    }
}, {
    test(n) {
        return n.getOSName(!0) === "windows"
    },
    describe() {
        return {
            type: qn.desktop
        }
    }
}, {
    test(n) {
        return n.getOSName(!0) === "linux"
    },
    describe() {
        return {
            type: qn.desktop
        }
    }
}, {
    test(n) {
        return n.getOSName(!0) === "playstation 4"
    },
    describe() {
        return {
            type: qn.tv
        }
    }
}, {
    test(n) {
        return n.getOSName(!0) === "roku"
    },
    describe() {
        return {
            type: qn.tv
        }
    }
}]
  , uie = [{
    test(n) {
        return n.getBrowserName(!0) === "microsoft edge"
    },
    describe(n) {
        if (/\sedg\//i.test(n))
            return {
                name: aa.Blink
            };
        const t = Me.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, n);
        return {
            name: aa.EdgeHTML,
            version: t
        }
    }
}, {
    test: [/trident/i],
    describe(n) {
        const e = {
            name: aa.Trident
        }
          , t = Me.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test(n) {
        return n.test(/presto/i)
    },
    describe(n) {
        const e = {
            name: aa.Presto
        }
          , t = Me.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test(n) {
        const e = n.test(/gecko/i)
          , t = n.test(/like gecko/i);
        return e && !t
    },
    describe(n) {
        const e = {
            name: aa.Gecko
        }
          , t = Me.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}, {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
        return {
            name: aa.Blink
        }
    }
}, {
    test: [/(apple)?webkit/i],
    describe(n) {
        const e = {
            name: aa.WebKit
        }
          , t = Me.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, n);
        return t && (e.version = t),
        e
    }
}];
class WA {
    constructor(e, t=!1) {
        if (e == null || e === "")
            throw new Error("UserAgent parameter can't be empty");
        this._ua = e,
        this.parsedResult = {},
        t !== !0 && this.parse()
    }
    getUA() {
        return this._ua
    }
    test(e) {
        return e.test(this._ua)
    }
    parseBrowser() {
        this.parsedResult.browser = {};
        const e = Me.find(aie, t=>{
            if (typeof t.test == "function")
                return t.test(this);
            if (t.test instanceof Array)
                return t.test.some(i=>this.test(i));
            throw new Error("Browser's test function is not valid")
        }
        );
        return e && (this.parsedResult.browser = e.describe(this.getUA())),
        this.parsedResult.browser
    }
    getBrowser() {
        return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser()
    }
    getBrowserName(e) {
        return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || ""
    }
    getBrowserVersion() {
        return this.getBrowser().version
    }
    getOS() {
        return this.parsedResult.os ? this.parsedResult.os : this.parseOS()
    }
    parseOS() {
        this.parsedResult.os = {};
        const e = Me.find(lie, t=>{
            if (typeof t.test == "function")
                return t.test(this);
            if (t.test instanceof Array)
                return t.test.some(i=>this.test(i));
            throw new Error("Browser's test function is not valid")
        }
        );
        return e && (this.parsedResult.os = e.describe(this.getUA())),
        this.parsedResult.os
    }
    getOSName(e) {
        const {name: t} = this.getOS();
        return e ? String(t).toLowerCase() || "" : t || ""
    }
    getOSVersion() {
        return this.getOS().version
    }
    getPlatform() {
        return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform()
    }
    getPlatformType(e=!1) {
        const {type: t} = this.getPlatform();
        return e ? String(t).toLowerCase() || "" : t || ""
    }
    parsePlatform() {
        this.parsedResult.platform = {};
        const e = Me.find(cie, t=>{
            if (typeof t.test == "function")
                return t.test(this);
            if (t.test instanceof Array)
                return t.test.some(i=>this.test(i));
            throw new Error("Browser's test function is not valid")
        }
        );
        return e && (this.parsedResult.platform = e.describe(this.getUA())),
        this.parsedResult.platform
    }
    getEngine() {
        return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine()
    }
    getEngineName(e) {
        return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || ""
    }
    parseEngine() {
        this.parsedResult.engine = {};
        const e = Me.find(uie, t=>{
            if (typeof t.test == "function")
                return t.test(this);
            if (t.test instanceof Array)
                return t.test.some(i=>this.test(i));
            throw new Error("Browser's test function is not valid")
        }
        );
        return e && (this.parsedResult.engine = e.describe(this.getUA())),
        this.parsedResult.engine
    }
    parse() {
        return this.parseBrowser(),
        this.parseOS(),
        this.parsePlatform(),
        this.parseEngine(),
        this
    }
    getResult() {
        return Me.assign({}, this.parsedResult)
    }
    satisfies(e) {
        const t = {};
        let i = 0;
        const r = {};
        let s = 0;
        if (Object.keys(e).forEach(a=>{
            const c = e[a];
            typeof c == "string" ? (r[a] = c,
            s += 1) : typeof c == "object" && (t[a] = c,
            i += 1)
        }
        ),
        i > 0) {
            const a = Object.keys(t)
              , c = Me.find(a, h=>this.isOS(h));
            if (c) {
                const h = this.satisfies(t[c]);
                if (h !== void 0)
                    return h
            }
            const u = Me.find(a, h=>this.isPlatform(h));
            if (u) {
                const h = this.satisfies(t[u]);
                if (h !== void 0)
                    return h
            }
        }
        if (s > 0) {
            const a = Object.keys(r)
              , c = Me.find(a, u=>this.isBrowser(u, !0));
            if (c !== void 0)
                return this.compareVersion(r[c])
        }
    }
    isBrowser(e, t=!1) {
        const i = this.getBrowserName().toLowerCase();
        let r = e.toLowerCase();
        const s = Me.getBrowserTypeByAlias(r);
        return t && s && (r = s.toLowerCase()),
        r === i
    }
    compareVersion(e) {
        let t = [0]
          , i = e
          , r = !1;
        const s = this.getBrowserVersion();
        if (typeof s == "string")
            return e[0] === ">" || e[0] === "<" ? (i = e.substr(1),
            e[1] === "=" ? (r = !0,
            i = e.substr(2)) : t = [],
            e[0] === ">" ? t.push(1) : t.push(-1)) : e[0] === "=" ? i = e.substr(1) : e[0] === "~" && (r = !0,
            i = e.substr(1)),
            t.indexOf(Me.compareVersions(s, i, r)) > -1
    }
    isOS(e) {
        return this.getOSName(!0) === String(e).toLowerCase()
    }
    isPlatform(e) {
        return this.getPlatformType(!0) === String(e).toLowerCase()
    }
    isEngine(e) {
        return this.getEngineName(!0) === String(e).toLowerCase()
    }
    is(e, t=!1) {
        return this.isBrowser(e, t) || this.isOS(e) || this.isPlatform(e)
    }
    some(e=[]) {
        return e.some(t=>this.is(t))
    }
}
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class pP {
    static getParser(e, t=!1) {
        if (typeof e != "string")
            throw new Error("UserAgent should be a string");
        return new WA(e,t)
    }
    static parse(e) {
        return new WA(e).getResult()
    }
    static get BROWSER_MAP() {
        return dP
    }
    static get ENGINE_MAP() {
        return aa
    }
    static get OS_MAP() {
        return Ji
    }
    static get PLATFORMS_MAP() {
        return qn
    }
}
const fie = ({serviceId: n, clientVersion: e})=>async()=>{
    var r, s, o, a, c;
    const t = typeof window < "u" && ((r = window == null ? void 0 : window.navigator) != null && r.userAgent) ? pP.parse(window.navigator.userAgent) : void 0
      , i = [["aws-sdk-js", e], ["ua", "2.0"], [`os/${((s = t == null ? void 0 : t.os) == null ? void 0 : s.name) || "other"}`, (o = t == null ? void 0 : t.os) == null ? void 0 : o.version], ["lang/js"], ["md/browser", `${((a = t == null ? void 0 : t.browser) == null ? void 0 : a.name) ?? "unknown"}_${((c = t == null ? void 0 : t.browser) == null ? void 0 : c.version) ?? "unknown"}`]];
    return n && i.push([`api/${n}`, e]),
    i
}
;
function hie(n) {
    let e = 0
      , t = 0
      , i = null
      , r = null;
    const s = a=>{
        if (typeof a != "number")
            throw new Error("Attempted to allocate an event message where size was not a number: " + a);
        e = a,
        t = 4,
        i = new Uint8Array(a),
        new DataView(i.buffer).setUint32(0, a, !1)
    }
      , o = async function*() {
        const a = n[Symbol.asyncIterator]();
        for (; ; ) {
            const {value: c, done: u} = await a.next();
            if (u) {
                if (e)
                    if (e === t)
                        yield i;
                    else
                        throw new Error("Truncated event message received.");
                else
                    return;
                return
            }
            const h = c.length;
            let m = 0;
            for (; m < h; ) {
                if (!i) {
                    const f = h - m;
                    r || (r = new Uint8Array(4));
                    const _ = Math.min(4 - t, f);
                    if (r.set(c.slice(m, m + _), t),
                    t += _,
                    m += _,
                    t < 4)
                        break;
                    s(new DataView(r.buffer).getUint32(0, !1)),
                    r = null
                }
                const d = Math.min(e - t, h - m);
                i.set(c.slice(m, m + d), t),
                t += d,
                m += d,
                e && e === t && (yield i,
                i = null,
                e = 0,
                t = 0)
            }
        }
    };
    return {
        [Symbol.asyncIterator]: o
    }
}
function die(n, e) {
    return async function(t) {
        const {value: i} = t.headers[":message-type"];
        if (i === "error") {
            const r = new Error(t.headers[":error-message"].value || "UnknownError");
            throw r.name = t.headers[":error-code"].value,
            r
        } else if (i === "exception") {
            const r = t.headers[":exception-type"].value
              , s = {
                [r]: t
            }
              , o = await n(s);
            if (o.$unknown) {
                const a = new Error(e(t.body));
                throw a.name = r,
                a
            }
            throw o[r]
        } else if (i === "event") {
            const r = {
                [t.headers[":event-type"].value]: t
            }
              , s = await n(r);
            return s.$unknown ? void 0 : s
        } else
            throw Error(`Unrecognizable event type: ${t.headers[":event-type"].value}`)
    }
}
let pie = class {
    constructor({utf8Encoder: e, utf8Decoder: t}) {
        this.eventStreamCodec = new RK(e,t),
        this.utfEncoder = e
    }
    deserialize(e, t) {
        const i = hie(e);
        return new DK({
            messageStream: new PK({
                inputStream: i,
                decoder: this.eventStreamCodec
            }),
            deserializer: die(t, this.utfEncoder)
        })
    }
    serialize(e, t) {
        return new LK({
            messageStream: new IK({
                inputStream: e,
                serializer: t
            }),
            encoder: this.eventStreamCodec,
            includeEndFrame: !0
        })
    }
}
;
const mie = n=>({
    [Symbol.asyncIterator]: async function*() {
        const e = n.getReader();
        try {
            for (; ; ) {
                const {done: t, value: i} = await e.read();
                if (t)
                    return;
                yield i
            }
        } finally {
            e.releaseLock()
        }
    }
})
  , gie = n=>{
    const e = n[Symbol.asyncIterator]();
    return new ReadableStream({
        async pull(t) {
            const {done: i, value: r} = await e.next();
            if (i)
                return t.close();
            t.enqueue(r)
        }
    })
}
;
class _ie {
    constructor({utf8Encoder: e, utf8Decoder: t}) {
        this.universalMarshaller = new pie({
            utf8Decoder: t,
            utf8Encoder: e
        })
    }
    deserialize(e, t) {
        const i = vie(e) ? mie(e) : e;
        return this.universalMarshaller.deserialize(i, t)
    }
    serialize(e, t) {
        const i = this.universalMarshaller.serialize(e, t);
        return typeof ReadableStream == "function" ? gie(i) : i
    }
}
const vie = n=>typeof ReadableStream == "function" && n instanceof ReadableStream
  , yie = n=>new _ie(n);
function xie(n, e, t=1024 * 1024) {
    return new Promise((i,r)=>{
        const s = new FileReader;
        s.addEventListener("error", r),
        s.addEventListener("abort", r);
        const o = n.size;
        let a = 0;
        function c() {
            if (a >= o) {
                i();
                return
            }
            s.readAsArrayBuffer(n.slice(a, Math.min(o, a + t)))
        }
        s.addEventListener("load", u=>{
            const h = u.target.result;
            e(new Uint8Array(h)),
            a += h.byteLength,
            c()
        }
        ),
        c()
    }
    )
}
const bie = async function(e, t) {
    const i = new e;
    return await xie(t, r=>{
        i.update(r)
    }
    ),
    i.digest()
}
  , Sie = n=>()=>Promise.reject(n)
  , na = 64
  , wie = 16
  , Eie = [1732584193, 4023233417, 2562383102, 271733878];
class Aie {
    constructor() {
        this.reset()
    }
    update(e) {
        if (Mie(e))
            return;
        if (this.finished)
            throw new Error("Attempted to update an already finished hash.");
        const t = Tie(e);
        let i = 0
          , {byteLength: r} = t;
        for (this.bytesHashed += r; r > 0; )
            this.buffer.setUint8(this.bufferLength++, t[i++]),
            r--,
            this.bufferLength === na && (this.hashBuffer(),
            this.bufferLength = 0)
    }
    async digest() {
        if (!this.finished) {
            const {buffer: t, bufferLength: i, bytesHashed: r} = this
              , s = r * 8;
            if (t.setUint8(this.bufferLength++, 128),
            i % na >= na - 8) {
                for (let o = this.bufferLength; o < na; o++)
                    t.setUint8(o, 0);
                this.hashBuffer(),
                this.bufferLength = 0
            }
            for (let o = this.bufferLength; o < na - 8; o++)
                t.setUint8(o, 0);
            t.setUint32(na - 8, s >>> 0, !0),
            t.setUint32(na - 4, Math.floor(s / 4294967296), !0),
            this.hashBuffer(),
            this.finished = !0
        }
        const e = new DataView(new ArrayBuffer(wie));
        for (let t = 0; t < 4; t++)
            e.setUint32(t * 4, this.state[t], !0);
        return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)
    }
    hashBuffer() {
        const {buffer: e, state: t} = this;
        let i = t[0]
          , r = t[1]
          , s = t[2]
          , o = t[3];
        i = Fi(i, r, s, o, e.getUint32(0, !0), 7, 3614090360),
        o = Fi(o, i, r, s, e.getUint32(4, !0), 12, 3905402710),
        s = Fi(s, o, i, r, e.getUint32(8, !0), 17, 606105819),
        r = Fi(r, s, o, i, e.getUint32(12, !0), 22, 3250441966),
        i = Fi(i, r, s, o, e.getUint32(16, !0), 7, 4118548399),
        o = Fi(o, i, r, s, e.getUint32(20, !0), 12, 1200080426),
        s = Fi(s, o, i, r, e.getUint32(24, !0), 17, 2821735955),
        r = Fi(r, s, o, i, e.getUint32(28, !0), 22, 4249261313),
        i = Fi(i, r, s, o, e.getUint32(32, !0), 7, 1770035416),
        o = Fi(o, i, r, s, e.getUint32(36, !0), 12, 2336552879),
        s = Fi(s, o, i, r, e.getUint32(40, !0), 17, 4294925233),
        r = Fi(r, s, o, i, e.getUint32(44, !0), 22, 2304563134),
        i = Fi(i, r, s, o, e.getUint32(48, !0), 7, 1804603682),
        o = Fi(o, i, r, s, e.getUint32(52, !0), 12, 4254626195),
        s = Fi(s, o, i, r, e.getUint32(56, !0), 17, 2792965006),
        r = Fi(r, s, o, i, e.getUint32(60, !0), 22, 1236535329),
        i = Bi(i, r, s, o, e.getUint32(4, !0), 5, 4129170786),
        o = Bi(o, i, r, s, e.getUint32(24, !0), 9, 3225465664),
        s = Bi(s, o, i, r, e.getUint32(44, !0), 14, 643717713),
        r = Bi(r, s, o, i, e.getUint32(0, !0), 20, 3921069994),
        i = Bi(i, r, s, o, e.getUint32(20, !0), 5, 3593408605),
        o = Bi(o, i, r, s, e.getUint32(40, !0), 9, 38016083),
        s = Bi(s, o, i, r, e.getUint32(60, !0), 14, 3634488961),
        r = Bi(r, s, o, i, e.getUint32(16, !0), 20, 3889429448),
        i = Bi(i, r, s, o, e.getUint32(36, !0), 5, 568446438),
        o = Bi(o, i, r, s, e.getUint32(56, !0), 9, 3275163606),
        s = Bi(s, o, i, r, e.getUint32(12, !0), 14, 4107603335),
        r = Bi(r, s, o, i, e.getUint32(32, !0), 20, 1163531501),
        i = Bi(i, r, s, o, e.getUint32(52, !0), 5, 2850285829),
        o = Bi(o, i, r, s, e.getUint32(8, !0), 9, 4243563512),
        s = Bi(s, o, i, r, e.getUint32(28, !0), 14, 1735328473),
        r = Bi(r, s, o, i, e.getUint32(48, !0), 20, 2368359562),
        i = ki(i, r, s, o, e.getUint32(20, !0), 4, 4294588738),
        o = ki(o, i, r, s, e.getUint32(32, !0), 11, 2272392833),
        s = ki(s, o, i, r, e.getUint32(44, !0), 16, 1839030562),
        r = ki(r, s, o, i, e.getUint32(56, !0), 23, 4259657740),
        i = ki(i, r, s, o, e.getUint32(4, !0), 4, 2763975236),
        o = ki(o, i, r, s, e.getUint32(16, !0), 11, 1272893353),
        s = ki(s, o, i, r, e.getUint32(28, !0), 16, 4139469664),
        r = ki(r, s, o, i, e.getUint32(40, !0), 23, 3200236656),
        i = ki(i, r, s, o, e.getUint32(52, !0), 4, 681279174),
        o = ki(o, i, r, s, e.getUint32(0, !0), 11, 3936430074),
        s = ki(s, o, i, r, e.getUint32(12, !0), 16, 3572445317),
        r = ki(r, s, o, i, e.getUint32(24, !0), 23, 76029189),
        i = ki(i, r, s, o, e.getUint32(36, !0), 4, 3654602809),
        o = ki(o, i, r, s, e.getUint32(48, !0), 11, 3873151461),
        s = ki(s, o, i, r, e.getUint32(60, !0), 16, 530742520),
        r = ki(r, s, o, i, e.getUint32(8, !0), 23, 3299628645),
        i = zi(i, r, s, o, e.getUint32(0, !0), 6, 4096336452),
        o = zi(o, i, r, s, e.getUint32(28, !0), 10, 1126891415),
        s = zi(s, o, i, r, e.getUint32(56, !0), 15, 2878612391),
        r = zi(r, s, o, i, e.getUint32(20, !0), 21, 4237533241),
        i = zi(i, r, s, o, e.getUint32(48, !0), 6, 1700485571),
        o = zi(o, i, r, s, e.getUint32(12, !0), 10, 2399980690),
        s = zi(s, o, i, r, e.getUint32(40, !0), 15, 4293915773),
        r = zi(r, s, o, i, e.getUint32(4, !0), 21, 2240044497),
        i = zi(i, r, s, o, e.getUint32(32, !0), 6, 1873313359),
        o = zi(o, i, r, s, e.getUint32(60, !0), 10, 4264355552),
        s = zi(s, o, i, r, e.getUint32(24, !0), 15, 2734768916),
        r = zi(r, s, o, i, e.getUint32(52, !0), 21, 1309151649),
        i = zi(i, r, s, o, e.getUint32(16, !0), 6, 4149444226),
        o = zi(o, i, r, s, e.getUint32(44, !0), 10, 3174756917),
        s = zi(s, o, i, r, e.getUint32(8, !0), 15, 718787259),
        r = zi(r, s, o, i, e.getUint32(36, !0), 21, 3951481745),
        t[0] = i + t[0] & 4294967295,
        t[1] = r + t[1] & 4294967295,
        t[2] = s + t[2] & 4294967295,
        t[3] = o + t[3] & 4294967295
    }
    reset() {
        this.state = Uint32Array.from(Eie),
        this.buffer = new DataView(new ArrayBuffer(na)),
        this.bufferLength = 0,
        this.bytesHashed = 0,
        this.finished = !1
    }
}
function ym(n, e, t, i, r, s) {
    return e = (e + n & 4294967295) + (i + s & 4294967295) & 4294967295,
    (e << r | e >>> 32 - r) + t & 4294967295
}
function Fi(n, e, t, i, r, s, o) {
    return ym(e & t | ~e & i, n, e, r, s, o)
}
function Bi(n, e, t, i, r, s, o) {
    return ym(e & i | t & ~i, n, e, r, s, o)
}
function ki(n, e, t, i, r, s, o) {
    return ym(e ^ t ^ i, n, e, r, s, o)
}
function zi(n, e, t, i, r, s, o) {
    return ym(t ^ (e | ~i), n, e, r, s, o)
}
function Mie(n) {
    return typeof n == "string" ? n.length === 0 : n.byteLength === 0
}
function Tie(n) {
    return typeof n == "string" ? lh(n) : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer,n.byteOffset,n.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(n)
}
const $A = typeof TextEncoder == "function" ? new TextEncoder : null
  , Cie = n=>{
    if (typeof n == "string") {
        if ($A)
            return $A.encode(n).byteLength;
        let e = n.length;
        for (let t = e - 1; t >= 0; t--) {
            const i = n.charCodeAt(t);
            i > 127 && i <= 2047 ? e++ : i > 2047 && i <= 65535 && (e += 2),
            i >= 56320 && i <= 57343 && t--
        }
        return e
    } else {
        if (typeof n.byteLength == "number")
            return n.byteLength;
        if (typeof n.size == "number")
            return n.size
    }
    throw new Error(`Body Length computation failed for ${n}`)
}
  , Rie = {
    CrtSignerV4: null
};
class mP {
    constructor(e) {
        this.sigv4Signer = new oZ(e),
        this.signerOptions = e
    }
    async sign(e, t={}) {
        if (t.signingRegion === "*") {
            if (this.signerOptions.runtime !== "node")
                throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
            return this.getSigv4aSigner().sign(e, t)
        }
        return this.sigv4Signer.sign(e, t)
    }
    async signWithCredentials(e, t, i={}) {
        if (i.signingRegion === "*") {
            if (this.signerOptions.runtime !== "node")
                throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
            return this.getSigv4aSigner().signWithCredentials(e, t, i)
        }
        return this.sigv4Signer.signWithCredentials(e, t, i)
    }
    async presign(e, t={}) {
        if (t.signingRegion === "*") {
            if (this.signerOptions.runtime !== "node")
                throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
            return this.getSigv4aSigner().presign(e, t)
        }
        return this.sigv4Signer.presign(e, t)
    }
    async presignWithCredentials(e, t, i={}) {
        if (i.signingRegion === "*")
            throw new Error("Method presignWithCredentials is not supported for [signingRegion=*].");
        return this.sigv4Signer.presignWithCredentials(e, t, i)
    }
    getSigv4aSigner() {
        if (!this.sigv4aSigner) {
            let e = null;
            try {
                if (e = Rie.CrtSignerV4,
                typeof e != "function")
                    throw new Error
            } catch (t) {
                throw t.message = `${t.message}
Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. 
You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`,
                t
            }
            this.sigv4aSigner = new e({
                ...this.signerOptions,
                signingAlgorithm: 1
            })
        }
        return this.sigv4aSigner
    }
}
const lx = "required"
  , W = "type"
  , K = "conditions"
  , Se = "fn"
  , we = "argv"
  , Mt = "ref"
  , Gn = "assign"
  , Ke = "url"
  , Ze = "properties"
  , gP = "backend"
  , Bs = "authSchemes"
  , ks = "disableDoubleEncoding"
  , zs = "signingName"
  , oo = "signingRegion"
  , Je = "headers"
  , Pie = !1
  , Rs = !0
  , gs = "isSet"
  , Si = "booleanEquals"
  , rt = "error"
  , zp = "aws.partition"
  , Dn = "stringEquals"
  , Yn = "getAttr"
  , Ir = "name"
  , js = "substring"
  , XA = "bucketSuffix"
  , _P = "parseURL"
  , qA = "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}"
  , Oe = "endpoint"
  , Ie = "tree"
  , vP = "aws.isVirtualHostableS3Bucket"
  , cp = "{url#scheme}://{Bucket}.{url#authority}{url#path}"
  , no = "not"
  , up = "{url#scheme}://{url#authority}{url#path}"
  , yP = "hardwareType"
  , xP = "regionPrefix"
  , jA = "bucketAliasSuffix"
  , Kv = "outpostId"
  , Ul = "isValidHostLabel"
  , cx = "s3-outposts"
  , Jc = "s3"
  , bP = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}"
  , SP = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}"
  , YA = "https://{Bucket}.s3.{partitionResult#dnsSuffix}"
  , wP = "aws.parseArn"
  , EP = "bucketArn"
  , AP = "arnType"
  , Hp = ""
  , ux = "s3-object-lambda"
  , MP = "accesspoint"
  , fx = "accessPointName"
  , KA = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}"
  , ZA = "mrapPartition"
  , JA = "outpostType"
  , QA = "arnPrefix"
  , TP = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}"
  , eM = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}"
  , tM = "https://s3.{partitionResult#dnsSuffix}"
  , nf = {
    [lx]: !1,
    [W]: "String"
}
  , xc = {
    [lx]: !0,
    default: !1,
    [W]: "Boolean"
}
  , rf = {
    [lx]: !1,
    [W]: "Boolean"
}
  , Ls = {
    [Se]: Si,
    [we]: [{
        [Mt]: "Accelerate"
    }, !0]
}
  , An = {
    [Se]: Si,
    [we]: [{
        [Mt]: "UseFIPS"
    }, !0]
}
  , En = {
    [Se]: Si,
    [we]: [{
        [Mt]: "UseDualStack"
    }, !0]
}
  , Qn = {
    [Se]: gs,
    [we]: [{
        [Mt]: "Endpoint"
    }]
}
  , CP = {
    [Se]: zp,
    [we]: [{
        [Mt]: "Region"
    }],
    [Gn]: "partitionResult"
}
  , nM = {
    [Se]: Dn,
    [we]: [{
        [Se]: Yn,
        [we]: [{
            [Mt]: "partitionResult"
        }, Ir]
    }, "aws-cn"]
}
  , Gp = {
    [Se]: gs,
    [we]: [{
        [Mt]: "Bucket"
    }]
}
  , or = {
    [Mt]: "Bucket"
}
  , Qi = {
    [Se]: _P,
    [we]: [{
        [Mt]: "Endpoint"
    }],
    [Gn]: "url"
}
  , fp = {
    [Se]: Si,
    [we]: [{
        [Se]: Yn,
        [we]: [{
            [Mt]: "url"
        }, "isIp"]
    }, !0]
}
  , RP = {
    [Mt]: "url"
}
  , PP = {
    [Se]: "uriEncode",
    [we]: [or],
    [Gn]: "uri_encoded_bucket"
}
  , Ao = {
    [gP]: "S3Express",
    [Bs]: [{
        [ks]: !0,
        [Ir]: "sigv4",
        [zs]: "s3express",
        [oo]: "{Region}"
    }]
}
  , Rt = {}
  , LP = {
    [Se]: vP,
    [we]: [or, !1]
}
  , Q0 = {
    [rt]: "S3Express bucket name is not a valid virtual hostable name.",
    [W]: rt
}
  , Vp = {
    [gP]: "S3Express",
    [Bs]: [{
        [ks]: !0,
        [Ir]: "sigv4-s3express",
        [zs]: "s3express",
        [oo]: "{Region}"
    }]
}
  , iM = {
    [Se]: gs,
    [we]: [{
        [Mt]: "UseS3ExpressControlEndpoint"
    }]
}
  , rM = {
    [Se]: Si,
    [we]: [{
        [Mt]: "UseS3ExpressControlEndpoint"
    }, !0]
}
  , Ut = {
    [Se]: no,
    [we]: [Qn]
}
  , sM = {
    [rt]: "Unrecognized S3Express bucket name format.",
    [W]: rt
}
  , oM = {
    [Se]: no,
    [we]: [Gp]
}
  , aM = {
    [Mt]: yP
}
  , lM = {
    [K]: [Ut],
    [rt]: "Expected a endpoint to be specified but no endpoint was found",
    [W]: rt
}
  , Gd = {
    [Bs]: [{
        [ks]: !0,
        [Ir]: "sigv4",
        [zs]: cx,
        [oo]: "{Region}"
    }]
}
  , e_ = {
    [Se]: Si,
    [we]: [{
        [Mt]: "ForcePathStyle"
    }, !1]
}
  , Lie = {
    [Mt]: "ForcePathStyle"
}
  , Jn = {
    [Se]: Si,
    [we]: [{
        [Mt]: "Accelerate"
    }, !1]
}
  , li = {
    [Se]: Dn,
    [we]: [{
        [Mt]: "Region"
    }, "aws-global"]
}
  , pi = {
    [Bs]: [{
        [ks]: !0,
        [Ir]: "sigv4",
        [zs]: Jc,
        [oo]: "us-east-1"
    }]
}
  , en = {
    [Se]: no,
    [we]: [li]
}
  , mi = {
    [Se]: Si,
    [we]: [{
        [Mt]: "UseGlobalEndpoint"
    }, !0]
}
  , cM = {
    [Ke]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}",
    [Ze]: {
        [Bs]: [{
            [ks]: !0,
            [Ir]: "sigv4",
            [zs]: Jc,
            [oo]: "{Region}"
        }]
    },
    [Je]: {}
}
  , ri = {
    [Bs]: [{
        [ks]: !0,
        [Ir]: "sigv4",
        [zs]: Jc,
        [oo]: "{Region}"
    }]
}
  , gi = {
    [Se]: Si,
    [we]: [{
        [Mt]: "UseGlobalEndpoint"
    }, !1]
}
  , Kt = {
    [Se]: Si,
    [we]: [{
        [Mt]: "UseDualStack"
    }, !1]
}
  , uM = {
    [Ke]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}",
    [Ze]: ri,
    [Je]: {}
}
  , Gt = {
    [Se]: Si,
    [we]: [{
        [Mt]: "UseFIPS"
    }, !1]
}
  , fM = {
    [Ke]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}",
    [Ze]: ri,
    [Je]: {}
}
  , hM = {
    [Ke]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}",
    [Ze]: ri,
    [Je]: {}
}
  , t_ = {
    [Se]: Si,
    [we]: [{
        [Se]: Yn,
        [we]: [RP, "isIp"]
    }, !1]
}
  , n_ = {
    [Ke]: bP,
    [Ze]: ri,
    [Je]: {}
}
  , Zv = {
    [Ke]: cp,
    [Ze]: ri,
    [Je]: {}
}
  , dM = {
    [Oe]: Zv,
    [W]: Oe
}
  , i_ = {
    [Ke]: SP,
    [Ze]: ri,
    [Je]: {}
}
  , pM = {
    [Ke]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}",
    [Ze]: ri,
    [Je]: {}
}
  , Vd = {
    [rt]: "Invalid region: region was not a valid DNS name.",
    [W]: rt
}
  , Mr = {
    [Mt]: EP
}
  , DP = {
    [Mt]: AP
}
  , r_ = {
    [Se]: Yn,
    [we]: [Mr, "service"]
}
  , hx = {
    [Mt]: fx
}
  , mM = {
    [K]: [En],
    [rt]: "S3 Object Lambda does not support Dual-stack",
    [W]: rt
}
  , gM = {
    [K]: [Ls],
    [rt]: "S3 Object Lambda does not support S3 Accelerate",
    [W]: rt
}
  , _M = {
    [K]: [{
        [Se]: gs,
        [we]: [{
            [Mt]: "DisableAccessPoints"
        }]
    }, {
        [Se]: Si,
        [we]: [{
            [Mt]: "DisableAccessPoints"
        }, !0]
    }],
    [rt]: "Access points are not supported for this operation",
    [W]: rt
}
  , s_ = {
    [K]: [{
        [Se]: gs,
        [we]: [{
            [Mt]: "UseArnRegion"
        }]
    }, {
        [Se]: Si,
        [we]: [{
            [Mt]: "UseArnRegion"
        }, !1]
    }, {
        [Se]: no,
        [we]: [{
            [Se]: Dn,
            [we]: [{
                [Se]: Yn,
                [we]: [Mr, "region"]
            }, "{Region}"]
        }]
    }],
    [rt]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`",
    [W]: rt
}
  , IP = {
    [Se]: Yn,
    [we]: [{
        [Mt]: "bucketPartition"
    }, Ir]
}
  , OP = {
    [Se]: Yn,
    [we]: [Mr, "accountId"]
}
  , o_ = {
    [Bs]: [{
        [ks]: !0,
        [Ir]: "sigv4",
        [zs]: ux,
        [oo]: "{bucketArn#region}"
    }]
}
  , vM = {
    [rt]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`",
    [W]: rt
}
  , a_ = {
    [rt]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`",
    [W]: rt
}
  , l_ = {
    [rt]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)",
    [W]: rt
}
  , c_ = {
    [rt]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`",
    [W]: rt
}
  , yM = {
    [rt]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.",
    [W]: rt
}
  , xM = {
    [rt]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided",
    [W]: rt
}
  , sf = {
    [Bs]: [{
        [ks]: !0,
        [Ir]: "sigv4",
        [zs]: Jc,
        [oo]: "{bucketArn#region}"
    }]
}
  , bM = {
    [Bs]: [{
        [ks]: !0,
        [Ir]: "sigv4",
        [zs]: cx,
        [oo]: "{bucketArn#region}"
    }]
}
  , SM = {
    [Se]: wP,
    [we]: [or]
}
  , wM = {
    [Ke]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
    [Ze]: ri,
    [Je]: {}
}
  , EM = {
    [Ke]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
    [Ze]: ri,
    [Je]: {}
}
  , AM = {
    [Ke]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
    [Ze]: ri,
    [Je]: {}
}
  , u_ = {
    [Ke]: TP,
    [Ze]: ri,
    [Je]: {}
}
  , MM = {
    [Ke]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
    [Ze]: ri,
    [Je]: {}
}
  , TM = {
    [Mt]: "UseObjectLambdaEndpoint"
}
  , f_ = {
    [Bs]: [{
        [ks]: !0,
        [Ir]: "sigv4",
        [zs]: ux,
        [oo]: "{Region}"
    }]
}
  , CM = {
    [Ke]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}",
    [Ze]: ri,
    [Je]: {}
}
  , RM = {
    [Ke]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}",
    [Ze]: ri,
    [Je]: {}
}
  , PM = {
    [Ke]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}",
    [Ze]: ri,
    [Je]: {}
}
  , h_ = {
    [Ke]: up,
    [Ze]: ri,
    [Je]: {}
}
  , LM = {
    [Ke]: "https://s3.{Region}.{partitionResult#dnsSuffix}",
    [Ze]: ri,
    [Je]: {}
}
  , d_ = [{
    [Mt]: "Region"
}]
  , Die = [{
    [Mt]: "Endpoint"
}]
  , Iie = [or]
  , p_ = [En]
  , Wd = [Ls]
  , Za = [Qn, Qi]
  , DM = [{
    [Se]: gs,
    [we]: [{
        [Mt]: "DisableS3ExpressSessionAuth"
    }]
}, {
    [Se]: Si,
    [we]: [{
        [Mt]: "DisableS3ExpressSessionAuth"
    }, !0]
}]
  , IM = [fp]
  , m_ = [PP]
  , g_ = [LP]
  , bc = [An]
  , OM = [{
    [Se]: js,
    [we]: [or, 6, 14, !0],
    [Gn]: "s3expressAvailabilityZoneId"
}, {
    [Se]: js,
    [we]: [or, 14, 16, !0],
    [Gn]: "s3expressAvailabilityZoneDelim"
}, {
    [Se]: Dn,
    [we]: [{
        [Mt]: "s3expressAvailabilityZoneDelim"
    }, "--"]
}]
  , NM = [{
    [K]: [An],
    [Oe]: {
        [Ke]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com",
        [Ze]: Ao,
        [Je]: {}
    },
    [W]: Oe
}, {
    [Oe]: {
        [Ke]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com",
        [Ze]: Ao,
        [Je]: {}
    },
    [W]: Oe
}]
  , UM = [{
    [Se]: js,
    [we]: [or, 6, 15, !0],
    [Gn]: "s3expressAvailabilityZoneId"
}, {
    [Se]: js,
    [we]: [or, 15, 17, !0],
    [Gn]: "s3expressAvailabilityZoneDelim"
}, {
    [Se]: Dn,
    [we]: [{
        [Mt]: "s3expressAvailabilityZoneDelim"
    }, "--"]
}]
  , FM = [{
    [K]: [An],
    [Oe]: {
        [Ke]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com",
        [Ze]: Vp,
        [Je]: {}
    },
    [W]: Oe
}, {
    [Oe]: {
        [Ke]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com",
        [Ze]: Vp,
        [Je]: {}
    },
    [W]: Oe
}]
  , Oie = [Gp]
  , BM = [{
    [Se]: Ul,
    [we]: [{
        [Mt]: Kv
    }, !1]
}]
  , kM = [{
    [Se]: Dn,
    [we]: [{
        [Mt]: xP
    }, "beta"]
}]
  , ia = [CP]
  , zM = [{
    [Se]: Ul,
    [we]: [{
        [Mt]: "Region"
    }, !1]
}]
  , ra = [{
    [Se]: Dn,
    [we]: [{
        [Mt]: "Region"
    }, "us-east-1"]
}]
  , __ = [{
    [Se]: Dn,
    [we]: [DP, MP]
}]
  , HM = [{
    [Se]: Yn,
    [we]: [Mr, "resourceId[1]"],
    [Gn]: fx
}, {
    [Se]: no,
    [we]: [{
        [Se]: Dn,
        [we]: [hx, Hp]
    }]
}]
  , Nie = [Mr, "resourceId[1]"]
  , v_ = [{
    [Se]: no,
    [we]: [{
        [Se]: Dn,
        [we]: [{
            [Se]: Yn,
            [we]: [Mr, "region"]
        }, Hp]
    }]
}]
  , GM = [{
    [Se]: no,
    [we]: [{
        [Se]: gs,
        [we]: [{
            [Se]: Yn,
            [we]: [Mr, "resourceId[2]"]
        }]
    }]
}]
  , Uie = [Mr, "resourceId[2]"]
  , y_ = [{
    [Se]: zp,
    [we]: [{
        [Se]: Yn,
        [we]: [Mr, "region"]
    }],
    [Gn]: "bucketPartition"
}]
  , VM = [{
    [Se]: Dn,
    [we]: [IP, {
        [Se]: Yn,
        [we]: [{
            [Mt]: "partitionResult"
        }, Ir]
    }]
}]
  , x_ = [{
    [Se]: Ul,
    [we]: [{
        [Se]: Yn,
        [we]: [Mr, "region"]
    }, !0]
}]
  , b_ = [{
    [Se]: Ul,
    [we]: [OP, !1]
}]
  , WM = [{
    [Se]: Ul,
    [we]: [hx, !1]
}]
  , $M = [{
    [Se]: Ul,
    [we]: [{
        [Mt]: "Region"
    }, !0]
}]
  , Fie = {
    version: "1.0",
    parameters: {
        Bucket: nf,
        Region: nf,
        UseFIPS: xc,
        UseDualStack: xc,
        Endpoint: nf,
        ForcePathStyle: xc,
        Accelerate: xc,
        UseGlobalEndpoint: xc,
        UseObjectLambdaEndpoint: rf,
        Key: nf,
        Prefix: nf,
        DisableAccessPoints: rf,
        DisableMultiRegionAccessPoints: xc,
        UseArnRegion: rf,
        UseS3ExpressControlEndpoint: rf,
        DisableS3ExpressSessionAuth: rf
    },
    rules: [{
        [K]: [{
            [Se]: gs,
            [we]: d_
        }],
        rules: [{
            [K]: [Ls, An],
            error: "Accelerate cannot be used with FIPS",
            [W]: rt
        }, {
            [K]: [En, Qn],
            error: "Cannot set dual-stack in combination with a custom endpoint.",
            [W]: rt
        }, {
            [K]: [Qn, An],
            error: "A custom endpoint cannot be combined with FIPS",
            [W]: rt
        }, {
            [K]: [Qn, Ls],
            error: "A custom endpoint cannot be combined with S3 Accelerate",
            [W]: rt
        }, {
            [K]: [An, CP, nM],
            error: "Partition does not support FIPS",
            [W]: rt
        }, {
            [K]: [Gp, {
                [Se]: js,
                [we]: [or, 0, 6, Rs],
                [Gn]: XA
            }, {
                [Se]: Dn,
                [we]: [{
                    [Mt]: XA
                }, "--x-s3"]
            }],
            rules: [{
                [K]: p_,
                error: "S3Express does not support Dual-stack.",
                [W]: rt
            }, {
                [K]: Wd,
                error: "S3Express does not support S3 Accelerate.",
                [W]: rt
            }, {
                [K]: Za,
                rules: [{
                    [K]: DM,
                    rules: [{
                        [K]: IM,
                        rules: [{
                            [K]: m_,
                            rules: [{
                                endpoint: {
                                    [Ke]: qA,
                                    [Ze]: Ao,
                                    [Je]: Rt
                                },
                                [W]: Oe
                            }],
                            [W]: Ie
                        }],
                        [W]: Ie
                    }, {
                        [K]: g_,
                        rules: [{
                            endpoint: {
                                [Ke]: cp,
                                [Ze]: Ao,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }],
                        [W]: Ie
                    }, Q0],
                    [W]: Ie
                }, {
                    [K]: IM,
                    rules: [{
                        [K]: m_,
                        rules: [{
                            endpoint: {
                                [Ke]: qA,
                                [Ze]: Vp,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }],
                        [W]: Ie
                    }],
                    [W]: Ie
                }, {
                    [K]: g_,
                    rules: [{
                        endpoint: {
                            [Ke]: cp,
                            [Ze]: Vp,
                            [Je]: Rt
                        },
                        [W]: Oe
                    }],
                    [W]: Ie
                }, Q0],
                [W]: Ie
            }, {
                [K]: [iM, rM],
                rules: [{
                    [K]: [PP, Ut],
                    rules: [{
                        [K]: bc,
                        endpoint: {
                            [Ke]: "https://s3express-control-fips.{Region}.amazonaws.com/{uri_encoded_bucket}",
                            [Ze]: Ao,
                            [Je]: Rt
                        },
                        [W]: Oe
                    }, {
                        endpoint: {
                            [Ke]: "https://s3express-control.{Region}.amazonaws.com/{uri_encoded_bucket}",
                            [Ze]: Ao,
                            [Je]: Rt
                        },
                        [W]: Oe
                    }],
                    [W]: Ie
                }],
                [W]: Ie
            }, {
                [K]: g_,
                rules: [{
                    [K]: DM,
                    rules: [{
                        [K]: OM,
                        rules: NM,
                        [W]: Ie
                    }, {
                        [K]: UM,
                        rules: NM,
                        [W]: Ie
                    }, sM],
                    [W]: Ie
                }, {
                    [K]: OM,
                    rules: FM,
                    [W]: Ie
                }, {
                    [K]: UM,
                    rules: FM,
                    [W]: Ie
                }, sM],
                [W]: Ie
            }, Q0],
            [W]: Ie
        }, {
            [K]: [oM, iM, rM],
            rules: [{
                [K]: Za,
                endpoint: {
                    [Ke]: up,
                    [Ze]: Ao,
                    [Je]: Rt
                },
                [W]: Oe
            }, {
                [K]: bc,
                endpoint: {
                    [Ke]: "https://s3express-control-fips.{Region}.amazonaws.com",
                    [Ze]: Ao,
                    [Je]: Rt
                },
                [W]: Oe
            }, {
                endpoint: {
                    [Ke]: "https://s3express-control.{Region}.amazonaws.com",
                    [Ze]: Ao,
                    [Je]: Rt
                },
                [W]: Oe
            }],
            [W]: Ie
        }, {
            [K]: [Gp, {
                [Se]: js,
                [we]: [or, 49, 50, Rs],
                [Gn]: yP
            }, {
                [Se]: js,
                [we]: [or, 8, 12, Rs],
                [Gn]: xP
            }, {
                [Se]: js,
                [we]: [or, 0, 7, Rs],
                [Gn]: jA
            }, {
                [Se]: js,
                [we]: [or, 32, 49, Rs],
                [Gn]: Kv
            }, {
                [Se]: zp,
                [we]: d_,
                [Gn]: "regionPartition"
            }, {
                [Se]: Dn,
                [we]: [{
                    [Mt]: jA
                }, "--op-s3"]
            }],
            rules: [{
                [K]: BM,
                rules: [{
                    [K]: [{
                        [Se]: Dn,
                        [we]: [aM, "e"]
                    }],
                    rules: [{
                        [K]: kM,
                        rules: [lM, {
                            [K]: Za,
                            endpoint: {
                                [Ke]: "https://{Bucket}.ec2.{url#authority}",
                                [Ze]: Gd,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }],
                        [W]: Ie
                    }, {
                        endpoint: {
                            [Ke]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}",
                            [Ze]: Gd,
                            [Je]: Rt
                        },
                        [W]: Oe
                    }],
                    [W]: Ie
                }, {
                    [K]: [{
                        [Se]: Dn,
                        [we]: [aM, "o"]
                    }],
                    rules: [{
                        [K]: kM,
                        rules: [lM, {
                            [K]: Za,
                            endpoint: {
                                [Ke]: "https://{Bucket}.op-{outpostId}.{url#authority}",
                                [Ze]: Gd,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }],
                        [W]: Ie
                    }, {
                        endpoint: {
                            [Ke]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}",
                            [Ze]: Gd,
                            [Je]: Rt
                        },
                        [W]: Oe
                    }],
                    [W]: Ie
                }, {
                    error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"',
                    [W]: rt
                }],
                [W]: Ie
            }, {
                error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.",
                [W]: rt
            }],
            [W]: Ie
        }, {
            [K]: Oie,
            rules: [{
                [K]: [Qn, {
                    [Se]: no,
                    [we]: [{
                        [Se]: gs,
                        [we]: [{
                            [Se]: _P,
                            [we]: Die
                        }]
                    }]
                }],
                error: "Custom endpoint `{Endpoint}` was not a valid URI",
                [W]: rt
            }, {
                [K]: [e_, LP],
                rules: [{
                    [K]: ia,
                    rules: [{
                        [K]: zM,
                        rules: [{
                            [K]: [Ls, nM],
                            error: "S3 Accelerate cannot be used in this region",
                            [W]: rt
                        }, {
                            [K]: [En, An, Jn, Ut, li],
                            endpoint: {
                                [Ke]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}",
                                [Ze]: pi,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }, {
                            [K]: [En, An, Jn, Ut, en, mi],
                            rules: [{
                                endpoint: cM,
                                [W]: Oe
                            }],
                            [W]: Ie
                        }, {
                            [K]: [En, An, Jn, Ut, en, gi],
                            endpoint: cM,
                            [W]: Oe
                        }, {
                            [K]: [Kt, An, Jn, Ut, li],
                            endpoint: {
                                [Ke]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}",
                                [Ze]: pi,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }, {
                            [K]: [Kt, An, Jn, Ut, en, mi],
                            rules: [{
                                endpoint: uM,
                                [W]: Oe
                            }],
                            [W]: Ie
                        }, {
                            [K]: [Kt, An, Jn, Ut, en, gi],
                            endpoint: uM,
                            [W]: Oe
                        }, {
                            [K]: [En, Gt, Ls, Ut, li],
                            endpoint: {
                                [Ke]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}",
                                [Ze]: pi,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }, {
                            [K]: [En, Gt, Ls, Ut, en, mi],
                            rules: [{
                                endpoint: fM,
                                [W]: Oe
                            }],
                            [W]: Ie
                        }, {
                            [K]: [En, Gt, Ls, Ut, en, gi],
                            endpoint: fM,
                            [W]: Oe
                        }, {
                            [K]: [En, Gt, Jn, Ut, li],
                            endpoint: {
                                [Ke]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}",
                                [Ze]: pi,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }, {
                            [K]: [En, Gt, Jn, Ut, en, mi],
                            rules: [{
                                endpoint: hM,
                                [W]: Oe
                            }],
                            [W]: Ie
                        }, {
                            [K]: [En, Gt, Jn, Ut, en, gi],
                            endpoint: hM,
                            [W]: Oe
                        }, {
                            [K]: [Kt, Gt, Jn, Qn, Qi, fp, li],
                            endpoint: {
                                [Ke]: bP,
                                [Ze]: pi,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }, {
                            [K]: [Kt, Gt, Jn, Qn, Qi, t_, li],
                            endpoint: {
                                [Ke]: cp,
                                [Ze]: pi,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }, {
                            [K]: [Kt, Gt, Jn, Qn, Qi, fp, en, mi],
                            rules: [{
                                [K]: ra,
                                endpoint: n_,
                                [W]: Oe
                            }, {
                                endpoint: n_,
                                [W]: Oe
                            }],
                            [W]: Ie
                        }, {
                            [K]: [Kt, Gt, Jn, Qn, Qi, t_, en, mi],
                            rules: [{
                                [K]: ra,
                                endpoint: Zv,
                                [W]: Oe
                            }, dM],
                            [W]: Ie
                        }, {
                            [K]: [Kt, Gt, Jn, Qn, Qi, fp, en, gi],
                            endpoint: n_,
                            [W]: Oe
                        }, {
                            [K]: [Kt, Gt, Jn, Qn, Qi, t_, en, gi],
                            endpoint: Zv,
                            [W]: Oe
                        }, {
                            [K]: [Kt, Gt, Ls, Ut, li],
                            endpoint: {
                                [Ke]: SP,
                                [Ze]: pi,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }, {
                            [K]: [Kt, Gt, Ls, Ut, en, mi],
                            rules: [{
                                [K]: ra,
                                endpoint: i_,
                                [W]: Oe
                            }, {
                                endpoint: i_,
                                [W]: Oe
                            }],
                            [W]: Ie
                        }, {
                            [K]: [Kt, Gt, Ls, Ut, en, gi],
                            endpoint: i_,
                            [W]: Oe
                        }, {
                            [K]: [Kt, Gt, Jn, Ut, li],
                            endpoint: {
                                [Ke]: YA,
                                [Ze]: pi,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }, {
                            [K]: [Kt, Gt, Jn, Ut, en, mi],
                            rules: [{
                                [K]: ra,
                                endpoint: {
                                    [Ke]: YA,
                                    [Ze]: ri,
                                    [Je]: Rt
                                },
                                [W]: Oe
                            }, {
                                endpoint: pM,
                                [W]: Oe
                            }],
                            [W]: Ie
                        }, {
                            [K]: [Kt, Gt, Jn, Ut, en, gi],
                            endpoint: pM,
                            [W]: Oe
                        }],
                        [W]: Ie
                    }, Vd],
                    [W]: Ie
                }],
                [W]: Ie
            }, {
                [K]: [Qn, Qi, {
                    [Se]: Dn,
                    [we]: [{
                        [Se]: Yn,
                        [we]: [RP, "scheme"]
                    }, "http"]
                }, {
                    [Se]: vP,
                    [we]: [or, Rs]
                }, e_, Gt, Kt, Jn],
                rules: [{
                    [K]: ia,
                    rules: [{
                        [K]: zM,
                        rules: [dM],
                        [W]: Ie
                    }, Vd],
                    [W]: Ie
                }],
                [W]: Ie
            }, {
                [K]: [e_, {
                    [Se]: wP,
                    [we]: Iie,
                    [Gn]: EP
                }],
                rules: [{
                    [K]: [{
                        [Se]: Yn,
                        [we]: [Mr, "resourceId[0]"],
                        [Gn]: AP
                    }, {
                        [Se]: no,
                        [we]: [{
                            [Se]: Dn,
                            [we]: [DP, Hp]
                        }]
                    }],
                    rules: [{
                        [K]: [{
                            [Se]: Dn,
                            [we]: [r_, ux]
                        }],
                        rules: [{
                            [K]: __,
                            rules: [{
                                [K]: HM,
                                rules: [mM, gM, {
                                    [K]: v_,
                                    rules: [_M, {
                                        [K]: GM,
                                        rules: [s_, {
                                            [K]: y_,
                                            rules: [{
                                                [K]: ia,
                                                rules: [{
                                                    [K]: VM,
                                                    rules: [{
                                                        [K]: x_,
                                                        rules: [{
                                                            [K]: [{
                                                                [Se]: Dn,
                                                                [we]: [OP, Hp]
                                                            }],
                                                            error: "Invalid ARN: Missing account id",
                                                            [W]: rt
                                                        }, {
                                                            [K]: b_,
                                                            rules: [{
                                                                [K]: WM,
                                                                rules: [{
                                                                    [K]: Za,
                                                                    endpoint: {
                                                                        [Ke]: KA,
                                                                        [Ze]: o_,
                                                                        [Je]: Rt
                                                                    },
                                                                    [W]: Oe
                                                                }, {
                                                                    [K]: bc,
                                                                    endpoint: {
                                                                        [Ke]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                        [Ze]: o_,
                                                                        [Je]: Rt
                                                                    },
                                                                    [W]: Oe
                                                                }, {
                                                                    endpoint: {
                                                                        [Ke]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                        [Ze]: o_,
                                                                        [Je]: Rt
                                                                    },
                                                                    [W]: Oe
                                                                }],
                                                                [W]: Ie
                                                            }, vM],
                                                            [W]: Ie
                                                        }, a_],
                                                        [W]: Ie
                                                    }, l_],
                                                    [W]: Ie
                                                }, c_],
                                                [W]: Ie
                                            }],
                                            [W]: Ie
                                        }],
                                        [W]: Ie
                                    }, yM],
                                    [W]: Ie
                                }, {
                                    error: "Invalid ARN: bucket ARN is missing a region",
                                    [W]: rt
                                }],
                                [W]: Ie
                            }, xM],
                            [W]: Ie
                        }, {
                            error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`",
                            [W]: rt
                        }],
                        [W]: Ie
                    }, {
                        [K]: __,
                        rules: [{
                            [K]: HM,
                            rules: [{
                                [K]: v_,
                                rules: [{
                                    [K]: __,
                                    rules: [{
                                        [K]: v_,
                                        rules: [_M, {
                                            [K]: GM,
                                            rules: [s_, {
                                                [K]: y_,
                                                rules: [{
                                                    [K]: ia,
                                                    rules: [{
                                                        [K]: [{
                                                            [Se]: Dn,
                                                            [we]: [IP, "{partitionResult#name}"]
                                                        }],
                                                        rules: [{
                                                            [K]: x_,
                                                            rules: [{
                                                                [K]: [{
                                                                    [Se]: Dn,
                                                                    [we]: [r_, Jc]
                                                                }],
                                                                rules: [{
                                                                    [K]: b_,
                                                                    rules: [{
                                                                        [K]: WM,
                                                                        rules: [{
                                                                            [K]: Wd,
                                                                            error: "Access Points do not support S3 Accelerate",
                                                                            [W]: rt
                                                                        }, {
                                                                            [K]: [An, En],
                                                                            endpoint: {
                                                                                [Ke]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                                [Ze]: sf,
                                                                                [Je]: Rt
                                                                            },
                                                                            [W]: Oe
                                                                        }, {
                                                                            [K]: [An, Kt],
                                                                            endpoint: {
                                                                                [Ke]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                                [Ze]: sf,
                                                                                [Je]: Rt
                                                                            },
                                                                            [W]: Oe
                                                                        }, {
                                                                            [K]: [Gt, En],
                                                                            endpoint: {
                                                                                [Ke]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                                [Ze]: sf,
                                                                                [Je]: Rt
                                                                            },
                                                                            [W]: Oe
                                                                        }, {
                                                                            [K]: [Gt, Kt, Qn, Qi],
                                                                            endpoint: {
                                                                                [Ke]: KA,
                                                                                [Ze]: sf,
                                                                                [Je]: Rt
                                                                            },
                                                                            [W]: Oe
                                                                        }, {
                                                                            [K]: [Gt, Kt],
                                                                            endpoint: {
                                                                                [Ke]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                                [Ze]: sf,
                                                                                [Je]: Rt
                                                                            },
                                                                            [W]: Oe
                                                                        }],
                                                                        [W]: Ie
                                                                    }, vM],
                                                                    [W]: Ie
                                                                }, a_],
                                                                [W]: Ie
                                                            }, {
                                                                error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}",
                                                                [W]: rt
                                                            }],
                                                            [W]: Ie
                                                        }, l_],
                                                        [W]: Ie
                                                    }, c_],
                                                    [W]: Ie
                                                }],
                                                [W]: Ie
                                            }],
                                            [W]: Ie
                                        }, yM],
                                        [W]: Ie
                                    }],
                                    [W]: Ie
                                }],
                                [W]: Ie
                            }, {
                                [K]: [{
                                    [Se]: Ul,
                                    [we]: [hx, Rs]
                                }],
                                rules: [{
                                    [K]: p_,
                                    error: "S3 MRAP does not support dual-stack",
                                    [W]: rt
                                }, {
                                    [K]: bc,
                                    error: "S3 MRAP does not support FIPS",
                                    [W]: rt
                                }, {
                                    [K]: Wd,
                                    error: "S3 MRAP does not support S3 Accelerate",
                                    [W]: rt
                                }, {
                                    [K]: [{
                                        [Se]: Si,
                                        [we]: [{
                                            [Mt]: "DisableMultiRegionAccessPoints"
                                        }, Rs]
                                    }],
                                    error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.",
                                    [W]: rt
                                }, {
                                    [K]: [{
                                        [Se]: zp,
                                        [we]: d_,
                                        [Gn]: ZA
                                    }],
                                    rules: [{
                                        [K]: [{
                                            [Se]: Dn,
                                            [we]: [{
                                                [Se]: Yn,
                                                [we]: [{
                                                    [Mt]: ZA
                                                }, Ir]
                                            }, {
                                                [Se]: Yn,
                                                [we]: [Mr, "partition"]
                                            }]
                                        }],
                                        rules: [{
                                            endpoint: {
                                                [Ke]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}",
                                                [Ze]: {
                                                    [Bs]: [{
                                                        [ks]: Rs,
                                                        name: "sigv4a",
                                                        [zs]: Jc,
                                                        signingRegionSet: ["*"]
                                                    }]
                                                },
                                                [Je]: Rt
                                            },
                                            [W]: Oe
                                        }],
                                        [W]: Ie
                                    }, {
                                        error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`",
                                        [W]: rt
                                    }],
                                    [W]: Ie
                                }],
                                [W]: Ie
                            }, {
                                error: "Invalid Access Point Name",
                                [W]: rt
                            }],
                            [W]: Ie
                        }, xM],
                        [W]: Ie
                    }, {
                        [K]: [{
                            [Se]: Dn,
                            [we]: [r_, cx]
                        }],
                        rules: [{
                            [K]: p_,
                            error: "S3 Outposts does not support Dual-stack",
                            [W]: rt
                        }, {
                            [K]: bc,
                            error: "S3 Outposts does not support FIPS",
                            [W]: rt
                        }, {
                            [K]: Wd,
                            error: "S3 Outposts does not support S3 Accelerate",
                            [W]: rt
                        }, {
                            [K]: [{
                                [Se]: gs,
                                [we]: [{
                                    [Se]: Yn,
                                    [we]: [Mr, "resourceId[4]"]
                                }]
                            }],
                            error: "Invalid Arn: Outpost Access Point ARN contains sub resources",
                            [W]: rt
                        }, {
                            [K]: [{
                                [Se]: Yn,
                                [we]: Nie,
                                [Gn]: Kv
                            }],
                            rules: [{
                                [K]: BM,
                                rules: [s_, {
                                    [K]: y_,
                                    rules: [{
                                        [K]: ia,
                                        rules: [{
                                            [K]: VM,
                                            rules: [{
                                                [K]: x_,
                                                rules: [{
                                                    [K]: b_,
                                                    rules: [{
                                                        [K]: [{
                                                            [Se]: Yn,
                                                            [we]: Uie,
                                                            [Gn]: JA
                                                        }],
                                                        rules: [{
                                                            [K]: [{
                                                                [Se]: Yn,
                                                                [we]: [Mr, "resourceId[3]"],
                                                                [Gn]: fx
                                                            }],
                                                            rules: [{
                                                                [K]: [{
                                                                    [Se]: Dn,
                                                                    [we]: [{
                                                                        [Mt]: JA
                                                                    }, MP]
                                                                }],
                                                                rules: [{
                                                                    [K]: Za,
                                                                    endpoint: {
                                                                        [Ke]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}",
                                                                        [Ze]: bM,
                                                                        [Je]: Rt
                                                                    },
                                                                    [W]: Oe
                                                                }, {
                                                                    endpoint: {
                                                                        [Ke]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                        [Ze]: bM,
                                                                        [Je]: Rt
                                                                    },
                                                                    [W]: Oe
                                                                }],
                                                                [W]: Ie
                                                            }, {
                                                                error: "Expected an outpost type `accesspoint`, found {outpostType}",
                                                                [W]: rt
                                                            }],
                                                            [W]: Ie
                                                        }, {
                                                            error: "Invalid ARN: expected an access point name",
                                                            [W]: rt
                                                        }],
                                                        [W]: Ie
                                                    }, {
                                                        error: "Invalid ARN: Expected a 4-component resource",
                                                        [W]: rt
                                                    }],
                                                    [W]: Ie
                                                }, a_],
                                                [W]: Ie
                                            }, l_],
                                            [W]: Ie
                                        }, c_],
                                        [W]: Ie
                                    }],
                                    [W]: Ie
                                }],
                                [W]: Ie
                            }, {
                                error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`",
                                [W]: rt
                            }],
                            [W]: Ie
                        }, {
                            error: "Invalid ARN: The Outpost Id was not set",
                            [W]: rt
                        }],
                        [W]: Ie
                    }, {
                        error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})",
                        [W]: rt
                    }],
                    [W]: Ie
                }, {
                    error: "Invalid ARN: No ARN type specified",
                    [W]: rt
                }],
                [W]: Ie
            }, {
                [K]: [{
                    [Se]: js,
                    [we]: [or, 0, 4, Pie],
                    [Gn]: QA
                }, {
                    [Se]: Dn,
                    [we]: [{
                        [Mt]: QA
                    }, "arn:"]
                }, {
                    [Se]: no,
                    [we]: [{
                        [Se]: gs,
                        [we]: [SM]
                    }]
                }],
                error: "Invalid ARN: `{Bucket}` was not a valid ARN",
                [W]: rt
            }, {
                [K]: [{
                    [Se]: Si,
                    [we]: [Lie, Rs]
                }, SM],
                error: "Path-style addressing cannot be used with ARN buckets",
                [W]: rt
            }, {
                [K]: m_,
                rules: [{
                    [K]: ia,
                    rules: [{
                        [K]: [Jn],
                        rules: [{
                            [K]: [En, Ut, An, li],
                            endpoint: {
                                [Ke]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
                                [Ze]: pi,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }, {
                            [K]: [En, Ut, An, en, mi],
                            rules: [{
                                endpoint: wM,
                                [W]: Oe
                            }],
                            [W]: Ie
                        }, {
                            [K]: [En, Ut, An, en, gi],
                            endpoint: wM,
                            [W]: Oe
                        }, {
                            [K]: [Kt, Ut, An, li],
                            endpoint: {
                                [Ke]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
                                [Ze]: pi,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }, {
                            [K]: [Kt, Ut, An, en, mi],
                            rules: [{
                                endpoint: EM,
                                [W]: Oe
                            }],
                            [W]: Ie
                        }, {
                            [K]: [Kt, Ut, An, en, gi],
                            endpoint: EM,
                            [W]: Oe
                        }, {
                            [K]: [En, Ut, Gt, li],
                            endpoint: {
                                [Ke]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
                                [Ze]: pi,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }, {
                            [K]: [En, Ut, Gt, en, mi],
                            rules: [{
                                endpoint: AM,
                                [W]: Oe
                            }],
                            [W]: Ie
                        }, {
                            [K]: [En, Ut, Gt, en, gi],
                            endpoint: AM,
                            [W]: Oe
                        }, {
                            [K]: [Kt, Qn, Qi, Gt, li],
                            endpoint: {
                                [Ke]: TP,
                                [Ze]: pi,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }, {
                            [K]: [Kt, Qn, Qi, Gt, en, mi],
                            rules: [{
                                [K]: ra,
                                endpoint: u_,
                                [W]: Oe
                            }, {
                                endpoint: u_,
                                [W]: Oe
                            }],
                            [W]: Ie
                        }, {
                            [K]: [Kt, Qn, Qi, Gt, en, gi],
                            endpoint: u_,
                            [W]: Oe
                        }, {
                            [K]: [Kt, Ut, Gt, li],
                            endpoint: {
                                [Ke]: eM,
                                [Ze]: pi,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }, {
                            [K]: [Kt, Ut, Gt, en, mi],
                            rules: [{
                                [K]: ra,
                                endpoint: {
                                    [Ke]: eM,
                                    [Ze]: ri,
                                    [Je]: Rt
                                },
                                [W]: Oe
                            }, {
                                endpoint: MM,
                                [W]: Oe
                            }],
                            [W]: Ie
                        }, {
                            [K]: [Kt, Ut, Gt, en, gi],
                            endpoint: MM,
                            [W]: Oe
                        }],
                        [W]: Ie
                    }, {
                        error: "Path-style addressing cannot be used with S3 Accelerate",
                        [W]: rt
                    }],
                    [W]: Ie
                }],
                [W]: Ie
            }],
            [W]: Ie
        }, {
            [K]: [{
                [Se]: gs,
                [we]: [TM]
            }, {
                [Se]: Si,
                [we]: [TM, Rs]
            }],
            rules: [{
                [K]: ia,
                rules: [{
                    [K]: $M,
                    rules: [mM, gM, {
                        [K]: Za,
                        endpoint: {
                            [Ke]: up,
                            [Ze]: f_,
                            [Je]: Rt
                        },
                        [W]: Oe
                    }, {
                        [K]: bc,
                        endpoint: {
                            [Ke]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}",
                            [Ze]: f_,
                            [Je]: Rt
                        },
                        [W]: Oe
                    }, {
                        endpoint: {
                            [Ke]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}",
                            [Ze]: f_,
                            [Je]: Rt
                        },
                        [W]: Oe
                    }],
                    [W]: Ie
                }, Vd],
                [W]: Ie
            }],
            [W]: Ie
        }, {
            [K]: [oM],
            rules: [{
                [K]: ia,
                rules: [{
                    [K]: $M,
                    rules: [{
                        [K]: [An, En, Ut, li],
                        endpoint: {
                            [Ke]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}",
                            [Ze]: pi,
                            [Je]: Rt
                        },
                        [W]: Oe
                    }, {
                        [K]: [An, En, Ut, en, mi],
                        rules: [{
                            endpoint: CM,
                            [W]: Oe
                        }],
                        [W]: Ie
                    }, {
                        [K]: [An, En, Ut, en, gi],
                        endpoint: CM,
                        [W]: Oe
                    }, {
                        [K]: [An, Kt, Ut, li],
                        endpoint: {
                            [Ke]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}",
                            [Ze]: pi,
                            [Je]: Rt
                        },
                        [W]: Oe
                    }, {
                        [K]: [An, Kt, Ut, en, mi],
                        rules: [{
                            endpoint: RM,
                            [W]: Oe
                        }],
                        [W]: Ie
                    }, {
                        [K]: [An, Kt, Ut, en, gi],
                        endpoint: RM,
                        [W]: Oe
                    }, {
                        [K]: [Gt, En, Ut, li],
                        endpoint: {
                            [Ke]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}",
                            [Ze]: pi,
                            [Je]: Rt
                        },
                        [W]: Oe
                    }, {
                        [K]: [Gt, En, Ut, en, mi],
                        rules: [{
                            endpoint: PM,
                            [W]: Oe
                        }],
                        [W]: Ie
                    }, {
                        [K]: [Gt, En, Ut, en, gi],
                        endpoint: PM,
                        [W]: Oe
                    }, {
                        [K]: [Gt, Kt, Qn, Qi, li],
                        endpoint: {
                            [Ke]: up,
                            [Ze]: pi,
                            [Je]: Rt
                        },
                        [W]: Oe
                    }, {
                        [K]: [Gt, Kt, Qn, Qi, en, mi],
                        rules: [{
                            [K]: ra,
                            endpoint: h_,
                            [W]: Oe
                        }, {
                            endpoint: h_,
                            [W]: Oe
                        }],
                        [W]: Ie
                    }, {
                        [K]: [Gt, Kt, Qn, Qi, en, gi],
                        endpoint: h_,
                        [W]: Oe
                    }, {
                        [K]: [Gt, Kt, Ut, li],
                        endpoint: {
                            [Ke]: tM,
                            [Ze]: pi,
                            [Je]: Rt
                        },
                        [W]: Oe
                    }, {
                        [K]: [Gt, Kt, Ut, en, mi],
                        rules: [{
                            [K]: ra,
                            endpoint: {
                                [Ke]: tM,
                                [Ze]: ri,
                                [Je]: Rt
                            },
                            [W]: Oe
                        }, {
                            endpoint: LM,
                            [W]: Oe
                        }],
                        [W]: Ie
                    }, {
                        [K]: [Gt, Kt, Ut, en, gi],
                        endpoint: LM,
                        [W]: Oe
                    }],
                    [W]: Ie
                }, Vd],
                [W]: Ie
            }],
            [W]: Ie
        }],
        [W]: Ie
    }, {
        error: "A region must be set when sending requests to S3.",
        [W]: rt
    }]
}
  , Bie = Fie
  , kie = (n,e={})=>HZ(Bie, {
    endpointParams: n,
    logger: e.logger
})
  , zie = n=>({
    apiVersion: "2006-03-01",
    base64Decoder: (n == null ? void 0 : n.base64Decoder) ?? $y,
    base64Encoder: (n == null ? void 0 : n.base64Encoder) ?? Xy,
    disableHostPrefix: (n == null ? void 0 : n.disableHostPrefix) ?? !1,
    endpointProvider: (n == null ? void 0 : n.endpointProvider) ?? kie,
    extensions: (n == null ? void 0 : n.extensions) ?? [],
    getAwsChunkedEncodingStream: (n == null ? void 0 : n.getAwsChunkedEncodingStream) ?? Wj,
    logger: (n == null ? void 0 : n.logger) ?? new ZR,
    sdkStreamMixin: (n == null ? void 0 : n.sdkStreamMixin) ?? Jj,
    serviceId: (n == null ? void 0 : n.serviceId) ?? "S3",
    signerConstructor: (n == null ? void 0 : n.signerConstructor) ?? mP,
    signingEscapePath: (n == null ? void 0 : n.signingEscapePath) ?? !1,
    urlParser: (n == null ? void 0 : n.urlParser) ?? Bp,
    useArnRegion: (n == null ? void 0 : n.useArnRegion) ?? !1,
    utf8Decoder: (n == null ? void 0 : n.utf8Decoder) ?? lh,
    utf8Encoder: (n == null ? void 0 : n.utf8Encoder) ?? hm
})
  , Hie = ["in-region", "cross-region", "mobile", "standard", "legacy"]
  , Gie = ({defaultsMode: n}={})=>y2(async()=>{
    const e = typeof n == "function" ? await n() : n;
    switch (e == null ? void 0 : e.toLowerCase()) {
    case "auto":
        return Promise.resolve(Vie() ? "mobile" : "standard");
    case "mobile":
    case "in-region":
    case "cross-region":
    case "standard":
    case "legacy":
        return Promise.resolve(e == null ? void 0 : e.toLocaleLowerCase());
    case void 0:
        return Promise.resolve("legacy");
    default:
        throw new Error(`Invalid parameter for "defaultsMode", expect ${Hie.join(", ")}, got ${e}`)
    }
}
)
  , Vie = ()=>{
    var t, i;
    const n = typeof window < "u" && ((t = window == null ? void 0 : window.navigator) != null && t.userAgent) ? pP.parse(window.navigator.userAgent) : void 0
      , e = (i = n == null ? void 0 : n.platform) == null ? void 0 : i.type;
    return e === "tablet" || e === "mobile"
}
  , Wie = n=>{
    const e = Gie(n)
      , t = ()=>e().then(EY)
      , i = zie(n);
    return {
        ...i,
        ...n,
        runtime: "browser",
        defaultsMode: e,
        bodyLengthChecker: (n == null ? void 0 : n.bodyLengthChecker) ?? Cie,
        credentialDefaultProvider: (n == null ? void 0 : n.credentialDefaultProvider) ?? (r=>()=>Promise.reject(new Error("Credential is missing"))),
        defaultUserAgentProvider: (n == null ? void 0 : n.defaultUserAgentProvider) ?? fie({
            serviceId: i.serviceId,
            clientVersion: Yee.version
        }),
        eventStreamSerdeProvider: (n == null ? void 0 : n.eventStreamSerdeProvider) ?? yie,
        maxAttempts: (n == null ? void 0 : n.maxAttempts) ?? kp,
        md5: (n == null ? void 0 : n.md5) ?? Aie,
        region: (n == null ? void 0 : n.region) ?? Sie("Region is missing"),
        requestHandler: (n == null ? void 0 : n.requestHandler) ?? new qy(t),
        retryMode: (n == null ? void 0 : n.retryMode) ?? (async()=>(await t()).retryMode || wJ),
        sha1: (n == null ? void 0 : n.sha1) ?? j2.Sha1,
        sha256: (n == null ? void 0 : n.sha256) ?? sP.Sha256,
        streamCollector: (n == null ? void 0 : n.streamCollector) ?? QR,
        streamHasher: (n == null ? void 0 : n.streamHasher) ?? bie,
        useDualstackEndpoint: (n == null ? void 0 : n.useDualstackEndpoint) ?? (()=>Promise.resolve(eJ)),
        useFipsEndpoint: (n == null ? void 0 : n.useFipsEndpoint) ?? (()=>Promise.resolve(tJ))
    }
}
  , $ie = n=>{
    let e = async()=>{
        if (n.region === void 0)
            throw new Error("Region is missing from runtimeConfig");
        const t = n.region;
        return typeof t == "string" ? t : t()
    }
    ;
    return {
        setRegion(t) {
            e = t
        },
        region() {
            return e
        }
    }
}
  , Xie = n=>({
    region: n.region()
})
  , S_ = n=>n
  , qie = (n,e)=>{
    const t = {
        ...S_($ie(n)),
        ...S_(RY(n)),
        ...S_(wj(n))
    };
    return e.forEach(i=>i.configure(t)),
    {
        ...n,
        ...Xie(t),
        ...PY(t),
        ...Ej(t)
    }
}
;
class jie extends zj {
    constructor(...[e]) {
        const t = Wie(e || {})
          , i = Pee(t)
          , r = nJ(i)
          , s = SJ(r)
          , o = $J(s)
          , a = o
          , c = gZ(a)
          , u = uZ(c, {
            session: [()=>this, ax]
        })
          , h = SZ(u)
          , m = iJ(h)
          , d = qie(m, (e == null ? void 0 : e.extensions) || []);
        super(d),
        this.config = d,
        this.middlewareStack.use(JJ(this.config)),
        this.middlewareStack.use(oJ(this.config)),
        this.middlewareStack.use(Lj(this.config)),
        this.middlewareStack.use(Oj(this.config)),
        this.middlewareStack.use(kj(this.config)),
        this.middlewareStack.use(bZ(this.config)),
        this.middlewareStack.use(pZ(this.config)),
        this.middlewareStack.use(Cj(this.config)),
        this.middlewareStack.use(kY(this.config)),
        this.middlewareStack.use(cZ(this.config)),
        this.middlewareStack.use(QZ(this.config))
    }
    destroy() {
        super.destroy()
    }
}
function Yie(n) {
    return e=>async t=>{
        let i = {
            ...t.input
        };
        const r = [{
            target: "SSECustomerKey",
            hash: "SSECustomerKeyMD5"
        }, {
            target: "CopySourceSSECustomerKey",
            hash: "CopySourceSSECustomerKeyMD5"
        }];
        for (const s of r) {
            const o = i[s.target];
            if (o) {
                const a = ArrayBuffer.isView(o) ? new Uint8Array(o.buffer,o.byteOffset,o.byteLength) : typeof o == "string" ? n.utf8Decoder(o) : new Uint8Array(o)
                  , c = n.base64Encoder(a)
                  , u = new n.md5;
                u.update(a),
                i = {
                    ...i,
                    [s.target]: c,
                    [s.hash]: n.base64Encoder(await u.digest())
                }
            }
        }
        return e({
            ...t,
            input: i
        })
    }
}
const Kie = {
    name: "ssecMiddleware",
    step: "initialize",
    tags: ["SSE"],
    override: !0
}
  , Zie = n=>({
    applyToStack: e=>{
        e.add(Yie(n), Kie)
    }
});
var bi;
(function(n) {
    n.MD5 = "MD5",
    n.CRC32 = "CRC32",
    n.CRC32C = "CRC32C",
    n.SHA1 = "SHA1",
    n.SHA256 = "SHA256"
}
)(bi || (bi = {}));
var XM;
(function(n) {
    n.HEADER = "header",
    n.TRAILER = "trailer"
}
)(XM || (XM = {}));
const Jie = bi.MD5
  , Qie = bi.CRC32
  , Jv = [bi.CRC32, bi.CRC32C, bi.SHA1, bi.SHA256]
  , ere = [bi.CRC32, bi.CRC32C, bi.SHA1, bi.SHA256]
  , tre = (n,{requestChecksumRequired: e, requestAlgorithmMember: t},i)=>{
    const r = i ? Qie : Jie;
    if (!t || !n[t])
        return e ? r : void 0;
    const s = n[t];
    if (!Jv.includes(s))
        throw new Error(`The checksum algorithm "${s}" is not supported by the client. Select one of ${Jv}.`);
    return s
}
  , dx = n=>n === bi.MD5 ? "content-md5" : `x-amz-checksum-${n.toLowerCase()}`
  , nre = (n,e)=>{
    const t = n.toLowerCase();
    for (const i of Object.keys(e))
        if (t === i.toLowerCase())
            return !0;
    return !1
}
  , px = n=>n !== void 0 && typeof n != "string" && !ArrayBuffer.isView(n) && !_2(n);
var w_ = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Qv = function(n, e) {
    return Qv = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(t, i) {
        t.__proto__ = i
    }
    || function(t, i) {
        for (var r in i)
            i.hasOwnProperty(r) && (t[r] = i[r])
    }
    ,
    Qv(n, e)
};
function ire(n, e) {
    Qv(n, e);
    function t() {
        this.constructor = n
    }
    n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype,
    new t)
}
var ey = function() {
    return ey = Object.assign || function(e) {
        for (var t, i = 1, r = arguments.length; i < r; i++) {
            t = arguments[i];
            for (var s in t)
                Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s])
        }
        return e
    }
    ,
    ey.apply(this, arguments)
};
function rre(n, e) {
    var t = {};
    for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
            e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
    return t
}
function sre(n, e, t, i) {
    var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        s = Reflect.decorate(n, e, t, i);
    else
        for (var a = n.length - 1; a >= 0; a--)
            (o = n[a]) && (s = (r < 3 ? o(s) : r > 3 ? o(e, t, s) : o(e, t)) || s);
    return r > 3 && s && Object.defineProperty(e, t, s),
    s
}
function ore(n, e) {
    return function(t, i) {
        e(t, i, n)
    }
}
function are(n, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(n, e)
}
function lre(n, e, t, i) {
    function r(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(h) {
            try {
                u(i.next(h))
            } catch (m) {
                o(m)
            }
        }
        function c(h) {
            try {
                u(i.throw(h))
            } catch (m) {
                o(m)
            }
        }
        function u(h) {
            h.done ? s(h.value) : r(h.value).then(a, c)
        }
        u((i = i.apply(n, e || [])).next())
    }
    )
}
function cre(n, e) {
    var t = {
        label: 0,
        sent: function() {
            if (s[0] & 1)
                throw s[1];
            return s[1]
        },
        trys: [],
        ops: []
    }, i, r, s, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    },
    typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }
    ),
    o;
    function a(u) {
        return function(h) {
            return c([u, h])
        }
    }
    function c(u) {
        if (i)
            throw new TypeError("Generator is already executing.");
        for (; t; )
            try {
                if (i = 1,
                r && (s = u[0] & 2 ? r.return : u[0] ? r.throw || ((s = r.return) && s.call(r),
                0) : r.next) && !(s = s.call(r, u[1])).done)
                    return s;
                switch (r = 0,
                s && (u = [u[0] & 2, s.value]),
                u[0]) {
                case 0:
                case 1:
                    s = u;
                    break;
                case 4:
                    return t.label++,
                    {
                        value: u[1],
                        done: !1
                    };
                case 5:
                    t.label++,
                    r = u[1],
                    u = [0];
                    continue;
                case 7:
                    u = t.ops.pop(),
                    t.trys.pop();
                    continue;
                default:
                    if (s = t.trys,
                    !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
                        t = 0;
                        continue
                    }
                    if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
                        t.label = u[1];
                        break
                    }
                    if (u[0] === 6 && t.label < s[1]) {
                        t.label = s[1],
                        s = u;
                        break
                    }
                    if (s && t.label < s[2]) {
                        t.label = s[2],
                        t.ops.push(u);
                        break
                    }
                    s[2] && t.ops.pop(),
                    t.trys.pop();
                    continue
                }
                u = e.call(n, t)
            } catch (h) {
                u = [6, h],
                r = 0
            } finally {
                i = s = 0
            }
        if (u[0] & 5)
            throw u[1];
        return {
            value: u[0] ? u[1] : void 0,
            done: !0
        }
    }
}
function ure(n, e, t, i) {
    i === void 0 && (i = t),
    n[i] = e[t]
}
function fre(n, e) {
    for (var t in n)
        t !== "default" && !e.hasOwnProperty(t) && (e[t] = n[t])
}
function ty(n) {
    var e = typeof Symbol == "function" && Symbol.iterator
      , t = e && n[e]
      , i = 0;
    if (t)
        return t.call(n);
    if (n && typeof n.length == "number")
        return {
            next: function() {
                return n && i >= n.length && (n = void 0),
                {
                    value: n && n[i++],
                    done: !n
                }
            }
        };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function NP(n, e) {
    var t = typeof Symbol == "function" && n[Symbol.iterator];
    if (!t)
        return n;
    var i = t.call(n), r, s = [], o;
    try {
        for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
            s.push(r.value)
    } catch (a) {
        o = {
            error: a
        }
    } finally {
        try {
            r && !r.done && (t = i.return) && t.call(i)
        } finally {
            if (o)
                throw o.error
        }
    }
    return s
}
function hre() {
    for (var n = [], e = 0; e < arguments.length; e++)
        n = n.concat(NP(arguments[e]));
    return n
}
function dre() {
    for (var n = 0, e = 0, t = arguments.length; e < t; e++)
        n += arguments[e].length;
    for (var i = Array(n), r = 0, e = 0; e < t; e++)
        for (var s = arguments[e], o = 0, a = s.length; o < a; o++,
        r++)
            i[r] = s[o];
    return i
}
function eh(n) {
    return this instanceof eh ? (this.v = n,
    this) : new eh(n)
}
function pre(n, e, t) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var i = t.apply(n, e || []), r, s = [];
    return r = {},
    o("next"),
    o("throw"),
    o("return"),
    r[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    r;
    function o(d) {
        i[d] && (r[d] = function(f) {
            return new Promise(function(_, g) {
                s.push([d, f, _, g]) > 1 || a(d, f)
            }
            )
        }
        )
    }
    function a(d, f) {
        try {
            c(i[d](f))
        } catch (_) {
            m(s[0][3], _)
        }
    }
    function c(d) {
        d.value instanceof eh ? Promise.resolve(d.value.v).then(u, h) : m(s[0][2], d)
    }
    function u(d) {
        a("next", d)
    }
    function h(d) {
        a("throw", d)
    }
    function m(d, f) {
        d(f),
        s.shift(),
        s.length && a(s[0][0], s[0][1])
    }
}
function mre(n) {
    var e, t;
    return e = {},
    i("next"),
    i("throw", function(r) {
        throw r
    }),
    i("return"),
    e[Symbol.iterator] = function() {
        return this
    }
    ,
    e;
    function i(r, s) {
        e[r] = n[r] ? function(o) {
            return (t = !t) ? {
                value: eh(n[r](o)),
                done: r === "return"
            } : s ? s(o) : o
        }
        : s
    }
}
function gre(n) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = n[Symbol.asyncIterator], t;
    return e ? e.call(n) : (n = typeof ty == "function" ? ty(n) : n[Symbol.iterator](),
    t = {},
    i("next"),
    i("throw"),
    i("return"),
    t[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    t);
    function i(s) {
        t[s] = n[s] && function(o) {
            return new Promise(function(a, c) {
                o = n[s](o),
                r(a, c, o.done, o.value)
            }
            )
        }
    }
    function r(s, o, a, c) {
        Promise.resolve(c).then(function(u) {
            s({
                value: u,
                done: a
            })
        }, o)
    }
}
function _re(n, e) {
    return Object.defineProperty ? Object.defineProperty(n, "raw", {
        value: e
    }) : n.raw = e,
    n
}
function vre(n) {
    if (n && n.__esModule)
        return n;
    var e = {};
    if (n != null)
        for (var t in n)
            Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
    return e.default = n,
    e
}
function yre(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function xre(n, e) {
    if (!e.has(n))
        throw new TypeError("attempted to get private field on non-instance");
    return e.get(n)
}
function bre(n, e, t) {
    if (!e.has(n))
        throw new TypeError("attempted to set private field on non-instance");
    return e.set(n, t),
    t
}
const Sre = Object.freeze(Object.defineProperty({
    __proto__: null,
    get __assign() {
        return ey
    },
    __asyncDelegator: mre,
    __asyncGenerator: pre,
    __asyncValues: gre,
    __await: eh,
    __awaiter: lre,
    __classPrivateFieldGet: xre,
    __classPrivateFieldSet: bre,
    __createBinding: ure,
    __decorate: sre,
    __exportStar: fre,
    __extends: ire,
    __generator: cre,
    __importDefault: yre,
    __importStar: vre,
    __makeTemplateObject: _re,
    __metadata: are,
    __param: ore,
    __read: NP,
    __rest: rre,
    __spread: hre,
    __spreadArrays: dre,
    __values: ty
}, Symbol.toStringTag, {
    value: "Module"
}))
  , UP = Fo(Sre);
var of = {}, qM;
function wre() {
    if (qM)
        return of;
    qM = 1,
    Object.defineProperty(of, "__esModule", {
        value: !0
    }),
    of.AwsCrc32c = void 0;
    var n = UP
      , e = Da()
      , t = FP()
      , i = function() {
        function r() {
            this.crc32c = new t.Crc32c
        }
        return r.prototype.update = function(s) {
            (0,
            e.isEmptyData)(s) || this.crc32c.update((0,
            e.convertToBuffer)(s))
        }
        ,
        r.prototype.digest = function() {
            return n.__awaiter(this, void 0, void 0, function() {
                return n.__generator(this, function(s) {
                    return [2, (0,
                    e.numToUint8)(this.crc32c.digest())]
                })
            })
        }
        ,
        r.prototype.reset = function() {
            this.crc32c = new t.Crc32c
        }
        ,
        r
    }();
    return of.AwsCrc32c = i,
    of
}
var jM;
function FP() {
    return jM || (jM = 1,
    function(n) {
        Object.defineProperty(n, "__esModule", {
            value: !0
        }),
        n.AwsCrc32c = n.Crc32c = n.crc32c = void 0;
        var e = UP
          , t = Da();
        function i(c) {
            return new r().update(c).digest()
        }
        n.crc32c = i;
        var r = function() {
            function c() {
                this.checksum = 4294967295
            }
            return c.prototype.update = function(u) {
                var h, m;
                try {
                    for (var d = e.__values(u), f = d.next(); !f.done; f = d.next()) {
                        var _ = f.value;
                        this.checksum = this.checksum >>> 8 ^ o[(this.checksum ^ _) & 255]
                    }
                } catch (g) {
                    h = {
                        error: g
                    }
                } finally {
                    try {
                        f && !f.done && (m = d.return) && m.call(d)
                    } finally {
                        if (h)
                            throw h.error
                    }
                }
                return this
            }
            ,
            c.prototype.digest = function() {
                return (this.checksum ^ 4294967295) >>> 0
            }
            ,
            c
        }();
        n.Crc32c = r;
        var s = [0, 4067132163, 3778769143, 324072436, 3348797215, 904991772, 648144872, 3570033899, 2329499855, 2024987596, 1809983544, 2575936315, 1296289744, 3207089363, 2893594407, 1578318884, 274646895, 3795141740, 4049975192, 51262619, 3619967088, 632279923, 922689671, 3298075524, 2592579488, 1760304291, 2075979607, 2312596564, 1562183871, 2943781820, 3156637768, 1313733451, 549293790, 3537243613, 3246849577, 871202090, 3878099393, 357341890, 102525238, 4101499445, 2858735121, 1477399826, 1264559846, 3107202533, 1845379342, 2677391885, 2361733625, 2125378298, 820201905, 3263744690, 3520608582, 598981189, 4151959214, 85089709, 373468761, 3827903834, 3124367742, 1213305469, 1526817161, 2842354314, 2107672161, 2412447074, 2627466902, 1861252501, 1098587580, 3004210879, 2688576843, 1378610760, 2262928035, 1955203488, 1742404180, 2511436119, 3416409459, 969524848, 714683780, 3639785095, 205050476, 4266873199, 3976438427, 526918040, 1361435347, 2739821008, 2954799652, 1114974503, 2529119692, 1691668175, 2005155131, 2247081528, 3690758684, 697762079, 986182379, 3366744552, 476452099, 3993867776, 4250756596, 255256311, 1640403810, 2477592673, 2164122517, 1922457750, 2791048317, 1412925310, 1197962378, 3037525897, 3944729517, 427051182, 170179418, 4165941337, 746937522, 3740196785, 3451792453, 1070968646, 1905808397, 2213795598, 2426610938, 1657317369, 3053634322, 1147748369, 1463399397, 2773627110, 4215344322, 153784257, 444234805, 3893493558, 1021025245, 3467647198, 3722505002, 797665321, 2197175160, 1889384571, 1674398607, 2443626636, 1164749927, 3070701412, 2757221520, 1446797203, 137323447, 4198817972, 3910406976, 461344835, 3484808360, 1037989803, 781091935, 3705997148, 2460548119, 1623424788, 1939049696, 2180517859, 1429367560, 2807687179, 3020495871, 1180866812, 410100952, 3927582683, 4182430767, 186734380, 3756733383, 763408580, 1053836080, 3434856499, 2722870694, 1344288421, 1131464017, 2971354706, 1708204729, 2545590714, 2229949006, 1988219213, 680717673, 3673779818, 3383336350, 1002577565, 4010310262, 493091189, 238226049, 4233660802, 2987750089, 1082061258, 1395524158, 2705686845, 1972364758, 2279892693, 2494862625, 1725896226, 952904198, 3399985413, 3656866545, 731699698, 4283874585, 222117402, 510512622, 3959836397, 3280807620, 837199303, 582374963, 3504198960, 68661723, 4135334616, 3844915500, 390545967, 1230274059, 3141532936, 2825850620, 1510247935, 2395924756, 2091215383, 1878366691, 2644384480, 3553878443, 565732008, 854102364, 3229815391, 340358836, 3861050807, 4117890627, 119113024, 1493875044, 2875275879, 3090270611, 1247431312, 2660249211, 1828433272, 2141937292, 2378227087, 3811616794, 291187481, 34330861, 4032846830, 615137029, 3603020806, 3314634738, 939183345, 1776939221, 2609017814, 2295496738, 2058945313, 2926798794, 1545135305, 1330124605, 3173225534, 4084100981, 17165430, 307568514, 3762199681, 888469610, 3332340585, 3587147933, 665062302, 2042050490, 2346497209, 2559330125, 1793573966, 3190661285, 1279665062, 1595330642, 2910671697]
          , o = (0,
        t.uint32ArrayFrom)(s)
          , a = wre();
        Object.defineProperty(n, "AwsCrc32c", {
            enumerable: !0,
            get: function() {
                return a.AwsCrc32c
            }
        })
    }(w_)),
    w_
}
var Ere = FP();
const BP = (n,e)=>({
    [bi.MD5]: e.md5,
    [bi.CRC32]: Zy.AwsCrc32,
    [bi.CRC32C]: Ere.AwsCrc32c,
    [bi.SHA1]: e.sha1,
    [bi.SHA256]: e.sha256
})[n]
  , kP = (n,e)=>{
    const t = new n;
    return t.update(kc(e || "")),
    t.digest()
}
  , Are = {
    name: "flexibleChecksumsMiddleware",
    step: "build",
    tags: ["BODY_CHECKSUM"],
    override: !0
}
  , Mre = (n,e)=>(t,i)=>async r=>{
    if (!dr.isInstance(r.request))
        return t(r);
    const {request: s} = r
      , {body: o, headers: a} = s
      , {base64Encoder: c, streamHasher: u} = n
      , {input: h, requestChecksumRequired: m, requestAlgorithmMember: d} = e
      , f = tre(h, {
        requestChecksumRequired: m,
        requestAlgorithmMember: d
    }, !!i.isS3ExpressBucket);
    let _ = o
      , g = a;
    if (f) {
        const y = dx(f)
          , w = BP(f, n);
        if (px(o)) {
            const {getAwsChunkedEncodingStream: S, bodyLengthChecker: E} = n;
            _ = S(o, {
                base64Encoder: c,
                bodyLengthChecker: E,
                checksumLocationName: y,
                checksumAlgorithmFn: w,
                streamHasher: u
            }),
            g = {
                ...a,
                "content-encoding": a["content-encoding"] ? `${a["content-encoding"]},aws-chunked` : "aws-chunked",
                "transfer-encoding": "chunked",
                "x-amz-decoded-content-length": a["content-length"],
                "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
                "x-amz-trailer": y
            },
            delete g["content-length"]
        } else if (!nre(y, a)) {
            const S = await kP(w, o);
            g = {
                ...a,
                [y]: c(S)
            }
        }
    }
    return await t({
        ...r,
        request: {
            ...s,
            headers: g,
            body: _
        }
    })
}
  , zP = (n=[])=>{
    const e = [];
    for (const t of ere)
        !n.includes(t) || !Jv.includes(t) || e.push(t);
    return e
}
  , Tre = n=>{
    const e = n.lastIndexOf("-");
    if (e !== -1) {
        const t = n.slice(e + 1);
        if (!t.startsWith("0")) {
            const i = parseInt(t, 10);
            if (!isNaN(i) && i >= 1 && i <= 1e4)
                return !0
        }
    }
    return !1
}
;
function YM(n) {
    return new Blob([n]).stream()
}
const Cre = async(n,{streamHasher: e, checksumAlgorithmFn: t, base64Encoder: i})=>{
    const r = px(n) ? e(t, n) : kP(t, n);
    return i(await r)
}
  , Rre = async(n,{config: e, responseAlgorithms: t})=>{
    const i = zP(t)
      , {body: r, headers: s} = n;
    for (const o of i) {
        const a = dx(o)
          , c = s[a];
        if (c) {
            const u = BP(o, e)
              , {streamHasher: h, base64Encoder: m} = e
              , d = await Cre(r, {
                streamHasher: h,
                checksumAlgorithmFn: u,
                base64Encoder: m
            });
            if (d === c)
                break;
            throw new Error(`Checksum mismatch: expected "${d}" but received "${c}" in response header "${a}".`)
        }
    }
}
  , Pre = {
    name: "flexibleChecksumsResponseMiddleware",
    toMiddleware: "deserializerMiddleware",
    relation: "after",
    tags: ["BODY_CHECKSUM"],
    override: !0
}
  , Lre = (n,e)=>(t,i)=>async r=>{
    if (!dr.isInstance(r.request))
        return t(r);
    const s = r.input
      , o = await t(r)
      , a = o.response;
    let c;
    const {requestValidationModeMember: u, responseAlgorithms: h} = e;
    if (u && s[u] === "ENABLED") {
        const {clientName: m, commandName: d} = i;
        if (m === "S3Client" && d === "GetObjectCommand" && zP(h).every(g=>{
            const v = dx(g)
              , y = a.headers[v];
            return !y || Tre(y)
        }
        ))
            return o;
        const _ = px(a.body);
        _ && (c = await n.streamCollector(a.body),
        a.body = YM(c)),
        await Rre(o.response, {
            config: n,
            responseAlgorithms: h
        }),
        _ && c && (a.body = YM(c))
    }
    return o
}
  , Dre = (n,e)=>({
    applyToStack: t=>{
        t.add(Mre(n, e), Are),
        t.addRelativeTo(Lre(n, e), Pre)
    }
});
class xm extends t2 {
    static getEndpointParameterInstructions() {
        return {
            Bucket: {
                type: "contextParams",
                name: "Bucket"
            },
            Key: {
                type: "contextParams",
                name: "Key"
            },
            ForcePathStyle: {
                type: "clientContextParams",
                name: "forcePathStyle"
            },
            UseArnRegion: {
                type: "clientContextParams",
                name: "useArnRegion"
            },
            DisableMultiRegionAccessPoints: {
                type: "clientContextParams",
                name: "disableMultiregionAccessPoints"
            },
            Accelerate: {
                type: "clientContextParams",
                name: "useAccelerateEndpoint"
            },
            DisableS3ExpressSessionAuth: {
                type: "clientContextParams",
                name: "disableS3ExpressSessionAuth"
            },
            UseGlobalEndpoint: {
                type: "builtInParams",
                name: "useGlobalEndpoint"
            },
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        }
    }
    constructor(e) {
        super(),
        this.input = e
    }
    resolveMiddleware(e, t, i) {
        this.middlewareStack.use(I2(t, this.serialize, this.deserialize)),
        this.middlewareStack.use(O2(t, xm.getEndpointParameterInstructions())),
        this.middlewareStack.use(Zie(t)),
        this.middlewareStack.use(Dre(t, {
            input: this.input,
            requestChecksumRequired: !1,
            requestValidationModeMember: "ChecksumMode",
            responseAlgorithms: ["CRC32", "CRC32C", "SHA256", "SHA1"]
        }));
        const r = e.concat(this.middlewareStack)
          , {logger: s} = t
          , c = {
            logger: s,
            clientName: "S3Client",
            commandName: "GetObjectCommand",
            inputFilterSensitiveLog: iQ,
            outputFilterSensitiveLog: nQ,
            [Ip]: {
                service: "AmazonS3",
                operation: "GetObject"
            }
        }
          , {requestHandler: u} = t;
        return r.resolve(h=>u.handle(h.request, i || {}), c)
    }
    serialize(e, t) {
        return xee(e, t)
    }
    deserialize(e, t) {
        return wee(e, t)
    }
}
function Ire(n) {
    const {port: e, query: t} = n;
    let {protocol: i, path: r, hostname: s} = n;
    i && i.slice(-1) !== ":" && (i += ":"),
    e && (s += `:${e}`),
    r && r.charAt(0) !== "/" && (r = `/${r}`);
    let o = t ? JR(t) : "";
    o && o[0] !== "?" && (o = `?${o}`);
    let a = "";
    if (n.username != null || n.password != null) {
        const u = n.username ?? ""
          , h = n.password ?? "";
        a = `${u}:${h}@`
    }
    let c = "";
    return n.fragment && (c = `#${n.fragment}`),
    `${i}//${a}${s}${r}${o}${c}`
}
const Ore = "UNSIGNED-PAYLOAD"
  , Nre = "X-Amz-Content-Sha256";
class KM {
    constructor(e) {
        const t = {
            service: e.signingName || e.service || "s3",
            uriEscapePath: e.uriEscapePath || !1,
            applyChecksum: e.applyChecksum || !1,
            ...e
        };
        this.signer = new mP(t)
    }
    presign(e, {unsignableHeaders: t=new Set, unhoistableHeaders: i=new Set, ...r}={}) {
        return this.prepareRequest(e, {
            unsignableHeaders: t,
            unhoistableHeaders: i
        }),
        this.signer.presign(e, {
            expiresIn: 900,
            unsignableHeaders: t,
            unhoistableHeaders: i,
            ...r
        })
    }
    presignWithCredentials(e, t, {unsignableHeaders: i=new Set, unhoistableHeaders: r=new Set, ...s}={}) {
        return this.prepareRequest(e, {
            unsignableHeaders: i,
            unhoistableHeaders: r
        }),
        this.signer.presignWithCredentials(e, t, {
            expiresIn: 900,
            unsignableHeaders: i,
            unhoistableHeaders: r,
            ...s
        })
    }
    prepareRequest(e, {unsignableHeaders: t=new Set, unhoistableHeaders: i=new Set}={}) {
        t.add("content-type"),
        Object.keys(e.headers).map(a=>a.toLowerCase()).filter(a=>a.startsWith("x-amz-server-side-encryption")).forEach(a=>{
            i.add(a)
        }
        ),
        e.headers[Nre] = Ore;
        const r = e.headers.host
          , s = e.port
          , o = `${e.hostname}${e.port != null ? ":" + s : ""}`;
        (!r || r === e.hostname && e.port != null) && (e.headers.host = o)
    }
}
const HP = async(n,e,t={})=>{
    var h, m;
    let i;
    if (typeof n.config.endpointProvider == "function") {
        const f = (m = (h = (await L2(e.input, e.constructor, n.config)).properties) == null ? void 0 : h.authSchemes) == null ? void 0 : m[0];
        i = new KM({
            ...n.config,
            signingName: f == null ? void 0 : f.signingName,
            region: async()=>f == null ? void 0 : f.signingRegion
        })
    } else
        i = new KM(n.config);
    const r = (d,f)=>async _=>{
        const {request: g} = _;
        if (!dr.isInstance(g))
            throw new Error("Request to be presigned is not an valid HTTP request.");
        delete g.headers["amz-sdk-invocation-id"],
        delete g.headers["amz-sdk-request"],
        delete g.headers["x-amz-user-agent"];
        let v;
        const y = {
            ...t,
            signingRegion: t.signingRegion ?? f.signing_region,
            signingService: t.signingService ?? f.signing_service
        };
        return f.s3ExpressIdentity ? v = await i.presignWithCredentials(g, f.s3ExpressIdentity, y) : v = await i.presign(g, y),
        {
            response: {},
            output: {
                $metadata: {
                    httpStatusCode: 200
                },
                presigned: v
            }
        }
    }
      , s = "presignInterceptMiddleware"
      , o = n.middlewareStack.clone();
    o.addRelativeTo(r, {
        name: s,
        relation: "before",
        toMiddleware: "awsAuthMiddleware",
        override: !0
    });
    const a = e.resolveMiddleware(o, n.config, {})
      , {output: c} = await a({
        input: e.input
    })
      , {presigned: u} = c;
    return Ire(u)
}
  , Ure = `precision highp float;
#define GLSLIFY 1

uniform sampler2D uTexture;
uniform vec2 uPlaneSizes;
uniform vec2 uImageSizes;
uniform float uAlpha;

varying vec2 vUv;
varying float vDistortion;

void main(){
  vec2 ratio = vec2(
    min(((uPlaneSizes.x / uPlaneSizes.y) / (uImageSizes.x / uImageSizes.y)), 1.),
    min(((uPlaneSizes.y / uPlaneSizes.x) / (uImageSizes.y / uImageSizes.x)), 1.)
  );

  vec2 uv = vec2(
    vUv.x * ratio.x + (1. - ratio.x) * 0.5,
    vUv.y * ratio.y + (1. - ratio.y) * 0.5
  );
  uv.y += vDistortion * 0.2;

	float grd = 0.02;
  float sqr = 100. * (smoothstep(0., grd, vUv.x) - smoothstep(1. - grd, 1., vUv.x)) * (smoothstep(0., grd, vUv.y) - smoothstep(1. - grd, 1., vUv.y)) -10.;

  vec4 texture = texture2D(uTexture, uv);
  texture.a = texture.a * sqr;

  gl_FragColor = texture;
}`
  , Fre = `#define GLSLIFY 1
#define PI 3.1415926535897932384626433832795

attribute vec3 position;
attribute vec2 uv;

uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;
uniform vec2 uViewportSizes;
uniform float uStrength;

varying vec2 vUv;
varying float vDistortion;

void main(){
  vec4 pos = modelViewMatrix * vec4(position, 1.);

  float distortion = sin(pos.y / uViewportSizes.y * PI + PI / 2.) * -uStrength;
  pos.z += distortion;

  vUv = uv;
  vDistortion = distortion;
  gl_Position = projectionMatrix * pos;
}`
  , Bre = "eu-west-3"
  , kre = "2012-10-17"
  , zre = "AKIAWD5FVUZLBWF7YHCG"
  , Hre = "hQlBcXJN30khf4Ad31fhSRjj514EMAHTJjxU4ITA"
  , GP = new jie({
    apiVersion: kre,
    region: Bre,
    credentials: {
        accessKeyId: zre,
        secretAccessKey: Hre
    }
});
class Gre {
    constructor({element: e, scene: t, geometry: i, screen: r, viewport: s}) {
        this.element = e,
        this.scene = t,
        this.geometry = i,
        this.screen = r,
        this.viewport = s,
        this.extra = 0,
        this.createMaterial(),
        this.createMesh(),
        this.onResize({
            viewport: s,
            screen: r
        })
    }
    createTexture() {
        this.videoSrc = this.element.getAttribute("video-src"),
        this.videoSrc !== null ? this.loadVideo() : (this.texture = window.TEXTURES[this.element.getAttribute("src")],
        this.material.uniforms.uTexture.value = this.texture)
    }
    createMaterial() {
        this.material = new EG({
            vertexShader: Fre,
            fragmentShader: Ure,
            uniforms: {
                uStrength: {
                    value: 0
                },
                uTexture: {
                    value: null
                },
                uImageSizes: {
                    value: new on(this.element.naturalWidth,this.element.naturalHeight)
                },
                uPlaneSizes: {
                    value: new on(0,0)
                },
                uViewportSizes: {
                    value: new on(this.viewport.width,this.viewport.height)
                }
            },
            transparent: !0
        })
    }
    createMesh() {
        this.mesh = new Lo(this.geometry,this.material),
        this.scene.add(this.mesh)
    }
    createBounds() {
        const e = this.element.getBoundingClientRect();
        this.bounds = {
            top: e.top,
            left: e.left,
            width: e.width,
            height: e.height
        },
        this.updateScale(),
        this.updateX(),
        this.updateY(0),
        this.material.uniforms.uPlaneSizes.value = new on(this.mesh.scale.x,this.mesh.scale.y)
    }
    updateScale() {
        this.mesh.scale.x = this.viewport.width * this.bounds.width / this.screen.width,
        this.mesh.scale.y = this.viewport.height * this.bounds.height / this.screen.height
    }
    updateX(e=0) {
        this.mesh.position.x = -this.viewport.width / 2 + this.mesh.scale.x / 2 + (this.bounds.left - e) / this.screen.width * this.viewport.width
    }
    updateY(e=0) {
        this.mesh.position.y = this.viewport.height / 2 - this.mesh.scale.y / 2 - (this.bounds.top - e) / this.screen.height * this.viewport.height + this.extra
    }
    show() {}
    hide() {}
    async loadVideo() {
        try {
            const e = new xm({
                Bucket: "evan-portfolio-video",
                Key: this.videoSrc
            })
              , t = await HP(GP, e);
            this.videoElement = document.createElement("video"),
            this.videoElement.src = t,
            this.videoElement.loop = !0,
            this.videoElement.muted = !0,
            this.videoElement.crossOrigin = "anonymous",
            this.videoElement.setAttribute("playsinline", "playsinline"),
            this.videoElement.load(),
            this.videoElement.oncanplay = ()=>{
                this.videoElement.play()
            }
            ,
            this.texture = new wG(this.videoElement),
            this.material.uniforms.uTexture.value = this.texture
        } catch {
            this.texture = window.TEXTURES[this.element.getAttribute("src")],
            this.material.uniforms.uTexture.value = this.texture
        }
    }
    onResize({screen: e, viewport: t, galleryHeight: i}) {
        this.screen = e,
        this.viewport = t,
        this.galleryHeight = i,
        this.extra = 0,
        this.material.uniforms.uViewportSizes.value = new on(this.viewport.width,this.viewport.height),
        this.createBounds(),
        this.videoElement && (this.videoElement.currentTime = 0)
    }
    update({scroll: e, direction: t, strength: i}) {
        this.material.uniforms.uStrength.value = i;
        const r = this.viewport.height / 2
          , s = this.mesh.scale.y / 2;
        t === "up" && this.mesh.position.y + s < -r ? this.extra += this.galleryHeight : t === "down" && this.mesh.position.y - s > r && (this.extra -= this.galleryHeight),
        this.videoElement && this.videoElement.readyState >= this.videoElement.HAVE_ENOUGH_DATA && (this.texture.needsUpdate = !0),
        this.updateY(e)
    }
}
function Wi(n, e, t) {
    return ve.utils.interpolate(n, e, t)
}
function Vre(n, e, t) {
    return ve.utils.clamp(n, e, t)
}
function Wre(n, e, t, i) {
    var r = n - t
      , s = e - i;
    return Math.hypot(r, s)
}
let $re = class {
    constructor({scene: e, screen: t, viewport: i, updateScroll: r}) {
        this.scene = e,
        this.screen = t,
        this.viewport = i,
        this.updateScroll = r,
        this.galleryElement = document.querySelector(".playground__gallery"),
        this.mediaElements = document.querySelectorAll(".playground__gallery__img"),
        this.group = new pf,
        this.scroll = {
            position: 0,
            current: 0,
            target: 0,
            last: 0,
            ease: .1
        },
        this.direction = "up",
        this.isVisible = !1,
        this.isDown = !1,
        this.speed = 2,
        this.createGeometry(),
        this.createGallery()
    }
    createGeometry() {
        this.geometry = new em(1,1,20,20)
    }
    createGallery() {
        this.medias = Jt.map(this.mediaElements, e=>new Gre({
            element: e,
            scene: this.group,
            geometry: this.geometry,
            screen: this.screen,
            viewport: this.viewport
        }))
    }
    createTexture() {
        Jt.each(this.medias, e=>{
            e && e.createTexture && e.createTexture()
        }
        )
    }
    show() {
        this.scene.add(this.group),
        Jt.each(this.medias, e=>{
            e && e.show && e.show()
        }
        ),
        this.isVisible = !0
    }
    hide() {
        Jt.each(this.medias, e=>{
            e && e.hide && e.hide()
        }
        ),
        ve.delayedCall(1.2, ()=>{
            this.isVisible = !1,
            this.scene.remove(this.group)
        }
        )
    }
    onResize({screen: e, viewport: t}) {
        this.galleryHeightPx = this.galleryElement.clientHeight,
        this.galleryHeight = this.galleryElement.clientHeight / this.screen.height * this.viewport.height,
        this.scroll = {
            position: 0,
            current: 0,
            target: 0,
            last: 0,
            ease: .1
        },
        Jt.each(this.medias, i=>{
            i && i.onResize && i.onResize({
                screen: e,
                viewport: t,
                galleryHeight: this.galleryHeight
            })
        }
        )
    }
    onTouchDown(e) {
        !this.isVisible || !tn.isMobile || (this.isDown = !0,
        this.scroll.position = this.scroll.current,
        this.start = e.touches ? e.touches[0].clientY : e.clientY)
    }
    onTouchMove(e) {
        if (!this.isVisible || !tn.isMobile || !this.isDown)
            return;
        const t = e.touches ? e.touches[0].clientY : e.clientY
          , i = (this.start - t) * 3;
        this.scroll.target = this.scroll.position + i
    }
    onTouchUp() {
        !this.isVisible || !tn.isMobile || (this.isDown = !1)
    }
    onWheel(e) {
        if (!this.isVisible)
            return;
        const t = e.pixelY;
        this.scroll.target += t
    }
    update() {
        if (!this.isVisible)
            return;
        if (this.scroll.target += this.speed,
        this.scroll.current = Wi(this.scroll.current, this.scroll.target, this.scroll.ease),
        this.scroll.current = Math.ceil(this.scroll.current),
        this.scroll.current < this.scroll.last ? (this.direction = "up",
        this.speed = -2) : this.scroll.current > this.scroll.last && (this.direction = "down",
        this.speed = 2),
        this.scroll.current !== this.scroll.last) {
            const t = (this.scroll.current % this.galleryHeightPx + this.galleryHeightPx) % this.galleryHeightPx
              , i = Math.round(t / this.galleryHeightPx * 100);
            this.updateScroll(i)
        }
        const e = (this.scroll.current - this.scroll.last) / this.screen.width * (tn.isMobile || this.screen.width < 768 ? 5 : 10);
        Jt.each(this.medias, t=>{
            t && t.update && t.update({
                scroll: this.scroll.current,
                direction: this.direction,
                strength: e
            })
        }
        ),
        this.scroll.last = this.scroll.current
    }
}
  , Xre = class {
    constructor({screen: e, engine: t, matterCanvas: i}) {
        this.screen = e,
        this.engine = t,
        this.matterCanvas = i,
        this.notFoundElement = document.querySelector(".not__found"),
        this.fallElement = {
            id: this.notFoundElement.getAttribute("id"),
            src: this.notFoundElement.getAttribute("data-fall-src"),
            width: this.notFoundElement.getAttribute("data-fall-width"),
            height: this.notFoundElement.getAttribute("data-fall-height"),
            svg: this.notFoundElement.getAttribute("data-fall-svg"),
            vertices: null
        },
        this.bodies = [],
        this.onResize({
            screen: this.screen
        })
    }
    show() {
        this.isVisible = !0,
        this.fallElement.svg && this.fallElement.src && (this.fallElement.vertices === null ? this.loadSvg(this.fallElement.svg).then(e=>{
            const t = qt.Svg.pathToVertices(e.querySelector("path"));
            ve.delayedCall(1.4, ()=>{
                this.makeSvgFall(t, this.fallElement)
            }
            )
        }
        ) : ve.delayedCall(1.4, ()=>{
            this.makeSvgFall(this.fallElement.vertices, this.fallElement)
        }
        ))
    }
    hide() {
        ve.delayedCall(1.2, ()=>{
            Jt.each(this.bodies, e=>qt.Composite.remove(this.engine.world, e))
        }
        )
    }
    onResize({screen: e}) {
        this.screen = e;
        const t = tn.isMobile || this.screen.width < 768 ? 393 : 1440;
        this.scale = this.screen.width / t
    }
    makeSvgFall(e, t) {
        Jt.each(qt.Composite.allBodies(this.engine.world), s=>{
            s.isStatic || qt.Composite.remove(this.engine.world, s)
        }
        );
        const i = .5;
        let r = Math.floor(this.screen.width / Number(t.width / 3 * this.scale));
        this.bodies = [],
        (tn.isMobile || this.screen.width < 768) && (r *= 1.5);
        for (let s = 0; s < r; s++) {
            let o = Number(t.width / 3 * this.scale) * (s + 1);
            const a = ve.utils.random(-200, -1e3);
            (tn.isMobile || this.screen.width < 768) && (o = o / 1.5);
            const c = qt.Bodies.fromVertices(o, a, [e], {
                render: {
                    sprite: {
                        texture: t.src
                    }
                }
            });
            if (!this.isVisible)
                return;
            this.bodies.push(c),
            qt.Body.rotate(c, ve.utils.random(-90, 90)),
            qt.Body.applyForce(c, c.position, {
                x: 0,
                y: i
            }),
            qt.Body.scale(c, this.scale, this.scale),
            c.render.sprite.xScale = this.scale / 3,
            c.render.sprite.yScale = this.scale / 3,
            qt.Composite.add(this.engine.world, c)
        }
    }
    loadSvg(e) {
        return fetch(e).then(function(t) {
            return t.text()
        }).then(function(t) {
            return new window.DOMParser().parseFromString(t, "image/svg+xml")
        })
    }
}
;
function qre(n) {
    return [(n >> 16 & 255) / 255, (n >> 8 & 255) / 255, (255 & n) / 255]
}
["SCREEN", "LINEAR_LIGHT"].reduce((n,e,t)=>Object.assign(n, {
    [e]: t
}), {});
class jre {
    constructor(e, t, i, r=!1) {
        const s = this
          , o = document.location.search.toLowerCase().indexOf("debug=webgl") !== -1;
        s.canvas = e,
        s.gl = s.canvas.getContext("webgl", {
            antialias: !0
        }),
        s.meshes = [];
        const a = s.gl;
        t && i && this.setSize(t, i),
        s.lastDebugMsg,
        s.debug = r && o ? function(u) {
            const h = new Date;
            h - s.lastDebugMsg > 1e3 && console.log("---"),
            console.log(h.toLocaleTimeString() + Array(Math.max(0, 32 - u.length)).join(" ") + u + ": ", ...Array.from(arguments).slice(1)),
            s.lastDebugMsg = h
        }
        : ()=>{}
        ,
        Object.defineProperties(s, {
            Material: {
                enumerable: !1,
                value: class {
                    constructor(u, h, m={}) {
                        const d = this;
                        function f(v, y) {
                            const w = a.createShader(v);
                            return a.shaderSource(w, y),
                            a.compileShader(w),
                            a.getShaderParameter(w, a.COMPILE_STATUS) || console.error(a.getShaderInfoLog(w)),
                            s.debug("Material.compileShaderSource", {
                                source: y
                            }),
                            w
                        }
                        function _(v, y) {
                            return Object.entries(v).map(([w,S])=>S.getDeclaration(w, y)).join(`
`)
                        }
                        d.uniforms = m,
                        d.uniformInstances = [];
                        const g = `
              precision highp float;
            `;
                        d.vertexSource = `
              ${g}
              attribute vec4 position;
              attribute vec2 uv;
              attribute vec2 uvNorm;
              ${_(s.commonUniforms, "vertex")}
              ${_(m, "vertex")}
              ${u}
            `,
                        d.Source = `
              ${g}
              ${_(s.commonUniforms, "fragment")}
              ${_(m, "fragment")}
              ${h}
            `,
                        d.vertexShader = f(a.VERTEX_SHADER, d.vertexSource),
                        d.fragmentShader = f(a.FRAGMENT_SHADER, d.Source),
                        d.program = a.createProgram(),
                        a.attachShader(d.program, d.vertexShader),
                        a.attachShader(d.program, d.fragmentShader),
                        a.linkProgram(d.program),
                        a.getProgramParameter(d.program, a.LINK_STATUS) || console.error(a.getProgramInfoLog(d.program)),
                        a.useProgram(d.program),
                        d.attachUniforms(void 0, s.commonUniforms),
                        d.attachUniforms(void 0, d.uniforms)
                    }
                    attachUniforms(u, h) {
                        const m = this;
                        u === void 0 ? Object.entries(h).forEach(([d,f])=>{
                            m.attachUniforms(d, f)
                        }
                        ) : h.type == "array" ? h.value.forEach((d,f)=>m.attachUniforms(`${u}[${f}]`, d)) : h.type == "struct" ? Object.entries(h.value).forEach(([d,f])=>m.attachUniforms(`${u}.${d}`, f)) : (s.debug("Material.attachUniforms", {
                            name: u,
                            uniform: h
                        }),
                        m.uniformInstances.push({
                            uniform: h,
                            location: a.getUniformLocation(m.program, u)
                        }))
                    }
                }
            },
            Uniform: {
                enumerable: !1,
                value: class {
                    constructor(u) {
                        this.type = "float",
                        Object.assign(this, u),
                        this.typeFn = {
                            float: "1f",
                            int: "1i",
                            vec2: "2fv",
                            vec3: "3fv",
                            vec4: "4fv",
                            mat4: "Matrix4fv"
                        }[this.type] || "1f",
                        this.update()
                    }
                    update(u) {
                        this.value !== void 0 && a[`uniform${this.typeFn}`](u, this.typeFn.indexOf("Matrix") === 0 ? this.transpose : this.value, this.typeFn.indexOf("Matrix") === 0 ? this.value : null)
                    }
                    getDeclaration(u, h, m) {
                        const d = this;
                        if (d.excludeFrom !== h) {
                            if (d.type === "array")
                                return d.value[0].getDeclaration(u, h, d.value.length) + `
const int ${u}_length = ${d.value.length};`;
                            if (d.type === "struct") {
                                let f = u.replace("u_", "");
                                return f = f.charAt(0).toUpperCase() + f.slice(1),
                                `uniform struct ${f} 
                                {
` + Object.entries(d.value).map(([_,g])=>g.getDeclaration(_, h).replace(/^uniform/, "")).join("") + `
} ${u}${m > 0 ? `[${m}]` : ""};`
                            }
                            return `uniform ${d.type} ${u}${m > 0 ? `[${m}]` : ""};`
                        }
                    }
                }
            },
            PlaneGeometry: {
                enumerable: !1,
                value: class {
                    constructor(u, h, m, d, f) {
                        a.createBuffer(),
                        this.attributes = {
                            position: new s.Attribute({
                                target: a.ARRAY_BUFFER,
                                size: 3
                            }),
                            uv: new s.Attribute({
                                target: a.ARRAY_BUFFER,
                                size: 2
                            }),
                            uvNorm: new s.Attribute({
                                target: a.ARRAY_BUFFER,
                                size: 2
                            }),
                            index: new s.Attribute({
                                target: a.ELEMENT_ARRAY_BUFFER,
                                size: 3,
                                type: a.UNSIGNED_SHORT
                            })
                        },
                        this.setTopology(m, d),
                        this.setSize(u, h, f)
                    }
                    setTopology(u=1, h=1) {
                        const m = this;
                        m.xSegCount = u,
                        m.ySegCount = h,
                        m.vertexCount = (m.xSegCount + 1) * (m.ySegCount + 1),
                        m.quadCount = m.xSegCount * m.ySegCount * 2,
                        m.attributes.uv.values = new Float32Array(2 * m.vertexCount),
                        m.attributes.uvNorm.values = new Float32Array(2 * m.vertexCount),
                        m.attributes.index.values = new Uint16Array(3 * m.quadCount);
                        for (let d = 0; d <= m.ySegCount; d++)
                            for (let f = 0; f <= m.xSegCount; f++) {
                                const _ = d * (m.xSegCount + 1) + f;
                                if (m.attributes.uv.values[2 * _] = f / m.xSegCount,
                                m.attributes.uv.values[2 * _ + 1] = 1 - d / m.ySegCount,
                                m.attributes.uvNorm.values[2 * _] = f / m.xSegCount * 2 - 1,
                                m.attributes.uvNorm.values[2 * _ + 1] = 1 - d / m.ySegCount * 2,
                                f < m.xSegCount && d < m.ySegCount) {
                                    const g = d * m.xSegCount + f;
                                    m.attributes.index.values[6 * g] = _,
                                    m.attributes.index.values[6 * g + 1] = _ + 1 + m.xSegCount,
                                    m.attributes.index.values[6 * g + 2] = _ + 1,
                                    m.attributes.index.values[6 * g + 3] = _ + 1,
                                    m.attributes.index.values[6 * g + 4] = _ + 1 + m.xSegCount,
                                    m.attributes.index.values[6 * g + 5] = _ + 2 + m.xSegCount
                                }
                            }
                        m.attributes.uv.update(),
                        m.attributes.uvNorm.update(),
                        m.attributes.index.update(),
                        s.debug("Geometry.setTopology", {
                            uv: m.attributes.uv,
                            uvNorm: m.attributes.uvNorm,
                            index: m.attributes.index
                        })
                    }
                    setSize(u=1, h=1, m="xz") {
                        const d = this;
                        d.width = u,
                        d.height = h,
                        d.orientation = m,
                        d.attributes.position.values && d.attributes.position.values.length === 3 * d.vertexCount || (d.attributes.position.values = new Float32Array(3 * d.vertexCount));
                        const f = u / -2
                          , _ = h / -2
                          , g = u / d.xSegCount
                          , v = h / d.ySegCount;
                        for (let y = 0; y <= d.ySegCount; y++) {
                            const w = _ + y * v;
                            for (let S = 0; S <= d.xSegCount; S++) {
                                const E = f + S * g
                                  , b = y * (d.xSegCount + 1) + S;
                                d.attributes.position.values[3 * b + "xyz".indexOf(m[0])] = E,
                                d.attributes.position.values[3 * b + "xyz".indexOf(m[1])] = -w
                            }
                        }
                        d.attributes.position.update(),
                        s.debug("Geometry.setSize", {
                            position: d.attributes.position
                        })
                    }
                }
            },
            Mesh: {
                enumerable: !1,
                value: class {
                    constructor(u, h) {
                        const m = this;
                        m.geometry = u,
                        m.material = h,
                        m.wireframe = !1,
                        m.attributeInstances = [],
                        Object.entries(m.geometry.attributes).forEach(([d,f])=>{
                            m.attributeInstances.push({
                                attribute: f,
                                location: f.attach(d, m.material.program)
                            })
                        }
                        ),
                        s.meshes.push(m),
                        s.debug("Mesh.constructor", {
                            mesh: m
                        })
                    }
                    draw() {
                        a.useProgram(this.material.program),
                        this.material.uniformInstances.forEach(({uniform: u, location: h})=>u.update(h)),
                        this.attributeInstances.forEach(({attribute: u, location: h})=>u.use(h)),
                        a.drawElements(this.wireframe ? a.LINES : a.TRIANGLES, this.geometry.attributes.index.values.length, a.UNSIGNED_SHORT, 0)
                    }
                    remove() {
                        s.meshes = s.meshes.filter(u=>u != this)
                    }
                }
            },
            Attribute: {
                enumerable: !1,
                value: class {
                    constructor(u) {
                        this.type = a.FLOAT,
                        this.normalized = !1,
                        this.buffer = a.createBuffer(),
                        Object.assign(this, u),
                        this.update()
                    }
                    update() {
                        this.values !== void 0 && (a.bindBuffer(this.target, this.buffer),
                        a.bufferData(this.target, this.values, a.STATIC_DRAW))
                    }
                    attach(u, h) {
                        const m = a.getAttribLocation(h, u);
                        return this.target === a.ARRAY_BUFFER && (a.enableVertexAttribArray(m),
                        a.vertexAttribPointer(m, this.size, this.type, this.normalized, 0, 0)),
                        m
                    }
                    use(u) {
                        a.bindBuffer(this.target, this.buffer),
                        this.target === a.ARRAY_BUFFER && (a.enableVertexAttribArray(u),
                        a.vertexAttribPointer(u, this.size, this.type, this.normalized, 0, 0))
                    }
                }
            }
        });
        const c = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        s.commonUniforms = {
            projectionMatrix: new s.Uniform({
                type: "mat4",
                value: c
            }),
            modelViewMatrix: new s.Uniform({
                type: "mat4",
                value: c
            }),
            resolution: new s.Uniform({
                type: "vec2",
                value: [1, 1]
            }),
            aspectRatio: new s.Uniform({
                type: "float",
                value: 1
            })
        }
    }
    setSize(e=640, t=480) {
        this.width = e,
        this.height = t,
        this.canvas.width = e,
        this.canvas.height = t,
        this.gl.viewport(0, 0, e, t),
        this.commonUniforms.resolution.value = [e, t],
        this.commonUniforms.aspectRatio.value = e / t,
        this.debug("MiniGL.setSize", {
            width: e,
            height: t
        })
    }
    setOrthographicCamera(e=0, t=0, i=0, r=-2e3, s=2e3) {
        this.commonUniforms.projectionMatrix.value = [2 / this.width, 0, 0, 0, 0, 2 / this.height, 0, 0, 0, 0, 2 / (r - s), 0, e, t, i, 1],
        this.debug("setOrthographicCamera", this.commonUniforms.projectionMatrix.value)
    }
    render() {
        this.gl.clearColor(0, 0, 0, 0),
        this.gl.clearDepth(1),
        this.meshes.forEach(e=>e.draw())
    }
}
function It(n, e, t) {
    return e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t,
    n
}
class Yre {
    constructor(...e) {
        It(this, "el", void 0),
        It(this, "cssVarRetries", 0),
        It(this, "maxCssVarRetries", 200),
        It(this, "angle", 0),
        It(this, "isLoadedClass", !1),
        It(this, "isScrolling", !1),
        It(this, "scrollingTimeout", void 0),
        It(this, "scrollingRefreshDelay", 200),
        It(this, "isIntersecting", !1),
        It(this, "shaderFiles", void 0),
        It(this, "vertexShader", void 0),
        It(this, "sectionColors", void 0),
        It(this, "computedCanvasStyle", void 0),
        It(this, "conf", void 0),
        It(this, "uniforms", void 0),
        It(this, "t", 1253106),
        It(this, "last", 0),
        It(this, "width", void 0),
        It(this, "minWidth", 1111),
        It(this, "height", 600),
        It(this, "xSegCount", void 0),
        It(this, "ySegCount", void 0),
        It(this, "mesh", void 0),
        It(this, "material", void 0),
        It(this, "geometry", void 0),
        It(this, "minigl", void 0),
        It(this, "scrollObserver", void 0),
        It(this, "amp", 320),
        It(this, "seed", 5),
        It(this, "freqX", 14e-5),
        It(this, "freqY", 29e-5),
        It(this, "freqDelta", 1e-5),
        It(this, "activeColors", [1, 1, 1, 1]),
        It(this, "isMetaKey", !1),
        It(this, "isGradientLegendVisible", !1),
        It(this, "isMouseDown", !1),
        It(this, "handleScroll", ()=>{
            clearTimeout(this.scrollingTimeout),
            this.scrollingTimeout = setTimeout(this.handleScrollEnd, this.scrollingRefreshDelay),
            this.isGradientLegendVisible && this.hideGradientLegend(),
            this.conf.playing && (this.isScrolling = !0,
            this.pause())
        }
        ),
        It(this, "handleScrollEnd", ()=>{
            this.isScrolling = !1,
            this.isIntersecting && this.play()
        }
        ),
        It(this, "resize", ()=>{
            this.width = window.innerWidth,
            this.minigl.setSize(this.width, this.height),
            this.minigl.setOrthographicCamera(),
            this.xSegCount = Math.ceil(this.width * this.conf.density[0]),
            this.ySegCount = Math.ceil(this.height * this.conf.density[1]),
            this.mesh.geometry.setTopology(this.xSegCount, this.ySegCount),
            this.mesh.geometry.setSize(this.width, this.height),
            this.mesh.material.uniforms.u_shadow_power.value = this.width < 600 ? 5 : 6
        }
        ),
        It(this, "handleMouseDown", t=>{
            this.isGradientLegendVisible && (this.isMetaKey = t.metaKey,
            this.isMouseDown = !0,
            this.conf.playing === !1 && requestAnimationFrame(this.animate))
        }
        ),
        It(this, "handleMouseUp", ()=>{
            this.isMouseDown = !1
        }
        ),
        It(this, "animate", t=>{
            if (!this.shouldSkipFrame(t) || this.isMouseDown) {
                if (this.t += Math.min(t - this.last, 1e3 / 15),
                this.last = t,
                this.isMouseDown) {
                    let i = 160;
                    this.isMetaKey && (i = -160),
                    this.t += i
                }
                this.mesh.material.uniforms.u_time.value = this.t,
                this.minigl.render()
            }
            if (this.last !== 0 && this.isStatic)
                return this.minigl.render(),
                void this.disconnect();
            (this.conf.playing || this.isMouseDown) && requestAnimationFrame(this.animate)
        }
        ),
        It(this, "addIsLoadedClass", ()=>{
            !this.isLoadedClass && (this.isLoadedClass = !0,
            this.el.classList.add("isLoaded"),
            setTimeout(()=>{
                this.el.parentElement.classList.add("isLoaded")
            }
            , 3e3))
        }
        ),
        It(this, "pause", ()=>{
            this.conf.playing = !1
        }
        ),
        It(this, "play", ()=>{
            requestAnimationFrame(this.animate),
            this.conf.playing = !0
        }
        ),
        It(this, "initGradient", t=>(this.el = t,
        this.connect(),
        this))
    }
    async connect() {
        this.shaderFiles = {
            vertex: `varying vec3 v_color;

void main() {
  float time = u_time * u_global.noiseSpeed;

  vec2 noiseCoord = resolution * uvNorm * u_global.noiseFreq;

  vec2 st = 1. - uvNorm.xy;

  //
  // Tilting the plane
  //

  // Front-to-back tilt
  float tilt = resolution.y / 2.0 * uvNorm.y;

  // Left-to-right angle
  float incline = resolution.x * uvNorm.x / 2.0 * u_vertDeform.incline;

  // Up-down shift to offset incline
  float offset = resolution.x / 2.0 * u_vertDeform.incline * mix(u_vertDeform.offsetBottom, u_vertDeform.offsetTop, uv.y);

  //
  // Vertex noise
  //

  float noise = snoise(vec3(
    noiseCoord.x * u_vertDeform.noiseFreq.x + time * u_vertDeform.noiseFlow,
    noiseCoord.y * u_vertDeform.noiseFreq.y,
    time * u_vertDeform.noiseSpeed + u_vertDeform.noiseSeed
  )) * u_vertDeform.noiseAmp;

  // Fade noise to zero at edges
  noise *= 1.0 - pow(abs(uvNorm.y), 2.0);

  // Clamp to 0
  noise = max(0.0, noise);

  vec3 pos = vec3(
    position.x,
    position.y + tilt + incline + noise - offset,
    position.z
  );

  //
  // Vertex color, to be passed to fragment shader
  //

  if (u_active_colors[0] == 1.) {
    v_color = u_baseColor;
  }

  for (int i = 0; i < u_waveLayers_length; i++) {
    if (u_active_colors[i + 1] == 1.) {
      WaveLayers layer = u_waveLayers[i];

      float noise = smoothstep(
        layer.noiseFloor,
        layer.noiseCeil,
        snoise(vec3(
          noiseCoord.x * layer.noiseFreq.x + time * layer.noiseFlow,
          noiseCoord.y * layer.noiseFreq.y,
          time * layer.noiseSpeed + layer.noiseSeed
        )) / 2.0 + 0.5
      );

      v_color = blendNormal(v_color, layer.color, pow(noise, 4.));
    }
  }

  //
  // Finish
  //

  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
}`,
            noise: `//
// Description : Array and textureless GLSL 2D/3D/4D simplex
//               noise functions.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : stegu
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//               https://github.com/stegu/webgl-noise
//

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
    return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

float snoise(vec3 v)
{
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

// First corner
  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 =   v - i + dot(i, C.xxx) ;

// Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  //   x0 = x0 - 0.0 + 0.0 * C.xxx;
  //   x1 = x0 - i1  + 1.0 * C.xxx;
  //   x2 = x0 - i2  + 2.0 * C.xxx;
  //   x3 = x0 - 1.0 + 3.0 * C.xxx;
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

// Permutations
  i = mod289(i);
  vec4 p = permute( permute( permute(
            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
          + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

// Gradients: 7x7 points over a square, mapped onto an octahedron.
// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
  float n_ = 0.142857142857; // 1.0/7.0
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

//Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

// Mix final noise value
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                dot(p2,x2), dot(p3,x3) ) );
}`,
            blend: `//
// https://github.com/jamieowen/glsl-blend
//

// Normal

vec3 blendNormal(vec3 base, vec3 blend) {
	return blend;
}

vec3 blendNormal(vec3 base, vec3 blend, float opacity) {
	return (blendNormal(base, blend) * opacity + base * (1.0 - opacity));
}

// Screen

float blendScreen(float base, float blend) {
	return 1.0-((1.0-base)*(1.0-blend));
}

vec3 blendScreen(vec3 base, vec3 blend) {
	return vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));
}

vec3 blendScreen(vec3 base, vec3 blend, float opacity) {
	return (blendScreen(base, blend) * opacity + base * (1.0 - opacity));
}

// Multiply

vec3 blendMultiply(vec3 base, vec3 blend) {
	return base*blend;
}

vec3 blendMultiply(vec3 base, vec3 blend, float opacity) {
	return (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));
}

// Overlay

float blendOverlay(float base, float blend) {
	return base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));
}

vec3 blendOverlay(vec3 base, vec3 blend) {
	return vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));
}

vec3 blendOverlay(vec3 base, vec3 blend, float opacity) {
	return (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));
}

// Hard light

vec3 blendHardLight(vec3 base, vec3 blend) {
	return blendOverlay(blend,base);
}

vec3 blendHardLight(vec3 base, vec3 blend, float opacity) {
	return (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));
}

// Soft light

float blendSoftLight(float base, float blend) {
	return (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));
}

vec3 blendSoftLight(vec3 base, vec3 blend) {
	return vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));
}

vec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {
	return (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));
}

// Color dodge

float blendColorDodge(float base, float blend) {
	return (blend==1.0)?blend:min(base/(1.0-blend),1.0);
}

vec3 blendColorDodge(vec3 base, vec3 blend) {
	return vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));
}

vec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {
	return (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));
}

// Color burn

float blendColorBurn(float base, float blend) {
	return (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);
}

vec3 blendColorBurn(vec3 base, vec3 blend) {
	return vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));
}

vec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {
	return (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));
}

// Vivid Light

float blendVividLight(float base, float blend) {
	return (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));
}

vec3 blendVividLight(vec3 base, vec3 blend) {
	return vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));
}

vec3 blendVividLight(vec3 base, vec3 blend, float opacity) {
	return (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));
}

// Lighten

float blendLighten(float base, float blend) {
	return max(blend,base);
}

vec3 blendLighten(vec3 base, vec3 blend) {
	return vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));
}

vec3 blendLighten(vec3 base, vec3 blend, float opacity) {
	return (blendLighten(base, blend) * opacity + base * (1.0 - opacity));
}

// Linear burn

float blendLinearBurn(float base, float blend) {
	// Note : Same implementation as BlendSubtractf
	return max(base+blend-1.0,0.0);
}

vec3 blendLinearBurn(vec3 base, vec3 blend) {
	// Note : Same implementation as BlendSubtract
	return max(base+blend-vec3(1.0),vec3(0.0));
}

vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {
	return (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));
}

// Linear dodge

float blendLinearDodge(float base, float blend) {
	// Note : Same implementation as BlendAddf
	return min(base+blend,1.0);
}

vec3 blendLinearDodge(vec3 base, vec3 blend) {
	// Note : Same implementation as BlendAdd
	return min(base+blend,vec3(1.0));
}

vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
	return (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));
}

// Linear light

float blendLinearLight(float base, float blend) {
	return blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));
}

vec3 blendLinearLight(vec3 base, vec3 blend) {
	return vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));
}

vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
	return (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));
}`,
            fragment: `varying vec3 v_color;

void main() {
  vec3 color = v_color;
  if (u_darken_top == 1.0) {
    vec2 st = gl_FragCoord.xy/resolution.xy;
    color.g -= pow(st.y + sin(-12.0) * st.x, u_shadow_power) * 0.4;
  }
  gl_FragColor = vec4(color, 1.0);
}`
        },
        this.conf = {
            presetName: "",
            wireframe: !1,
            density: [.06, .16],
            zoom: 1,
            rotation: 0,
            playing: !0
        },
        document.querySelectorAll("canvas").length < 1 ? console.log("DID NOT LOAD HERO STRIPE CANVAS") : (this.minigl = new jre(this.el,null,null,!0),
        requestAnimationFrame(()=>{
            this.el && (this.computedCanvasStyle = getComputedStyle(this.el),
            this.waitForCssVars())
        }
        ))
    }
    disconnect() {
        this.scrollObserver && (window.removeEventListener("scroll", this.handleScroll),
        window.removeEventListener("mousedown", this.handleMouseDown),
        window.removeEventListener("mouseup", this.handleMouseUp),
        window.removeEventListener("keydown", this.handleKeyDown),
        this.scrollObserver.disconnect()),
        window.removeEventListener("resize", this.resize)
    }
    initMaterial() {
        this.uniforms = {
            u_time: new this.minigl.Uniform({
                value: 0
            }),
            u_shadow_power: new this.minigl.Uniform({
                value: 5
            }),
            u_darken_top: new this.minigl.Uniform({
                value: this.el.dataset.jsDarkenTop === "" ? 1 : 0
            }),
            u_active_colors: new this.minigl.Uniform({
                value: this.activeColors,
                type: "vec4"
            }),
            u_global: new this.minigl.Uniform({
                value: {
                    noiseFreq: new this.minigl.Uniform({
                        value: [this.freqX, this.freqY],
                        type: "vec2"
                    }),
                    noiseSpeed: new this.minigl.Uniform({
                        value: 5e-6
                    })
                },
                type: "struct"
            }),
            u_vertDeform: new this.minigl.Uniform({
                value: {
                    incline: new this.minigl.Uniform({
                        value: Math.sin(this.angle) / Math.cos(this.angle)
                    }),
                    offsetTop: new this.minigl.Uniform({
                        value: -.5
                    }),
                    offsetBottom: new this.minigl.Uniform({
                        value: -.5
                    }),
                    noiseFreq: new this.minigl.Uniform({
                        value: [3, 4],
                        type: "vec2"
                    }),
                    noiseAmp: new this.minigl.Uniform({
                        value: this.amp
                    }),
                    noiseSpeed: new this.minigl.Uniform({
                        value: 10
                    }),
                    noiseFlow: new this.minigl.Uniform({
                        value: 3
                    }),
                    noiseSeed: new this.minigl.Uniform({
                        value: this.seed
                    })
                },
                type: "struct",
                excludeFrom: "fragment"
            }),
            u_baseColor: new this.minigl.Uniform({
                value: this.sectionColors[0],
                type: "vec3",
                excludeFrom: "fragment"
            }),
            u_waveLayers: new this.minigl.Uniform({
                value: [],
                excludeFrom: "fragment",
                type: "array"
            })
        };
        for (let e = 1; e < this.sectionColors.length; e += 1)
            this.uniforms.u_waveLayers.value.push(new this.minigl.Uniform({
                value: {
                    color: new this.minigl.Uniform({
                        value: this.sectionColors[e],
                        type: "vec3"
                    }),
                    noiseFreq: new this.minigl.Uniform({
                        value: [2 + e / this.sectionColors.length, 3 + e / this.sectionColors.length],
                        type: "vec2"
                    }),
                    noiseSpeed: new this.minigl.Uniform({
                        value: 11 + .3 * e
                    }),
                    noiseFlow: new this.minigl.Uniform({
                        value: 6.5 + .3 * e
                    }),
                    noiseSeed: new this.minigl.Uniform({
                        value: this.seed + 10 * e
                    }),
                    noiseFloor: new this.minigl.Uniform({
                        value: .1
                    }),
                    noiseCeil: new this.minigl.Uniform({
                        value: .63 + .07 * e
                    })
                },
                type: "struct"
            }));
        return this.vertexShader = [this.shaderFiles.noise, this.shaderFiles.blend, this.shaderFiles.vertex].join(`

`),
        new this.minigl.Material(this.vertexShader,this.shaderFiles.fragment,this.uniforms)
    }
    initMesh() {
        this.material = this.initMaterial(),
        this.geometry = new this.minigl.PlaneGeometry,
        this.mesh = new this.minigl.Mesh(this.geometry,this.material)
    }
    shouldSkipFrame(e) {
        return !!window.document.hidden || !this.conf.playing || parseInt(e, 10) % 2 == 0 || void 0
    }
    updateFrequency(e) {
        this.freqX += e,
        this.freqY += e
    }
    toggleColor(e) {
        this.activeColors[e] = this.activeColors[e] === 0 ? 1 : 0
    }
    showGradientLegend() {
        this.width > this.minWidth && (this.isGradientLegendVisible = !0,
        document.body.classList.add("isGradientLegendVisible"))
    }
    hideGradientLegend() {
        this.isGradientLegendVisible = !1,
        document.body.classList.remove("isGradientLegendVisible")
    }
    init() {
        this.initGradientColors(),
        this.initMesh(),
        this.resize(),
        requestAnimationFrame(this.animate),
        window.addEventListener("resize", this.resize)
    }
    waitForCssVars() {
        if (this.computedCanvasStyle && this.computedCanvasStyle.getPropertyValue("--gradient-color-1").indexOf("#") !== -1)
            this.init(),
            this.addIsLoadedClass();
        else {
            if (this.cssVarRetries += 1,
            this.cssVarRetries > this.maxCssVarRetries)
                return this.sectionColors = [16711680, 16711680, 16711935, 65280, 255],
                void this.init();
            requestAnimationFrame(()=>this.waitForCssVars())
        }
    }
    initGradientColors() {
        this.sectionColors = ["--gradient-color-1", "--gradient-color-2", "--gradient-color-3", "--gradient-color-4"].map(e=>{
            let t = this.computedCanvasStyle.getPropertyValue(e).trim();
            return t.length === 4 && (t = `#${t.substr(1).split("").map(r=>r + r).join("")}`),
            t && `0x${t.substr(1)}`
        }
        ).filter(Boolean).map(qre)
    }
}
let Kre = class {
    constructor() {
        this.playgroundGradientElement = document.querySelector(".card__playground__canvas"),
        this.cardSlotElement = document.querySelector(".card__slot"),
        this.isVisible = !1,
        this.gradients = {
            playground: null,
            profile: null,
            cardSlot: null
        }
    }
    addNewGradient(e) {
        Jt.each(e, t=>{
            let i = this.gradients[t.name];
            i !== null ? (i.pause(),
            i.initGradient(t.element),
            i.play()) : (i = new Yre,
            i.initGradient(t.element),
            i.play(),
            this.gradients[t.name] = i)
        }
        )
    }
    add(e) {
        e === "/" ? this.addNewGradient([{
            name: "playground",
            element: this.playgroundGradientElement
        }]) : ve.delayedCall(.5, ()=>{
            const t = this.cardSlotElement.querySelector("canvas");
            this.addNewGradient([{
                name: "cardSlot",
                element: t
            }])
        }
        )
    }
    show() {}
    hide() {}
}
;
class Zre {
    constructor({template: e, page: t, updateScroll: i}) {
        this.template = e,
        this.updateScroll = i,
        this.threeCanvas = document.querySelector(".three"),
        this.matterCanvas = document.querySelector(".matter"),
        this.isVisible = !0,
        this.textureLoaded = !1,
        this.createThree(),
        this.createMatter(),
        this.onResize(),
        this.createCard(),
        this.createProjects(),
        this.createPlayground(),
        this.createNotFound(),
        this.createLoader(t)
    }
    createThree() {
        this.createRenderer(),
        this.createScene(),
        this.createCamera()
    }
    createRenderer() {
        this.renderer = new ER({
            alpha: !0,
            antialias: !0,
            canvas: this.threeCanvas
        }),
        this.renderer.setSize(window.innerWidth, window.innerHeight)
    }
    createScene() {
        this.scene = new SG
    }
    createCamera() {
        this.camera = new ps(45,window.innerWidth / window.innerHeight,.1,100),
        this.camera.position.z = 5
    }
    createMatter() {
        this.engine = qt.Engine.create(),
        this.render = qt.Render.create({
            canvas: this.matterCanvas,
            engine: this.engine,
            options: {
                background: "transparent",
                wireframes: !1,
                width: window.innerWidth,
                height: window.innerHeight
            }
        }),
        this.ground = qt.Bodies.rectangle(window.innerWidth / 2, window.innerHeight + 32, 27184, 60, {
            isStatic: !0
        }),
        this.leftWall = qt.Bodies.rectangle(0 - 30, window.innerHeight / 2, 60, window.innerHeight, {
            isStatic: !0
        }),
        this.rightWall = qt.Bodies.rectangle(window.innerWidth + 30, window.innerHeight / 2, 60, window.innerHeight, {
            isStatic: !0
        });
        const e = qt.Mouse.create(this.render.canvas)
          , t = qt.MouseConstraint.create(this.engine, {
            mouse: e,
            constraint: {
                stiffness: .2,
                render: {
                    visible: !1
                }
            }
        });
        qt.Composite.add(this.engine.world, this.ground),
        qt.Composite.add(this.engine.world, this.leftWall),
        qt.Composite.add(this.engine.world, this.rightWall),
        qt.Composite.add(this.engine.world, t),
        qt.Render.run(this.render),
        this.runner = qt.Runner.create(),
        qt.Runner.run(this.runner, this.engine)
    }
    createLoader(e) {
        if (e.id === "playground" && !this.textureLoaded) {
            this.textureLoaded = !0;
            const t = new CG;
            Promise.all(Jt.map(window.ASSETS, r=>new Promise(s=>{
                t.load(r, o=>{
                    window.TEXTURES[r] = o,
                    s()
                }
                )
            }
            ))).then(()=>{
                this.playground.createTexture()
            }
            )
        }
    }
    createCard() {
        this.card = new Kre
    }
    createProjects() {
        this.projects = new Sj({
            screen: this.screen,
            engine: this.engine,
            matterCanvas: this.matterCanvas
        })
    }
    createPlayground() {
        this.playground = new $re({
            scene: this.scene,
            screen: this.screen,
            viewport: this.viewport,
            updateScroll: this.updateScroll
        })
    }
    createNotFound() {
        this.notFound = new Xre({
            screen: this.screen,
            engine: this.engine,
            matterCanvas: this.matterCanvas
        })
    }
    onPreloaded() {
        this.onChangeEnd(this.template, !0)
    }
    onChangeStart() {
        this.template === "/playground" && this.playground.hide(),
        this.template.includes("project") && this.projects.hide(),
        this.template === "/404" && this.notFound.hide()
    }
    onChangeEnd(e, t) {
        e === "/" && this.card.add(e),
        e === "/playground" && (this.playground.show(t),
        this.card.add(e)),
        e.includes("project") && this.projects.show(e),
        e === "/404" && this.notFound.show(t),
        this.template = e
    }
    onResize() {
        this.screen = {
            width: window.innerWidth,
            height: window.innerHeight
        },
        this.renderer.setSize(this.screen.width, this.screen.height),
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)),
        this.camera.aspect = this.screen.width / this.screen.height,
        this.camera.updateProjectionMatrix(),
        this.render.canvas.width = this.screen.width,
        this.render.canvas.height = this.screen.height,
        qt.Body.setPosition(this.ground, qt.Vector.create(this.screen.width / 2, this.screen.height + 32)),
        qt.Body.setPosition(this.leftWall, qt.Vector.create(0 - 30, this.screen.height / 2)),
        qt.Body.setPosition(this.rightWall, qt.Vector.create(this.screen.width + 30, this.screen.height / 2));
        const e = this.camera.fov * (Math.PI / 180)
          , t = 2 * Math.tan(e / 2) * this.camera.position.z
          , i = t * this.camera.aspect;
        this.viewport = {
            width: i,
            height: t
        },
        this.playground && this.playground.onResize && this.playground.onResize({
            screen: this.screen,
            viewport: this.viewport
        }),
        this.projects && this.projects.onResize && this.projects.onResize({
            screen: this.screen
        }),
        this.notFound && this.notFound.onResize && this.notFound.onResize({
            screen: this.screen
        })
    }
    onTouchDown(e) {
        this.playground && this.playground.onTouchDown && this.playground.onTouchDown(e)
    }
    onTouchMove(e) {
        this.playground && this.playground.onTouchMove && this.playground.onTouchMove(e)
    }
    onTouchUp() {
        this.playground && this.playground.onTouchUp && this.playground.onTouchUp()
    }
    onWheel(e) {
        this.playground && this.playground.onWheel && this.playground.onWheel(e)
    }
    update(e) {
        this.renderer.render(this.scene, this.camera),
        this.isVisible && (this.playground && this.playground.update && this.playground.update(e),
        this.projects && this.projects.update && this.projects.update(e))
    }
}
var VP = {
    exports: {}
}, E_ = {
    exports: {}
}, ZM;
function Jre() {
    return ZM || (ZM = 1,
    function(n) {
        (function(e, t) {
            n.exports ? n.exports = t() : e.EvEmitter = t()
        }
        )(typeof window < "u" ? window : lr, function() {
            function e() {}
            let t = e.prototype;
            return t.on = function(i, r) {
                if (!i || !r)
                    return this;
                let s = this._events = this._events || {}
                  , o = s[i] = s[i] || [];
                return o.includes(r) || o.push(r),
                this
            }
            ,
            t.once = function(i, r) {
                if (!i || !r)
                    return this;
                this.on(i, r);
                let s = this._onceEvents = this._onceEvents || {}
                  , o = s[i] = s[i] || {};
                return o[r] = !0,
                this
            }
            ,
            t.off = function(i, r) {
                let s = this._events && this._events[i];
                if (!s || !s.length)
                    return this;
                let o = s.indexOf(r);
                return o != -1 && s.splice(o, 1),
                this
            }
            ,
            t.emitEvent = function(i, r) {
                let s = this._events && this._events[i];
                if (!s || !s.length)
                    return this;
                s = s.slice(0),
                r = r || [];
                let o = this._onceEvents && this._onceEvents[i];
                for (let a of s)
                    o && o[a] && (this.off(i, a),
                    delete o[a]),
                    a.apply(this, r);
                return this
            }
            ,
            t.allOff = function() {
                return delete this._events,
                delete this._onceEvents,
                this
            }
            ,
            e
        })
    }(E_)),
    E_.exports
}
/*!
 * imagesLoaded v5.0.0
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */
(function(n) {
    (function(e, t) {
        n.exports ? n.exports = t(e, Jre()) : e.imagesLoaded = t(e, e.EvEmitter)
    }
    )(typeof window < "u" ? window : lr, function(t, i) {
        let r = t.jQuery
          , s = t.console;
        function o(d) {
            return Array.isArray(d) ? d : typeof d == "object" && typeof d.length == "number" ? [...d] : [d]
        }
        function a(d, f, _) {
            if (!(this instanceof a))
                return new a(d,f,_);
            let g = d;
            if (typeof d == "string" && (g = document.querySelectorAll(d)),
            !g) {
                s.error(`Bad element for imagesLoaded ${g || d}`);
                return
            }
            this.elements = o(g),
            this.options = {},
            typeof f == "function" ? _ = f : Object.assign(this.options, f),
            _ && this.on("always", _),
            this.getImages(),
            r && (this.jqDeferred = new r.Deferred),
            setTimeout(this.check.bind(this))
        }
        a.prototype = Object.create(i.prototype),
        a.prototype.getImages = function() {
            this.images = [],
            this.elements.forEach(this.addElementImages, this)
        }
        ;
        const c = [1, 9, 11];
        a.prototype.addElementImages = function(d) {
            d.nodeName === "IMG" && this.addImage(d),
            this.options.background === !0 && this.addElementBackgroundImages(d);
            let {nodeType: f} = d;
            if (!f || !c.includes(f))
                return;
            let _ = d.querySelectorAll("img");
            for (let g of _)
                this.addImage(g);
            if (typeof this.options.background == "string") {
                let g = d.querySelectorAll(this.options.background);
                for (let v of g)
                    this.addElementBackgroundImages(v)
            }
        }
        ;
        const u = /url\((['"])?(.*?)\1\)/gi;
        a.prototype.addElementBackgroundImages = function(d) {
            let f = getComputedStyle(d);
            if (!f)
                return;
            let _ = u.exec(f.backgroundImage);
            for (; _ !== null; ) {
                let g = _ && _[2];
                g && this.addBackground(g, d),
                _ = u.exec(f.backgroundImage)
            }
        }
        ,
        a.prototype.addImage = function(d) {
            let f = new h(d);
            this.images.push(f)
        }
        ,
        a.prototype.addBackground = function(d, f) {
            let _ = new m(d,f);
            this.images.push(_)
        }
        ,
        a.prototype.check = function() {
            if (this.progressedCount = 0,
            this.hasAnyBroken = !1,
            !this.images.length) {
                this.complete();
                return
            }
            let d = (f,_,g)=>{
                setTimeout(()=>{
                    this.progress(f, _, g)
                }
                )
            }
            ;
            this.images.forEach(function(f) {
                f.once("progress", d),
                f.check()
            })
        }
        ,
        a.prototype.progress = function(d, f, _) {
            this.progressedCount++,
            this.hasAnyBroken = this.hasAnyBroken || !d.isLoaded,
            this.emitEvent("progress", [this, d, f]),
            this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify(this, d),
            this.progressedCount === this.images.length && this.complete(),
            this.options.debug && s && s.log(`progress: ${_}`, d, f)
        }
        ,
        a.prototype.complete = function() {
            let d = this.hasAnyBroken ? "fail" : "done";
            if (this.isComplete = !0,
            this.emitEvent(d, [this]),
            this.emitEvent("always", [this]),
            this.jqDeferred) {
                let f = this.hasAnyBroken ? "reject" : "resolve";
                this.jqDeferred[f](this)
            }
        }
        ;
        function h(d) {
            this.img = d
        }
        h.prototype = Object.create(i.prototype),
        h.prototype.check = function() {
            if (this.getIsImageComplete()) {
                this.confirm(this.img.naturalWidth !== 0, "naturalWidth");
                return
            }
            this.proxyImage = new Image,
            this.img.crossOrigin && (this.proxyImage.crossOrigin = this.img.crossOrigin),
            this.proxyImage.addEventListener("load", this),
            this.proxyImage.addEventListener("error", this),
            this.img.addEventListener("load", this),
            this.img.addEventListener("error", this),
            this.proxyImage.src = this.img.currentSrc || this.img.src
        }
        ,
        h.prototype.getIsImageComplete = function() {
            return this.img.complete && this.img.naturalWidth
        }
        ,
        h.prototype.confirm = function(d, f) {
            this.isLoaded = d;
            let {parentNode: _} = this.img
              , g = _.nodeName === "PICTURE" ? _ : this.img;
            this.emitEvent("progress", [this, g, f])
        }
        ,
        h.prototype.handleEvent = function(d) {
            let f = "on" + d.type;
            this[f] && this[f](d)
        }
        ,
        h.prototype.onload = function() {
            this.confirm(!0, "onload"),
            this.unbindEvents()
        }
        ,
        h.prototype.onerror = function() {
            this.confirm(!1, "onerror"),
            this.unbindEvents()
        }
        ,
        h.prototype.unbindEvents = function() {
            this.proxyImage.removeEventListener("load", this),
            this.proxyImage.removeEventListener("error", this),
            this.img.removeEventListener("load", this),
            this.img.removeEventListener("error", this)
        }
        ;
        function m(d, f) {
            this.url = d,
            this.element = f,
            this.img = new Image
        }
        return m.prototype = Object.create(h.prototype),
        m.prototype.check = function() {
            this.img.addEventListener("load", this),
            this.img.addEventListener("error", this),
            this.img.src = this.url,
            this.getIsImageComplete() && (this.confirm(this.img.naturalWidth !== 0, "naturalWidth"),
            this.unbindEvents())
        }
        ,
        m.prototype.unbindEvents = function() {
            this.img.removeEventListener("load", this),
            this.img.removeEventListener("error", this)
        }
        ,
        m.prototype.confirm = function(d, f) {
            this.isLoaded = d,
            this.emitEvent("progress", [this, this.element, f])
        }
        ,
        a.makeJQueryPlugin = function(d) {
            d = d || t.jQuery,
            d && (r = d,
            r.fn.imagesLoaded = function(f, _) {
                return new a(this,f,_).jqDeferred.promise(r(this))
            }
            )
        }
        ,
        a.makeJQueryPlugin(),
        a
    })
}
)(VP);
var Qre = VP.exports;
const ese = Uo(Qre);
var mx = {
    exports: {}
}, zc = typeof Reflect == "object" ? Reflect : null, JM = zc && typeof zc.apply == "function" ? zc.apply : function(e, t, i) {
    return Function.prototype.apply.call(e, t, i)
}
, hp;
zc && typeof zc.ownKeys == "function" ? hp = zc.ownKeys : Object.getOwnPropertySymbols ? hp = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
}
: hp = function(e) {
    return Object.getOwnPropertyNames(e)
}
;
function tse(n) {
    console && console.warn && console.warn(n)
}
var WP = Number.isNaN || function(e) {
    return e !== e
}
;
function gn() {
    gn.init.call(this)
}
mx.exports = gn;
mx.exports.once = sse;
gn.EventEmitter = gn;
gn.prototype._events = void 0;
gn.prototype._eventsCount = 0;
gn.prototype._maxListeners = void 0;
var QM = 10;
function bm(n) {
    if (typeof n != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof n)
}
Object.defineProperty(gn, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
        return QM
    },
    set: function(n) {
        if (typeof n != "number" || n < 0 || WP(n))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + n + ".");
        QM = n
    }
});
gn.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null),
    this._eventsCount = 0),
    this._maxListeners = this._maxListeners || void 0
}
;
gn.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || WP(e))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e,
    this
}
;
function $P(n) {
    return n._maxListeners === void 0 ? gn.defaultMaxListeners : n._maxListeners
}
gn.prototype.getMaxListeners = function() {
    return $P(this)
}
;
gn.prototype.emit = function(e) {
    for (var t = [], i = 1; i < arguments.length; i++)
        t.push(arguments[i]);
    var r = e === "error"
      , s = this._events;
    if (s !== void 0)
        r = r && s.error === void 0;
    else if (!r)
        return !1;
    if (r) {
        var o;
        if (t.length > 0 && (o = t[0]),
        o instanceof Error)
            throw o;
        var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
        throw a.context = o,
        a
    }
    var c = s[e];
    if (c === void 0)
        return !1;
    if (typeof c == "function")
        JM(c, this, t);
    else
        for (var u = c.length, h = KP(c, u), i = 0; i < u; ++i)
            JM(h[i], this, t);
    return !0
}
;
function XP(n, e, t, i) {
    var r, s, o;
    if (bm(t),
    s = n._events,
    s === void 0 ? (s = n._events = Object.create(null),
    n._eventsCount = 0) : (s.newListener !== void 0 && (n.emit("newListener", e, t.listener ? t.listener : t),
    s = n._events),
    o = s[e]),
    o === void 0)
        o = s[e] = t,
        ++n._eventsCount;
    else if (typeof o == "function" ? o = s[e] = i ? [t, o] : [o, t] : i ? o.unshift(t) : o.push(t),
    r = $P(n),
    r > 0 && o.length > r && !o.warned) {
        o.warned = !0;
        var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        a.name = "MaxListenersExceededWarning",
        a.emitter = n,
        a.type = e,
        a.count = o.length,
        tse(a)
    }
    return n
}
gn.prototype.addListener = function(e, t) {
    return XP(this, e, t, !1)
}
;
gn.prototype.on = gn.prototype.addListener;
gn.prototype.prependListener = function(e, t) {
    return XP(this, e, t, !0)
}
;
function nse() {
    if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn),
        this.fired = !0,
        arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
}
function qP(n, e, t) {
    var i = {
        fired: !1,
        wrapFn: void 0,
        target: n,
        type: e,
        listener: t
    }
      , r = nse.bind(i);
    return r.listener = t,
    i.wrapFn = r,
    r
}
gn.prototype.once = function(e, t) {
    return bm(t),
    this.on(e, qP(this, e, t)),
    this
}
;
gn.prototype.prependOnceListener = function(e, t) {
    return bm(t),
    this.prependListener(e, qP(this, e, t)),
    this
}
;
gn.prototype.removeListener = function(e, t) {
    var i, r, s, o, a;
    if (bm(t),
    r = this._events,
    r === void 0)
        return this;
    if (i = r[e],
    i === void 0)
        return this;
    if (i === t || i.listener === t)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete r[e],
        r.removeListener && this.emit("removeListener", e, i.listener || t));
    else if (typeof i != "function") {
        for (s = -1,
        o = i.length - 1; o >= 0; o--)
            if (i[o] === t || i[o].listener === t) {
                a = i[o].listener,
                s = o;
                break
            }
        if (s < 0)
            return this;
        s === 0 ? i.shift() : ise(i, s),
        i.length === 1 && (r[e] = i[0]),
        r.removeListener !== void 0 && this.emit("removeListener", e, a || t)
    }
    return this
}
;
gn.prototype.off = gn.prototype.removeListener;
gn.prototype.removeAllListeners = function(e) {
    var t, i, r;
    if (i = this._events,
    i === void 0)
        return this;
    if (i.removeListener === void 0)
        return arguments.length === 0 ? (this._events = Object.create(null),
        this._eventsCount = 0) : i[e] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete i[e]),
        this;
    if (arguments.length === 0) {
        var s = Object.keys(i), o;
        for (r = 0; r < s.length; ++r)
            o = s[r],
            o !== "removeListener" && this.removeAllListeners(o);
        return this.removeAllListeners("removeListener"),
        this._events = Object.create(null),
        this._eventsCount = 0,
        this
    }
    if (t = i[e],
    typeof t == "function")
        this.removeListener(e, t);
    else if (t !== void 0)
        for (r = t.length - 1; r >= 0; r--)
            this.removeListener(e, t[r]);
    return this
}
;
function jP(n, e, t) {
    var i = n._events;
    if (i === void 0)
        return [];
    var r = i[e];
    return r === void 0 ? [] : typeof r == "function" ? t ? [r.listener || r] : [r] : t ? rse(r) : KP(r, r.length)
}
gn.prototype.listeners = function(e) {
    return jP(this, e, !0)
}
;
gn.prototype.rawListeners = function(e) {
    return jP(this, e, !1)
}
;
gn.listenerCount = function(n, e) {
    return typeof n.listenerCount == "function" ? n.listenerCount(e) : YP.call(n, e)
}
;
gn.prototype.listenerCount = YP;
function YP(n) {
    var e = this._events;
    if (e !== void 0) {
        var t = e[n];
        if (typeof t == "function")
            return 1;
        if (t !== void 0)
            return t.length
    }
    return 0
}
gn.prototype.eventNames = function() {
    return this._eventsCount > 0 ? hp(this._events) : []
}
;
function KP(n, e) {
    for (var t = new Array(e), i = 0; i < e; ++i)
        t[i] = n[i];
    return t
}
function ise(n, e) {
    for (; e + 1 < n.length; e++)
        n[e] = n[e + 1];
    n.pop()
}
function rse(n) {
    for (var e = new Array(n.length), t = 0; t < e.length; ++t)
        e[t] = n[t].listener || n[t];
    return e
}
function sse(n, e) {
    return new Promise(function(t, i) {
        function r(o) {
            n.removeListener(e, s),
            i(o)
        }
        function s() {
            typeof n.removeListener == "function" && n.removeListener("error", r),
            t([].slice.call(arguments))
        }
        ZP(n, e, s, {
            once: !0
        }),
        e !== "error" && ose(n, r, {
            once: !0
        })
    }
    )
}
function ose(n, e, t) {
    typeof n.on == "function" && ZP(n, "error", e, t)
}
function ZP(n, e, t, i) {
    if (typeof n.on == "function")
        i.once ? n.once(e, t) : n.on(e, t);
    else if (typeof n.addEventListener == "function")
        n.addEventListener(e, function r(s) {
            i.once && n.removeEventListener(e, r),
            t(s)
        });
    else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof n)
}
var ase = mx.exports;
const JP = Uo(ase);
function lse(n, e) {
    for (var t = -1, i = n == null ? 0 : n.length; ++t < i && e(n[t], t, n) !== !1; )
        ;
    return n
}
var cse = lse
  , use = YR;
function fse(n) {
    return typeof n == "function" ? n : use
}
var hse = fse
  , dse = cse
  , pse = KR
  , mse = hse
  , gse = so;
function _se(n, e) {
    var t = gse(n) ? dse : pse;
    return t(n, mse(e))
}
var vse = _se
  , yse = vse;
const xse = Uo(yse);
class Oa extends JP {
    constructor({classes: e, element: t, elements: i}) {
        super(),
        Il(this),
        this.classes = e,
        this.selector = t,
        this.selectorChildren = {
            ...i
        },
        this.create(),
        this.addEventListeners()
    }
    create() {
        this.selector instanceof window.HTMLElement ? this.element = this.selector : this.element = document.querySelector(this.selector),
        this.elements = {},
        xse(this.selectorChildren, (e,t)=>{
            e instanceof window.HTMLElement || e instanceof window.NodeList || Array.isArray(e) ? this.elements[t] = e : (this.elements[t] = this.element.querySelectorAll(e),
            this.elements[t].length === 0 ? this.elements[t] = null : this.elements[t].length === 1 && (this.elements[t] = this.element.querySelector(e)))
        }
        )
    }
    addEventListeners() {}
    removeEventListeners() {}
}
ve.registerPlugin(Bo);
const Bn = Bo.create("smooth", "0.7, 0, 0.3, 1")
  , af = Bo.create("translate", ".9, 0, .1, 1")
  , Gi = Bo.create("expoInOut", "1, 0, 0, 1")
  , eT = Bo.create("snap", "0, 1, 0.5, 1");
Bo.create("easeInOutCirc", "0.785, 0.135, 0.15, 0.86");
class bse extends Oa {
    constructor({gl: e, page: t}) {
        super({
            element: ".preloader",
            elements: {
                wrapper: ".preloader__wrapper",
                nav: ".preloader__nav",
                navTextFirst: ".preloader__first",
                navTextSecond: ".preloader__second",
                navTextThird: ".preloader__third",
                navTextFourth: ".preloader__fourth",
                navTextFifth: ".preloader__fifth",
                navLoader: ".preloader__nav__number__text",
                gallery: ".preloader__gallery",
                items: ".preloader__gallery__item",
                leftContainer: "preloader__nav__left__container"
            }
        }),
        this.gl = e,
        this.page = t,
        this.textureLoaded = 0,
        this.time = 0,
        this.prelaoderDuration = 2,
        this.totalAssets = window.ASSETS.length,
        this.transformPrefix = La("transform"),
        this.clock = new RG,
        this.isMobile = tn.isMobile || window.innerWidth <= 768,
        this.scroll = {
            position: 0,
            current: 0,
            target: 0,
            ease: .1
        },
        window.TEXTURES = {},
        ve.set(this.elements.nav, {
            autoAlpha: 1
        }),
        this.createLoader(),
        this.createAutoScroll()
    }
    createLoader() {
        const e = new Promise(t=>{
            ese(document.body, t)
        }
        );
        Promise.all([e]).then(()=>{
            this.onLoaded()
        }
        )
    }
    createAutoScroll() {
        Ot.scrollerProxy(".preloader__gallery", {
            scrollTop: ()=>this.scroll.current,
            getBoundingClientRect() {
                return {
                    top: 0,
                    left: 0,
                    width: window.innerWidth,
                    height: window.innerHeight
                }
            }
        }),
        Ot.defaults({
            scroller: ".preloader__gallery"
        })
    }
    onAssetLoaded() {
        this.textureLoaded += 1,
        this.textureLoaded / this.totalAssets === 1 && this.onLoaded()
    }
    onLoaded() {
        ve.set(this.elements.gallery, {
            autoAlpha: 1
        }),
        ve.fromTo(this.elements.items, {
            autoAlpha: 0
        }, {
            autoAlpha: 1,
            ease: Bn
        }),
        this.update(),
        ve.timeline({
            defaults: {
                ease: "none"
            },
            scrollTrigger: {
                trigger: this.elements.gallery,
                start: "top bottom+=5%",
                end: "bottom top-=5%",
                scrub: !0
            }
        }).set(this.elements.gallery, {
            transformOrigin: "0% 50%"
        }).set(this.elements.items, {
            transformOrigin: "50% 0%"
        }).to(this.elements.items, {
            duration: .5,
            ease: "power2",
            z: 500,
            stagger: .04
        }, 0).to(this.elements.items, {
            duration: .5,
            ease: "power2.in",
            z: 0,
            stagger: .04
        }, .5).fromTo(this.elements.items, {
            rotationX: -70,
            filter: "brightness(120%)"
        }, {
            duration: 1,
            rotationX: 70,
            filter: `brightness(${this.isMobile ? 20 : 0}%)`,
            stagger: .04
        }, 0),
        ve.to(this.elements.navLoader, {
            innerText: 100,
            duration: this.prelaoderDuration,
            ease: "linear",
            delay: .2,
            modifiers: {
                innerText: function(t) {
                    return ve.utils.snap(1, t).toString() + "%"
                }
            }
        }, 0),
        ve.delayedCall(this.prelaoderDuration, ()=>{
            ve.delayedCall(1.6, ()=>{
                Ot.getAll().forEach(i=>i.kill()),
                window.cancelAnimationFrame(this.updateFunction)
            }
            ),
            ve.timeline().set([document.body, document.documentElement], {
                backgroundColor: this.page.element.getAttribute("data-background"),
                color: this.page.element.getAttribute("data-color")
            }).to(this.elements.navTextFirst, {
                yPercent: 105,
                duration: .8,
                ease: Bn
            }, 0).to(this.elements.navTextSecond, {
                yPercent: 105,
                duration: .8,
                ease: Bn
            }, .2).to(this.elements.navTextThird, {
                yPercent: 105,
                duration: .8,
                ease: Bn
            }, .7).to(this.elements.navTextFourth, {
                yPercent: 105,
                duration: .8,
                ease: Bn
            }, .8).to(this.elements.navTextFifth, {
                yPercent: 105,
                duration: .8,
                ease: Bn
            }, .9).to(this.elements.items, {
                autoAlpha: 0,
                duration: .6,
                ease: Bn
            }, 1).to(this.element, {
                transformOrigin: "bottom",
                height: 0,
                duration: 1.2,
                ease: Gi,
                onComplete: ()=>{
                    this.destroy(),
                    this.emit("loaded")
                }
            }, .8)
        }
        )
    }
    update() {
        const e = this.clock.getElapsedTime()
          , t = e - this.time;
        this.time = e,
        this.scroll.target += t * 100,
        this.scroll.current = Wi(this.scroll.current, this.scroll.target, this.scroll.ease),
        this.elements.gallery.style[this.transformPrefix] = `translate(${this.isMobile ? -150 : -25}%, 0%) rotateY(30deg) translate3d(0, ${-Math.round(this.scroll.current)}px, 0)`,
        Ot.update(),
        this.updateFunction = window.requestAnimationFrame(this.update.bind(this))
    }
    destroy() {
        this.element.parentNode.removeChild(this.element)
    }
}
class Sse {
    constructor() {
        this.element = document.querySelector(".scroll"),
        this.reset()
    }
    update(e) {
        isNaN(e) ? this.element.innerText = "0%" : this.element.innerText = `${e}%`
    }
    reset() {
        this.element.innerText = "0%"
    }
}
(function() {
    function n() {
        for (var i = arguments.length, r = 0; r < i; r++) {
            var s = r < 0 || arguments.length <= r ? void 0 : arguments[r];
            s.nodeType === 1 || s.nodeType === 11 ? this.appendChild(s) : this.appendChild(document.createTextNode(String(s)))
        }
    }
    function e() {
        for (; this.lastChild; )
            this.removeChild(this.lastChild);
        arguments.length && this.append.apply(this, arguments)
    }
    function t() {
        for (var i = this.parentNode, r = arguments.length, s = new Array(r), o = 0; o < r; o++)
            s[o] = arguments[o];
        var a = s.length;
        if (i)
            for (a || i.removeChild(this); a--; ) {
                var c = s[a];
                typeof c != "object" ? c = this.ownerDocument.createTextNode(c) : c.parentNode && c.parentNode.removeChild(c),
                a ? i.insertBefore(this.previousSibling, c) : i.replaceChild(c, this)
            }
    }
    typeof Element < "u" && (Element.prototype.append || (Element.prototype.append = n,
    DocumentFragment.prototype.append = n),
    Element.prototype.replaceChildren || (Element.prototype.replaceChildren = e,
    DocumentFragment.prototype.replaceChildren = e),
    Element.prototype.replaceWith || (Element.prototype.replaceWith = t,
    DocumentFragment.prototype.replaceWith = t))
}
)();
function wse(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function tT(n, e) {
    for (var t = 0; t < e.length; t++) {
        var i = e[t];
        i.enumerable = i.enumerable || !1,
        i.configurable = !0,
        "value"in i && (i.writable = !0),
        Object.defineProperty(n, i.key, i)
    }
}
function nT(n, e, t) {
    return e && tT(n.prototype, e),
    t && tT(n, t),
    n
}
function Ese(n, e, t) {
    return e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t,
    n
}
function iT(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(n);
        e && (i = i.filter(function(r) {
            return Object.getOwnPropertyDescriptor(n, r).enumerable
        })),
        t.push.apply(t, i)
    }
    return t
}
function rT(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? iT(Object(t), !0).forEach(function(i) {
            Ese(n, i, t[i])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : iT(Object(t)).forEach(function(i) {
            Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i))
        })
    }
    return n
}
function QP(n, e) {
    return Mse(n) || Cse(n, e) || eL(n, e) || Pse()
}
function ar(n) {
    return Ase(n) || Tse(n) || eL(n) || Rse()
}
function Ase(n) {
    if (Array.isArray(n))
        return ny(n)
}
function Mse(n) {
    if (Array.isArray(n))
        return n
}
function Tse(n) {
    if (typeof Symbol < "u" && Symbol.iterator in Object(n))
        return Array.from(n)
}
function Cse(n, e) {
    if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(n)))) {
        var t = []
          , i = !0
          , r = !1
          , s = void 0;
        try {
            for (var o = n[Symbol.iterator](), a; !(i = (a = o.next()).done) && (t.push(a.value),
            !(e && t.length === e)); i = !0)
                ;
        } catch (c) {
            r = !0,
            s = c
        } finally {
            try {
                !i && o.return != null && o.return()
            } finally {
                if (r)
                    throw s
            }
        }
        return t
    }
}
function eL(n, e) {
    if (n) {
        if (typeof n == "string")
            return ny(n, e);
        var t = Object.prototype.toString.call(n).slice(8, -1);
        if (t === "Object" && n.constructor && (t = n.constructor.name),
        t === "Map" || t === "Set")
            return Array.from(n);
        if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
            return ny(n, e)
    }
}
function ny(n, e) {
    (e == null || e > n.length) && (e = n.length);
    for (var t = 0, i = new Array(e); t < e; t++)
        i[t] = n[t];
    return i
}
function Rse() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function Pse() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function hl(n, e) {
    return Object.getOwnPropertyNames(Object(n)).reduce(function(t, i) {
        var r = Object.getOwnPropertyDescriptor(Object(n), i)
          , s = Object.getOwnPropertyDescriptor(Object(e), i);
        return Object.defineProperty(t, i, s || r)
    }, {})
}
function fh(n) {
    return typeof n == "string"
}
function gx(n) {
    return Array.isArray(n)
}
function $d() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = hl(n), t;
    return e.types !== void 0 ? t = e.types : e.split !== void 0 && (t = e.split),
    t !== void 0 && (e.types = (fh(t) || gx(t) ? String(t) : "").split(",").map(function(i) {
        return String(i).trim()
    }).filter(function(i) {
        return /((line)|(word)|(char))/i.test(i)
    })),
    (e.absolute || e.position) && (e.absolute = e.absolute || /absolute/.test(n.position)),
    e
}
function _x(n) {
    var e = fh(n) || gx(n) ? String(n) : "";
    return {
        none: !e,
        lines: /line/i.test(e),
        words: /word/i.test(e),
        chars: /char/i.test(e)
    }
}
function Sm(n) {
    return n !== null && typeof n == "object"
}
function Lse(n) {
    return Sm(n) && /^(1|3|11)$/.test(n.nodeType)
}
function Dse(n) {
    return typeof n == "number" && n > -1 && n % 1 === 0
}
function Ise(n) {
    return Sm(n) && Dse(n.length)
}
function Dl(n) {
    return gx(n) ? n : n == null ? [] : Ise(n) ? Array.prototype.slice.call(n) : [n]
}
function sT(n) {
    var e = n;
    return fh(n) && (/^(#[a-z]\w+)$/.test(n.trim()) ? e = document.getElementById(n.trim().slice(1)) : e = document.querySelectorAll(n)),
    Dl(e).reduce(function(t, i) {
        return [].concat(ar(t), ar(Dl(i).filter(Lse)))
    }, [])
}
var Ose = Object.entries
  , Wp = "_splittype"
  , Fs = {}
  , Nse = 0;
function Js(n, e, t) {
    if (!Sm(n))
        return console.warn("[data.set] owner is not an object"),
        null;
    var i = n[Wp] || (n[Wp] = ++Nse)
      , r = Fs[i] || (Fs[i] = {});
    return t === void 0 ? e && Object.getPrototypeOf(e) === Object.prototype && (Fs[i] = rT(rT({}, r), e)) : e !== void 0 && (r[e] = t),
    t
}
function dl(n, e) {
    var t = Sm(n) ? n[Wp] : null
      , i = t && Fs[t] || {};
    return e === void 0 ? i : i[e]
}
function tL(n) {
    var e = n && n[Wp];
    e && (delete n[e],
    delete Fs[e])
}
function Use() {
    Object.keys(Fs).forEach(function(n) {
        delete Fs[n]
    })
}
function Fse() {
    Ose(Fs).forEach(function(n) {
        var e = QP(n, 2)
          , t = e[0]
          , i = e[1]
          , r = i.isRoot
          , s = i.isSplit;
        (!r || !s) && (Fs[t] = null,
        delete Fs[t])
    })
}
function Bse(n) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : " "
      , t = n ? String(n) : "";
    return t.trim().replace(/\s+/g, " ").split(e)
}
var vx = "\\ud800-\\udfff"
  , nL = "\\u0300-\\u036f\\ufe20-\\ufe23"
  , iL = "\\u20d0-\\u20f0"
  , rL = "\\ufe0e\\ufe0f"
  , kse = "[".concat(vx, "]")
  , iy = "[".concat(nL).concat(iL, "]")
  , ry = "\\ud83c[\\udffb-\\udfff]"
  , zse = "(?:".concat(iy, "|").concat(ry, ")")
  , sL = "[^".concat(vx, "]")
  , oL = "(?:\\ud83c[\\udde6-\\uddff]){2}"
  , aL = "[\\ud800-\\udbff][\\udc00-\\udfff]"
  , lL = "\\u200d"
  , cL = "".concat(zse, "?")
  , uL = "[".concat(rL, "]?")
  , Hse = "(?:" + lL + "(?:" + [sL, oL, aL].join("|") + ")" + uL + cL + ")*"
  , Gse = uL + cL + Hse
  , Vse = "(?:".concat(["".concat(sL).concat(iy, "?"), iy, oL, aL, kse].join("|"), `
)`)
  , Wse = RegExp("".concat(ry, "(?=").concat(ry, ")|").concat(Vse).concat(Gse), "g")
  , $se = [lL, vx, nL, iL, rL]
  , Xse = RegExp("[".concat($se.join(""), "]"));
function qse(n) {
    return n.split("")
}
function fL(n) {
    return Xse.test(n)
}
function jse(n) {
    return n.match(Wse) || []
}
function Yse(n) {
    return fL(n) ? jse(n) : qse(n)
}
function Kse(n) {
    return n == null ? "" : String(n)
}
function Zse(n) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return n = Kse(n),
    n && fh(n) && !e && fL(n) ? Yse(n) : n.split(e)
}
function sy(n, e) {
    var t = document.createElement(n);
    return e && Object.keys(e).forEach(function(i) {
        var r = e[i]
          , s = fh(r) ? r.trim() : r;
        s === null || s === "" || (i === "children" ? t.append.apply(t, ar(Dl(s))) : t.setAttribute(i, s))
    }),
    t
}
var yx = {
    splitClass: "",
    lineClass: "line",
    wordClass: "word",
    charClass: "char",
    types: ["lines", "words", "chars"],
    absolute: !1,
    tagName: "div"
};
function Jse(n, e) {
    e = hl(yx, e);
    var t = _x(e.types)
      , i = e.tagName
      , r = n.nodeValue
      , s = document.createDocumentFragment()
      , o = []
      , a = [];
    return /^\s/.test(r) && s.append(" "),
    o = Bse(r).reduce(function(c, u, h, m) {
        var d, f;
        return t.chars && (f = Zse(u).map(function(_) {
            var g = sy(i, {
                class: "".concat(e.splitClass, " ").concat(e.charClass),
                style: "display: inline-block;",
                children: _
            });
            return Js(g, "isChar", !0),
            a = [].concat(ar(a), [g]),
            g
        })),
        t.words || t.lines ? (d = sy(i, {
            class: "".concat(e.wordClass, " ").concat(e.splitClass),
            style: "display: inline-block; ".concat(t.words && e.absolute ? "position: relative;" : ""),
            children: t.chars ? f : u
        }),
        Js(d, {
            isWord: !0,
            isWordStart: !0,
            isWordEnd: !0
        }),
        s.appendChild(d)) : f.forEach(function(_) {
            s.appendChild(_)
        }),
        h < m.length - 1 && s.append(" "),
        t.words ? c.concat(d) : c
    }, []),
    /\s$/.test(r) && s.append(" "),
    n.replaceWith(s),
    {
        words: o,
        chars: a
    }
}
function hL(n, e) {
    var t = n.nodeType
      , i = {
        words: [],
        chars: []
    };
    if (!/(1|3|11)/.test(t))
        return i;
    if (t === 3 && /\S/.test(n.nodeValue))
        return Jse(n, e);
    var r = Dl(n.childNodes);
    if (r.length && (Js(n, "isSplit", !0),
    !dl(n).isRoot)) {
        n.style.display = "inline-block",
        n.style.position = "relative";
        var s = n.nextSibling
          , o = n.previousSibling
          , a = n.textContent || ""
          , c = s ? s.textContent : " "
          , u = o ? o.textContent : " ";
        Js(n, {
            isWordEnd: /\s$/.test(a) || /^\s/.test(c),
            isWordStart: /^\s/.test(a) || /\s$/.test(u)
        })
    }
    return r.reduce(function(h, m) {
        var d = hL(m, e)
          , f = d.words
          , _ = d.chars;
        return {
            words: [].concat(ar(h.words), ar(f)),
            chars: [].concat(ar(h.chars), ar(_))
        }
    }, i)
}
function Qse(n, e, t, i) {
    if (!t.absolute)
        return {
            top: e ? n.offsetTop : null
        };
    var r = n.offsetParent
      , s = QP(i, 2)
      , o = s[0]
      , a = s[1]
      , c = 0
      , u = 0;
    if (r && r !== document.body) {
        var h = r.getBoundingClientRect();
        c = h.x + o,
        u = h.y + a
    }
    var m = n.getBoundingClientRect()
      , d = m.width
      , f = m.height
      , _ = m.x
      , g = m.y
      , v = g + a - u
      , y = _ + o - c;
    return {
        width: d,
        height: f,
        top: v,
        left: y
    }
}
function dL(n) {
    dl(n).isWord ? (tL(n),
    n.replaceWith.apply(n, ar(n.childNodes))) : Dl(n.children).forEach(function(e) {
        return dL(e)
    })
}
var eoe = function() {
    return document.createDocumentFragment()
};
function toe(n, e, t) {
    var i = _x(e.types), r = e.tagName, s = n.getElementsByTagName("*"), o = [], a = [], c = null, u, h, m, d = [], f = n.parentElement, _ = n.nextElementSibling, g = eoe(), v = window.getComputedStyle(n), y = v.textAlign, w = parseFloat(v.fontSize), S = w * .2;
    return e.absolute && (m = {
        left: n.offsetLeft,
        top: n.offsetTop,
        width: n.offsetWidth
    },
    h = n.offsetWidth,
    u = n.offsetHeight,
    Js(n, {
        cssWidth: n.style.width,
        cssHeight: n.style.height
    })),
    Dl(s).forEach(function(E) {
        var b = E.parentElement === n
          , T = Qse(E, b, e, t)
          , C = T.width
          , P = T.height
          , A = T.top
          , R = T.left;
        /^br$/i.test(E.nodeName) || (i.lines && b && ((c === null || A - c >= S) && (c = A,
        o.push(a = [])),
        a.push(E)),
        e.absolute && Js(E, {
            top: A,
            left: R,
            width: C,
            height: P
        }))
    }),
    f && f.removeChild(n),
    i.lines && (d = o.map(function(E) {
        var b = sy(r, {
            class: "".concat(e.splitClass, " ").concat(e.lineClass),
            style: "display: block; text-align: ".concat(y, "; width: 100%;")
        });
        Js(b, "isLine", !0);
        var T = {
            height: 0,
            top: 1e4
        };
        return g.appendChild(b),
        E.forEach(function(C, P, A) {
            var R = dl(C)
              , I = R.isWordEnd
              , D = R.top
              , H = R.height
              , B = A[P + 1];
            T.height = Math.max(T.height, H),
            T.top = Math.min(T.top, D),
            b.appendChild(C),
            I && dl(B).isWordStart && b.append(" ")
        }),
        e.absolute && Js(b, {
            height: T.height,
            top: T.top
        }),
        b
    }),
    i.words || dL(g),
    n.replaceChildren(g)),
    e.absolute && (n.style.width = "".concat(n.style.width || h, "px"),
    n.style.height = "".concat(u, "px"),
    Dl(s).forEach(function(E) {
        var b = dl(E)
          , T = b.isLine
          , C = b.top
          , P = b.left
          , A = b.width
          , R = b.height
          , I = dl(E.parentElement)
          , D = !T && I.isLine;
        E.style.top = "".concat(D ? C - I.top : C, "px"),
        E.style.left = T ? "".concat(m.left, "px") : "".concat(P - (D ? m.left : 0), "px"),
        E.style.height = "".concat(R, "px"),
        E.style.width = T ? "".concat(m.width, "px") : "".concat(A, "px"),
        E.style.position = "absolute"
    })),
    f && (_ ? f.insertBefore(n, _) : f.appendChild(n)),
    d
}
var Sc = hl(yx, {})
  , xx = function() {
    nT(n, null, [{
        key: "clearData",
        value: function() {
            Use()
        }
    }, {
        key: "setDefaults",
        value: function(t) {
            return Sc = hl(Sc, $d(t)),
            yx
        }
    }, {
        key: "revert",
        value: function(t) {
            sT(t).forEach(function(i) {
                var r = dl(i)
                  , s = r.isSplit
                  , o = r.html
                  , a = r.cssWidth
                  , c = r.cssHeight;
                s && (i.innerHTML = o,
                i.style.width = a || "",
                i.style.height = c || "",
                tL(i))
            })
        }
    }, {
        key: "create",
        value: function(t, i) {
            return new n(t,i)
        }
    }, {
        key: "data",
        get: function() {
            return Fs
        }
    }, {
        key: "defaults",
        get: function() {
            return Sc
        },
        set: function(t) {
            Sc = hl(Sc, $d(t))
        }
    }]);
    function n(e, t) {
        wse(this, n),
        this.isSplit = !1,
        this.settings = hl(Sc, $d(t)),
        this.elements = sT(e),
        this.split()
    }
    return nT(n, [{
        key: "split",
        value: function(t) {
            var i = this;
            this.revert(),
            this.elements.forEach(function(o) {
                Js(o, "html", o.innerHTML)
            }),
            this.lines = [],
            this.words = [],
            this.chars = [];
            var r = [window.pageXOffset, window.pageYOffset];
            t !== void 0 && (this.settings = hl(this.settings, $d(t)));
            var s = _x(this.settings.types);
            s.none || (this.elements.forEach(function(o) {
                Js(o, "isRoot", !0);
                var a = hL(o, i.settings)
                  , c = a.words
                  , u = a.chars;
                i.words = [].concat(ar(i.words), ar(c)),
                i.chars = [].concat(ar(i.chars), ar(u))
            }),
            this.elements.forEach(function(o) {
                if (s.lines || i.settings.absolute) {
                    var a = toe(o, i.settings, r);
                    i.lines = [].concat(ar(i.lines), ar(a))
                }
            }),
            this.isSplit = !0,
            window.scrollTo(r[0], r[1]),
            Fse())
        }
    }, {
        key: "revert",
        value: function() {
            this.isSplit && (this.lines = null,
            this.words = null,
            this.chars = null,
            this.isSplit = !1),
            n.revert(this.elements)
        }
    }]),
    n
}();
const oT = (n,e,t)=>{
    n.forEach(i=>{
        const r = document.createElement(e);
        r.classList = t,
        i.parentNode.appendChild(r),
        r.appendChild(i)
    }
    )
}
  , ma = (n,e,t)=>{
    const i = document.createElement(e);
    i.classList = t,
    i.textContent = n.textContent,
    n.textContent = "",
    n.appendChild(i)
}
;
class noe extends Oa {
    constructor({template: e}) {
        super({
            element: ".middle__bar",
            elements: {
                number: ".middle__bar__cards__number",
                text: ".middle__bar__cards__text",
                collected: ".middle__bar__cards__collected",
                page: ".middle__bar__page"
            }
        }),
        this.cardsCollected = [],
        ma(this.elements.number, "span", "oh"),
        ma(this.elements.text, "span", "oh"),
        ma(this.elements.collected, "span", "oh"),
        ma(this.elements.page, "span", "oh"),
        this.spansElements = this.element.querySelectorAll("span"),
        this.spanPageElement = this.spansElements[3],
        this.spanNumberElements = new xx(this.spansElements[0],{
            types: "chars",
            tagName: "span"
        }),
        (e === "/about" || e === "/playground" || e.includes("/project")) && (this.cardsCollected.push(e),
        this.spanNumberElements.chars[0].innerText = this.cardsCollected.length),
        ve.set(this.spansElements, {
            yPercent: 150
        }),
        this.setNewPage(e)
    }
    show() {
        ve.set(this.element, {
            autoAlpha: 1
        }),
        ve.to(this.spansElements, {
            yPercent: 0,
            duration: .7,
            ease: Bn,
            stagger: .1,
            delay: .7
        })
    }
    showAcutalPage(e) {
        this.checkNewCard(e),
        this.setNewPage(e)
    }
    setNewPage(e) {
        e === "/" && (this.spanPageElement.innerText = "(homepage)"),
        e === "/about" && (this.spanPageElement.innerText = "(profile)"),
        e === "/playground" && (this.spanPageElement.innerText = "(playground)"),
        e === "/404" && (this.spanPageElement.innerText = "(404)"),
        e.includes("/project") && (this.spanPageElement.innerText = `(${window.location.pathname.split("/project/")[1]})`)
    }
    checkNewCard(e) {
        e === "/" || e === "/404" || this.cardsCollected.includes(e) || (this.cardsCollected.push(e),
        this.spanNumberElements.chars[0].innerText = this.cardsCollected.length)
    }
}
var ioe = Wy
  , roe = lm
  , soe = cm;
function ooe(n) {
    return function(e, t, i) {
        var r = Object(e);
        if (!roe(e)) {
            var s = ioe(t);
            e = soe(e),
            t = function(a) {
                return s(r[a], a, r)
            }
        }
        var o = n(e, t, i);
        return o > -1 ? r[s ? e[o] : o] : void 0
    }
}
var aoe = ooe;
function loe(n, e, t, i) {
    for (var r = n.length, s = t + (i ? 1 : -1); i ? s-- : ++s < r; )
        if (e(n[s], s, n))
            return s;
    return -1
}
var coe = loe
  , uoe = /\s/;
function foe(n) {
    for (var e = n.length; e-- && uoe.test(n.charAt(e)); )
        ;
    return e
}
var hoe = foe
  , doe = hoe
  , poe = /^\s+/;
function moe(n) {
    return n && n.slice(0, doe(n) + 1).replace(poe, "")
}
var goe = moe
  , _oe = goe
  , aT = sm
  , voe = um
  , lT = 0 / 0
  , yoe = /^[-+]0x[0-9a-f]+$/i
  , xoe = /^0b[01]+$/i
  , boe = /^0o[0-7]+$/i
  , Soe = parseInt;
function woe(n) {
    if (typeof n == "number")
        return n;
    if (voe(n))
        return lT;
    if (aT(n)) {
        var e = typeof n.valueOf == "function" ? n.valueOf() : n;
        n = aT(e) ? e + "" : e
    }
    if (typeof n != "string")
        return n === 0 ? n : +n;
    n = _oe(n);
    var t = xoe.test(n);
    return t || boe.test(n) ? Soe(n.slice(2), t ? 2 : 8) : yoe.test(n) ? lT : +n
}
var Eoe = woe
  , Aoe = Eoe
  , cT = 1 / 0
  , Moe = 17976931348623157e292;
function Toe(n) {
    if (!n)
        return n === 0 ? n : 0;
    if (n = Aoe(n),
    n === cT || n === -cT) {
        var e = n < 0 ? -1 : 1;
        return e * Moe
    }
    return n === n ? n : 0
}
var Coe = Toe
  , Roe = Coe;
function Poe(n) {
    var e = Roe(n)
      , t = e % 1;
    return e === e ? t ? e - t : e : 0
}
var Loe = Poe
  , Doe = coe
  , Ioe = Wy
  , Ooe = Loe
  , Noe = Math.max;
function Uoe(n, e, t) {
    var i = n == null ? 0 : n.length;
    if (!i)
        return -1;
    var r = t == null ? 0 : Ooe(t);
    return r < 0 && (r = Noe(i + r, 0)),
    Doe(n, Ioe(e), r)
}
var Foe = Uoe
  , Boe = aoe
  , koe = Foe
  , zoe = Boe(koe)
  , Hoe = zoe;
const Goe = Uo(Hoe);
class bx {
    constructor({button: e, buttonInner: t, buttonElements: i, trigger: r=1.5, scale: s=1.3, translate: o="translate(0, 0)"}) {
        this.elements = {
            button: e,
            buttonInner: t,
            buttonElements: i
        },
        this.trigger = r,
        this.scale = s,
        this.translate = o,
        this.mouse = {
            x: 0,
            y: 0
        },
        this.button = {
            currentX: 0,
            targetX: 0,
            currentY: 0,
            targetY: 0,
            currentScale: 1,
            targetScale: 1
        },
        this.isHover = !1,
        this.transformPrefix = La("transform")
    }
    onResize() {
        this.buttonBounds = this.elements.button.getBoundingClientRect(),
        this.triggerDistance = this.buttonBounds.width * this.trigger
    }
    onTouchMove(e) {
        tn.isMobile || (this.mouse.x = e.clientX,
        this.mouse.y = e.clientY)
    }
    onMouseEnter() {
        tn.isMobile || (this.isHover = !0,
        this.button.targetScale = this.scale,
        ve.killTweensOf(this.elements.buttonElements, "scale"),
        ve.to(this.elements.buttonElements, {
            scale: .8,
            ease: "expo"
        }))
    }
    onMouseLeave() {
        tn.isMobile || (this.isHover = !1,
        this.button.targetScale = 1,
        ve.killTweensOf(this.elements.buttonElements, "scale"),
        ve.to(this.elements.buttonElements, {
            scale: 1,
            ease: "expo"
        }))
    }
    update() {
        if (tn.isMobile)
            return;
        const e = Wre(this.mouse.x, this.mouse.y, this.buttonBounds.left + this.buttonBounds.width / 2, this.buttonBounds.top + this.buttonBounds.height / 2);
        let t = 0
          , i = 0;
        e < this.triggerDistance ? (this.isHover || this.onMouseEnter(),
        t = (this.mouse.x - (this.buttonBounds.left + this.buttonBounds.width / 2)) * .3,
        i = (this.mouse.y - (this.buttonBounds.top + this.buttonBounds.height / 2)) * .3) : this.isHover && this.onMouseLeave(),
        this.button.targetX = t,
        this.button.currentX = Wi(this.button.currentX, this.button.targetX, .1).toFixed(2),
        this.button.targetY = i,
        this.button.currentY = Wi(this.button.currentY, this.button.targetY, .1).toFixed(2),
        this.button.currentScale = Wi(this.button.currentScale, this.button.targetScale, .2).toFixed(2),
        !this.isHover && this.button.currentX < .1 && (this.button.currentX = 0),
        !this.isHover && this.button.currentY < .1 && (this.button.currentY = 0),
        this.elements.button.style[this.transformPrefix] = `${this.translate} translate3d(${this.button.currentX}px,${this.button.currentY}px, 400px) scale(${this.button.currentScale})`,
        this.elements.buttonInner && (this.elements.buttonInner.style[this.transformPrefix] = `translate3d(${this.button.currentX * .2}px,${this.button.currentY * .2}px, 0)`)
    }
}
class Voe extends Oa {
    constructor({page: e}) {
        super({
            element: ".card__slot",
            elements: {
                button: ".card__slot__button",
                buttonInner: ".card__slot__button__inner",
                buttonIcon: ".card__slot__button__icon"
            }
        }),
        Il(this),
        this.page = e,
        this.activeCard = null,
        this.mobileButtonActive = window.innerWidth < 768,
        this.windowWidth = window.innerWidth,
        this.elements.mobileButton = document.querySelector(".card__slot__mobile"),
        this.cardsElements = document.querySelectorAll(".card"),
        this.button = new bx({
            button: this.elements.button,
            buttonInner: this.elements.buttonInner,
            buttonElements: this.elements.buttonIcon,
            translate: "translate(50%, -50%)"
        }),
        this.onResize()
    }
    onChange(e) {
        this.transitionPage = e,
        e === "home" && this.animateFromAnyToHome(e),
        e !== "home" && this.page === "home" && this.animateFromHomeToProject(e),
        e !== "home" && this.page !== "home" && this.animateFromProjectToProject(e),
        this.page = e
    }
    animateFromAnyToHome() {
        tn.isMobile ? this.hideMobileButton() : (this.windowWidth < 768 && this.hideMobileButton(),
        ve.set(this.elements.button, {
            autoAlpha: 0,
            delay: 1.2,
            onComplete: ()=>{
                this.activeCard.remove(),
                this.activeCard = null
            }
        }))
    }
    animateFromHomeToProject(e) {
        tn.isMobile ? this.showMobileButton() : (this.windowWidth < 768 && this.showMobileButton(),
        ve.delayedCall(1.2, ()=>{
            this.addNewCard(e)
        }
        ))
    }
    animateFromProjectToProject(e) {
        tn.isMobile || ve.delayedCall(1.2, ()=>{
            this.activeCard.remove(),
            this.addNewCard(e)
        }
        )
    }
    show() {
        this.page !== "home" && (tn.isMobile && this.page !== "404" ? this.showMobileButton() : (this.windowWidth < 768 && this.page !== "404" && this.showMobileButton(),
        this.addNewCard(this.page)))
    }
    addNewCard(e) {
        const t = Goe(this.cardsElements, s=>s.getAttribute("data-id") === e);
        this.activeCard = t.cloneNode(!0);
        const i = this.activeCard.querySelector(".card__effects");
        i && i.remove(),
        this.activeCard.classList.add("card__card__slot"),
        this.element.appendChild(this.activeCard);
        let r = ve.utils.random(-6, 6, 2);
        r === 0 && (r = ve.utils.random(2, 6, 2)),
        ve.set(this.activeCard, {
            top: this.bounds.top,
            left: this.bounds.left,
            position: "fixed",
            transform: `translate3d(0, 0, 1px) perspective(100vw) rotate(${r}deg)`,
            autoAlpha: 1
        }),
        e !== "404" && ve.set(this.elements.button, {
            autoAlpha: 1
        })
    }
    showMobileButton() {
        this.mobileButtonActive = !0,
        ve.to(this.elements.mobileButton, {
            autoAlpha: 1,
            duration: 1,
            ease: Bn,
            delay: .7
        })
    }
    hideMobileButton() {
        this.mobileButtonActive = !1,
        ve.to(this.elements.mobileButton, {
            autoAlpha: 0,
            duration: 1,
            ease: Bn
        })
    }
    onResize() {
        this.windowWidth = window.innerWidth,
        this.bounds = this.element.getBoundingClientRect(),
        this.button.onResize(),
        this.windowWidth > 768 && this.mobileButtonActive && (this.mobileButtonActive = !1,
        ve.killTweensOf(this.elements.mobileButton, "autoAlpha"),
        ve.set(this.elements.mobileButton, {
            autoAlpha: 0
        })),
        this.windowWidth < 768 && !this.mobileButtonActive && this.transitionPage !== "home" && this.showMobileButton()
    }
    onTouchMove(e) {
        this.activeCard !== null && this.button.onTouchMove(e)
    }
    update() {
        this.activeCard !== null && this.button.update()
    }
}
class Fl {
    constructor({element: e, elements: t}) {
        Il(this);
        const {delay: i, target: r} = e.dataset;
        this.element = e,
        this.elements = t,
        this.delay = isNaN(Number(i)) ? 0 : Number(i),
        this.target = r ? e.closest(r) : e,
        this.transformPrefix = La("transform"),
        this.isVisible = !1,
        this.isAnimated = !1
    }
    createAnimation() {
        "IntersectionObserver"in window ? this.createObserver() : this.animateIn()
    }
    destroyAnimation() {
        this.observer && this.observer.disconnect()
    }
    hideAnimation() {
        this.animateOut()
    }
    createObserver() {
        this.observer = new window.IntersectionObserver(e=>{
            e.forEach(t=>{
                !this.isVisible && t.isIntersecting ? (this.animateIn(),
                this.observer.unobserve(this.element)) : !t.isIntersecting && this.isVisible && this.animateOut()
            }
            )
        }
        ),
        this.observer.observe(this.target)
    }
    animateIn() {
        this.isVisible = !0,
        this.isAnimated = !0
    }
    animateOut() {
        this.isVisible = !1,
        this.isAnimated = !1
    }
}
class oy extends Fl {
    constructor({element: e}) {
        ma(e, "span", "oh");
        const t = e.querySelector("span")
          , i = document.createElement("span");
        i.className = "first__line",
        e.appendChild(i);
        const r = document.createElement("span");
        r.className = "second__line",
        e.appendChild(r),
        super({
            element: e,
            elements: {
                span: t,
                firstLine: i,
                secondLine: r
            }
        });
        const {pause: s} = this.element.dataset;
        this.noAnimate = s !== void 0,
        this.addEventsListener()
    }
    animateIn() {
        this.noAnimate || ve.timeline({
            delay: this.delay
        }).to(this.elements.span, {
            yPercent: 0,
            opacity: 1,
            duration: .7,
            ease: Bn
        }).to(this.elements.firstLine, {
            scaleX: 1,
            transformOrigin: "left",
            duration: .7,
            ease: Bn
        }, .2),
        super.animateIn()
    }
    animateOut() {
        this.noAnimate ? ve.set(this.elements.firstLine, {
            scaleX: 1
        }) : (ve.set(this.elements.span, {
            yPercent: 125
        }),
        ve.set(this.elements.firstLine, {
            scaleX: 0
        })),
        super.animateOut()
    }
    onMouseEnter() {
        ve.killTweensOf([this.elements.firstLine, this.elements.secondLine]),
        ve.set(this.elements.firstLine, {
            transformOrigin: "right"
        }),
        ve.to(this.elements.firstLine, {
            scaleX: 0,
            duration: .6,
            ease: Gi
        }),
        ve.set(this.elements.secondLine, {
            transformOrigin: "left"
        }),
        ve.to(this.elements.secondLine, {
            scaleX: 1,
            duration: .8,
            delay: .2,
            ease: Gi
        })
    }
    onMouseLeave() {
        ve.killTweensOf([this.elements.firstLine, this.elements.secondLine]),
        ve.set(this.elements.secondLine, {
            transformOrigin: "left"
        }),
        ve.to(this.elements.secondLine, {
            scaleX: 0,
            duration: .6,
            ease: Gi
        }),
        ve.set(this.elements.firstLine, {
            transformOrigin: "right"
        }),
        ve.to(this.elements.firstLine, {
            scaleX: 1,
            duration: .8,
            delay: .2,
            ease: Gi
        })
    }
    addEventsListener() {
        this.element.addEventListener("mouseenter", this.onMouseEnter, {
            passive: !0
        }),
        this.element.addEventListener("mouseleave", this.onMouseLeave, {
            passive: !0
        })
    }
}
class Woe extends Oa {
    constructor({template: e}) {
        super({
            element: "html",
            elements: {
                cardAside: ".card__aside",
                cardAsideGallery: ".card__aside__gallery",
                cardAsideContent: ".card__aside__content",
                cardAsideTitle: ".card__aside__content__title",
                cardAsideButton: ".card__aside__content__button",
                goldenAside: ".golden__aside",
                goldenAsideCard: ".golden__aside__card",
                goldenAsideContent: ".golden__aside__content",
                goldenAsideButton: ".golden__aside__content__button",
                button: ".aside__button",
                openIcon: ".aside__button__open",
                closeIcon: ".aside__button__close",
                closeIconLines: ".aside__button__close__line",
                goldenIcon: ".aside__button__golden"
            }
        }),
        Il(this),
        this.template = e,
        this.cardsCollected = [],
        this.isOpen = !1,
        this.isGolden = !1,
        this.isAnimating = !1,
        this.isDownloading = !1,
        this.isMobile = tn.isMobile || window.innerWidth < 768,
        this.titleLeftText = this.elements.cardAsideTitle.textContent.split(" / ")[1],
        this.cardsTotal = Number(this.elements.cardAside.getAttribute("data-total")),
        this.cardAsideComplexLink = new oy({
            element: this.elements.cardAsideButton
        }),
        this.cardAsideComplexLink.animateIn(),
        this.goldenAsideComplexLink = new oy({
            element: this.elements.goldenAsideButton
        }),
        this.goldenAsideComplexLink.animateIn(),
        this.button = new bx({
            button: this.elements.button,
            buttonElements: [this.elements.openIcon, this.elements.closeIcon, this.elements.goldenIcon],
            translate: "translate(0, 0)"
        }),
        this.checkNewCard(this.template),
        this.addEventsListener()
    }
    showCardAside() {
        ve.timeline({
            defaults: {
                duration: 1,
                ease: af
            },
            onStart: ()=>this.emit("open"),
            onComplete: ()=>this.isAnimating = !1
        }).set(this.elements.cardAside, {
            display: "flex"
        }).set(this.elements.closeIconLines, {
            scaleX: 0
        }).to([this.elements.openIcon], {
            scale: 0,
            autoAlpha: 0,
            duration: .5
        }, 0).to(this.elements.cardAside, {
            autoAlpha: 1
        }, 0).fromTo(this.elements.cardAsideContent, {
            yPercent: this.isMobile ? 250 : 150
        }, {
            yPercent: 0,
            duration: 1.2,
            ease: Gi
        }, this.isMobile ? .21 : .15).fromTo(this.elements.cardAsideGallery, {
            yPercent: this.isMobile ? 250 : 150
        }, {
            yPercent: 0,
            duration: 1.2,
            ease: Gi
        }, this.isMobile ? .15 : .21).to(this.elements.closeIconLines, {
            scaleX: 1,
            autoAlpha: 1
        }, .25)
    }
    hideCardAside() {
        ve.timeline({
            defaults: {
                duration: .8,
                ease: af
            },
            onComplete: ()=>{
                ve.set(this.elements.cardAside, {
                    display: "none"
                }),
                this.isAnimating = !1,
                this.emit("close")
            }
        }).to(this.elements.closeIconLines, {
            scaleX: 0,
            autoAlpha: 0,
            duration: .5
        }, 0).to(this.elements.cardAsideContent, {
            yPercent: this.isMobile ? 250 : 150,
            ease: Gi
        }, 0).to(this.elements.cardAsideGallery, {
            yPercent: this.isMobile ? 250 : 150,
            ease: Gi
        }, .06).to(this.elements.openIcon, {
            autoAlpha: 1,
            scale: 1
        }, .25).to(this.elements.cardAside, {
            autoAlpha: 0
        }, .4)
    }
    showGoldenAside() {
        ve.timeline({
            defaults: {
                duration: 1,
                ease: af
            },
            onStart: ()=>this.emit("open"),
            onComplete: ()=>this.isAnimating = !1
        }).set(this.elements.goldenAside, {
            display: "flex"
        }).set(this.elements.closeIconLines, {
            scaleX: 0
        }).to([this.elements.goldenIcon], {
            scale: 0,
            autoAlpha: 0,
            duration: .5
        }, 0).to(this.elements.goldenAside, {
            autoAlpha: 1
        }, 0).fromTo(this.elements.goldenAsideContent, {
            yPercent: this.isMobile ? 250 : 150
        }, {
            yPercent: 0,
            duration: 1.2,
            ease: Gi
        }, this.isMobile ? .21 : .15).fromTo(this.elements.goldenAsideCard, {
            yPercent: this.isMobile ? 250 : 150
        }, {
            yPercent: 0,
            duration: 1.2,
            ease: Gi
        }, this.isMobile ? .15 : .21).to(this.elements.closeIconLines, {
            scaleX: 1,
            autoAlpha: 1
        }, .25)
    }
    hideGoldenAside() {
        ve.timeline({
            defaults: {
                duration: .8,
                ease: af
            },
            onComplete: ()=>{
                ve.set(this.elements.goldenAside, {
                    display: "none"
                }),
                this.isAnimating = !1,
                this.emit("close")
            }
        }).to(this.elements.closeIconLines, {
            scaleX: 0,
            autoAlpha: 0,
            duration: .5
        }, 0).to(this.elements.goldenAsideContent, {
            yPercent: this.isMobile ? 250 : 150,
            ease: Gi
        }, 0).to(this.elements.goldenAsideCard, {
            yPercent: this.isMobile ? 250 : 150,
            ease: Gi
        }, .06).to(this.elements.goldenIcon, {
            autoAlpha: 1,
            scale: 1
        }, .25).to(this.elements.goldenAside, {
            autoAlpha: 0
        }, .4)
    }
    showGoldenButton() {
        const e = ve.timeline({
            defaults: {
                duration: 1,
                ease: af
            },
            onComplete: ()=>{
                this.isAnimating = !1
            }
        });
        e.set(this.elements.goldenIcon, {
            scale: 0
        }),
        e.to([this.elements.openIcon, this.elements.closeIconLines], {
            scaleX: 0,
            autoAlpha: 0,
            duration: .5
        }, 0).to(this.elements.goldenIcon, {
            scale: 1,
            autoAlpha: 1
        }, .25)
    }
    checkNewCard(e) {
        this.template = e,
        !(e === "/" || e === "/404" || this.cardsCollected.includes(e)) && (this.cardsCollected.push(e),
        this.titleLeftText && (this.elements.cardAsideTitle.textContent = `${this.cardsCollected.length} / ${this.titleLeftText}`),
        this.cardsCollected.length === this.cardsTotal && (this.isGolden = !0,
        this.showGoldenButton()))
    }
    onButtonClick() {
        this.isAnimating || (this.isAnimating = !0,
        this.isGolden ? this.isOpen ? this.hideGoldenAside() : this.showGoldenAside() : this.isOpen ? this.hideCardAside() : this.showCardAside(),
        this.isOpen = !this.isOpen)
    }
    onDownloadClick() {
        if (this.isDownloading)
            return;
        this.isDownloading = !0;
        const e = this.elements.goldenAside.getAttribute("data-download-image");
        fetch(e).then(t=>t.blob()).then(t=>{
            const i = window.URL.createObjectURL(t)
              , r = document.createElement("a");
            r.target = "_blank",
            r.href = i,
            r.click(),
            this.isDownloading = !1
        }
        )
    }
    onResize() {
        this.button.onResize(),
        this.isMobile = tn.isMobile || window.innerWidth < 768
    }
    onTouchMove(e) {
        this.button.onTouchMove(e)
    }
    addEventsListener() {
        this.elements.button.addEventListener("click", this.onButtonClick, {
            passive: !0
        }),
        this.elements.cardAsideButton.addEventListener("click", this.onButtonClick, {
            passive: !0
        }),
        this.elements.cardAside.addEventListener("click", e=>{
            e.target == this.elements.cardAside && this.onButtonClick()
        }
        , {
            passive: !0
        }),
        this.elements.goldenAsideButton.addEventListener("click", this.onDownloadClick, {
            passive: !0
        }),
        this.elements.goldenAside.addEventListener("click", e=>{
            e.target == this.elements.goldenAside && this.onButtonClick()
        }
        , {
            passive: !0
        })
    }
    update() {
        this.button.update()
    }
}
class $oe extends Oa {
    constructor() {
        super({
            element: ".transition",
            elements: {
                wrapper: ".transition__wrapper",
                inner: ".transition__inner",
                text: ".transition__text .oh"
            }
        }),
        ve.set(this.elements.wrapper, {
            yPercent: 100
        }),
        ve.set(this.elements.inner, {
            yPercent: -100
        }),
        ve.set(this.elements.text, {
            yPercent: 100
        }),
        this.elements.textReversed = [...this.elements.text].reverse()
    }
    animate() {
        ve.killTweensOf(this.elements.wrapper, "yPercent"),
        ve.killTweensOf(this.elements.text, "yPercent"),
        ve.killTweensOf(this.elements.inner, "yPercent"),
        ve.timeline({
            defaults: {
                ease: Gi
            },
            onComplete: ()=>{
                ve.set([this.elements.wrapper, this.elements.text], {
                    yPercent: 100
                }),
                ve.set(this.elements.inner, {
                    yPercent: -100
                })
            }
        }).to([this.elements.wrapper, this.elements.inner], {
            yPercent: 0,
            duration: 1.2
        }, 0).to(this.elements.text, {
            yPercent: 0,
            duration: .8,
            ease: Bn,
            stagger: .06
        }, .3).to(this.elements.textReversed, {
            yPercent: -100,
            duration: .8,
            ease: Bn,
            stagger: .06
        }, 1.2).to(this.elements.wrapper, {
            yPercent: -100,
            duration: 1.2
        }, 1.2).to(this.elements.inner, {
            yPercent: 100,
            duration: 1.2
        }, 1.2)
    }
}
class Xoe extends Oa {
    constructor({element: e}) {
        super({
            element: e,
            elements: {
                effects: ".card__effects"
            }
        }),
        this.isVisble = !1,
        this.extra = 0,
        this.rotate = {
            currentX: 0,
            targetX: 0,
            currentY: 0,
            targetY: 0,
            ease: .1
        },
        this.pointer = {
            currentX: 50,
            targetX: 50,
            currentY: 50,
            targetY: 50,
            ease: .1
        },
        this.opacity = {
            current: 0,
            target: 0,
            ease: .1
        },
        this.maxAngle = 15,
        this.transformPrefix = La("transform"),
        this.createCard()
    }
    createCard() {
        ve.set(this.element, {
            background: this.element.getAttribute("data-background"),
            color: this.element.getAttribute("data-color")
        })
    }
    show() {
        ve.timeline({
            delay: .5,
            onComplete: ()=>this.isVisble = !0
        }).fromTo(this.element, {
            opacity: 0
        }, {
            opacity: 1,
            ease: Bn,
            duration: 1
        }, 0).fromTo(this.element, {
            scale: .8
        }, {
            scale: 1,
            ease: "expo.out",
            duration: .6
        }, 0),
        this.elements.effects && (this.elements.effects.style = `--pointer-x: ${this.pointer.currentX}%; --pointer-y: ${this.pointer.currentY}%; --opacity: ${this.opacity.current};`)
    }
    hide() {
        this.isVisble = !1
    }
    onResize({heightTotal: e}) {
        this.offset = Wf(this.element),
        this.heightTotal = e,
        this.extra = 0
    }
    onMouseMove(e) {
        if (tn.isMobile)
            return;
        const t = e.clientX
          , i = e.clientY
          , r = Wf(this.element)
          , s = t - r.left - r.width / 2;
        this.rotate.targetX = s / (r.width / 2) * this.maxAngle;
        const o = i - r.top - r.height / 2;
        if (this.rotate.targetY = o / (r.height / 2) * this.maxAngle,
        this.elements.effects) {
            const a = Math.abs(Math.floor(100 / r.width * (t - r.left)))
              , c = Math.abs(Math.floor(100 / r.height * (i - r.top)));
            this.pointer.targetX = a,
            this.pointer.targetY = c,
            this.opacity.target = 1
        }
    }
    onMouseLeave() {
        tn.isMobile || (this.rotate.targetX = 0,
        this.rotate.targetY = 0,
        this.pointer.targetX = 50,
        this.pointer.targetY = 50,
        this.opacity.target = 0)
    }
    update({scroll: e, direction: t}) {
        if (!this.isVisble)
            return;
        const i = -e - this.extra
          , r = i + this.offset.top + this.offset.height;
        this.isBefore = r < 0,
        this.isAfter = r > this.heightTotal,
        t === "up" && this.isBefore && (this.extra -= this.heightTotal,
        this.isBefore = !1,
        this.isAfter = !1),
        t === "down" && this.isAfter && (this.extra += this.heightTotal,
        this.isBefore = !1,
        this.isAfter = !1),
        this.rotate.currentX = Wi(this.rotate.currentX, this.rotate.targetX, this.rotate.ease).toFixed(2),
        this.rotate.currentY = Wi(this.rotate.currentY, this.rotate.targetY, this.rotate.ease).toFixed(2),
        this.element.style[this.transformPrefix] = `translate3d(0, ${Math.floor(i)}px, 200px) perspective(100vw) rotateX(${-this.rotate.currentY}deg) rotateY(${this.rotate.currentX}deg)`,
        this.elements.effects && (this.pointer.currentX = Wi(this.pointer.currentX, this.pointer.targetX, this.pointer.ease).toFixed(2),
        this.pointer.currentY = Wi(this.pointer.currentY, this.pointer.targetY, this.pointer.ease).toFixed(2),
        this.opacity.current = Number(Wi(this.opacity.current, this.opacity.target, this.opacity.ease).toFixed(2)),
        this.opacity.target === 0 && this.opacity.current <= .05 && (this.opacity.current = 0),
        this.elements.effects.style = `--pointer-x: ${this.pointer.currentX}%; --pointer-y: ${this.pointer.currentY}%; --opacity: ${this.opacity.current};`)
    }
    addEventListeners() {
        this.element.addEventListener("mousemove", this.onMouseMove.bind(this), {
            passive: !0
        }),
        this.element.addEventListener("mouseleave", this.onMouseLeave.bind(this), {
            passive: !0
        })
    }
}
let qoe = class extends Oa {
    constructor({element: e}) {
        super({
            element: e
        }),
        this.isVisble = !1,
        this.extra = 0,
        this.scroll = 0,
        this.transformPrefix = La("transform")
    }
    show() {
        this.isVisble = !0,
        ve.fromTo(this.element, {
            autoAlpha: 0
        }, {
            autoAlpha: 1,
            duration: .7,
            ease: Bn,
            delay: 1
        })
    }
    hide() {
        this.isVisble = !1
    }
    onResize({widthTotal: e}) {
        this.offset = Wf(this.element),
        this.widthTotal = e,
        this.extra = 0
    }
    update({scroll: e, direction: t}) {
        if (!this.isVisble)
            return;
        const i = -e - this.extra
          , r = i + this.offset.left + this.offset.width;
        this.isBefore = r < 0,
        this.isAfter = r > this.widthTotal,
        t === "up" && this.isBefore && (this.extra -= this.widthTotal,
        this.isBefore = !1,
        this.isAfter = !1),
        t === "down" && this.isAfter && (this.extra += this.widthTotal,
        this.isBefore = !1,
        this.isAfter = !1),
        this.element.style[this.transformPrefix] = `translate3d(${Math.floor(i)}px, 0, 0) `
    }
}
;
class joe extends Fl {
    constructor({element: e}) {
        super({
            element: e,
            elements: {
                spans: []
            }
        }),
        this.elements.spans = new xx(this.element,{
            types: "lines"
        }),
        oT(this.elements.spans.lines, "span", "oh"),
        ve.set(this.elements.spans.lines, {
            yPercent: 105
        })
    }
    animateIn() {
        ve.to(this.elements.spans.lines, {
            yPercent: 0,
            duration: .7,
            ease: "power2.out",
            delay: this.delay,
            stagger: .075
        }),
        super.animateIn()
    }
    animateOut() {
        Jt.each(this.elements.lines, e=>{
            ve.set(e, {
                yPercent: 105
            })
        }
        ),
        super.animateOut()
    }
    onResize() {
        this.elements.spans.split(),
        oT(this.elements.spans.lines, "div", "oh"),
        this.isAnimated || ve.set(this.elements.spans.lines, {
            yPercent: 105
        })
    }
}
class Yoe extends Fl {
    constructor({element: e}) {
        ma(e, "span", "oh");
        const t = e.querySelector("span")
          , i = document.createElement("span");
        i.className = "line",
        e.appendChild(i),
        super({
            element: e,
            elements: {
                span: t,
                line: i
            }
        }),
        this.addEventListener()
    }
    animateIn() {
        ve.to(this.elements.span, {
            yPercent: 0,
            duration: .7,
            ease: Bn,
            delay: this.delay
        }),
        super.animateIn()
    }
    animateOut() {
        ve.set(this.elements.span, {
            yPercent: 125
        }),
        super.animateOut()
    }
    onMouseEnter() {
        ve.set(this.elements.line, {
            transformOrigin: "left"
        }),
        ve.to(this.elements.line, {
            scaleX: 1,
            duration: .6,
            ease: Gi
        })
    }
    onMouseLeave() {
        ve.set(this.elements.line, {
            transformOrigin: "right"
        }),
        ve.to(this.elements.line, {
            scaleX: 0,
            duration: .6,
            ease: Gi
        })
    }
    addEventListener() {
        this.element.addEventListener("mouseenter", this.onMouseEnter, {
            passive: !0
        }),
        this.element.addEventListener("mouseleave", this.onMouseLeave, {
            passive: !0
        })
    }
}
class Koe extends Fl {
    constructor({element: e}) {
        ma(e, "span", "oh");
        const t = e.querySelector("span");
        super({
            element: e,
            elements: {
                span: t
            }
        })
    }
    animateIn() {
        ve.to(this.elements.span, {
            yPercent: 0,
            duration: .7,
            ease: Bn,
            delay: this.delay
        }),
        super.animateIn()
    }
    animateOut() {
        ve.set(this.elements.span, {
            yPercent: 115
        }),
        super.animateOut()
    }
}
class Zoe extends Fl {
    constructor({element: e}) {
        super({
            element: e,
            elements: {}
        })
    }
    animateIn() {
        ve.to(this.element, {
            opacity: 1,
            delay: this.delay,
            duration: 1,
            ease: Bn
        }),
        super.animateIn()
    }
    animateOut() {
        ve.set(this.element, {
            opacity: 0
        }),
        super.animateOut()
    }
}
class Joe extends Fl {
    constructor({element: e}) {
        const t = new xx(e,{
            types: "chars",
            tagName: "span"
        });
        super({
            element: e,
            elements: {
                titles: t
            }
        })
    }
    animateIn() {
        ve.to(this.elements.titles.chars, {
            yPercent: 0,
            duration: .7,
            ease: Bn,
            delay: this.delay,
            stagger: .05
        }),
        super.animateIn()
    }
    animateOut() {
        ve.set(this.elements.titles.chars, {
            yPercent: 200
        }),
        super.animateOut()
    }
}
class Qoe extends Fl {
    constructor({element: e}) {
        ma(e, "span", "oh");
        const t = e.querySelector("span");
        super({
            element: e,
            elements: {
                span: t
            }
        })
    }
    animateIn() {
        ve.to(this.elements.span, {
            yPercent: 0,
            rotate: 0,
            duration: 1.25,
            ease: Bn,
            delay: this.delay
        }),
        super.animateIn()
    }
    animateOut() {
        ve.set(this.elements.span, {
            yPercent: 150,
            rotate: "5deg"
        }),
        super.animateOut()
    }
}
class eae extends Oa {
    constructor({element: e}) {
        super({
            element: e
        }),
        this.element = e,
        this.createObserver()
    }
    createObserver() {
        this.observer = new window.IntersectionObserver(e=>{
            e.forEach(t=>{
                if (t.isIntersecting) {
                    const i = this.element.getAttribute("data-src");
                    !this.element.src && i ? this.loadVideo(i) : this.element.play()
                } else
                    this.element.pause()
            }
            )
        }
        ),
        this.observer.observe(this.element)
    }
    async loadVideo(e) {
        try {
            const t = new xm({
                Bucket: "evan-portfolio-video",
                Key: e
            })
              , i = await HP(GP, t);
            this.element.src = i,
            this.element.loop = !0,
            this.element.muted = !0,
            this.element.crossOrigin = "anonymous",
            this.element.setAttribute("playsinline", "playsinline"),
            this.element.load(),
            this.element.oncanplay = ()=>{
                this.element.play()
            }
        } catch {}
    }
}
class hh extends JP {
    constructor({classes: e, id: t, element: i, elements: r, isScrollable: s=!0, updateScroll: o=()=>{}
    }) {
        super(),
        Il(this),
        this.classes = {
            ...e
        },
        this.id = t,
        this.selectors = {
            element: i,
            elements: {
                preloaders: "[data-src]",
                loaders: "[lazy-src]",
                animationsParagraphs: '[data-animation="paragraph"]',
                animationsSimpleLinks: '[data-animation="simple-link"]',
                animationsComplexLinks: '[data-animation="complex-link"]',
                animationsTexts: '[data-animation="text"]',
                animationsHighlights: '[data-animation="highlight"]',
                animationsTitles: '[data-animation="title"]',
                animationsSlowTexts: '[data-animation="slow-text"]',
                ...r
            }
        },
        this.isScrollable = s,
        this.updateScroll = o,
        this.imagesLoaded = !1,
        this.scroll = {
            position: 0,
            current: 0,
            target: 0,
            limit: 0,
            last: 0,
            ease: .1
        },
        this.transformPrefix = La("transform"),
        this.create()
    }
    create() {
        this.animations = [],
        this.element = document.querySelector(this.selectors.element),
        this.elements = {},
        Jt.each(this.selectors.elements, (e,t)=>{
            e instanceof window.HTMLElement || e instanceof window.NodeList ? this.elements[t] = e : Array.isArray(e) ? this.elements[t] = e : (this.elements[t] = this.element.querySelectorAll(e),
            this.elements[t].length === 0 ? this.elements[t] = null : this.elements[t].length === 1 && (this.elements[t] = this.element.querySelector(e)))
        }
        ),
        this.isScrollable && (this.scroll = {
            position: 0,
            current: 0,
            target: 0,
            limit: this.elements.wrapper.clientHeight - window.innerHeight,
            last: 0,
            ease: .1
        }),
        this.createAnimations(),
        this.createObserver(),
        this.createPreloaders()
    }
    createAnimations() {
        this.animationsParagraphs = $s(this.elements.animationsParagraphs, e=>new joe({
            element: e
        })),
        this.animationsSimpleLinks = $s(this.elements.animationsSimpleLinks, e=>new Yoe({
            element: e
        })),
        this.animationsComplexLinks = $s(this.elements.animationsComplexLinks, e=>new oy({
            element: e
        })),
        this.animationsText = $s(this.elements.animationsTexts, e=>new Koe({
            element: e
        })),
        this.animationsHighlight = $s(this.elements.animationsHighlights, e=>new Zoe({
            element: e
        })),
        this.animationsTitle = $s(this.elements.animationsTitles, e=>new Joe({
            element: e
        })),
        this.animationsSlowText = $s(this.elements.animationsSlowTexts, e=>new Qoe({
            element: e
        })),
        this.animations.push(...this.animationsParagraphs, ...this.animationsSimpleLinks, ...this.animationsComplexLinks, ...this.animationsText, ...this.animationsHighlight, ...this.animationsTitle, ...this.animationsSlowText)
    }
    createObserver() {
        this.observer = new window.ResizeObserver(e=>{
            let t = !1;
            for (const i of e)
                if (i.target === this.elements.wrapper) {
                    t = !0;
                    break
                }
            t && window.requestAnimationFrame(()=>{
                this.scroll.limit = this.elements.wrapper.clientHeight - window.innerHeight
            }
            )
        }
        ),
        this.observer.observe(this.elements.wrapper)
    }
    createPreloaders() {
        this.preloaders = $s(this.elements.preloaders, e=>new eae({
            element: e
        }))
    }
    createLoader() {
        this.imagesLoaded || (this.imagesLoaded = !0,
        $s(this.elements.loaders, e=>{
            const t = e.getAttribute("lazy-src");
            t && (e.src = t)
        }
        ))
    }
    reset() {
        this.scroll = {
            position: 0,
            current: 0,
            target: 0,
            limit: 0,
            last: 0,
            ease: .1
        },
        this.transform(this.elements.wrapper, this.scroll.current)
    }
    set(e) {
        this.scroll.current = this.scroll.target = this.scroll.last = e,
        this.transform(this.elements.wrapper, this.scroll.current)
    }
    show(e) {
        this.reset(),
        Jt.each(this.animations, t=>t.hideAnimation()),
        e ? this.animateIn = e : (this.animateIn = ve.timeline(),
        this.animateIn.set([document.body, document.documentElement], {
            backgroundColor: this.element.getAttribute("data-background"),
            color: this.element.getAttribute("data-color")
        }).to(this.element, {
            autoAlpha: 1,
            duration: .7,
            ease: Bn
        }, 0)),
        this.animateIn.call(()=>{
            this.addEventListeners(),
            Jt.each(this.animations, t=>t.createAnimation())
        }
        )
    }
    hide(e) {
        this.removeEventListeners(),
        ve.set(this.element, {
            autoAlpha: 0,
            onComplete: ()=>{
                Jt.each(this.animations, t=>t.destroyAnimation()),
                this.reset()
            }
        })
    }
    transform(e, t) {
        e.style[this.transformPrefix] = `translate3d(0, ${-Math.round(t)}px, 0)`
    }
    onResize() {
        this.elements.wrapper && window.requestAnimationFrame(()=>{
            this.scroll.limit = this.elements.wrapper.clientHeight - window.innerHeight,
            this.elements.wrapper.clientHeight === window.innerHeight && this.isScrollable && this.updateScroll(100),
            Jt.each(this.animations, e=>{
                e.onResize && e.onResize()
            }
            )
        }
        )
    }
    onTouchDown(e) {
        !tn.isMobile || !this.isVisible || (this.isDown = !0,
        this.scroll.position = this.scroll.current,
        this.start = e.touches ? e.touches[0].clientY : e.clientY)
    }
    onTouchMove(e) {
        if (!tn.isMobile || !this.isDown || !this.isVisible)
            return;
        const t = e.touches ? e.touches[0].clientY : e.clientY
          , i = (this.start - t) * 3;
        this.scroll.target = this.scroll.position + i
    }
    onTouchUp() {
        !tn.isMobile || !this.isVisible || (this.isDown = !1)
    }
    onWheel(e) {
        if (!this.isVisible)
            return;
        const t = e.pixelY;
        return this.scroll.target += t,
        t
    }
    addEventListeners() {}
    removeEventListeners() {}
    update() {
        !this.isScrollable || !this.isVisible || (this.scroll.target = Vre(0, this.scroll.limit, this.scroll.target),
        this.scroll.current = Wi(this.scroll.current, this.scroll.target, this.scroll.ease),
        this.scroll.target === 0 ? this.scroll.current = Math.floor(this.scroll.current) : this.scroll.current = Math.ceil(this.scroll.current),
        this.scroll.current < .1 && (this.scroll.current = 0),
        this.elements.wrapper && this.transform(this.elements.wrapper, this.scroll.current),
        Jt.each(this.animations, e=>{
            e.update && e.update(this.scroll)
        }
        ),
        this.scroll.current !== this.scroll.last && this.updateScroll(Math.ceil(this.scroll.current / this.scroll.limit * 100)),
        this.scroll.last = this.scroll.current,
        Ot.update())
    }
}
class tae extends hh {
    constructor(e) {
        super({
            id: "home",
            classes: {
                active: "home--active"
            },
            element: ".home",
            elements: {
                wrapper: ".home__wrapper",
                cardsContainer: ".home__card__container",
                cards: ".card",
                titlesContainer: ".home__title",
                titles: ".home__title__content",
                opportunities: ".home__opportunities",
                opportunitiesInner: ".home__opportunities__inner",
                opportunitiesIcon: ".home__opportunities__icon",
                opportunitiesText: ".home__opportunities__text",
                opportunitiesTextOpen: ".home__opportunities__text--open",
                opportunitiesTextClick: ".home__opportunities__text--click",
                opportunitiesTextCopied: ".home__opportunities__text--copied"
            },
            isScrollable: !1
        }),
        this.updateScroll = e,
        this.scroll = {
            position: 0,
            current: 0,
            target: 0,
            last: 0,
            ease: .1
        },
        this.speedScroll = {
            position: 0,
            current: 0,
            target: 0,
            last: 0,
            speed: 2,
            ease: .1
        },
        this.isDown = !1,
        this.isVisible = !1,
        this.direction = "up"
    }
    create() {
        super.create(),
        this.cards = Jt.map(this.elements.cards, e=>new Xoe({
            element: e
        })),
        this.titles = Jt.map(this.elements.titles, e=>new qoe({
            element: e
        })),
        this.opportunitiesButton = new bx({
            button: this.elements.opportunities,
            buttonInner: this.elements.opportunitiesInner,
            buttonElements: [this.elements.opportunitiesText, this.elements.opportunitiesIcon],
            trigger: .5,
            scale: 1.2,
            translate: "translateX(-50%)"
        }),
        this.elements.opportunities.addEventListener("mouseenter", ()=>{
            ve.set(this.elements.opportunitiesTextOpen, {
                autoAlpha: 0
            }),
            ve.set(this.elements.opportunitiesTextClick, {
                autoAlpha: 1
            })
        }
        , {
            passive: !0
        }),
        this.elements.opportunities.addEventListener("mouseleave", ()=>{
            ve.set([this.elements.opportunitiesTextClick, this.elements.opportunitiesTextCopied], {
                autoAlpha: 0
            }),
            ve.set(this.elements.opportunitiesTextOpen, {
                autoAlpha: 1
            })
        }
        , {
            passive: !0
        }),
        this.elements.opportunities.addEventListener("click", ()=>{
            ve.set(this.elements.opportunitiesTextClick, {
                autoAlpha: 0
            }),
            ve.set(this.elements.opportunitiesTextCopied, {
                autoAlpha: 1
            }),
            navigator.clipboard.writeText("hello@evanfasquelle.com"),
            tn.isMobile && ve.delayedCall(1.5, ()=>{
                ve.set(this.elements.opportunitiesTextCopied, {
                    autoAlpha: 0
                }),
                ve.set(this.elements.opportunitiesTextOpen, {
                    autoAlpha: 1
                })
            }
            )
        }
        , {
            passive: !0
        })
    }
    show(e) {
        return Jt.each(this.cards, t=>{
            t && t.show && (ve.set(t.element, {
                y: 0,
                rotateX: 0,
                rotateY: 0
            }),
            t.show())
        }
        ),
        Jt.each(this.titles, t=>{
            t && t.show && (ve.set(t.element, {
                y: 0
            }),
            t.show())
        }
        ),
        ve.fromTo(this.elements.opportunities, {
            yPercent: 25,
            autoAlpha: 0
        }, {
            yPercent: 0,
            autoAlpha: 1,
            duration: .4,
            ease: Bn,
            delay: .8
        }),
        ve.delayedCall(1.6, ()=>this.isVisible = !0),
        this.element.classList.add(this.classes.active),
        super.show(e)
    }
    hide(e) {
        return this.element.classList.remove(this.classes.active),
        this.isVisible = !1,
        Jt.each(this.cards, t=>{
            t && t.show && t.hide()
        }
        ),
        Jt.each(this.titles, t=>{
            t && t.show && t.hide()
        }
        ),
        super.hide(e)
    }
    onResize() {
        super.onResize(),
        this.opportunitiesButton.onResize(),
        this.scroll = {
            position: 0,
            current: 0,
            target: 0,
            last: 0,
            ease: .1
        },
        this.speedScroll = {
            position: 0,
            current: 0,
            target: 0,
            last: 0,
            speed: 2,
            ease: .1
        },
        this.galleryHeight = this.elements.cardsContainer.clientHeight,
        this.titleWidth = this.elements.titlesContainer.clientWidth,
        Jt.each(this.cards, e=>{
            e && e.onResize && e.onResize({
                heightTotal: this.galleryHeight
            })
        }
        ),
        Jt.each(this.titles, e=>{
            e && e.onResize && e.onResize({
                widthTotal: this.titleWidth
            })
        }
        )
    }
    onTouchDown(e) {
        !this.isVisible || !tn.isMobile || (this.isDown = !0,
        this.scroll.position = this.scroll.current,
        this.speedScroll.position = this.scroll.current,
        this.start = e.touches ? e.touches[0].clientY : e.clientY)
    }
    onTouchMove(e) {
        if (!this.isVisible || (this.opportunitiesButton.onTouchMove(e),
        !tn.isMobile || !this.isDown))
            return;
        const t = e.touches ? e.touches[0].clientY : e.clientY
          , i = (this.start - t) * 3;
        this.scroll.target = this.scroll.position + i,
        this.speedScroll.target = this.speedScroll.position + i
    }
    onTouchUp(e) {
        !this.isVisible || !tn.isMobile || (this.isDown = !1)
    }
    onWheel(e) {
        if (!this.isVisible)
            return;
        const t = e.pixelY;
        this.scroll.target += t,
        this.speedScroll.target += t
    }
    update() {
        if (super.update(),
        this.speedScroll.target += this.speedScroll.speed,
        this.speedScroll.current = Wi(this.speedScroll.current, this.speedScroll.target, this.speedScroll.ease),
        this.speedScroll.current = Math.floor(this.speedScroll.current),
        Jt.each(this.titles, e=>{
            e && e.update && e.update({
                scroll: this.speedScroll.current,
                direction: this.direction
            })
        }
        ),
        !!this.isVisible) {
            if (this.opportunitiesButton.update(),
            this.scroll.current = Wi(this.scroll.current, this.scroll.target, this.scroll.ease),
            this.scroll.current = Math.floor(this.scroll.current),
            this.scroll.current > this.scroll.last ? (this.direction = "up",
            this.speedScroll.speed = 2) : this.scroll.current < this.scroll.last && (this.direction = "down",
            this.speedScroll.speed = -2),
            this.scroll.current !== this.scroll.last) {
                const e = (this.scroll.current % this.galleryHeight + this.galleryHeight) % this.galleryHeight
                  , t = Math.round(e / this.galleryHeight * 100);
                this.updateScroll(t)
            }
            Jt.each(this.cards, e=>{
                e && e.update && e.update({
                    scroll: this.scroll.current,
                    direction: this.direction
                })
            }
            ),
            this.scroll.last = this.scroll.current
        }
    }
}
let nae = class {
    constructor({title: e, image: t}) {
        this.title = e,
        this.image = t,
        Il(this),
        this.transformPrefix = La("transform"),
        this.isVisible = !1,
        this.isHover = !1,
        this.isDownloading = !1,
        this.mouse = {
            x: 0,
            y: 0
        },
        this.position = {
            currentX: 0,
            targetX: 0,
            lastX: 0,
            currentY: 0,
            targetY: 0,
            lastY: 0
        },
        this.rotate = {
            current: 0,
            target: 0
        },
        this.addEventListeners()
    }
    show() {
        this.isVisible = !0
    }
    hide() {
        this.isVisible = !1
    }
    onResize() {
        this.offset = Wf(this.title)
    }
    onMouseEnter() {
        !this.isVisible || tn.isMobile || (this.isHover = !0)
    }
    onMouseMove(e) {
        if (!this.isVisible || !this.isHover || tn.isMobile)
            return;
        const t = Wf(this.title)
          , i = e.clientX
          , r = e.clientY;
        this.position.targetX = i - t.left - this.offset.width / 2,
        this.position.targetY = r - t.top - this.offset.height / 2
    }
    onMouseLeave() {
        !this.isVisible || tn.isMobile || (this.isHover = !1,
        this.position.targetX = 0,
        this.position.targetY = 0)
    }
    onMouseClick() {
        if (this.isDownloading)
            return;
        this.isDownloading = !0;
        const e = this.title.getAttribute("data-download-image");
        fetch(e).then(t=>t.blob()).then(t=>{
            const i = window.URL.createObjectURL(t)
              , r = document.createElement("a");
            r.target = "_blank",
            r.href = i,
            r.click(),
            this.isDownloading = !1
        }
        )
    }
    addEventListeners() {
        this.title.addEventListener("mouseenter", this.onMouseEnter, {
            passive: !0
        }),
        this.title.addEventListener("mousemove", this.onMouseMove, {
            passive: !0
        }),
        this.title.addEventListener("mouseleave", this.onMouseLeave, {
            passive: !0
        }),
        this.title.addEventListener("click", this.onMouseClick, {
            passive: !0
        })
    }
    update() {
        !this.isVisible || tn.isMobile || (this.position.currentX = Wi(this.position.currentX, this.position.targetX, .1).toFixed(2),
        this.position.currentY = Wi(this.position.currentY, this.position.targetY, .1).toFixed(2),
        this.rotate.target = (this.position.lastX - this.position.currentX) * 1.25,
        this.rotate.current = Wi(this.rotate.current, this.rotate.target, .1).toFixed(2),
        this.position.lastX = this.position.currentX,
        this.position.lastY = this.position.currentY,
        this.image.style[this.transformPrefix] = `translate(-50%, -50%) translate3d(${this.position.currentX}px,${this.position.currentY}px, 0) rotate(${-this.rotate.current}deg)`)
    }
}
;
class iae extends hh {
    constructor(e) {
        super({
            id: "about",
            classes: {
                active: "about--active"
            },
            element: ".about",
            elements: {
                wrapper: ".about__wrapper",
                aboutTitle: ".about__download__title",
                aboutImage: ".about__download__media"
            },
            updateScroll: e,
            isScrollable: !0
        }),
        this.isVisible = !1
    }
    create() {
        super.create(),
        this.image = new nae({
            title: this.elements.aboutTitle,
            image: this.elements.aboutImage
        })
    }
    async show(e) {
        return ve.delayedCall(1.5, ()=>this.isVisible = !0),
        this.element.classList.add(this.classes.active),
        this.image && this.image.show && this.image.show(),
        super.show(e)
    }
    async hide(e) {
        return this.isVisible = !1,
        this.element.classList.remove(this.classes.active),
        this.image && this.image.hide && this.image.hide(),
        super.hide(e)
    }
    onResize() {
        super.onResize(),
        this.image && this.image.onResize && this.image.onResize()
    }
    update() {
        this.isVisible && (super.update(),
        this.image && this.image.update && this.image.update(this.scroll.current))
    }
}
class rae extends hh {
    constructor({id: e, updateScroll: t}) {
        super({
            id: `project-${e}`,
            classes: {
                active: "project--active"
            },
            element: `#${e}`,
            elements: {
                wrapper: ".project__wrapper",
                next: ".project__next",
                nextCard: ".card__project",
                frontCard: ".card__project__front",
                backCard: ".card__project__back",
                nextCardSlot: ".project__next__card__slot",
                nextCardSlotDesktopPath: ".project__next__card__slot__icon--dekstop path:last-child",
                nextCardSlotMobilePath: ".project__next__card__slot__icon--mobile path:last-child",
                images: "img"
            },
            isScrollable: !0,
            updateScroll: t
        }),
        this.isVisible = !1,
        this.desktopPathLength = this.elements.nextCardSlotDesktopPath.getTotalLength(),
        this.mobilePathLength = this.elements.nextCardSlotMobilePath.getTotalLength(),
        this.isMobile = tn.isMobile || window.innerWidth < 768
    }
    create() {
        super.create()
    }
    async show(e) {
        return this.element.classList.add(this.classes.active),
        ve.set(this.elements.frontCard, {
            background: this.elements.frontCard.getAttribute("data-background"),
            color: this.elements.frontCard.getAttribute("data-color"),
            rotateY: "180deg"
        }),
        ve.set(this.elements.backCard, {
            backgroundImage: `url(${this.elements.backCard.getAttribute("data-image")})`,
            rotateY: 0
        }),
        ve.delayedCall(1.5, ()=>{
            this.isVisible = !0,
            this.animateCard = ve.timeline({
                defaults: {
                    ease: "none"
                },
                scrollTrigger: {
                    trigger: this.elements.next,
                    start: "100% bottom",
                    end: "200% bottom",
                    scrub: .1,
                    pin: !0
                }
            }),
            this.animateCard.to(this.elements.nextCardSlot, {
                top: "60%"
            }, 0).to(this.elements.nextCard, {
                top: "60%"
            }).to(this.elements.frontCard, {
                rotateY: 0
            }, "<").to(this.elements.backCard, {
                rotateY: -180
            }, "<")
        }
        ),
        super.show(e)
    }
    async hide(e) {
        return this.isVisible = !1,
        this.element.classList.remove(this.classes.active),
        ve.killTweensOf([document.body, document.documentElement]),
        ve.delayedCall(1, ()=>{
            this.animateCard && this.animateCard.kill();
            const t = this.element.querySelector(".pin-spacer");
            t && t.replaceWith(this.elements.next),
            this.elements.nextCard.style = "",
            this.elements.frontCard.style = "",
            this.elements.backCard.style = "",
            this.elements.next.style = "",
            this.elements.nextCardSlotDesktopPath.style = "",
            this.elements.nextCardSlotMobilePath.style = "",
            this.elements.nextCardSlot.style = ""
        }
        ),
        super.hide(e)
    }
    animateToNextPage() {
        const e = ve.timeline({
            defaults: {
                duration: .8
            }
        });
        this.isMobile ? e.set(this.elements.nextCardSlotMobilePath, {
            opacity: 1
        }).fromTo(this.elements.nextCardSlotMobilePath, {
            strokeDashoffset: this.mobilePathLength,
            strokeDasharray: `${this.mobilePathLength} ${this.mobilePathLength}`
        }, {
            strokeDashoffset: 0,
            strokeDasharray: `${this.mobilePathLength} ${this.mobilePathLength}`,
            ease: eT,
            duration: .4
        }) : e.set(this.elements.nextCardSlotDesktopPath, {
            opacity: 1
        }).fromTo(this.elements.nextCardSlotDesktopPath, {
            strokeDashoffset: this.desktopPathLength,
            strokeDasharray: `${this.desktopPathLength} ${this.desktopPathLength}`
        }, {
            strokeDashoffset: 0,
            strokeDasharray: `${this.desktopPathLength} ${this.desktopPathLength}`,
            ease: eT,
            duration: .4
        }),
        e.fromTo(this.elements.nextCardSlot, {
            background: "#dbd9d5",
            boxShadow: "0px 0px 0x 0px #FFF"
        }, {
            background: "#cccac6",
            boxShadow: "0px 0px 24px 0px #FFF"
        }, 0),
        ve.delayedCall(.8, ()=>{
            const t = new MouseEvent("click",{
                bubbles: !0,
                cancelable: !0,
                view: window
            });
            this.elements.nextCard.dispatchEvent(t)
        }
        )
    }
    onResize() {
        this.isMobile = tn.isMobile || window.innerWidth < 768,
        super.onResize()
    }
    update() {
        this.isVisible && (super.update(),
        this.scroll.current === this.scroll.limit && (this.isVisible = !1,
        this.animateToNextPage()))
    }
}
class sae extends hh {
    constructor() {
        super({
            id: "playground",
            classes: {
                active: "playground--active"
            },
            element: ".playground",
            elements: {
                wrapper: ".playground__wrapper"
            },
            isScrollable: !1
        }),
        this.isVisible = !1
    }
    async show(e) {
        return this.isVisible = !0,
        this.element.classList.add(this.classes.active),
        super.show(e)
    }
    async hide(e) {
        return this.isVisible = !1,
        this.element.classList.remove(this.classes.active),
        super.hide(e)
    }
}
class oae extends hh {
    constructor(e) {
        super({
            id: "404",
            classes: {
                active: "not__found--active"
            },
            element: ".not__found",
            elements: {
                wrapper: ".not__found__wrapper"
            },
            isScrollable: !1
        }),
        this.updateScroll = e,
        this.isVisible = !1
    }
    async show(e) {
        return this.isVisible = !0,
        this.element.classList.add(this.classes.active),
        this.updateScroll(100),
        super.show(e)
    }
    async hide(e) {
        return this.isVisible = !1,
        this.element.classList.remove(this.classes.active),
        super.hide(e)
    }
}
ve.registerPlugin(Ot);
class uT {
    constructor() {
        this.template = window.location.pathname,
        this.isChangingPage = !1,
        Il(this),
        this.init()
    }
    init() {
        this.createScroll(),
        this.createPages(),
        this.createMiddleBar(),
        this.createCanvas(),
        this.createPreloader(),
        this.createCardSlot(),
        this.createAside(),
        this.createTransition(),
        this.checkTheme(),
        this.addEventListeners(),
        this.addLinkListeners()
    }
    createScrollTrigger() {
        Ot.scrollerProxy("#wrapper", {
            scrollTop: e=>(arguments.length && (this.page.scroll.current = e),
            this.page.scroll.current),
            getBoundingClientRect() {
                return {
                    top: 0,
                    left: 0,
                    width: window.innerWidth,
                    height: window.innerHeight
                }
            }
        }),
        Ot.defaults({
            scroller: "#wrapper"
        })
    }
    createScroll() {
        this.scroll = new Sse
    }
    createMiddleBar() {
        this.middleBar = new noe({
            template: this.template
        })
    }
    createCanvas() {
        this.canvas = new Zre({
            template: this.template,
            page: this.page,
            updateScroll: e=>this.scroll.update(e)
        })
    }
    createPreloader() {
        this.preloader = new bse({
            gl: this.canvas.gl,
            page: this.page
        }),
        this.preloader.once("loaded", this.onPreloaded)
    }
    createCardSlot() {
        this.cardSlot = new Voe({
            page: this.page.id
        }),
        this.cardSlot.show()
    }
    createAside() {
        this.aside = new Woe({
            template: this.template
        }),
        this.aside.on("open", ()=>{
            this.page.isVisible = !1,
            this.canvas.isVisible = !1
        }
        ),
        this.aside.on("close", ()=>{
            this.page.isVisible = !0,
            this.canvas.isVisible = !0
        }
        )
    }
    createTransition() {
        this.transition = new $oe
    }
    createPages() {
        this.home = new tae(t=>this.scroll.update(t)),
        this.about = new iae(t=>this.scroll.update(t)),
        this.playground = new sae,
        this.notFound = new oae(t=>this.scroll.update(t)),
        this.projects = [],
        this.template !== "/" && this.template.endsWith("/") && (this.template = this.template.slice(0, -1)),
        this.pages = {
            "/": this.home,
            "/about": this.about,
            "/playground": this.playground
        };
        const e = document.querySelectorAll(".project");
        Jt.each(e, t=>{
            const i = t.getAttribute("id")
              , r = new rae({
                id: i,
                updateScroll: s=>this.scroll.update(s)
            });
            this.pages[`/project/${i}`] = r,
            this.projects.push(r)
        }
        ),
        this.page = this.pages[this.template],
        this.page === void 0 && (this.page = this.notFound,
        this.template = "/404"),
        this.page.createLoader()
    }
    onPreloaded() {
        this.onResize(),
        this.update(),
        this.createScrollTrigger(),
        this.middleBar.show(),
        this.page.show(),
        this.canvas.onPreloaded()
    }
    onPopState() {
        this.onChange({
            url: window.location.pathname,
            push: !1
        })
    }
    async onChange({url: e, push: t=!0}) {
        this.isChangingPage && (this.page.hide(),
        Ot.getAll().forEach(r=>r.kill()),
        this.scroll.reset(),
        this.isChangingPage = !1),
        this.isChangingPage = !0,
        e = e.replace(window.location.origin, "");
        let i = this.pages[e];
        i === void 0 && (i = this.notFound),
        i.createLoader(),
        this.canvas.createLoader(i),
        this.canvas.onChangeStart(),
        this.cardSlot.onChange(i.id),
        this.transition.animate(i),
        ve.delayedCall(1.2, ()=>{
            this.page.hide(),
            Ot.getAll().forEach(r=>r.kill()),
            this.scroll.reset(),
            t && window.history.pushState({}, "", e),
            this.createScrollTrigger(),
            this.page = i,
            this.page.id === "404" ? this.template = "/404" : this.template = window.location.pathname,
            this.canvas.onChangeEnd(this.template, !0),
            this.page.show(),
            this.middleBar.showAcutalPage(this.template),
            this.aside.checkNewCard(this.template),
            this.onResize(),
            this.isChangingPage = !1
        }
        )
    }
    onResize() {
        this.page && this.page.onResize && this.page.onResize(),
        this.cardSlot && this.cardSlot.onResize && this.cardSlot.onResize(),
        this.aside && this.aside.onResize && this.aside.onResize(),
        window.requestAnimationFrame(()=>{
            this.canvas && this.canvas.onResize && this.canvas.onResize()
        }
        )
    }
    onTouchDown(e) {
        this.canvas && this.canvas.onTouchDown && this.canvas.onTouchDown(e),
        this.page && this.page.onTouchDown && this.page.onTouchDown(e)
    }
    onTouchMove(e) {
        this.canvas && this.canvas.onTouchMove && this.canvas.onTouchMove(e),
        this.page && this.page.onTouchMove && this.page.onTouchMove(e),
        this.cardSlot && this.cardSlot.onTouchMove && this.cardSlot.onTouchMove(e),
        this.aside && this.aside.onTouchMove && this.aside.onTouchMove(e)
    }
    onTouchUp(e) {
        this.canvas && this.canvas.onTouchUp && this.canvas.onTouchUp(e),
        this.page && this.page.onTouchUp && this.page.onTouchUp(e)
    }
    onWheel(e) {
        const t = SF(e);
        this.canvas && this.canvas.onWheel && this.canvas.onWheel(t),
        this.page && this.page.onWheel && this.page.onWheel(t)
    }
    checkTheme() {
        const e = document.querySelectorAll(".meta__icon");
        window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches && Jt.each(e, t=>t.href = t.getAttribute("data-dark-src")),
        window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({matches: t})=>{
            t ? Jt.each(e, i=>i.href = i.getAttribute("data-dark-src")) : Jt.each(e, i=>i.href = i.getAttribute("data-light-src"))
        }
        )
    }
    changeIcon() {}
    update() {
        var e;
        this.page && this.page.update(),
        this.canvas && this.canvas.update && this.canvas.update((e = this == null ? void 0 : this.page) == null ? void 0 : e.scroll),
        this.cardSlot && this.cardSlot.update && this.cardSlot.update(),
        this.aside && this.aside.update && this.aside.update(),
        window.requestAnimationFrame(this.update.bind(this))
    }
    addEventListeners() {
        window.addEventListener("popstate", this.onPopState, {
            passive: !0
        }),
        window.addEventListener("resize", this.onResize, {
            passive: !0
        }),
        window.addEventListener("mousedown", this.onTouchDown, {
            passive: !0
        }),
        window.addEventListener("mousemove", this.onTouchMove, {
            passive: !0
        }),
        window.addEventListener("mouseup", this.onTouchUp, {
            passive: !0
        }),
        window.addEventListener("touchstart", this.onTouchDown, {
            passive: !0
        }),
        window.addEventListener("touchmove", this.onTouchMove, {
            passive: !0
        }),
        window.addEventListener("touchend", this.onTouchUp, {
            passive: !0
        }),
        window.addEventListener("wheel", this.onWheel, {
            passive: !0
        })
    }
    addLinkListeners() {
        const e = document.querySelectorAll("a");
        Jt.each(e, t=>{
            const i = t.href.indexOf(window.location.origin) > -1
              , r = t.href.indexOf("#") > -1
              , s = t.href.indexOf("mailto") === -1
              , o = t.href.indexOf("tel") === -1;
            i ? t.onclick = a=>{
                a.preventDefault(),
                r || this.onChange({
                    url: t.href
                })
            }
            : s && o && (t.rel = "noopener",
            t.target = "_blank")
        }
        )
    }
}
const aae = new Yp("Instrument Serif")
  , lae = new Yp("Nautica")
  , cae = new Yp("Neue Haas Grotesk Display Pro")
  , uae = new Yp("Comic Sans MS");
Promise.all([aae.load(), lae.load(), cae.load(), uae.load()]).then(()=>new uT).catch(()=>new uT);
